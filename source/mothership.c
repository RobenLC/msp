#include <stdint.h> 
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h>
//#include <getopt.h> 
#include <unistd.h> 
#include <stddef.h>

int pipe(int pipefd[2]);

#define _GNU_SOURCE
#include <fcntl.h> 
int pipe2(int pipefd[2], int flags);
#define GHP_EN (1)
#include <sys/ioctl.h> 
#include <sys/mman.h> 
#include <sys/epoll.h>
#include <sys/prctl.h>
#include <sys/sysinfo.h> 
#include <sys/types.h>
#include <linux/types.h> 
#include <linux/kernel.h> 
#include <linux/spi/spidev.h> 
//#include <sys/times.h> 
#include <time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
//#include <linux/poll.h>
#include <poll.h>
#include <signal.h>

#include <dirent.h>
#include <sys/stat.h>  
#include <netdb.h>
#include <ifaddrs.h>
#include <linux/if_link.h>
#include <math.h>
#include <errno.h> 
//#include <mysql.h>
#if GHP_EN
#include <jpeglib.h>
#include <jerror.h>
//#include <turbojpeg.h>
//#include <GL/gl.h>
//#include <GL/glext.h>
#include <GLES2/gl2.h>
#include <GLES2/gl2ext.h>
//#include <GLES2/gl2platform.h>
#include <EGL/egl.h>
#include <EGL/eglext.h>
//#include <GL/glx.h>
#include "BKImage.h"
#include <linux/membarrier.h>
#endif

//#include <arch/arm/include/asm/barriers.h>
//#include <arm/include/asm/barriers.h>
//#include <asm-generic/barrier.h>
//#include <linux/compiler-gcc.h>
//#include <linux/memcontrol.h>

//main()
// version example: MSP Version v0.0.2, 2019-03-13 13:36:30 f2be242, 2019.12.17 14:48:18

static char mver[] = "MSP Version v0.2.5.rc";
static char gitcommit[] = "2020-07-16 10:12:15 7666ffb";
static char buildtime[] = __TIMESTAMP__; // 24 
static char genssid[128];

#define MSP_VERSION mver
#define MSP_GIT gitcommit
#define MSP_TIME buildtime
#define MSP_SSID genssid

#define DISABLE_SPI  (1)
#define DISABLE_USB  (0)
#define SPI1_ENABLE (1) 

#if SPI1_ENABLE
#define SPIDEV_SWITCH (0)
#else // spidev switch must be disable
#define SPIDEV_SWITCH (0)
#endif

#if !GHP_EN
#define ImgProc_None             	0
#define NewImageIn             		1
#define ImageProcDone             	2
#define NewAreaReq             		3
#define ChkBox1L             		4
#define ChkBox1R             		5
#define SRNBox1L             		6
#define SRNBox1R             		7
#define ChkBox2L             		8
#define ChkBox2R             		9
#define SRNBox2L             		10
#define SRNBox2R             		11

#define iJobOK						0
#define iJobImgInquirey				1
#define iJobImgComplete				2
#define ImageOverSize				3
#define ImageZeroSize				4
#define iJobCurDone					5
#define iJobSaveIntPM				6
#define iJobImgOCR					7 
#define iJobImgMatch				8
#define iJobImgNoMatch				9
typedef struct  
{
	int yr;				//Height,y, 	// Rows and columns in the image 
	int	xc;             //Width,x
	int oyi; 			 //y, 		// Origin 
	int	oxj;             //x, 
}	t_Imgheader;
typedef struct	
{
		unsigned char	BKNote_Layers;			//number of color layer in each page of scan
		unsigned char	LEDMode;				//?
		unsigned char	LEDH2L1;				//if BMP/4_layers, it only use the first 4 LEDs
		unsigned char	LEDH4L3;
		unsigned char	LEDH6L5;
		unsigned char	LEDH8L7;
		unsigned char	SelLayerNum;
}	t_ImageLayers;
//
//this data structure is used for passs the image parameter in the Jobcmd.
//the host send the image block information with this data structure
typedef struct		
{
	t_Imgheader		BKNoteImageRect;	//the rectangle information of the BKNote, the orginal point (0,0) is the bottom left cornor.
    int			 	SeqIdx;				//the sequence number during proceesing for the current image file
    int			 	iJobIdx;			//assigned for the image processing job
	t_Imgheader		ImageRect;			//the rectagle information for the image using in the assigned iJobIdx, valid if width not equal to zero
    int			 	iJobRtnCode;		//The return status code for the iJobIdx
	t_ImageLayers	ImageLayerInfo; 	//Provide the LED information for each layer
    int			 	IpPAMemorySize;		//The size of the attached memory 
    unsigned char  	*AttImgData;    	//usually, pointer to the t_imageIP	if there is an image data attached
}   t_ImageParam;  
#endif

#define LOG_ALL_DISABLE (1)

#define ONLY_ONE_USB (0)
#if DISABLE_USB
#define USB_META (0)
#define MOVE_MUTX_TO_FRONT_P6  (0)
#else
#define USB_META (1)
#define MOVE_MUTX_TO_FRONT_P6  (1)
#endif
#define MIN_SECTOR_SIZE (512)
#define RING_BUFF_NUM (64)
//#define RING_BUFF_NUM_USB   (1728)//(1728)//(1330)//(1536)
#define RING_BUFF_NUM_USB   (1600) //(500) //(3200) //(1536) (3200)
#define USB_BUF_SIZE (65536) //(98304) (65536)
#define USB_META_SIZE 512
#define TABLE_SLOT_SIZE 4
#define CYCLE_LEN (40)
#define USB_CALLBACK_LOOP (1)
#define DBG_DUMP_DAT32  (0)
#define USB_BOOTUP_SYNC (1)                 // notice this 
#define USB_ALIVE_POLLING (1)               // notice this 
#define USB_PC_IDLE_CHK (0)
#define USB_RECVLEN_ZERO_HANDLE   (1)
#define USB_AUTO_PAUSE    (0)
#define USB_AUTO_RESUME  (0)
#define DBG_PAUSE_RESUME (0)

#if 1                                                          // notice this 
#define WIRELESS_INT           "wlan0"
#define WIRELESS_INT_WPA  "wlan1"
#else /* SPI simulator setting */
#define WIRELESS_INT           "uap0"
#define WIRELESS_INT_WPA  "mlan0"
#endif

#define AP_AUTO (1)
#define AP_CLR_STATUS (1)

#define PIC_ALL_SEND (0)
#define MFOUR_IMG_SEND_BACK (0)
#define MFOUR_BMP_SEND_BACK (0)
#define MFOUR_SIM_MODE (0)
#define MFOUR_SIM_MODE_BMP (0)

#if GHP_EN
#define SMP_EN (1)
#define MFOUR_API (1)
#else
#define SMP_EN (1)
#define MFOUR_API (0)
#endif

#define RJOB_TX_BLOCK_SIZE   (16*1024)
#define RJOB_TOTAL_TX_BLOCK  (2)
#define RJOB_RX_BLOCK_SIZE   (16*1024)
#define IOCNR_RJOB_WCMD     2
#define IOCNR_RJOB_RCMD     3
#define IOCTL_RJOB_WCMD     _IOW(0xb5,IOCNR_RJOB_WCMD,mfour_rjob_cmd)
#define IOCTL_RJOB_RCMD     _IOR(0xb5,IOCNR_RJOB_RCMD,mfour_rjob_cmd)

#if MFOUR_API
#define RJOB_IOCT_WT_CMD(a, b)    RJOB_IOCT_WT_CMD_API(a, (void *)b)
#define RJOB_IOCT_RD_CMD(a, b)    RJOB_IOCT_RD_CMD_API(a, (void *)b)
#else
#define RJOB_IOCT_WT_CMD(a, b)    ioctl(a, IOCTL_RJOB_WCMD, b)
#define RJOB_IOCT_RD_CMD(a, b)    ioctl(a, IOCTL_RJOB_RCMD, b)
#endif

#define BKCMD_ABORT              0x0030
#define BKCMD_IMAGE_IN           0x0031
#define BKCMD_IMAGE_IN_RSP       0x0131
#define BKCMD_REQUIRE_AREA       0x8032      // bit15=1=rjob1
#define BKCMD_REQUIRE_AREA_RSP   0x8132      // bit15=1=rjob1
#define BKCMD_SEND_AREA          0x0033
#define BKCMD_DONE_AREA          0x8034      // bit15=1=rjob1
#define BKCMD_DONE_AREA_RSP      0x8134      // bit15=1=rjob1
#define BKCMD_IMAGE_COMPLETE     0x8035      // bit15=1=rjob1
#define BKCMD_IMAGE_COMPLETE_RSP 0x8135      // bit15=1=rjob1

#define GADGET_GET_PRINTER_STATUS	_IOR('g', 0x21, unsigned char)
#define GADGET_SET_OUTPUT_ADDRESS	_IOWR('g', 0x23, unsigned char)
#define GADGET_SET_CSW_ADDRESS		_IOWR('g', 0x24, unsigned char)

#define GADGET_IOCT_GET_STATUS(a, b)     ioctl(a, GADGET_GET_PRINTER_STATUS, b)
#define GADGET_IOCT_SET_OUT(a, b)     ioctl(a, GADGET_SET_OUTPUT_ADDRESS, b)

#define IOCNR_GET_DEVICE_ID		1
#define IOCNR_GET_VID_PID		6
#define IOCNR_CONTI_READ_START  8
#define IOCNR_CONTI_READ_STOP    9
#define IOCNR_CONTI_READ_PROBE    10
#define IOCNR_CONTI_READ_ONCE    11
#define IOCNR_CONTI_READ_RESET   12
#define IOCNR_CONTI_BUFF_CREATE    13
#define IOCNR_CONTI_BUFF_PROBE    14
#define IOCNR_CONTI_BUFF_RELEASE    15
#define IOCNR_CONTI_BUFF_SET           16
#define IOCNR_CONTI_BUFF_PRESET    17
#define IOCNR_CONTI_READ_PAUSE     18
#define IOCNR_CONTI_READ_RESTART    19

#define USB_IOC_CONTI_READ_START  _IOC(_IOC_NONE, 'P', IOCNR_CONTI_READ_START, 0)
#define USB_IOC_CONTI_READ_STOP    _IOC(_IOC_NONE, 'P', IOCNR_CONTI_READ_STOP, 0)
#define USB_IOC_CONTI_READ_PROBE  _IOC(_IOC_NONE, 'P', IOCNR_CONTI_READ_PROBE, 0)
#define USB_IOC_CONTI_READ_ONCE   _IOC(_IOC_NONE, 'P', IOCNR_CONTI_READ_ONCE, 0)
#define USB_IOC_CONTI_READ_RESET   _IOC(_IOC_NONE, 'P', IOCNR_CONTI_READ_RESET, 0)
#define USB_IOC_CONTI_BUFF_CREATE  _IOC(_IOC_NONE, 'P', IOCNR_CONTI_BUFF_CREATE, 0)
#define USB_IOC_CONTI_BUFF_PROBE  _IOC(_IOC_NONE, 'P', IOCNR_CONTI_BUFF_PROBE, 0)
#define USB_IOC_CONTI_BUFF_RELEASE  _IOC(_IOC_NONE, 'P', IOCNR_CONTI_BUFF_RELEASE, 0)
#define USB_IOC_CONTI_BUFF_SET  _IOC(_IOC_NONE, 'P', IOCNR_CONTI_BUFF_SET, 0)
#define USB_IOC_CONTI_BUFF_PRESET  _IOC(_IOC_NONE, 'P', IOCNR_CONTI_BUFF_PRESET, 0)
#define USB_IOC_CONTI_READ_PAUSE   _IOC(_IOC_NONE, 'P', IOCNR_CONTI_READ_PAUSE, 0)
#define USB_IOC_CONTI_READ_RESTART  _IOC(_IOC_NONE, 'P', IOCNR_CONTI_READ_RESTART, 0)

#define LPIOC_GET_DEVICE_ID(len)     _IOC(_IOC_READ, 'P', IOCNR_GET_DEVICE_ID, len) 
#define LPIOC_GET_VID_PID(len) _IOC(_IOC_READ, 'P', IOCNR_GET_VID_PID, len)

#define USB_IOCT_LOOP_START(a, b)               ioctl(a, USB_IOC_CONTI_READ_START, b)
#define USB_IOCT_LOOP_CONTI_READ(a, b)     ioctl(a, USB_IOC_CONTI_READ_PROBE, b)
#define USB_IOCT_LOOP_STOP(a, b)               ioctl(a, USB_IOC_CONTI_READ_STOP, b)
#define USB_IOCT_LOOP_ONCE(a, b)               ioctl(a, USB_IOC_CONTI_READ_ONCE, b)
#define USB_IOCT_LOOP_RESET(a, b)               ioctl(a, USB_IOC_CONTI_READ_RESET, b)
#define USB_IOCT_LOOP_BUFF_CREATE(a, b)     ioctl(a, USB_IOC_CONTI_BUFF_CREATE, b)
#define USB_IOCT_LOOP_BUFF_PROBE(a, b)     ioctl(a, USB_IOC_CONTI_BUFF_PROBE, b)
#define USB_IOCT_LOOP_BUFF_RELEASE(a, b)     ioctl(a, USB_IOC_CONTI_BUFF_RELEASE, b)
#define USB_IOCT_LOOP_BUFF_SET(a, b)     ioctl(a, USB_IOC_CONTI_BUFF_SET, b)
#define USB_IOCT_LOOP_BUFF_PRESET(a, b)     ioctl(a, USB_IOC_CONTI_BUFF_PRESET, b)
#define USB_IOCT_LOOP_READ_PAUSE(a, b)     ioctl(a, USB_IOC_CONTI_READ_PAUSE, b)
#define USB_IOCT_LOOP_READ_RESTART(a, b)     ioctl(a, USB_IOC_CONTI_READ_RESTART, b)

#define USB_IOCT_GET_DEVICE_ID(a, b)          ioctl(a, LPIOC_GET_DEVICE_ID(4), b)
#define USB_IOCT_GET_VID_PID(a, b)          ioctl(a, LPIOC_GET_VID_PID(8), b)

#define PULL_LOW_AFTER_DATA (0)

#define asp_mem_barrier() asm volatile("" ::: "memory")

#define MODULE_NAME "/dev/mem"
static char usbdevpath[] = "/dev/g_printer";
static char usbdevpath0[] = "/dev/g_printer0";        
static char usbhostpath1[] = "/dev/usb/lp0";
static char usbhostpath2[] = "/dev/usb/lp1";

#define SPI_CPHA  0x01          /* clock phase */
#define SPI_CPOL  0x02           /* clock polarity */
#define SPI_MODE_0      (0|0)
#define SPI_MODE_1      (0|SPI_CPHA)
#define SPI_MODE_2      (SPI_CPOL|0)
#define SPI_MODE_3      (SPI_CPOL|SPI_CPHA)
#if SPI1_ENABLE
static char spidev_1[] = "/dev/spidev32766.0"; 
#else //#if SPI1_ENABLE
static char *spidev_1 = 0;
#endif //#if SPI1_ENABLE
static char spidev_0[] = "/dev/spidev32765.0"; 
static int *asptotMalloc=0;
static int *totSalloc=0;
//static char netIntfs[16] = "uap0";

#if 1
#define container_of(ptr, type, member) ({				\
	void *__mptr = (void *)(ptr);					\
	((type *)(__mptr - offsetof(type, member))); })
#endif
	
#define CBW_CMD_SEND_OPCODE   0x11
#define CBW_CMD_START_SCAN    0x12
#define CBW_CMD_STOP_SCAN    0x13
#define CBW_CMD_PAUSE_SCAN    0x14
#define CBW_CMD_RESTART_SCAN    0x15
#define CBW_CMD_READY   0x08

/* flow operation */
#define OP_NONE          0x0     
#define OP_PON            0x1                
#define OP_QRY            0x2
#define OP_RDY            0x3                
#define OP_SINGLE       0x4
#define OP_DOUBLE      0x5
#define OP_ACTION       0x6
#define OP_FIH             0x7
#define OP_RAW            0x8
#define OP_MSINGLE     0x9
#define OP_MDOUBLE     0xa
#define OP_HANDSCAN  0xb
#define OP_NOTESCAN  0xc
#define OP_POLL           0xd
#define OP_BANKNOTE  0xf

#define  OP_SEND_BACK        0x08
#define  OP_Multi_Single     0x09
#define  OP_Multi_DUPLEX     0x0A
#define  OP_Hand_Scan       0x0B
#define  OP_Note_Scan         0x0C
#define  OP_Multi_Hand_Scan  0x0D
#define  OP_Start_scan    0x0E
#define  OP_Stop_scan     0x0F

#define  OP_META             0x4C
#define OP_META_Sub0      0x0
#define OP_META_Sub1      0x1

#define  OPSUB_WiFi_only      0x01
#define  OPSUB_SD_only       0x02
#define  OPSUB_WiFi_SD       0x03
#define OPSUB_WBC_Proc    0x84
#define  OPSUB_USB_Scan    0x85
#define  OPSUB_DualStream_WiFi_only  0x86
#define  OPSUB_DualStream_SD_only   0x87
#define  OPSUB_Hand_Scan     0x89
#define  OPSUB_Enc_Dec_Test   0x8A

/* SD read write operation */               
#define OP_SDRD            0x20
#define OP_SDWT            0x21
#define OP_STSEC_00     0x22
#define OP_STSEC_01     0x23
#define OP_STSEC_02     0x24
#define OP_STSEC_03     0x25
#define OP_STLEN_00     0x26
#define OP_STLEN_01     0x27
#define OP_STLEN_02     0x28
#define OP_STLEN_03     0x29
#define OP_SDAT             0x2a
#define OP_FREESEC       0x2b
#define OP_USEDSEC       0x2c
#define OP_SDINIT          0x2d
#define OP_SDSTATS       0x2e
#define OP_EG_DECT       0x2f
/* scanner parameters */
#define OP_MSG                0x30       
#define OP_FFORMAT        0x31
#define OP_COLRMOD        0x32
#define OP_COMPRAT        0x33
#define OP_RESOLTN         0x34
#define OP_SCANGAV        0x35
#define OP_MAXWIDH        0x36
#define OP_WIDTHAD_H    0x37
#define OP_WIDTHAD_L    0x38
#define OP_SCANLEN_H     0x39
#define OP_SCANLEN_L     0x3a
#define OP_INTERIMG       0x3b
#define OP_AFEIC             0x3c
#define OP_EXTPULSE       0x3d
#define OP_SUPBACK        0x3e
#define OP_LOG                0x3f

#define OP_RGRD              0x40
#define OP_RGWT              0x41
#define OP_RGDAT            0x42
#define OP_RGADD_H       0x43
#define OP_RGADD_L        0x44

#define OP_CROP_01        0x45
#define OP_CROP_02        0x46
#define OP_CROP_03        0x47
#define OP_CROP_04        0x48
#define OP_CROP_05        0x49
#define OP_CROP_06        0x4a

#define OP_IMG_LEN        0x4b

#define OP_META_DAT     0x4c

#define OP_AP_MODEN     0x50
/*
#define OP_DAT 0x08
#define OP_SCM 0x09
#define OP_DUL 0x0a
*/
#define OP_FUNCTEST_00              0x70
#define OP_FUNCTEST_01              0x71
#define OP_FUNCTEST_02              0x72
#define OP_FUNCTEST_03              0x73
#define OP_FUNCTEST_04              0x74
#define OP_FUNCTEST_05              0x75
#define OP_FUNCTEST_06              0x76
#define OP_FUNCTEST_07              0x77
#define OP_FUNCTEST_08              0x78
#define OP_FUNCTEST_09              0x79
#define OP_FUNCTEST_10              0x7A
#define OP_FUNCTEST_11              0x7B
#define OP_FUNCTEST_12              0x7C
#define OP_FUNCTEST_13              0x7D
#define OP_FUNCTEST_14              0x7E
#define OP_FUNCTEST_15              0x7F

#define OP_BLEEDTHROU_ADJUST 0x81
#define OP_BLACKWHITE_THSHLD 0x82
#define OP_SD_CLK_RATE_16        0x83    
#define OP_PAPER_SIZE                 0x84  
#define OP_JPGRATE_ENG_17        0x85  
#define OP_FUNCTEST_18              0x86  
#define OP_FUNCTEST_19              0x87  
#define OP_FUNCTEST_20              0x88 
#define OP_FUNCTEST_21              0x89 
#define OP_FUNCTEST_22              0x8a
#define OP_SKIP_LENGTH              0x8b
/* debug */

#define OP_SAVE              0x80
#define OP_ERROR            0xe0

#define SPI_MAX_TXSZ  (1024 * 1024)
#define SPI_TRUNK_SZ   (32768)

/* kthread */
#define SPI_KTHREAD_USE    (1) 
#define SPI_UPD_NO_KTHREAD     (0)
#define SPI_KTHREAD_DLY    (0)
#define SPI_TRUNK_FULL_FIX (0)

/* socket */
#define SOCKET_NON_BLOCK_RX  (1)
#define SOCKET_NON_BLOCK_TX  (1)
#define SOCKET_EPOLL_EN (1)
#if SOCKET_EPOLL_EN 
#define MAX_EVENTS (32)
#define EPOLLLT (0)
#endif
/* polling */
#define POLL_MODE_EN (0)
/* wifi debug */
#define DBG_WIFI_REAL (1)

#define MSP_P_NUM (18) /* P0 ~ P15 */
#define ASP_MEM_SLOT_NUM (4096)

#define DIR_POOL_SIZE (1024)

#define MAX_PDF_H  (900.0)
#define MAX_PDF_W (1600.0)

#define JPG_FFD9_CUT (1)
#define JPG_FFD9_RANGE (1024)

#define CROP_USE_META (1)
#define SCANGO_CHECK (1)

#define SAVE_CROP_MASS (0)
#define MSP_SAVE_LOG_TO_FILE (0)

#define OUT_BUFF_LEN  (64*1024)
#define CROP_MAX_NUM_META (18)

#define CHECK_SOCKET_STATUS (0)
#define LOG_P6_CROP_EN    (0)
//#define DEBUG_CROP_ENABLE 
#ifdef DEBUG_CROP_ENABLE
#define CROP_CALCU_DETAIL (0)
#define CROP_CALCU_PROCESS (1)
#define LOG_CROP_CROSUP (1)
#define LOG_CROP_CROSSDNAPH (1)
#define LOG_CROP_MOSTRL (1)
#define LOG_CROP_CROSSUPLINE (1)
#define LOG_CROP_CROSSDNLINE (1)
#define LOG_CROP_ROT36 (1)
#define LOG_CROP_RECT (1)
#define LOG_CROP_FINDBASELINE (1)
#define LOG_CROP_FINDPOINTS (1)
#define LOG_CROP_CALCULINE (1)
#define LOG_CROP_FINDLINE (1)
#define LOG_CROP_TOPOFFSET (1)
#else
#define CROP_CALCU_DETAIL (0)
#define CROP_CALCU_PROCESS (0)
#define LOG_CROP_CROSUP (0)
#define LOG_CROP_CROSSDNAPH (0)
#define LOG_CROP_MOSTRL (0)
#define LOG_CROP_CROSSUPLINE (0)
#define LOG_CROP_CROSSDNLINE (0)
#define LOG_CROP_ROT36 (0)
#define LOG_CROP_RECT (0)
#define LOG_CROP_FINDBASELINE (0)
#define LOG_CROP_FINDPOINTS (0)
#define LOG_CROP_CALCULINE (0)
#define LOG_CROP_FINDLINE (0)
#define LOG_CROP_TOPOFFSET (0)
#endif
//#define CROP_SELEC_RATIO (100.0)
#define CROP_SELEC_HEAD (10)
#define CROP_SELEC_TAIL (10)
#define CROP_MIGRATE_TO_APP (0)

#define CROP_SINGLE_LAST_SET (0x1<<24)

#define CFLOAT double

#define FAT_DIRPOOL_IDX_MAX   (65535)
#define FAT_DIRPOO_ARY_MAX   (4095)

#define LOG_FS_EN (0)
#define LOG_DOT_PROG_EN (0)

#define ANSP0_RECOVER (1)

#define PI (CFLOAT)(3.1415)
#define BMP_TEST (0)

#define SD_RDWT_USING_META (1)
#define MIN_MEM_ALLOC_SIZE (4)

static FILE *mlog = 0;
static struct logPool_s *mlogPool;

typedef int (*func)(int argc, char *argv[]);

typedef enum {
    STINIT = 0,
    WAIT,
    NEXT,
    BREAK,
    BKWRD,
    FWORD,
    EVTMAX,
}event_e;

typedef enum {
    SPY = 0,
    BULLET,      // 1
    LASER,       //  2
    DOUBLEC,   // 3
    DOUBLED,   // 4
    REGE,         // 5
    REGF,
    FATG,
    FATH,
    SUPI,          // 9
    SINJ,          // a
    SAVK,         // b
    SDAL,         // c
    SDAM,        // d
    SDAN,        // e
    SDAO,        // f
    WTBAKP,     // 10
    WTBAKQ,     // 11
    CROPR,     // 11
    VECTORS, // 12
    SAVPARM, // 13
    METAT, // 14
    MDUOU, // 15
    MTSDV, // 16
    OCRW, // 17
    FMTX, // 18
    FMTY, // 19
    USBZ, // 20
    BMFA, // 21
    SMAX,
}state_e;

typedef enum {
    PSSET = 0,
    PSACT,
    PSWT,
    PSRLT,
    PSTSM,
    PSMAX,
}status_e;

typedef enum {
    ASPFS_TYPE_ROOT = 0x1,
    ASPFS_TYPE_DIR,
    ASPFS_TYPE_FILE,
} aspFStp_e;

typedef enum {
    ASPOP_STA_NONE = 0x0,
    ASPOP_STA_WR = 0x01,
    ASPOP_STA_UPD = 0x02,
    ASPOP_STA_APP = 0x04,
    ASPOP_STA_CON = 0x08,
    ASPOP_STA_SCAN = 0x10,
} aspOpSt_e;

typedef enum {
    ASPOP_CODE_NONE = 0,
    ASPOP_FILE_FORMAT,   /* 01 */
    ASPOP_COLOR_MODE,
    ASPOP_COMPRES_RATE,
    ASPOP_SCAN_SINGLE,
    ASPOP_SCAN_DOUBLE,
    ASPOP_ACTION,
    ASPOP_RESOLUTION,
    ASPOP_SCAN_GRAVITY,
    ASPOP_MAX_WIDTH,
    ASPOP_WIDTH_ADJ_H, /* 10 */
    ASPOP_WIDTH_ADJ_L,
    ASPOP_SCAN_LENS_H,
    ASPOP_SCAN_LENS_L,
    ASPOP_INTER_IMG,     
    ASPOP_AFEIC_SEL,     
    ASPOP_EXT_PULSE,     
    ASPOP_SDFAT_RD,      
    ASPOP_SDFAT_WT,
    ASPOP_SDFAT_STR01,
    ASPOP_SDFAT_STR02,  /* 20 */
    ASPOP_SDFAT_STR03,
    ASPOP_SDFAT_STR04,
    ASPOP_SDFAT_LEN01,
    ASPOP_SDFAT_LEN02,
    ASPOP_SDFAT_LEN03,
    ASPOP_SDFAT_LEN04,
    ASPOP_SDFAT_SDAT,
    ASPOP_REG_RD,
    ASPOP_REG_WT,
    ASPOP_REG_ADDRH, /* 30 */
    ASPOP_REG_ADDRL,
    ASPOP_REG_DAT,
    ASPOP_SUP_SAVE,
    ASPOP_SDFREE_FREESEC,
    ASPOP_SDFREE_STR01,
    ASPOP_SDFREE_STR02,
    ASPOP_SDFREE_STR03,
    ASPOP_SDFREE_STR04,
    ASPOP_SDFREE_LEN01,
    ASPOP_SDFREE_LEN02, /* 40 */
    ASPOP_SDFREE_LEN03,
    ASPOP_SDFREE_LEN04,
    ASPOP_SDUSED_USEDSEC,
    ASPOP_SDUSED_STR01,
    ASPOP_SDUSED_STR02,
    ASPOP_SDUSED_STR03,
    ASPOP_SDUSED_STR04,
    ASPOP_SDUSED_LEN01,
    ASPOP_SDUSED_LEN02,
    ASPOP_SDUSED_LEN03, /* 50 */
    ASPOP_SDUSED_LEN04,
    ASPOP_FUNTEST_00,
    ASPOP_FUNTEST_01,
    ASPOP_FUNTEST_02,
    ASPOP_FUNTEST_03,
    ASPOP_FUNTEST_04,
    ASPOP_FUNTEST_05,
    ASPOP_FUNTEST_06,
    ASPOP_FUNTEST_07,
    ASPOP_FUNTEST_08, /* 60 */
    ASPOP_FUNTEST_09,
    ASPOP_FUNTEST_10,
    ASPOP_FUNTEST_11,
    ASPOP_FUNTEST_12,
    ASPOP_FUNTEST_13,
    ASPOP_FUNTEST_14,
    ASPOP_FUNTEST_15,
    ASPOP_BLEEDTHROU_ADJUST,
    ASPOP_BLACKWHITE_THSHLD,
    ASPOP_SD_CLK_RATE_16,
    ASPOP_PAPER_SIZE,
    ASPOP_JPGRATE_ENG_17,
    ASPOP_FUNCTEST_18,
    ASPOP_FUNCTEST_19,
    ASPOP_FUNCTEST_20,
    ASPOP_FUNCTEST_21,
    ASPOP_FUNCTEST_22,
    ASPOP_SKIP_LENGTH,
    ASPOP_CROP_01,
    ASPOP_CROP_02, /* 70 */
    ASPOP_CROP_03,
    ASPOP_CROP_04,
    ASPOP_CROP_05,
    ASPOP_CROP_06,
    ASPOP_IMG_LEN, /* must be here for old design */
    ASPOP_CROP_07,
    ASPOP_CROP_08,
    ASPOP_CROP_09,
    ASPOP_CROP_10,
    ASPOP_CROP_11, /* 80 */
    ASPOP_CROP_12,
    ASPOP_CROP_13,
    ASPOP_CROP_14,
    ASPOP_CROP_15,
    ASPOP_CROP_16,
    ASPOP_CROP_17,
    ASPOP_CROP_18,
    ASPOP_CROP_COOR_XH,
    ASPOP_CROP_COOR_XL,
    ASPOP_CROP_COOR_YH, /* 90 */
    ASPOP_CROP_COOR_YL,
    ASPOP_EG_DECT,
    ASPOP_AP_MODE,
    ASPOP_XCROP_GAT,
    ASPOP_XCROP_LINSTR,
    ASPOP_XCROP_LINREC,
    ASPOP_RAW_SIZE,
    ASPOP_CROP_01_DUO,
    ASPOP_CROP_02_DUO, 
    ASPOP_CROP_03_DUO,
    ASPOP_CROP_04_DUO,   /* 100 */
    ASPOP_CROP_05_DUO,
    ASPOP_CROP_06_DUO,
    ASPOP_IMG_LEN_DUO, /* must be here for old design */
    ASPOP_CROP_07_DUO,
    ASPOP_CROP_08_DUO,
    ASPOP_CROP_09_DUO,
    ASPOP_CROP_10_DUO,
    ASPOP_CROP_11_DUO, 
    ASPOP_CROP_12_DUO,
    ASPOP_CROP_13_DUO,  /* 110 */
    ASPOP_CROP_14_DUO,
    ASPOP_CROP_15_DUO,
    ASPOP_CROP_16_DUO,
    ASPOP_CROP_17_DUO,
    ASPOP_CROP_18_DUO,
    ASPOP_XCROP_GAT_DUO,
    ASPOP_XCROP_LINSTR_DUO,
    ASPOP_XCROP_LINREC_DUO,
    ASPOP_RAW_SIZE_DUO,
    ASPOP_MULTI_LOOP,
    ASPOP_SCAN_STATUS,
    ASPOP_SCAN_STATUS_DUO,
    ASPOP_SCAN_WIDTH,
    ASPOP_SCAN_WIDTH_DUO,
    ASPOP_SCAN_SIDE,
    ASPOP_SCAN_SIDE_DUO,
    ASPOP_USBCROP_FP01,
    ASPOP_USBCROP_FP02,
    ASPOP_USBCROP_FP03,
    ASPOP_USBCROP_FP04,
    ASPOP_USBCROP_FP01_DUO,
    ASPOP_USBCROP_FP02_DUO,
    ASPOP_USBCROP_FP03_DUO,
    ASPOP_USBCROP_FP04_DUO,

    ASPOP_CODE_MAX, /* 121 */
} aspOpCode_e;

typedef enum {
    ASPOP_MASK_0 = 0x0,
    ASPOP_MASK_1 = 0x1,
    ASPOP_MASK_2 = 0x3,
    ASPOP_MASK_3 = 0x7,
    ASPOP_MASK_4 = 0xf,
    ASPOP_MASK_5 = 0x1f,
    ASPOP_MASK_6 = 0x3f,
    ASPOP_MASK_7 = 0x7f,
    ASPOP_MASK_8 = 0xff,
    ASPOP_MASK_16 = 0xffff,
    ASPOP_MASK_32 = 0xffffffff,
} aspOpMask_e;

typedef enum {
    ASPOP_TYPE_NONE = 0,
    ASPOP_TYPE_SINGLE,
    ASPOP_TYPE_MULTI,
    ASPOP_TYPE_VALUE,
} aspOpType_e;

typedef enum {
    SINSCAN_NONE=0,
    SINSCAN_WIFI_ONLY,
    SINSCAN_SD_ONLY,
    SINSCAN_WIFI_SD,
    SINSCAN_WHIT_BLNC,
    SINSCAN_USB,
    SINSCAN_DUAL_STRM,
    SINSCAN_DUAL_SD,
} singleScan_e;

typedef enum {
    DOUSCAN_NONE=0,
    DOUSCAN_WIFI_ONLY,
    DOUSCAN_SD_ONLY,
    DOUSCAN_WIFI_SD,
} doubleScan_e;

typedef enum {
    NOTESCAN_NONE=0,
    NOTESCAN_OPTION_01,
    NOTESCAN_OPTION_02,
    NOTESCAN_OPTION_03,
    NOTESCAN_OPTION_04,
    NOTESCAN_OPTION_05,
    NOTESCAN_OPTION_06,
    NOTESCAN_OPTION_07,
} noteScan_e;

typedef enum {
    SUPBACK_NONE=0,
    SUPBACK_SD,
    SUPBACK_RAW,
    SUPBACK_FAT,
} supBack_e;

typedef enum {
    ACTION_NONE=0,
    ACTION_OPTION_01,
    ACTION_OPTION_02,
    ACTION_OPTION_03,
    ACTION_OPTION_04,
    ACTION_OPTION_05,
} actOption_e;

typedef enum {
    FILE_FORMAT_NONE=0,
    FILE_FORMAT_JPG,
    FILE_FORMAT_PDF,
    FILE_FORMAT_RAW,
    FILE_FORMAT_TIFF_I,
    FILE_FORMAT_TIFF_M,
} fileFormat_e;

typedef enum {
    COLOR_MODE_NONE=0,
    COLOR_MODE_COLOR,
    COLOR_MODE_GRAY,
    COLOR_MODE_GRAY_DETAIL,
    COLOR_MODE_BLACKWHITE,
} colorMode_e;

typedef enum {
    RESOLUTION_NONE=0,
    RESOLUTION_1200,
    RESOLUTION_600,
    RESOLUTION_300, 
    RESOLUTION_200, 
    RESOLUTION_150, 
    RESOLUTION_100, 
    RESOLUTION_75, 
} resolution_e;

typedef enum {
    DEFAULTWIDTH_NONE=0,
    DEFAULTWIDTH_1 = 1,//7000,
    DEFAULTWIDTH_2 = 2,//5184,
    DEFAULTWIDTH_3 = 3,//5120,
    DEFAULTWIDTH_4 = 4,//4856,
    DEFAULTWIDTH_5 = 5,//4320,
    DEFAULTWIDTH_FROM_NUM,
} defaultWidthTag_e;

typedef enum {
    DEFAULTWIDTH_VALNON=0,
    DEFAULTWIDTH_VAL1 = 7000,
    DEFAULTWIDTH_VAL2 = 5184,
    DEFAULTWIDTH_VAL3 = 5120,
    DEFAULTWIDTH_VAL4 = 4856,
    DEFAULTWIDTH_VAL5 = 4320,
} defaultWidthValue_e;

typedef enum {
    SDSTATS_ERROR=0,
    SDSTATS_OK,
} SDStatus_e;

typedef enum {
    APM_NONE=0,
    APM_AP,
    APM_DIRECT,
} APMode_e;

struct aspMemAsign_s{
    int aspMemSize[ASP_MEM_SLOT_NUM];
    uint32_t aspMemAddr[ASP_MEM_SLOT_NUM];
};

struct aspInfoSplit_s{
    char *infoStr;
    int     infoLen;
    struct aspInfoSplit_s *n;
};

struct aspWaitRlt_s{
    char *wtRlt; /* size == 16bytes */
    int  wtMs;
    int  wtComp;
    int  wtChan;
    struct mainRes_s *wtMrs;
};

struct aspConfig_s{
    uint32_t opStatus;
    uint32_t opCode;
    uint32_t opValue;
    uint32_t opMask;
    uint32_t opType;
    uint32_t opBitlen;
};

typedef enum {
    ASPFS_ATTR_READ_ONLY = 0x01,
    ASPFS_ATTR_HIDDEN = 0x02,
    ASPFS_ATTR_SYSTEM = 0x04,
    ASPFS_ATTR_VOLUME_ID = 0x08,
    ASPFS_ATTR_DIRECTORY = 0x10,
    ASPFS_ATTR_ARCHIVE = 0x20,
} aspFSattribute_e;

typedef enum {
    ASPFS_STATUS_NONE = 0,
    ASPFS_STATUS_ING,
    ASPFS_STATUS_EN,
    ASPFS_STATUS_DIS,
} aspFSstatus_e;

typedef enum {
    ASPMETA_POWON_INIT = 0,
    ASPMETA_SCAN_GO = 1,
    ASPMETA_SCAN_COMPLETE = 2,
    ASPMETA_CROP_300DPI = 3,
    ASPMETA_CROP_600DPI = 4,
    ASPMETA_SCAN_COMPLE_DUO = 5,
    ASPMETA_CROP_300DPI_DUO = 6,
    ASPMETA_CROP_600DPI_DUO = 7,
    ASPMETA_SD = 8,
    ASPMETA_OCR = 9,
} aspMetaParam_e;

typedef enum {
    ASPMETA_INPUT = 0,
    ASPMETA_OUTPUT = 1,
} aspMetaInoutFlag_e;

typedef enum {
    ASPMETA_FUNC_NONE = 0,
    ASPMETA_FUNC_CONF = 0b00000001,
    ASPMETA_FUNC_CROP = 0b00000010,
    ASPMETA_FUNC_IMGLEN = 0b00000100,
    ASPMETA_FUNC_SDFREE = 0b00001000,
    ASPMETA_FUNC_SDUSED = 0b00010000,
    ASPMETA_FUNC_SDRD = 0b00100000,
    ASPMETA_FUNC_SDWT = 0b01000000,
} aspMetaFuncbit_e;


typedef enum {
    CSW_STATUS_USER_ABORT = 0x01,
    CSW_STATUS_NO_PAPER = 0x02,
    CSW_STATUS_COVER_OPEN = 0x04,
    CSW_STATUS_SCAN_ERROR = 0x08,
    CSW_STATUS_USER_SCAN = 0x10,
    CSW_STATUS_GENERIC_FAIL = 0x20,
    CSW_STATUS_USB_FAIL = 0x40,
    CSW_STATUS_PAUSE_FAIL = 0x80,
} aspCSWErrCode_e;


struct apWifiConfig_s{
    char wfssid[36];
    int wfsidLen;
    char wfpsk[64];
    int wfpskLen;
};

struct supdataBack_s{
    struct supdataBack_s   *n;
    int supdataTot;
    int supdataUse;
    char supdataBuff[SPI_TRUNK_SZ];
};

struct directnFile_s{
    uint32_t   dftype;
    uint32_t   dfstats;
    char        dfLFN[256];
    char        dfSFN[16];
    uint16_t   dflen;
    uint16_t   dfattrib;
    uint32_t   dfcretime;
    uint32_t   dfcredate;
    uint32_t   dflstacdate;
    uint32_t   dfrecotime;
    uint32_t   dfrecodate;
    uint32_t   dfclstnum;
    uint32_t   dflength;
    struct directnFile_s *pa;
    uint32_t   dfpaid;
    struct directnFile_s *br;
    uint32_t   dfbrid;
    struct directnFile_s *ch;   
    uint32_t   dfchid;
    
    struct adFATLinkList_s *fln;
    uint32_t   dfindex;
};

struct folderQueue_s{
    struct directnFile_s *fdObj;
    struct folderQueue_s *fdnxt;
};

struct pipe_s{
    int rt[2];
};

typedef enum {
    ASPFAT_STATUS_INIT = 0x0,
    ASPFAT_STATUS_MBR = 0x1,
    ASPFAT_STATUS_BOOT_SEC = 0x2,
    ASPFAT_STATUS_FS_INFO = 0x4,
    ASPFAT_STATUS_FAT = 0x8,
    ASPFAT_STATUS_ROOT_DIR = 0x10,
    ASPFAT_STATUS_FOLDER = 0x20,
    ASPFAT_STATUS_SDRD = 0x40,
    ASPFAT_STATUS_SDWT = 0x80,
    ASPFAT_STATUS_FATWT = 0x100,
    ASPFAT_STATUS_DFEWT = 0x200,
    ASPFAT_STATUS_BOOT = 0x400,
    ASPFAT_STATUS_DFECHK = 0x800,
    ASPFAT_STATUS_DFERD = 0x1000,
    ASPFAT_STATUS_SDWBK = 0x2000,
    ASPFAT_STATUS_FMTBSEC = 0x4000,
    ASPFAT_STATUS_FMTFAT = 0x8000,
    ASPFAT_STATUS_FMTROOT = 0x10000,
    ASPFAT_STATUS_FOLDRWT = 0x20000,
} aspFatStatus_e;


struct sdRaw_s{
    char rowBP[512];
};

struct sdbootsec_s{
    int secSt;              // status of boot sector 
    int secJpcmd;      // jump command to the boot program
    char secSysid[8];
    int secSize;          // 512
    int secPrClst;       // 4 8 16 32 64
    int secResv;        // M 
    int secNfat;         // should be 2
    int secTotal;        // total sectors
    int secIDm;         // must be 0xF8
    int secPrfat;         // sectors per FAT
    int secPrtrk;         // sectors per track
    int secNsid;          // number of sides
    int secNhid;          // number of hidden sectors
    int secExtf;           // extension flag, specify the status of FAT mirroring
    int secVers;          // File system version
    int secRtclst;        // indicate the cluster number of root dir
    int secFSif;           // indicate the sector number of FS info, will be 1 normally
    int secBkbt;          // indicate the offset sector number of backup boot sector
    int secPhdk;         // pyhsical disk number, should be 0x80
    int secExtbt;        // extended boot record signature, should be 0x29
    int secVoid;          // volume ID number
    char secVola[12]; // volume label
    char secFtyp[12];   // file system type in ascii
    int secSign;          // shall be 0x55 (BP510) and 0xAA (BP511)
    int secWhfat;        // indicate the sector of fat table
    int secWhroot;      // indicate the sector of root dir
    int secBoffset;
};

struct sdFSinfo_s{
    int finLdsn;            // lead ingnature, shall be 0x52 0x52 0x61 0x41
    int finStsn;             // structure signature, shall be 0x72 0x72 0x41 0x61
    int finFreClst;        // free cluster count
    int finNxtFreClst;   // next free cluster
    int finTrsn;             // shall be 0x00 0x00 0x55 0xaa
};

struct adFATSpaceInfo_s{
    uint32_t  ftfreeClst;
    uint32_t  ftusedClst;
    struct adFATLinkList_s *f;    
};

struct adFATLinkList_s{
    uint32_t ftStart;              // start cluster
    uint32_t ftLen;                // cluster length
    struct adFATLinkList_s *n;    
};

struct sdFATable_s{
    uint8_t *ftbFat1;
    uint32_t ftbLen;
    struct adFATLinkList_s *h;
    struct adFATLinkList_s *c;
    struct adFATSpaceInfo_s ftbMng;
};

struct sdParseBuff_s{
    int dirBuffMax;
    int dirBuffUsed;
    char *dirParseBuff;
};

struct sdDirPool_s{
    int dirMax;
    int dirUsed;
    struct directnFile_s   dirPool[FAT_DIRPOOL_IDX_MAX];
};

struct sdFatDir_s{
    int dirFATMax;
    int dirFATUsed;
    int dirFATDirty;
    struct sdDirPool_s      *fatDirPool[FAT_DIRPOO_ARY_MAX];
    struct directnFile_s     *dirCur;
    struct directnFile_s     *dirRoot;
};

struct sdFatFormat_s{
    uint32_t fmtTotSector;
    uint32_t fmtHidnSector;
    uint32_t fmtSectorPerCls;
    struct sdbootsec_s     fmtBootsec;
    struct sdFSinfo_s       fmtInfosec;
};

struct sdFAT_s{
    int fatStatus;
    int fatRetry;
    struct directnFile_s     fatFileDnld;
    struct directnFile_s     fatFileUpld;
    struct directnFile_s     fatFolderCrt;
    struct directnFile_s     fatCurDir;
    struct directnFile_s     fatRootdir;
    struct sdbootsec_s     fatBootsec;
    struct sdFSinfo_s       fatFSinfo;
    struct sdFATable_s     fatTable;
    struct sdFatDir_s         fatDirTr;
    struct sdParseBuff_s  parBuf;
    struct supdataBack_s    *fatSupdata;
    struct supdataBack_s    *fatSupcur;
    struct supdataBack_s    *fatSupdataDuo;
    struct supdataBack_s    *fatSupcurDuo;
    struct sdFatFormat_s     fatFormat;
};

struct psdata_s {
    uint32_t bkofw;
    uint32_t result;
    uint32_t ansp0;
    struct procRes_s *rs;
};

typedef int (*stfunc)(struct psdata_s *data);

struct logPool_s{
    char *pool;
    char *cur;
    int max;
    int len;
    uint32_t dislog;
};

struct cmd_s{
    int  id;
    char str[16];
    func pfunc;
};

struct ring_s{
    int run;
    int seq;
};

struct ring_p{
    struct ring_s lead;
    struct ring_s dual;
    struct ring_s prelead;
    struct ring_s predual;
    struct ring_s folw;
    struct ring_s psudo;
    struct ring_s *usbrunnig;
    struct ring_s *usbgettig;
};

struct socket_s{
    int listenfd;
    int connfd;
    struct sockaddr_in serv_addr; 
    struct sockaddr_in clint_addr; 
    struct addrinfo addr_in;
};

struct shmem_s{
    int totsz;
    int chksz;
    int slotn;
    char **pp;
    char **bb;
    int svdist;
    struct ring_p *r;
    int lastflg;
    int lastsz;
    int dualsz;
    int *urun;
    int *uget;
};

struct modersp_s{
    int m;
    int r;
    int d;
    int v;  
    int c;
    int t;
};

struct info16Bit_s{
    uint8_t     inout;
    uint8_t     seqnum;
    uint8_t     opcode;
    uint8_t     data;
    uint32_t   opinfo;
};

struct machineCtrl_s{
    uint32_t seqcnt;
    struct info16Bit_s poll;
    struct info16Bit_s tmp;
    struct info16Bit_s cur;
    struct info16Bit_s get;
    struct info16Bit_s ubs;
    struct modersp_s mch;
    char mshmem[SPI_TRUNK_SZ];
};

struct intMbs16_s{
    union {
        uint16_t n;
        uint8_t d[2];
    };
};

struct intMbs32_s{
    union {
        uint32_t n;
        uint8_t d[4];
    };
};

struct t_BKArea {
    struct intMbs16_s	bknax;
    struct intMbs16_s	bknaY;
    struct intMbs16_s	bknaw;
    struct intMbs16_s	bknah;
    uint8_t		bknaside;
    uint8_t		bknalayer;
};

struct aspMetaData_s{
  struct intMbs32_s     FUNC_BITS;             // byte[4] 
  unsigned char  ASP_MAGIC[2];            //byte[6] "0x20 0x14"
  
  /* ASPMETA_FUNC_CONF = 0x1 */       /* 0b00000001 */
  unsigned char  FILE_FORMAT;             //0x31
  unsigned char  COLOR_MODE;              //0x32
  unsigned char  COMPRESSION_RATE;        //0x33
  unsigned char  RESOLUTION;              //0x34
  unsigned char  SCAN_GRAVITY;            //0x35
  unsigned char  CIS_MAX_WIDTH;           //0x36
  unsigned char  WIDTH_ADJUST_H;          //0x37
  unsigned char  WIDTH_ADJUST_L;          //0x38
  unsigned char  SCAN_LENGTH_H;           //0x39
  unsigned char  SCAN_LENGTH_L;           //0x3a
  unsigned char  INTERNAL_IMG;             //0x3b
  unsigned char  AFE_IC_SELEC;             //0x3c
  unsigned char  EXTNAL_PULSE;            //0x3d
  unsigned char  SUP_WRITEBK;             //0x3e
  unsigned char  OP_FUNC_00;               //0x70
  unsigned char  OP_FUNC_01;               //0x71
  unsigned char  OP_FUNC_02;               //0x72
  unsigned char  OP_FUNC_03;               //0x73
  unsigned char  OP_FUNC_04;               //0x74
  unsigned char  OP_FUNC_05;               //0x75
  unsigned char  OP_FUNC_06;               //0x76
  unsigned char  OP_FUNC_07;               //0x77
  unsigned char  OP_FUNC_08;               //0x78
  unsigned char  OP_FUNC_09;               //0x79
  unsigned char  OP_FUNC_10;               //0x7A
  unsigned char  OP_FUNC_11;               //0x7B
  unsigned char  OP_FUNC_12;               //0x7C
  unsigned char  OP_FUNC_13;               //0x7D
  unsigned char  OP_FUNC_14;               //0x7E
  unsigned char  OP_FUNC_15;               //0x7F  
  unsigned char  BLEEDTHROU_ADJUST; //0x81
  unsigned char  BLACKWHITE_THSHLD; //0x82  
  unsigned char  SD_CLK_RATE_16;        //0x83    
  unsigned char  PAPER_SIZE;                //0x84  
  unsigned char  JPGRATE_ENG_17;       //0x85  
  unsigned char  OP_FUNC_18;               //0x86  
  unsigned char  OP_FUNC_19;               //0x87  
  unsigned char  OP_FUNC_20;               //0x88  
  unsigned char  OP_FUNC_21;               //0x89  
  unsigned char  OP_FUNC_22;               //0x8a
  unsigned char  SKIP_LENGTH;              //0x8b
  unsigned char  OP_RESERVE[17];          // byte[64]

  /* bank note area */
  unsigned char  BK_RESERVE1[64];	//byte[128]
  struct intMbs16_s BKNA_NUM;		//byte[130] 16bits
  struct t_BKArea  BKNA_ITEM[5];	//byte[180] 
  unsigned char  BK_RESERVE2[8];	//byte[188]
  
  /* ASPMETA_FUNC_CROP = 0x2 */       /* 0b00000010 */ /* not use in usbscan */
  struct intMbs32_s CROP_POS_1;        //byte[192]
  struct intMbs32_s CROP_POS_2;        //byte[196]
  struct intMbs32_s CROP_POS_3;        //byte[200]
  struct intMbs32_s CROP_POS_4;        //byte[204]
  struct intMbs32_s CROP_POS_5;        //byte[208]
  struct intMbs32_s CROP_POS_6;        //byte[212]
  struct intMbs32_s CROP_POS_7;        //byte[216]
  struct intMbs32_s CROP_POS_8;        //byte[220]
  struct intMbs32_s CROP_POS_9;        //byte[224]
  struct intMbs32_s CROP_POS_10;        //byte[228]
  struct intMbs32_s CROP_POS_11;        //byte[232]
  struct intMbs32_s CROP_POS_12;        //byte[236]
  struct intMbs32_s CROP_POS_13;        //byte[240]
  struct intMbs32_s CROP_POS_14;        //byte[244]
  struct intMbs32_s CROP_POS_15;        //byte[248]
  struct intMbs32_s CROP_POS_16;        //byte[252]
  struct intMbs32_s CROP_POS_17;        //byte[256]
  struct intMbs32_s CROP_POS_18;        //byte[260]
  unsigned char  Start_Pos_1st;         //byte[261]
  unsigned char  Start_Pos_2nd;        //byte[262]
  unsigned char  End_Pos_All;            //byte[263]
  unsigned char  Start_Pos_RSV;        //byte[264], not using for now
  unsigned char  YLine_Gap;               //byte[265]
  unsigned char  Start_YLine_No;       //byte[266]
  unsigned short YLines_Recorded;     //byte[268] 16bits
  
  struct intMbs32_s SCAN_IMAGE_LEN;     //byte[272]
  
  struct intMbs32_s  FREE_SECTOR_ADD;   //byte[276]
  struct intMbs32_s  FREE_SECTOR_LEN;   //byte[280]
  
  struct intMbs32_s  USED_SECTOR_ADD;   //byte[284]
  struct intMbs32_s  USED_SECTOR_LEN;   //byte[288]
  
  struct intMbs32_s  SD_RW_SECTOR_ADD;  //byte[292]
  struct intMbs32_s  SD_RW_SECTOR_LEN;  //byte[296]
  
  unsigned char available[216];
};

struct aspMetaDataviaUSB_s{
  unsigned char  ASP_MAGIC_ASPC[4];  //byte[4] "ASPC"
  unsigned char IMG_HIGH[2];                   // byte[6]
  unsigned char  WIDTH_RESERVE[5];    // byte[11]
  unsigned char IMG_WIDTH[2];                // byte[13] 
  unsigned char MINGS_USE[2];                 // byte[15]
  unsigned char PRI_O_SEC;                 // byte[16]
  unsigned char Scaned_Page[2];                            //byte[18]
  unsigned char BKNote_Total_Layers;                    //byte[19]
  unsigned char   LEDMode;                                                                             //byte[20]
  unsigned char   LEDH2L1;            //if BMP/4_layers, it only use the first 4 LEDs     //byte[21]
  unsigned char   LEDH4L3;                                                                             //byte[22]
  unsigned char   LEDH6L5;                                                                             //byte[23]
  unsigned char   LEDH8L7;                                                                             //byte[24]
  unsigned char   LEDRsvd;                                                                             //byte[25]
  unsigned char MUSE_RESERVE[10];   // byte[35]
  unsigned char BKNote_Slice_idx;   // current image slice index of this Bank Note                            //byte[36]
  unsigned char BKNote_Block_idx;   // current image block index of this Bank Note                            //byte[37]
  unsigned char MCROP_RESERVE[9];   // byte[46]
  unsigned char OCR_rotangle[2];    // byte[48]
  unsigned char OCR_strlen;            // byte[49]
  unsigned char OCR_chars[15];      // byte[64]
  struct intMbs32_s CROP_POS_1;        //byte[68]
  struct intMbs32_s CROP_POS_2;        //byte[72]
  struct intMbs32_s CROP_POS_3;        //byte[76]
  struct intMbs32_s CROP_POS_4;        //byte[80]
  struct intMbs32_s CROP_POS_5;        //byte[84]
  struct intMbs32_s CROP_POS_6;        //byte[88]
  struct intMbs32_s CROP_POS_7;        //byte[92]
  struct intMbs32_s CROP_POS_8;        //byte[96]
  struct intMbs32_s CROP_POS_9;        //byte[100]
  struct intMbs32_s CROP_POS_10;        //byte[104]
  struct intMbs32_s CROP_POS_11;        //byte[108]
  struct intMbs32_s CROP_POS_12;        //byte[112]
  struct intMbs32_s CROP_POS_13;        //byte[116]
  struct intMbs32_s CROP_POS_14;        //byte[120]
  struct intMbs32_s CROP_POS_15;        //byte[124]
  struct intMbs32_s CROP_POS_16;        //byte[128]
  struct intMbs32_s CROP_POS_17;        //byte[132]
  struct intMbs32_s CROP_POS_18;        //byte[136]
  unsigned char  Start_Pos_1st;         //byte[137]
  unsigned char  Start_Pos_2nd;        //byte[138]
  unsigned char  End_Pos_All;            //byte[139]
  unsigned char  Start_Pos_RSV;        //byte[140], not using for now
  unsigned char  YLine_Gap;               //byte[141]
  unsigned char  Start_YLine_No;       //byte[142]
  unsigned short YLines_Recorded;     //byte[144] 16bits
  struct intMbs32_s CROP_POS_F1;        //byte[148]
  struct intMbs32_s CROP_POS_F2;        //byte[152]
  struct intMbs32_s CROP_POS_F3;        //byte[156]
  struct intMbs32_s CROP_POS_F4;        //byte[160]
  unsigned char EPOINT_RESERVE1[64];         //byte[224]
  unsigned char ASP_MAGIC_YL[2];    //byte[226]
  unsigned short MPIONT_LEN;           //byte[228] 16bits  
  unsigned char EXTRA_POINT[4];    //byte[232]
};

struct aspMetaMass_s{
    int massUsed;
    int massMax;
    int massGap;
    int massRecd;
    int massStart;
    char *masspt;
};

struct aspCrop36_s{
    uint32_t crp36Flag;
    CFLOAT crp36Pots[40];
    CFLOAT crp36LineUpbnd[3];
    CFLOAT crp36LineTop[3];
    CFLOAT crp36LineBotn[3];
    CFLOAT crp36LineRight[3];
    CFLOAT crp36LineLeft[3];
    int crp36Up;
    int crp36Dn;
    int crp36Rt;
    int crp36Lf;
    CFLOAT crp36CsUp[2];
    CFLOAT crp36CsDn[2];
    CFLOAT crp36MsLf[2];
    CFLOAT crp36MsRt[2];
    CFLOAT crp36AngleUp;
    CFLOAT crp36AngleDn;
    CFLOAT crp36AngleLf;
    CFLOAT crp36AngleRt;
    CFLOAT crp36CsLineLU[3];
    CFLOAT crp36CsLineRU[3];    
    CFLOAT crp36CsLineLD[3];
    CFLOAT crp36CsLineRD[3];    
    CFLOAT crp36P1[2];
    CFLOAT crp36P2[2];
    CFLOAT crp36P3[2];
    CFLOAT crp36P4[2];
};

struct aspCropExtra_s{
    int crpexMax;
    int crpexSize;
    CFLOAT crpexLfPots[2048];
    CFLOAT crpexRtPots[2048];
    int crpexLfAbs[1024];
    CFLOAT crpexLfAbsVec[512][3];
    CFLOAT crpexLfAbsVecDist[512];
    int crpexLfAbsUsed;
    int crpexLfAbsCut;
    int crpexLfAbsMax;
    int crpexRtAbs[1024];
    CFLOAT crpexRtAbsVec[512][3];
    CFLOAT crpexRtAbsVecDist[512];
    int crpexRtAbsUsed;
    int crpexRtAbsCut;
    int crpexRtAbsMax;
    CFLOAT crpexCrosUp[2];
    CFLOAT crpexCrosDn[2];
    CFLOAT crpexMostLt[2];
    CFLOAT crpexMostRt[2];
    CFLOAT *crpexGrpLUpt;
    CFLOAT *crpexGrpLDpt;
    CFLOAT *crpexGrpRUpt;
    CFLOAT *crpexGrpRDpt;
    int crpexGrpLUStr;
    int crpexGrpLDStr;
    int crpexGrpRUStr;
    int crpexGrpRDStr;
    int crpexGrpLULen;
    int crpexGrpLDLen;
    int crpexGrpRULen;
    int crpexGrpRDLen;
    CFLOAT crpexGrpLUDist;
    CFLOAT crpexGrpLDDist;
    CFLOAT crpexGrpRUDist;
    CFLOAT crpexGrpRDDist;
    CFLOAT crpexLinLU[3];
    CFLOAT crpexLinLD[3];
    CFLOAT crpexLinRU[3];
    CFLOAT crpexLinRD[3];
    CFLOAT crpexLinLUDiv;
    CFLOAT crpexLinLDDiv;
    CFLOAT crpexLinRUDiv;
    CFLOAT crpexLinRDDiv;
    CFLOAT crpCropUp[2];
    CFLOAT crpCropDn[2];
    CFLOAT crpCropLf[2];
    CFLOAT crpCropRt[2];
};

struct aspDoCropCalcu{
    int acrpDPI;
    struct aspCrop36_s       *acrp36;
    struct aspCropExtra_s   *acrpex;
};

struct aspRectObj{
    CFLOAT aspRectLU[2];
    CFLOAT aspRectRU[2];    
    CFLOAT aspRectLD[2];
    CFLOAT aspRectRD[2];    
};

struct bitmapHeader_s {
    char aspbmpMagic[4];
    int    aspbhSize;
    char aspbhReserve[4];
    int    aspbhRawoffset;
    int    aspbiSize;
    int    aspbiWidth;
    int    aspbiHeight;
    int    aspbiCPP;
    int    aspbiCompMethd;
    int    aspbiRawSize;
    int    aspbiResoluH;
    int    aspbiResoluV;
    int    aspbiNumCinCP;
    int    aspbiNumImpColor;
};

struct bitmapRotate_s {
    char *aspRotCrossAry;
    int aspRotCASize;
    char *aspRotCpyBuff;
    int aspRotBuffSize;
};

typedef struct 
{
    long            msgtype;    // for msg , don't modify
    unsigned long   tag;        // for user
    unsigned short  cmd;        // for user
    unsigned short  rsp;        // for user
    unsigned short  dSize;      // for user, attached data size/buffer size
    void *          dPtr;       // for user, attached data_ptr
    void *          mPtr;       // Driver internal use
}__attribute__((__packed__))   mfour_rjob_cmd;

typedef struct
{
    unsigned short mfourRectX;
    unsigned short mfourRectY;
    unsigned short mfourRectW;
    unsigned short mfourRectH;
    unsigned int     mfourLayer;
}   mfour_rect_st;

typedef struct
{
    unsigned short mfourAreaTot;
    mfour_rect_st  mfourAreas[0];
}   mfour_areas_st;

typedef struct
{
    //unsigned short mfourImgW;
    //unsigned short mfourImgH;
    unsigned int mfourIdx;
    //unsigned char mfourResrvd[2];
    //char               mfourFilename[32];
    t_ImageParam mfourAttb;
    unsigned char  mfourData[0];
}   mfour_image_param_st;          // used in BKCMD_SEND_AREA , BKCMD_DONE_AREA

struct bitmapDecodeItem_s {
    int aspDcMax;
    int aspDcWidth;
    int aspDcHeight;
    int aspDcLen;
    mfour_image_param_st *aspDcData;
};

#define BMP_DECODE_PIC_SIZE (4)
struct bitmapDecodeMfour_s {
    int         aspDecStatus;
    struct timespec   aspDecPostime[2];
    int         aspDecPagerst;
    int         aspDecImgidx;
    int         aspPipeMfourRx[2];
    int         aspPipeMfourTx[2];
    int         aspPipeMfourCom[2];
    int          aspDecRectSt[BMP_DECODE_PIC_SIZE];
    mfour_rect_st aspDecRect[BMP_DECODE_PIC_SIZE];
    struct bitmapDecodeItem_s aspDecJpeg;
    struct bitmapDecodeItem_s aspDecMeta;
    struct bitmapDecodeItem_s aspDecMetaex;
    struct bitmapDecodeItem_s aspDecRaw;
    struct bitmapDecodeItem_s aspDecMfPiRaw[BMP_DECODE_PIC_SIZE];
    struct bitmapDecodeItem_s aspDecMfPiJpg[BMP_DECODE_PIC_SIZE];
};

struct usbCBWopc_s{
		struct intMbs32_s 	opcID; 			// 0x55534243 
		struct intMbs32_s 	opcTag;			// sent by host , and device will send it back in CSW
		struct intMbs32_s 	opcDataLength;	// data length between CBW and CSW , 0 = no data 
		uint8_t	              opcreserved0[3];	// 3 byte reserved
		uint8_t 	              opcType;		// refer to section 2.1
		uint8_t	              opcOpcode;		// opcode 	, refer to section 4
		uint8_t	              opcSubOPCode;	// sub opcode , refer to section 4
		uint8_t	              opcParameter;	// parameter , refer to section 4
		uint8_t	              opcreserved1[12]; 	// 12 byte reserved
};

struct usbCBWpram_s{
		struct intMbs32_s 	pramID; 			// 0x55534243 
		struct intMbs32_s 	pramTag;			// sent by host , and device will send it back in CSW
		struct intMbs32_s 	pramDataLength;	// data length between CBW and CSW , 0 = no data 
		uint8_t	              pramreserved0[3];	// 3 byte reserved
		uint8_t 	              pramType;		// 0x00 ~ 0x0F = Programmer OPCode
		struct intMbs32_s	pramAddress;		// forward to MCU
		uint8_t	              pramreserved1[8]; 	// forward to MCU
		uint8_t	              ASIC_sel; 	             //  0=Primary ASIC , 1=Secondary ASIC
		uint8_t	              cs; 	                           // forward to MCU
		uint8_t	              pramDirect;		// 1=output (BULK OUT), 2=input (BULK IN), 0=no data
};

struct usbCBWfile_s{
		struct intMbs32_s 	pramID; 			// 0x55534243 
		struct intMbs32_s 	pramTag;			// sent by host , and device will send it back in CSW
		struct intMbs32_s 	pramDataLength;	// data length between CBW and CSW , 0 = no data 
		uint8_t	              pramFileId[2];	       // file id for linux access
		uint8_t	              pramWrtorRd[1];	       // write or read access to fileid 1=read 2=write
		uint8_t 	              pramType;		      // 0x0B = file access OPCode
		struct intMbs32_s	pramAddress;		// address to MCU
		struct intMbs32_s	pramFilesize;	       // file size for file id
		uint8_t	              pramreserved1[4]; 	// forward to MCU
		uint8_t	              ASIC_sel; 	             //  0=Primary ASIC , 1=Secondary ASIC
		uint8_t	              cs; 	                           // forward to MCU
		uint8_t	              pramDirect;		// 1=output (BULK OUT), 2=input (BULK IN), 0=no data
};

struct usbCSWfile_s{
		struct intMbs32_s 	pramID; 			// 0x55534243 
		struct intMbs32_s 	pramTag;			// sent by host , and device will send it back in CSW
		struct intMbs32_s 	pramFilesize;	      // file size of current file id
		uint8_t	              pramStatus;		      // status of file id access
};

struct usbFileidContent_s{
		char       usfdid[4];
		uint32_t  usfdsize;
		uint32_t  usfdAddr;
};

struct usbFileidAccess_s{
		char                                  usfacMagicBegin[4];
		int                                     usfacLength;
		struct usbFileidContent_s  *usfacPt;
		char                                  usfacMagicEnd[4];
};

struct usbhost_s{
    int ushid;
    struct shmem_s *pushring;
    struct shmem_s *pgatring;
    char *puhsmeta;
    int *pushrx;
    int *pushtx;
    int *pgatrx;
    int *pgattx;
    int *pjpgrx;
    int *pjpgtx;
    int pushcnt;
    int pushrmcnt;
    int pushcswerr;
    
    uint32_t *pushvaddrtb;
};

struct usbHostmem_s {
    char         *ushostname;
    int            ushostid;
    uint32_t  *ushostblvir;
    uint32_t  *ushostblphy;
    int            ushostbmax;
    int            ushostbthrshold;
    int            ushostbtrktot;
    int            ushostbtrkcms;
    int            ushostbtrkbuffed;
    int            ushostbtrkpage;
    int            ushostbtrkpageavg;
    int            ushostbpagecnt;
    int            ushostresume;
    int            ushostpause;
    int            ushostpidvid[2];
};

struct usbIndex_s{
    int uimIdex;
    int uimCount;
    int uimGetCnt;    
    struct usbIndex_s *uimNxt;
};

struct usbBuff_s{
    //char bpt[USB_BUF_SIZE];
    int bsz;
    char *bpt;
    struct usbBuff_s *bn;
};

struct usbBuffLink_s{
    int ubindex;
    struct usbBuff_s *ubbufh;
    struct usbBuff_s *ubbufc;
    struct usbBuff_s *ubbufo;
    struct usbBuffLink_s *ubnxt;     
    int ublastsize;
    int ubmetasize;
    int ubcylcnt;
    int ubcswerr;
    char *ubinfoaddr;
};

struct usbfileid_s{
    int usbfileidnx;
    int usbfilesize;
    int usbfileaddr;
};

struct mainRes_s{
    char nmrs[32];
    uint32_t mspconfig;
    int sid[19];
    int sfm[2];
    int smode;
    int usbmfd;
    int usbdv;
    char *usbdvname;
    struct usbFileidAccess_s usbfile;
    struct usbhost_s *usbhost[2];
    struct usbHostmem_s *usbmh[2];
    struct psdata_s stdata;
    struct sdFAT_s aspFat;
    struct aspConfig_s configTable[ASPOP_CODE_MAX];
    struct folderQueue_s *folder_dirt;
    struct machineCtrl_s mchine;
    // 3 pipe
    struct pipe_s pipedn[22];
    struct pipe_s pipeup[22];
    // data mode share memory
    struct shmem_s dataRx;
    // command mode share memory
    struct shmem_s cmdRx; /* cmdRx for spi0 */
    struct shmem_s cmdTx;
    struct spi_ioc_transfer *spioc1;
    struct spi_ioc_transfer *spioc2;
    // file save
    FILE *fs;
    // file log
    FILE *flog;
    // time measurement
    struct timespec time[2];
    struct timespec time2[2];
    struct timespec roundtripgoto[2];
    struct timespec roundtripback[2];
    // log buffer
    char log[1024];
    struct socket_s socket_r;
    struct socket_s socket_t;
    struct socket_s socket_at;
    struct socket_s socket_n;
    struct socket_s socket_v;
    struct logPool_s *plog;
    struct aspWaitRlt_s wtg;
    struct apWifiConfig_s wifconf;
    struct aspMetaDataviaUSB_s  metaUsb;
    struct aspMetaDataviaUSB_s  metaUsbfs145;
    struct aspMetaData_s metaout;
    struct aspMetaData_s metain;
    struct aspMetaMass_s metaMass;
    struct aspCrop36_s      crop32;
    struct aspCropExtra_s  cropex;
    struct aspMetaDataviaUSB_s  metaUsbDuo;
    struct aspMetaDataviaUSB_s  metaUsbDuofs145;
    struct aspMetaData_s  metainDuo;
    struct aspMetaMass_s metaMassDuo;
    struct aspCrop36_s       crop32Duo;
    struct aspCropExtra_s   cropexDuo;
    struct bitmapHeader_s bmpheader;
    struct bitmapHeader_s bmpheaderDuo;
    struct bitmapRotate_s bmpRotate;
    struct bitmapDecodeMfour_s bmpDecMfour[4];
    char       *bmpMfourTxbuff;
    char       *bmpMfourRxbuff;
    int          *bmpMfourPipTx;
    int          *bmpMfourPipRx;

    char netIntfs[32];
    char netIntwpa[32];
    char *dbglog;
};

typedef int (*fselec)(struct mainRes_s *mrs, struct modersp_s *modersp);

struct fselec_s{
    int  id;
    fselec pfunc;
};

struct procRes_s{
    char nrs[32];
    // pipe
    uint32_t *pmsconfig;
    int spifd;
    int usbdvid;
    char *usvdvname;
    struct usbFileidAccess_s *pusbfile;
    struct usbhost_s *pusbhost;
    struct usbHostmem_s *pusbmh[2];
    struct psdata_s *pstdata;
    struct sdFAT_s *psFat;
    struct sdFatDir_s   *cpyfatDirTr;
    struct aspConfig_s *pcfgTable;
    struct pipe_s *ppipedn;
    struct pipe_s *ppipeup;
    struct shmem_s *pdataRx;
    struct shmem_s *pcmdRx;
    struct shmem_s *pcmdTx;
    struct spi_ioc_transfer *rspioc1;
    struct spi_ioc_transfer *rspioc2;

    struct machineCtrl_s *pmch;

    // data mode share memory
    int cdsz_s;
    int mdsz_s;
    char **dmp_s;
    // command mode share memory
    int ccsz_s;
    int mcsz_s;
    char **cmp_s;
    // save file
    FILE *fs_s;
    // save log file
    FILE *flog_s;
    // save data file
    FILE *fdat_s[4];
    // time measurement
    struct timespec *tm[2];
    struct timespec *tm2[2];
    struct timespec *rtpTo[2];
    struct timespec *rtpBk[2];
    struct timespec tdf[2];
    char logs[2048];
    struct socket_s *psocket_r;
    struct socket_s *psocket_t;
    struct socket_s *psocket_at;
    struct socket_s *psocket_n;
    struct socket_s *psocket_v;
    struct apWifiConfig_s *pwifconf;
    struct aspMetaData_s *pmetaout;
    struct aspMetaDataviaUSB_s *pmetausb;
    struct aspMetaData_s *pmetain;
    struct aspMetaMass_s *pmetaMass;
    struct aspCrop36_s *pcrop32;
    struct aspCropExtra_s *pcropex;
    struct aspMetaDataviaUSB_s *pmetausbduo;
    struct aspMetaData_s *pmetainduo;
    struct aspMetaMass_s *pmetaMassduo;
    struct aspCrop36_s *pcrop32duo;
    struct aspCropExtra_s *pcropexduo;
    struct bitmapHeader_s *pbheader;
    struct bitmapHeader_s *pbheaderDuo;
    struct bitmapRotate_s *pbrotate;
    struct bitmapDecodeMfour_s *pbDecMfour[4];
    
    char *pbMfTxBuff;
    char *pbMfRxBuff;

    struct logPool_s *plogs;
    char *pnetIntfs;
    char *pnetIntwpa;
};

struct aspMemAsign_s *aspMemAsign=0;

#if LOG_ALL_DISABLE
static int sprintf_f(char *a, char *b, ...);
static int sprintf_f(char *a, char *b, ...)
{

    return 0;
}
#else
#define sprintf_f  sprintf
#endif

//memory alloc. put in/put out
static char **memory_init(int *sz, uint32_t tsize, int csize);
//debug printf
static int print_f(struct logPool_s *plog, char *head, char *str);
static int printf_flush(struct logPool_s *plog, FILE *f);
static int print_dbg(struct logPool_s *plog, char *str, int size);
static int printf_dbgflush(struct logPool_s *plog, struct mainRes_s *mrs, int argc);
//time measurement, start /stop
static int time_diff(struct timespec *s, struct timespec *e, int unit);
//file rw open, save to file for debug
static int file_save_get(FILE **fp, char *path1);
static FILE *find_save(char *dst, char *tmple);
static FILE *find_read(char *dst);
static FILE *find_write(char *dst);
//res put in
static int res_put_in(struct procRes_s *rs, struct mainRes_s *mrs, int idx);
//p0: control, monitor, and debug
static int p0(struct mainRes_s *mrs);
static int p0_init(struct mainRes_s *mrs);
static int p0_end(struct mainRes_s *mrs);
//p1: spi0 send
static int p1(struct procRes_s *rs, struct procRes_s *rcmd);
static int p1_init(struct procRes_s *rs, struct procRes_s *rcmd);
static int p1_end(struct procRes_s *rs, struct procRes_s *rcmd);
//p2: spi0 recv
static int p2(struct procRes_s *rs);
static int p2_init(struct procRes_s *rs);
static int p2_end(struct procRes_s *rs);
//p3: spi1 recv
static int p3(struct procRes_s *rs);
static int p3_init(struct procRes_s *rs);
static int p3_end(struct procRes_s *rs);
//p4: socket send
static int p4(struct procRes_s *rs);
static int p4_init(struct procRes_s *rs);
static int p4_end(struct procRes_s *rs);
//p5: socket recv
static int p5(struct procRes_s *rs, struct procRes_s *rcmd);
static int p5_init(struct procRes_s *rs, struct procRes_s *rcmd);
static int p5_end(struct procRes_s *rs, struct procRes_s *rcmd);
//p6: file list recv/send
static int p6(struct procRes_s *rs);
static int p6_init(struct procRes_s *rs);
static int p6_end(struct procRes_s *rs);
//p7: socket send data for spi1 command mode
static int p7(struct procRes_s *rs);
static int p7_init(struct procRes_s *rs);
static int p7_end(struct procRes_s *rs);
//p8: get UDP broadcast and reply
static int p8(struct procRes_s *rs);
static int p8_init(struct procRes_s *rs);
static int p8_end(struct procRes_s *rs);
static int p9(struct procRes_s *rs);
static int p9_init(struct procRes_s *rs);
static int p9_end(struct procRes_s *rs);
static int p10(struct procRes_s *rs);
static int p10_init(struct procRes_s *rs);
static int p10_end(struct procRes_s *rs);
static int p11(struct procRes_s *rs, struct procRes_s *rsd, struct procRes_s *rcmd);
static int p11_init(struct procRes_s *rs, struct procRes_s *rsd, struct procRes_s *rcmd);
static int p11_end(struct procRes_s *rs, struct procRes_s *rsd, struct procRes_s *rcmd);
static int pn_init(struct procRes_s *rs);
static int pn_end(struct procRes_s *rs);
//IPC wrap
static int rs_ipc_put(struct procRes_s *rs, char *str, int size);
static int rs_ipc_get(struct procRes_s *rs, char *str, int size);
static int mrs_ipc_put(struct mainRes_s *mrs, char *str, int size, int idx);
static int mrs_ipc_get(struct mainRes_s *mrs, char *str, int size, int idx);
static int msp_spi_conf(int dev, int flag, void *bitset);
static int mtx_data(int fd, uint8_t *rx_buff, uint8_t *tx_buff, int pksz, struct spi_ioc_transfer *tr);

static int ring_buf_init(struct shmem_s *pp);
static int ring_buf_get_dual(struct shmem_s *pp, char **addr, int sel);
static int ring_buf_set_last_dual(struct shmem_s *pp, int size, int sel);
static int ring_buf_prod_dual(struct shmem_s *pp, int sel);
static int ring_buf_cons_dual(struct shmem_s *pp, char **addr, int sel);
static int ring_buf_get(struct shmem_s *pp, char **addr);
static int ring_buf_set_last(struct shmem_s *pp, int size);
static int ring_buf_prod(struct shmem_s *pp);
static int ring_buf_cons(struct shmem_s *pp, char **addr);
static int ring_buf_info_len(struct shmem_s *pp);
static int shmem_from_str(char **addr, char *dst, char *sz);
static int shmem_dump(char *src, int size);
static int shmem_pop_send(struct mainRes_s *mrs, char **addr, int seq, int p);
static int shmem_rlt_get(struct mainRes_s *mrs, int seq, int p);
static int stspy_01(struct psdata_s *data);
static int stspy_02(struct psdata_s *data);
static int stspy_03(struct psdata_s *data);
static int stspy_04(struct psdata_s *data);
static int stspy_05(struct psdata_s *data);
static int stbullet_01(struct psdata_s *data);
static int stbullet_02(struct psdata_s *data);
static int stbullet_03(struct psdata_s *data);
static int stbullet_04(struct psdata_s *data);
static int stbullet_05(struct psdata_s *data);
static int stlaser_01(struct psdata_s *data);
static int stlaser_02(struct psdata_s *data);
static int stlaser_03(struct psdata_s *data);
static int stlaser_04(struct psdata_s *data);
static int stlaser_05(struct psdata_s *data);
static int stdob_01(struct psdata_s *data);
static int stdob_02(struct psdata_s *data);
static int stdob_03(struct psdata_s *data);
static int stdob_04(struct psdata_s *data);
static int stdob_05(struct psdata_s *data);
static int stdob_06(struct psdata_s *data);
static int stdob_07(struct psdata_s *data);
static int stdob_08(struct psdata_s *data);
static int stdob_09(struct psdata_s *data);
static int stdob_10(struct psdata_s *data);
static int streg_11(struct psdata_s *data);
static int streg_12(struct psdata_s *data);
static int streg_13(struct psdata_s *data);
static int streg_14(struct psdata_s *data);
static int streg_15(struct psdata_s *data);
static int streg_16(struct psdata_s *data);
static int streg_17(struct psdata_s *data);
static int stfat_18(struct psdata_s *data);
static int stfat_19(struct psdata_s *data);
static int stfat_20(struct psdata_s *data);
static int stfat_21(struct psdata_s *data);
static int stfat_22(struct psdata_s *data);
static int stfat_23(struct psdata_s *data);
static int stfat_24(struct psdata_s *data);
static int stfat_25(struct psdata_s *data);
static int stfat_26(struct psdata_s *data);
static int stfat_27(struct psdata_s *data);
static int stfat_28(struct psdata_s *data);
static int stfat_29(struct psdata_s *data);
static int stfat_30(struct psdata_s *data);
static int stsup_31(struct psdata_s *data);
static int stsup_32(struct psdata_s *data);
static int stsup_33(struct psdata_s *data);
static int stsup_34(struct psdata_s *data);
static int stsup_35(struct psdata_s *data);
static int stsin_36(struct psdata_s *data);
static int stdow_37(struct psdata_s *data);
static int stupd_38(struct psdata_s *data);
static int stupd_39(struct psdata_s *data);
static int stupd_40(struct psdata_s *data);

static int mspFS_createRoot(struct directnFile_s **root, struct sdFAT_s *psFat, char *dir);
static int mspFS_insertChilds(struct sdFAT_s *psFat, struct directnFile_s *root);
static int mspFS_insertChildDir(struct sdFAT_s *psFat, struct directnFile_s *parent, char *dir);
static int mspFS_insertChildFile(struct sdFAT_s *psFat, struct directnFile_s *parent, char *str);
static int mspFS_list(struct directnFile_s *root, int depth);
static int mspFS_FileSearch(struct directnFile_s **dir, struct directnFile_s *root, char *path);
static int mspFS_showFolder(struct directnFile_s *root);
static int mspFS_folderJump(struct directnFile_s **dir, struct directnFile_s *root, char *path);
static int mspSD_parseFAT2LinkList(struct adFATLinkList_s **head, uint32_t idx, uint8_t *fat, uint32_t max);

static int mspFS_allocDir(struct sdFatDir_s  *pfatDir, struct directnFile_s **dir, int pidx);
static uint32_t mspSD_getNextFreeFAT(uint32_t idx, uint8_t *fat, uint32_t max) ;
static int aspFS_createFATRoot(struct sdFAT_s *pfat);
static int aspFS_insertFATChilds(struct sdFAT_s *pfat, struct directnFile_s *root, char *dir, int max);
static int aspFS_insertFATChild(struct directnFile_s *parent, struct directnFile_s *r);
static uint8_t aspFSchecksum(uint8_t *pch);
static char aspLnameFilter(char ch);
static char aspSnameFilterIn(char ch);
static char aspSnameFilterOut(char ch);
static uint32_t aspFSdateCps(uint32_t val);
static uint32_t aspFStimeCps(uint32_t val);
static int aspNameCpyfromRaw(char *raw, char *dst, int offset, int len, int jump);
static int aspNameCpyfromName(char *raw, char *dst, int offset, int len, int jump);
static int atFindIdx(char *str, char ch);

static int cmdfunc_opchk_single(uint32_t val, uint32_t mask, int len, int type);
static int cfgTableUpd(struct aspConfig_s *table, int idx, uint32_t val);
static int cfgTableSet(struct aspConfig_s *table, int idx, uint32_t val);
static void* aspMemalloc(uint32_t asz, int pidx);
static int aspMemFree(void *dval, int pidx);
static void* aspMalloc(int mlen, int pidx);
static void aspFree(void *p, int pidx);
static void* aspSalloc(uint32_t slen);
static int getParallelVectorFromV(CFLOAT *vec, CFLOAT *p, CFLOAT *vecIn);
static int getRectVectorFromV(CFLOAT *vec, CFLOAT *p, CFLOAT *vecIn);
static int getVectorFromP(CFLOAT *vec, CFLOAT *p1, CFLOAT *p2);
static int getCross(CFLOAT *v1, CFLOAT *v2, CFLOAT *pt);
static CFLOAT calcuDistance(CFLOAT *p1, CFLOAT *p2);
static CFLOAT calcuVectorDistancePoint(CFLOAT *vec, CFLOAT *p);
static CFLOAT calcuLineGroupDist(CFLOAT *pGrp, CFLOAT *vecTr, int gpLen);
static int calcuGroupLine(CFLOAT *pGrp, CFLOAT *vecTr, CFLOAT *div, int gpLen, int midx);
static int topPositive(struct aspCropExtra_s *pcpex);
static int cfgTableGet(struct aspConfig_s *table, int idx, uint32_t *rval);
static int cfgTableGetChk(struct aspConfig_s *table, int idx, uint32_t *rval, uint32_t stat);
static int mspFS_folderList(struct directnFile_s *root, int depth);
static char **memory_init_vtable(char **pbuf, int tsize, int csize, uint32_t *tbl);
static int fileid_save(char *fileidpoll, struct usbFileidAccess_s *pubf);
static int bitmapHeaderSetup(struct bitmapHeader_s *ph, int clr, int w, int h, int dpi, int flen);
static int findRectOrient(struct aspRectObj *pRout, struct aspRectObj *pRin);
static CFLOAT aspMin(CFLOAT d1, CFLOAT d2);
static inline char* getPixel(char *rawCpy, int dx, int dy, int rowsz, int bitset);
static int cfgTableGetChkDPI(struct aspConfig_s *table, int idx, uint32_t *rval, uint32_t stat);
static int dbgRjobCmd(mfour_rjob_cmd *rjcmd, int len);
#if MFOUR_API
int mfourmaind(char *shmtx);
int mfourSetPipEpt1(int *pip);
int mfourSetPipEpt2(int *pip);
int m4_enter(int id);

static int *pipMfTx=0;
static int *pipMfRx=0;

static int mfourWtCmd(int dvid, mfour_rjob_cmd  *fcmd);
static int mfourRdCmd(int dvid, mfour_rjob_cmd  *fcmd);

#define RJOB_IOCT_WT_CMD_API    mfourWtCmd
#define RJOB_IOCT_RD_CMD_API    mfourRdCmd
#endif

#if GHP_EN
#define	MaxCount_SRN	20
void *BKOCR_Check( void * img_buf, int img_size, char *out_buf, int buf_size );
void *BKOCR_Check6( void * img_buf, int img_size, char *out_buf, int buf_size );
void *BKOCR_Check7( void * img_buf, int img_size, char *out_buf, int buf_size );
#else
#define	MaxCount_SRN	20
static void *BKOCR_NULL( void * img_buf, int img_size, char *out_buf, int buf_size );
static void *BKOCR_NULL( void * img_buf, int img_size, char *out_buf, int buf_size )
{
    return 0l;
}


#define BKOCR_Check BKOCR_NULL
#define BKOCR_Check6 BKOCR_NULL
#define BKOCR_Check7 BKOCR_NULL
#endif

static int qsort_comp(const void *a, const void *b) {
    CFLOAT *pa = (CFLOAT *) a;
    CFLOAT *pb = (CFLOAT *) b;
    CFLOAT ia = *(pa + 1);
    CFLOAT ib = *(pb + 1);
    if (ia < ib) { return -1; }
    else if (ia == ib) { return 0; }
    else return 1;
}

#if GHP_EN
#if 0 // tubojpeg
static int tj_jpeg2rgb(unsigned char *pjpg, int jpgsz, char *prgb, int rgbsz, int *getW, int *getH, int clrsp)
{
    long unsigned int _jpegSize=0;
    int jpegSubsamp=0, width=0, height=0;

    tjhandle _jpegDecompressor = tjInitDecompress();

    tjDecompressHeader2(_jpegDecompressor, pjpg, jpgsz, &width, &height, &jpegSubsamp);

    tjDecompress2(_jpegDecompressor, pjpg, jpgsz, prgb, width, 0, height, clrsp, TJFLAG_FASTDCT);

    *getW = width;
    *getH = height;

    tjDestroy(_jpegDecompressor);

    return 0;
}
#endif
#define WIN_WIDTH (400)
#define WIN_HEIGHT (400)

GLuint textureID=0;
GLuint renderBufferID=0;
GLuint frameBufferID=0;
static void SetupRC(void)
{
    #if 0
    glRenderMode(GL_RENDER);
    glGenTextures(1, &textureID);
    glBindTexture(GL_TEXTURE_2D, textureID);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, WIN_WIDTH, WIN_HEIGHT, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
    //glBindTexture(GL_TEXTURE_2D, 0);

    glGenRenderbuffers(1, &renderBufferID);
    glBindRenderbuffer(GL_RENDERBUFFER, renderBufferID);
    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, WIN_WIDTH, WIN_HEIGHT);
    //glBindRenderbuffer(GL_RENDERBUFFER, 0);

    glGenFramebuffers(1, &frameBufferID);
    glBindFramebuffer(GL_FRAMEBUFFER, frameBufferID);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, textureID, 0);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, renderBufferID);
    //glBindFramebuffer(GL_FRAMEBUFFER, 0);   

    printf("[GL] setup GL %d %d %d \n", textureID, renderBufferID, frameBufferID);

    GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
    if (status != GL_FRAMEBUFFER_COMPLETE)
    {
        fprintf(stderr, "GLEW Error, FRAME BUFFER STATUS Error!%d", status);
        //return;
    }

    glEnable(GL_DEPTH_TEST);
    glEnable(GL_TEXTURE_2D);
    #endif
}

static int glsetup(void)
{

    return 0;
}

void drawCube()
{
    #if 0
    glBindTexture(GL_TEXTURE_2D, textureID);
    glColor4f(1, 1, 1, 1);

    glBegin(GL_QUADS);
    //Front
    glNormal3d(0, 0, 1);
    glVertex3d(-1,-1, 1);   glTexCoord2d(0,0);
    glVertex3d(1, -1, 1);   glTexCoord2d(1,0);
    glVertex3d(1, 1, 1);    glTexCoord2d(1,1);
    glVertex3d(-1, 1, 1);   glTexCoord2d(0,1);

    //Back
    glNormal3d(0, 0, -1);
    glVertex3d(1, -1 , -1); glTexCoord2d(0, 0);
    glVertex3d(-1, -1, -1); glTexCoord2d(1, 0);
    glVertex3d(-1, 1, -1);  glTexCoord2d(1, 1);
    glVertex3d(1, 1, -1);   glTexCoord2d(0, 1);

    //Left
    glNormal3d(-1, 0, 0);
    glVertex3d(-1, -1, -1); glTexCoord2d(0, 0);
    glVertex3d(-1, -1, 1);  glTexCoord2d(1, 0);
    glVertex3d(-1, 1, 1);   glTexCoord2d(1, 1);
    glVertex3d(-1, 1, -1);  glTexCoord2d(0, 1);

    //Right
    glNormal3d(1, 0, 0);
    glVertex3d(1, -1, 1);   glTexCoord2d(0, 0);
    glVertex3d(1, -1, -1);  glTexCoord2d(1, 0);
    glVertex3d(1, 1, -1);   glTexCoord2d(1, 1);
    glVertex3d(1, 1, 1);    glTexCoord2d(0, 1);

    //Top
    glNormal3d(0, 1, 0);
    glVertex3d(-1, 1, 1);   glTexCoord2d(0, 0);
    glVertex3d(1, 1, 1);    glTexCoord2d(1, 0);
    glVertex3d(1, 1, -1);   glTexCoord2d(1, 1);
    glVertex3d(-1, 1, -1);  glTexCoord2d(0, 1);

    //Bottom
    glNormal3d(0, -1, 0);
    glVertex3d(1, -1, 1);   glTexCoord2d(0, 0);
    glVertex3d(-1, -1, 1);  glTexCoord2d(1, 0);
    glVertex3d(-1, -1, -1); glTexCoord2d(1, 1);
    glVertex3d(1, -1, -1);  glTexCoord2d(0, 1);

    glEnd();
    glBindTexture(GL_TEXTURE_2D, 0);
    #endif
}

static int draw(void)
{
    GLuint fb0=0;

    int ret=0;
    GLenum fbstatus=0;
    
    #if 1
    SetupRC();
    #else
    glGenFramebuffers(1, &fb0);
    if (fb0) {
        printf("[GL] gen framebuffer fb0: %d!!! \n", fb0);
        glBindFramebuffer(GL_FRAMEBUFFER, fb0);
    } else {
        printf("[GL] gen framebuffer error!!! \n");

        glGenBuffers(1, &fb0);
        if (fb0) {
            printf("[GL] gen buffer fb0: %d!!! \n", fb0);
            glBindBuffer(GL_FRAMEBUFFER, fb0);
        } else {
            printf("[GL] gen buffer error!!! \n");
            //glBindBuffer(GL_FRAMEBUFFER, 0);
            glBindFramebuffer(GL_FRAMEBUFFER, 0);
        }
    }
    
     fbstatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);
    if (fbstatus != GL_FRAMEBUFFER_COMPLETE)
    {
        printf("GLEW Error FRAME BUFFER STATUS Error: %d \n", fbstatus);
    }

    glGenTextures(1, &textureID);
    if (textureID) {
        printf("[GL] gen texture id: %d!!! \n", textureID);
        glBindTexture(GL_TEXTURE_2D, textureID);
        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, WIN_WIDTH, WIN_HEIGHT, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
    } else {
        printf("[GL] gen texture error!!! \n");
    }
    #endif

    #if 0
    //glBindBuffer(GLenum target, GLuint buffer)
    //glBufferStorage(GLenum target, GLsizeiptr size, const void * data, GLbitfield flags)
    //glClear(GL_COLOR_BUFFER_BIT);
    //glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer)
    glBegin(GL_TRIANGLES);

    //glLoadIdentity();
    
    //glRasterPos2i(0, 0);
    
    glColor3f(1.0f, 0.0f, 0.0f); glVertex2f(0.0f, 0.0f);

    glColor3f(0.0f, 1.0f, 0.0f); glVertex2f(1.0f, 0.0f);

    glColor3f(0.0f, 0.0f, 1.0f); glVertex2f(0.5f, 1.0f);

    glEnd();

    //glPixelZoom(-0.5f,-0.5f);
    //glRasterPos2i(1, 1);

    //glCopyPixels(WIN_WIDTH/2, WIN_HEIGHT/2, WIN_WIDTH/2, WIN_HEIGHT/2, GL_COLOR);

    //glFlush();
    #endif
    
    drawCube();
    
    
    return 0;
}

#if MFOUR_API
#define MOUR_WTCMD_LOG_EN 0
static int mfourWtCmd(int dvid, mfour_rjob_cmd  *fcmd)
{
    int len=0;
    char ch2[2]={0};

    if (!pipMfTx) return -1;

    len = sizeof(mfour_rjob_cmd);

    ch2[0] = 's';
    ch2[1] = len;

    if (fcmd->dSize && fcmd->dPtr && fcmd->mPtr) {
        memcpy(fcmd->mPtr, fcmd->dPtr, fcmd->dSize);
    }

    #if MOUR_WTCMD_LOG_EN
    printf("[m4] dPtr:0x%.8x, mPtf:0x%.8x, dsize: %d \n", (uint32_t)fcmd->dPtr, (uint32_t)fcmd->mPtr, fcmd->dSize);
    #endif

    dbgRjobCmd(fcmd, len);
    
    write(pipMfTx[1], ch2, 2);
    
    write(pipMfTx[1], fcmd, len);

    return 0;
}

#define MOUR_RDCMD_LOG_EN 0
static int mfourRdCmd(int dvid, mfour_rjob_cmd  *fcmd)
{
    int pipRet=0, len=0, op=0, txd=0;
    char ch2[2]={0};
    struct pollfd pllfd[2]={0};
    char *recvptr=0;

    recvptr = fcmd->dPtr;

    pllfd[0].fd = pipMfRx[0];
    pllfd[0].events = POLLIN;

    while (1) {
        pipRet = poll(pllfd, 1, 1000);

        #if MOUR_RDCMD_LOG_EN
        printf("%s line: %d ret: %d - 1\n", __func__, __LINE__, pipRet);
        #endif
        
        if (pipRet <= 0) {
            continue;
        }

        pipRet = read(pllfd[0].fd, ch2, 2);
        #if MOUR_RDCMD_LOG_EN
        printf("%s line: %d 0x%.2x 0x%.2x ret: %d \n", __func__, __LINE__, ch2[0], ch2[1], pipRet);
        #endif
        
        if (pipRet == 2) {
            break;
        }        
    }

    op = ch2[0];
    len = ch2[1];
    #if MOUR_RDCMD_LOG_EN
    printf("%s line: %d 0x%.2x 0x%.2x (0x%.2x) len: %d \n", __func__, __LINE__, ch2[0], ch2[1], op, len);
    #endif

    if (op != 0x72) { // 0x72 == r
        return 0;
    }

    txd = len;
    while (1) {
        pipRet = poll(pllfd, 1, 500);

        #if MOUR_RDCMD_LOG_EN
        printf("%s line: %d ret: %d - 2\n", __func__, __LINE__, pipRet);
        #endif
        
        if (pipRet <= 0) {
            continue;
        }

        pipRet = read(pllfd[0].fd, fcmd, txd);
        
        #if MOUR_RDCMD_LOG_EN
        printf("%s read len: %d ret: %d \n", __func__, txd, pipRet);
        #endif

        if (pipRet > 0) {
            txd -= pipRet;
        }

        if (txd == 0) {
            break;
        }
    }

    dbgRjobCmd(fcmd, len);

     fcmd->dPtr = recvptr;

    if (fcmd->dSize && fcmd->dPtr && fcmd->mPtr) {
        memcpy(fcmd->dPtr, fcmd->mPtr, fcmd->dSize);
    }
    
    return 0;
}
#endif

static int grapjpg(unsigned char *ptr, int len)
{
    char ptfilepath[256];
    static char ptfiledump[] = "/home/root/Jpg_%.3d.jpg";
    FILE *dumpFile=0;
    int ret=0;
    
    printf("[GL] grap JPG \n");
        
    dumpFile = find_save(ptfilepath, ptfiledump);
    if (!dumpFile) {
        return -3;
    }
    
    ret = fwrite(ptr, 1, len, dumpFile);    
    printf("[GL] write JPG file %s size: %d ret: %d \n", ptfilepath, len, ret);
    
    sync();
    fclose(dumpFile);

    return 0;
}

static int grapbmp(unsigned char *ptr, struct bitmapHeader_s * bmphead, char *pthr, int hlen)
{
    char ptfilepath[256];
    static char ptfiledump[] = "/home/root/dump_%.3d.bmp";
    FILE *dumpFile=0;
    GLubyte *pPixelData=0, *ph=0;
    GLint rowSize=0, bmplen=0, bmptotal=0;
    struct bitmapHeader_s *bheader = 0;
    int ret=0, setwidth=0, setheight=0, bpp=0;

    setwidth = bmphead->aspbiWidth;
    setheight = bmphead->aspbiHeight;
    bpp = bmphead->aspbiCPP >> 16;
    
    printf("[GL] grap bmp w: %d h: %d bpp: %d \n", setwidth, setheight, bpp);

    rowSize = ((setwidth * bpp + 31) / 32) * 4;
    bmptotal = rowSize * setheight;

    pPixelData = ptr;
    bheader = bmphead;
        
    dumpFile = find_save(ptfilepath, ptfiledump);
    if (!dumpFile) {
        return -3;
    }

    if (pthr) {
        ph = pthr;
        bmplen = hlen;
    } else {
        ph = &bheader->aspbmpMagic[2];
        bmplen = sizeof(struct bitmapHeader_s) - 2;
    }

    ret = fwrite(ph, 1, bmplen, dumpFile);
    printf("[GL] write file %s size: %d ret: %d \n", ptfilepath, bmplen, ret);
        
    ret = fwrite(pPixelData, 1, bmptotal, dumpFile);    
    printf("[GL] write file %s size: %d ret: %d \n", ptfilepath, bmptotal, ret);
    
    sync();
    fflush(dumpFile);
    fclose(dumpFile);

    return 0;
}

static int rgb2jpgRvs(unsigned char *prgb, unsigned char *ppjpg, int *jlen, int setW, int setH, int bpp)
{
    struct jpeg_compress_struct cinfo;
    struct jpeg_error_mgr jerr;
    JSAMPROW row_pointer[1];
    unsigned int row_stride;
    unsigned long lLen=0;
    int clrsp=0;
    unsigned char *pbuff=0, *pret=0;

    //printf("[JPG] rgb2jpg enter \n"); 
    
    cinfo.err = jpeg_std_error(&jerr);
    jpeg_create_compress(&cinfo);

    jpeg_mem_dest(&cinfo, &pbuff, &lLen);

    cinfo.image_width = setW;      /* image width and height, in pixels */
    cinfo.image_height = setH;
    cinfo.input_components = bpp / 8;         /* # of color components per pixel */
    
    clrsp = (bpp==8) ? JCS_GRAYSCALE:JCS_RGB;
    cinfo.in_color_space = clrsp;//JCS_RGB;
    
    jpeg_set_defaults(&cinfo);
    jpeg_set_quality(&cinfo, 90, TRUE);

    jpeg_start_compress(&cinfo, TRUE);

    //oldRowsz = ((bpp * oldWidth + 31) / 32) * 4;
    row_stride = ((cinfo.image_width * bpp + 31) / 32) * 4;
    //printf("[JPG] bpp: %d row: %d \n", bpp, row_stride);

    while (cinfo.next_scanline < cinfo.image_height) 
    {
        row_pointer[0] = &prgb[(cinfo.image_height - cinfo.next_scanline - 1) * row_stride];
        //printf("l: %d \n", cinfo.next_scanline);
        //row_pointer[0] = &prgb[cinfo.next_scanline * row_stride];
        (void) jpeg_write_scanlines(&cinfo, row_pointer, 1);
    }

    jpeg_finish_compress(&cinfo);

    jpeg_destroy_compress(&cinfo);

    //printf("[JPG] dst: 0x%.8x len: %ld \n", (uint32_t)ppjpg, lLen);
    
    if (!ppjpg) {
        printf("[JPG] Error!!! return memory failed\n");
    } else {
        memcpy(ppjpg, pbuff, lLen);
    }
    
    *jlen = (int)lLen;
    
    free(pbuff);
    
    return 0;
}

static int rgb2jpg(unsigned char *prgb, unsigned char *ppjpg, int *jlen, int setW, int setH, int bpp)
{
    struct jpeg_compress_struct cinfo;
    struct jpeg_error_mgr jerr;
    JSAMPROW row_pointer[1];
    unsigned int row_stride;
    unsigned long lLen=0;
    int clrsp=0;
    unsigned char *pbuff=0, *pret=0;

    //printf("[JPG] rgb2jpg enter \n"); 
    
    cinfo.err = jpeg_std_error(&jerr);
    jpeg_create_compress(&cinfo);

    jpeg_mem_dest(&cinfo, &pbuff, &lLen);

    cinfo.image_width = setW;      /* image width and height, in pixels */
    cinfo.image_height = setH;
    cinfo.input_components = bpp / 8;         /* # of color components per pixel */
    
    clrsp = (bpp==8) ? JCS_GRAYSCALE:JCS_RGB;
    cinfo.in_color_space = clrsp;//JCS_RGB;
    
    jpeg_set_defaults(&cinfo);
    jpeg_set_quality(&cinfo, 90, TRUE);

    jpeg_start_compress(&cinfo, TRUE);

    //oldRowsz = ((bpp * oldWidth + 31) / 32) * 4;
    row_stride = ((cinfo.image_width * bpp + 31) / 32) * 4;
    //printf("[JPG] bpp: %d row: %d \n", bpp, row_stride);

    while (cinfo.next_scanline < cinfo.image_height) 
    {
        //row_pointer[0] = &prgb[(cinfo.image_height - cinfo.next_scanline - 1) * row_stride];
        //printf("l: %d \n", cinfo.next_scanline);
        row_pointer[0] = &prgb[cinfo.next_scanline * row_stride];
        (void) jpeg_write_scanlines(&cinfo, row_pointer, 1);
    }

    jpeg_finish_compress(&cinfo);

    jpeg_destroy_compress(&cinfo);

    //printf("[JPG] dst: 0x%.8x len: %ld \n", (uint32_t)ppjpg, lLen);
    
    if (!ppjpg) {
        printf("[JPG] Error!!! return memory failed\n");
    } else {
        memcpy(ppjpg, pbuff, lLen);
    }
    
    *jlen = (int)lLen;
    
    free(pbuff);
    
    return 0;
}

static int jpeg2rgbWH(unsigned char *pjpg, int jpgsz, char *prgb, int rgbsz, int *getW, int * getH, int bpp, int offsetWin, int widthWin, int offsetYWin, int heightWin)
{
#define MAX_LINE_NUM 1536
    struct jpeg_decompress_struct cinfo;
    struct jpeg_error_mgr err;
 
    JSAMPARRAY samplebuffer;
    unsigned char  *bufferarry[MAX_LINE_NUM];
    JDIMENSION offsetx, cropW, skipf, skipb;
    int row_stride=0, row_stride_org=0;
    unsigned char *tmpbuff = NULL;
    int rgb_size, clrsp=0, ix=0, lnum=0;;

    //printf("[JPG] jpeg2rgb enter \n"); 
    
    if (!pjpg) {
        printf("[JPG] jpg buffer is null \n");
        return -1;
    }
    
    if (!prgb)
    {
        printf("[JPG] output buff is null \n");
        return -2;
    }
    
    cinfo.err = jpeg_std_error(&err);
    
    #if 1 /* fast decoding */
    cinfo.do_fancy_upsampling=TRUE;
    cinfo.dct_method=JDCT_FASTEST;
    #endif
    
    jpeg_create_decompress(&cinfo);
    //printf("[JPG] jpeg_create_decompress. \n"); 

    #if 1 /* fast decoding */
    cinfo.do_fancy_upsampling=TRUE;
    cinfo.dct_method=JDCT_FASTEST;
    #endif

    jpeg_mem_src(&cinfo, pjpg, jpgsz);
    //printf("[JPG] jpeg_mem_src size: %d \n", jpgsz); 
    
    //shmem_dump(pjpg, 512);
     
    jpeg_read_header(&cinfo, TRUE);
    //printf("[JPG] jpeg_read_header. bpp: %d output_components: %d \n", bpp, cinfo.output_components); 
    cinfo.output_components = bpp / 8;
    
    clrsp = (bpp==8) ? JCS_GRAYSCALE:JCS_RGB;
    
    cinfo.out_color_space = clrsp;//JCS_GRAYSCALE;//JCS_RGB;//JCS_GRAYSCALE; //JCS_YCbCr;
    
    #if 1 /* fast decoding */
    cinfo.do_fancy_upsampling=TRUE;
    cinfo.dct_method=JDCT_FASTEST;
    #endif

    jpeg_start_decompress(&cinfo);
    //printf("[JPG] jpeg_start_decompress. \n"); 

    row_stride = ((cinfo.output_width * bpp + 31) / 32) * 4;
    row_stride_org = row_stride;
    *getW = cinfo.output_width;
    *getH = cinfo.output_height;

    printf("[JPG] jpeg_read_header. width: %d height: %d row_stride: %d \n", cinfo.output_width, cinfo.output_height, row_stride); 
    
    #if 1
    offsetx = offsetWin;
    cropW = widthWin;
    //printf("[JPG] jpeg_crop_scanline. %d, %d S\n", offsetx, cropW); 
    jpeg_crop_scanline(&cinfo, &offsetx, &cropW);
    //printf("[JPG] jpeg_crop_scanline. %d, %d E\n", offsetx, cropW); 
    #endif
    
    //row_stride = cinfo.output_width * cinfo.output_components;
    row_stride = ((cinfo.output_width * bpp + 31) / 32) * 4;

    printf("[JPG] jpeg_read_header. width: %d height: %d row_stride: %d after 1\n", cinfo.output_width, cinfo.output_height, row_stride); 

    lnum = cinfo.output_height;
    if (lnum > MAX_LINE_NUM) {
        return -3;
    }

    tmpbuff = prgb + ((offsetx * bpp) / 8);
    for (ix=0; ix < lnum; ix++) {
        bufferarry[ix] = tmpbuff;
        msync(tmpbuff, row_stride_org, MS_SYNC);
        
        tmpbuff += row_stride_org;
    }

    printf("[JPG] jpeg_read_header. width: %d height: %d row_stride: %d after 2\n", cinfo.output_width, cinfo.output_height, row_stride); 
    
    //*getW = cinfo.output_width;
    //*getH = cinfo.output_height;
    
    rgb_size = row_stride * cinfo.output_height;
    if (rgbsz < rgb_size) {
        printf("[JPG] width: %d height: %d row_stride: %d \n", cinfo.output_width, cinfo.output_height, row_stride); 
        printf("[JPG] output buff size %d is wrong should be %d \n", rgbsz, rgb_size);
        return -4;
    }
    
    //printf("[JPG] output buff size: %d, bmp size: %d \n", rgbsz, rgb_size);
    
    samplebuffer = (*cinfo.mem->alloc_sarray)((j_common_ptr) &cinfo, JPOOL_IMAGE, row_stride, 1);
    if (!samplebuffer) {
        printf("[JPG] failed to allocate memory size: %d x %d = %d\n", row_stride, cinfo.output_height, row_stride * 1);
    }
    

    #if 0
    printf("[JPG] debug: rgb_size: %d, raw size: %d w: %d h: %d row_stride: %d \n", rgb_size,
                cinfo.image_width*cinfo.image_height*cinfo.output_components,
                cinfo.image_width, 
                cinfo.image_height,
                row_stride);
    #endif

    #if 0
    ix=0;
    //printf("[JPG] scan begin line: %d output: %d\n", cinfo.output_scanline, cinfo.output_height);
    while (cinfo.output_scanline < cinfo.output_height) {
        skipf = cinfo.output_scanline;
        skipb = cinfo.output_height - cinfo.output_scanline;
        jpeg_read_scanlines(&cinfo, &samplebuffer[skipf], skipb);

        ix++;
        //printf("[JPG] scan begin line: %d output: %d - %d \n", cinfo.output_scanline, cinfo.output_height, ix);
    }

    tmpbuff = prgb + ((offsetx * bpp) / 8);
    for (ix=0; ix < cinfo.output_height; ix++) {
        memcpy(tmpbuff, samplebuffer[ix], row_stride);
        tmpbuff += row_stride_org;
    }
    #elif 0
    //skipf = cinfo.output_height;
    //jpeg_skip_scanlines(&cinfo, skipf);
    //tmpbuff = prgb;
    ix = 0;
    while (cinfo.output_scanline < cinfo.output_height)
    {
        jpeg_read_scanlines(&cinfo, &bufferarry[ix], 1);
        //jpeg_skip_scanlines(&cinfo, 1);
        //memcpy(tmpbuff, samplebuffer[0], row_stride);
        //tmpbuff += row_stride_org;
        ix++;
    }

    //printf("[JPG] jpeg_read, cnt: %d line: %d output: %d \n", ix, cinfo.output_scanline, cinfo.output_height); 
    
    #else
    skipf = offsetYWin;
    skipb = cinfo.output_height - offsetYWin - heightWin;
    
    jpeg_skip_scanlines(&cinfo, skipf);
    //printf("[JPG] jpeg_read_header. width: %d height: %d row_stride: %d jpeg_skip_scanlines - 1\n", cinfo.output_width, cinfo.output_height, row_stride); 
                
    tmpbuff = prgb + ((offsetx * bpp) / 8);
    tmpbuff += row_stride_org * skipf;
    while (cinfo.output_scanline < (cinfo.output_height - skipb))
    {
        jpeg_read_scanlines(&cinfo, samplebuffer, 1);
        memcpy(tmpbuff, samplebuffer[0], row_stride);
        tmpbuff += row_stride_org;
    }

    jpeg_skip_scanlines(&cinfo, skipb);
    //printf("[JPG] jpeg_read_header. width: %d height: %d row_stride: %d jpeg_skip_scanlines - 2\n", cinfo.output_width, cinfo.output_height, row_stride); 
    #endif
    
    jpeg_finish_decompress(&cinfo);

    //printf("[JPG] jpeg_read_header. width: %d height: %d row_stride: %d jpeg_skip_scanlines FINISH\n", cinfo.output_width, cinfo.output_height, row_stride); 
    
    jpeg_destroy_decompress(&cinfo);
    
    return 0;
}

static int jpeg2rgbRvs(unsigned char *pjpg, int jpgsz, char *prgb, int rgbsz, int *getW, int * getH, int bpp)
{
    struct jpeg_decompress_struct cinfo;
    struct jpeg_error_mgr err;
 
    JSAMPARRAY samplebuffer;
    JDIMENSION offsetx, cropW, skipf, skipb;
    int row_stride=0, row_stride_org=0;
    char* tmpbuff = NULL;
    int rgb_size, clrsp=0;

    //printf("[JPG] jpeg2rgb enter \n"); 
    
    if (!pjpg) {
        printf("[JPG] jpg buffer is null \n");
        return -1;
    }
    
    if (!prgb)
    {
        printf("[JPG] output buff is null \n");
        return -2;
    }
    
    cinfo.err = jpeg_std_error(&err);

    #if 1 /* fast decoding */
    cinfo.do_fancy_upsampling=TRUE;
    cinfo.dct_method=JDCT_FASTEST;
    #endif
    
    jpeg_create_decompress(&cinfo);
    //printf("[JPG] jpeg_create_decompress. \n"); 
    
    jpeg_mem_src(&cinfo, pjpg, jpgsz);
    //printf("[JPG] jpeg_mem_src size: %d \n", jpgsz); 

    #if 1 /* fast decoding */
    cinfo.do_fancy_upsampling=TRUE;
    cinfo.dct_method=JDCT_FASTEST;
    #endif
    
    //shmem_dump(pjpg, 512);
     
    jpeg_read_header(&cinfo, TRUE);
    //printf("[JPG] jpeg_read_header. bpp: %d output_components: %d \n", bpp, cinfo.output_components); 
    cinfo.output_components = bpp / 8;
    
    clrsp = (bpp==8) ? JCS_GRAYSCALE:JCS_RGB;
    
    cinfo.out_color_space = clrsp;//JCS_GRAYSCALE;//JCS_RGB;//JCS_GRAYSCALE; //JCS_YCbCr;
 
    jpeg_start_decompress(&cinfo);
    //printf("[JPG] jpeg_start_decompress. \n"); 

    row_stride = ((cinfo.output_width * bpp + 31) / 32) * 4;
    row_stride_org = row_stride;
    *getW = cinfo.output_width;
    *getH = cinfo.output_height;

    printf("[JPG] jpeg_read_header. width: %d height: %d row_stride: %d before \n", cinfo.output_width, cinfo.output_height, row_stride); 
    
    #if 0
    offsetx = offsetWin;
    cropW = widthWin;
    printf("[JPG] jpeg_crop_scanline. %d, %d S\n", offsetx, cropW); 
    jpeg_crop_scanline(&cinfo, &offsetx, &cropW);
    printf("[JPG] jpeg_crop_scanline. %d, %d E\n", offsetx, cropW); 
    #endif
    
    //row_stride = cinfo.output_width * cinfo.output_components;
    row_stride = ((cinfo.output_width * bpp + 31) / 32) * 4;
    
    //*getW = cinfo.output_width;
    //*getH = cinfo.output_height;

    printf("[JPG] jpeg_read_header. width: %d height: %d row_stride: %d after \n", cinfo.output_width, cinfo.output_height, row_stride); 
    
    //skipf = 100;
    //skipb = 200;
    //jpeg_skip_scanlines(&cinfo, skipf);
    //printf("[JPG] jpeg_read_header. width: %d height: %d row_stride: %d jpeg_skip_scanlines E1\n", cinfo.output_width, cinfo.output_height, row_stride); 
    
    rgb_size = row_stride * cinfo.output_height;
    if (rgbsz < rgb_size) {
        printf("[JPG] output buff size %d is wrong should be %d \n", rgbsz, rgb_size);
        return -3;
    }
    
    //printf("[JPG] output buff size: %d, bmp size: %d \n", rgbsz, rgb_size);
    
    samplebuffer = (*cinfo.mem->alloc_sarray)((j_common_ptr) &cinfo, JPOOL_IMAGE, row_stride, 1);

    #if 0
    printf("[JPG] debug: rgb_size: %d, raw size: %d w: %d h: %d row_stride: %d \n", rgb_size,
                cinfo.image_width*cinfo.image_height*cinfo.output_components,
                cinfo.image_width, 
                cinfo.image_height,
                row_stride);
    #endif
                
    tmpbuff = prgb + cinfo.output_height * row_stride_org;
    while (cinfo.output_scanline < (cinfo.output_height))
    {
        tmpbuff -= row_stride_org;
        jpeg_read_scanlines(&cinfo, samplebuffer, 1);
        memcpy(tmpbuff, samplebuffer[0], row_stride);
    }

    //printf("[JPG] jpeg_read_header. width: %d height: %d row_stride: %d jpeg_skip_scanlines S2\n", cinfo.output_width, cinfo.output_height, row_stride); 
    //jpeg_skip_scanlines(&cinfo, skipb);
    //printf("[JPG] jpeg_read_header. width: %d height: %d row_stride: %d jpeg_skip_scanlines E2\n", cinfo.output_width, cinfo.output_height, row_stride); 
    
    jpeg_finish_decompress(&cinfo);

    //printf("[JPG] jpeg_read_header. width: %d height: %d row_stride: %d jpeg_skip_scanlines FINISH\n", cinfo.output_width, cinfo.output_height, row_stride); 
    
    jpeg_destroy_decompress(&cinfo);
    
    return 0;
}

static int jpeg2rgb(unsigned char *pjpg, int jpgsz, char *prgb, int rgbsz, int *getW, int * getH, int bpp)
{
    struct jpeg_decompress_struct cinfo;
    struct jpeg_error_mgr err;
 
    JSAMPARRAY samplebuffer;
    JDIMENSION offsetx, cropW, skipf, skipb;
    int row_stride = 0;
    char* tmpbuff = NULL;
    int rgb_size, clrsp=0;

    //printf("[JPG] jpeg2rgb enter \n"); 
    
    if (!pjpg) {
        printf("[JPG] jpg buffer is null \n");
        return -1;
    }
    
    if (!prgb)
    {
        printf("[JPG] output buff is null \n");
        return -2;
    }
    
    cinfo.err = jpeg_std_error(&err);
    
    #if 1 /* fast decoding */
    cinfo.do_fancy_upsampling=TRUE;
    cinfo.dct_method=JDCT_FASTEST;
    #endif

    jpeg_create_decompress(&cinfo);
    //printf("[JPG] jpeg_create_decompress. \n"); 

    #if 1 /* fast decoding */
    cinfo.do_fancy_upsampling=TRUE;
    cinfo.dct_method=JDCT_FASTEST;
    #endif

    jpeg_mem_src(&cinfo, pjpg, jpgsz);
    //printf("[JPG] jpeg_mem_src size: %d \n", jpgsz); 
    
    //shmem_dump(pjpg, 512);
     
    jpeg_read_header(&cinfo, TRUE);
    //printf("[JPG] jpeg_read_header. bpp: %d output_components: %d \n", bpp, cinfo.output_components); 
    cinfo.output_components = bpp / 8;
    
    clrsp = (bpp==8) ? JCS_GRAYSCALE:JCS_RGB;
    
    cinfo.out_color_space = clrsp;//JCS_GRAYSCALE;//JCS_RGB;//JCS_GRAYSCALE; //JCS_YCbCr;

    #if 1 /* fast decoding */
    cinfo.do_fancy_upsampling=TRUE;
    cinfo.dct_method=JDCT_FASTEST;
    #endif

    jpeg_start_decompress(&cinfo);
    //printf("[JPG] jpeg_start_decompress. \n"); 
     
    #if 0
    offsetx = cinfo.output_width / 4;
    cropW = cinfo.output_width / 2;
    printf("[JPG] jpeg_crop_scanline. %d, %d S\n", offsetx, cropW); 
    jpeg_crop_scanline(&cinfo, &offsetx, &cropW);
    printf("[JPG] jpeg_crop_scanline. %d, %d E\n", offsetx, cropW); 
    #endif
    
    //row_stride = cinfo.output_width * cinfo.output_components;
    row_stride = ((cinfo.output_width * bpp + 31) / 32) * 4;;
    
    *getW = cinfo.output_width;
    *getH = cinfo.output_height;
    
    //printf("[JPG] jpeg_read_header. width: %d height: %d row_stride: %d jpeg_skip_scanlines S1\n", cinfo.output_width, cinfo.output_height, row_stride); 
    //skipf = 100;
    //skipb = 200;
    //jpeg_skip_scanlines(&cinfo, skipf);
    //printf("[JPG] jpeg_read_header. width: %d height: %d row_stride: %d jpeg_skip_scanlines E1\n", cinfo.output_width, cinfo.output_height, row_stride); 
     
    rgb_size = row_stride * cinfo.output_height;
    if (rgbsz < rgb_size) {
        printf("[JPG] output buff size %d is wrong should be %d \n", rgbsz, rgb_size);
        return -3;
    }
    
    //printf("[JPG] output buff size: %d, bmp size: %d \n", rgbsz, rgb_size);
    
    samplebuffer = (*cinfo.mem->alloc_sarray)((j_common_ptr) &cinfo, JPOOL_IMAGE, row_stride, 1);

    #if 0
    printf("[JPG] debug: rgb_size: %d, raw size: %d w: %d h: %d row_stride: %d \n", rgb_size,
                cinfo.image_width*cinfo.image_height*cinfo.output_components,
                cinfo.image_width, 
                cinfo.image_height,
                row_stride);
    #endif
                
    tmpbuff = prgb;
    while (cinfo.output_scanline < (cinfo.output_height))
    {
        jpeg_read_scanlines(&cinfo, samplebuffer, 1);
        memcpy(tmpbuff, samplebuffer[0], row_stride);
        tmpbuff += row_stride;
    }
 
    //printf("[JPG] jpeg_read_header. width: %d height: %d row_stride: %d jpeg_skip_scanlines S2\n", cinfo.output_width, cinfo.output_height, row_stride); 
    //jpeg_skip_scanlines(&cinfo, skipb);
    //printf("[JPG] jpeg_read_header. width: %d height: %d row_stride: %d jpeg_skip_scanlines E2\n", cinfo.output_width, cinfo.output_height, row_stride); 
    
    jpeg_finish_decompress(&cinfo);

    //printf("[JPG] jpeg_read_header. width: %d height: %d row_stride: %d jpeg_skip_scanlines FINISH\n", cinfo.output_width, cinfo.output_height, row_stride); 
    
    jpeg_destroy_decompress(&cinfo);
    
    return 0;
}
#endif
static unsigned long long int time_get_ms(struct timespec *s)
{
    unsigned long long int cur, tnow, lnow, gunit;
    unsigned long long int ms, deg;

    gunit = 1000000;
    deg = 1000000000;

    cur = s->tv_sec;
    tnow = s->tv_nsec;
    lnow = cur * deg + tnow;

    ms = lnow / gunit;

    return ms;
}

static int time_diff(struct timespec *s, struct timespec *e, int unit)
{
    unsigned long long cur, tnow, lnow, past, tbef, lpast, gunit;
    int diff;

    gunit = unit;
    //clock_gettime(CLOCK_REALTIME, &curtime);
    cur = s->tv_sec;
    tnow = s->tv_nsec;
    lnow = cur * 1000000000+tnow;
    
    //clock_gettime(CLOCK_REALTIME, &curtime);
    past = e->tv_sec;
    tbef = e->tv_nsec;      
    lpast = past * 1000000000+tbef; 

    if (lpast < lnow) {
        diff = -1;
    } else {
        diff = (lpast - lnow)/gunit;
    }

    if (diff == 0) {
        diff = 1;
    }

    return diff;
}

static int usb_nonblock_set (int sfd)
{
    int val, ret;
    ret = fcntl (sfd, F_GETFL, 0);
    if (ret == -1)
    {
        perror ("fcntl");
        return -1;
    }

    val = ret;  
    val |= O_NONBLOCK;
    ret = fcntl (sfd, F_SETFL, val);
    if (ret == -1)
    {
        perror ("fcntl");
        return -1;
    }

    return 0;
}

static int insert_cbw(char *cbw, char cmd, char opc, char dat)
{
    if (!cbw) return -1;

    cbw[15] = cmd;
    cbw[16] = opc;
    cbw[17] = dat;

    return 0;
}

static int insert_filecbw(char *cbw, struct usbCBWfile_s *dwfile)
{
    if (!cbw) return -1;

    memcpy(cbw, (char *)dwfile, 32);

    return 0;
}

#if SMP_EN
#define USBC_PHY_EN (0)
#else
#define USBC_PHY_EN (1)
#endif
static inline int usbcphy_write(int usbfd, char *vir, char *phy, int len)
{
    int ret=0;
    
    #if USBC_PHY_EN
    if (len == USB_BUF_SIZE) {

        ret = GADGET_IOCT_SET_OUT(usbfd, phy);
        
        //printf("[USBC] wt len: %d addr: 0x%.8x ret: %d ioctl\n", len, phy, ret);
    } else {
        
        ret = write(usbfd, vir, len);
        
        //printf("[USBC] wt len: %d addr: 0x%.8x ret: %d write\n", len, vir, ret);
    }
    #else
    
    //printf("[USBC] wt len: %d write\n", len);
    
    ret = write(usbfd, vir, len);
    #endif

    return ret;
}

static inline int usbc_write(int usbfd, char *vir, int len)
{
    int ret=0;
    
    ret = write(usbfd, vir, len);

    return ret;
}

#define USB_TX_LOG 0
static int usb_send(char *pts, int usbfd, int len)
{
    int ret=0, send=0;
    struct pollfd pllfd[1];

#if 0
    if (!(len % 512)) {
        len += 1;
    }
#endif

#if 0
    if (!pts) return -1;
    if (!usbfd) return -2;

    pllfd[0].fd = usbfd;
    pllfd[0].events = POLLOUT;
    
    while(1) {
        ret = poll(pllfd, 1, -1);
        //printf("[UW] usb poll ret: %d \n", ret);
        if (ret < 0) {
            printf("[UW] usb poll failed ret: %d\n", ret);
            break;
        }

        if (ret && (pllfd[0].revents & POLLOUT)) {
            
            send = write(pllfd[0].fd, pts, len);

#if USB_TX_LOG
            printf("[UW] usb write %d bytes, ret: %d (1)\n", len, send);
#endif

            break;
        }                
    }
#else
    send = write(usbfd, pts, len);
    //printf("[USB] usb write %d bytes, ret: %d (2)\n", len, send);
#endif
    return send;    
}

static int usb_read(char *ptr, int usbfd, int len)
{
    int ret=0, recv=-1, cnt=0;
    
#if 0
    struct pollfd pllfd[1];
    if (!ptr) return -1;
    if (!usbfd) return -2;

    memset(pllfd, 0x0, sizeof(struct pollfd));
    
    usb_nonblock_set(usbfd);
    
    pllfd[0].fd = usbfd;
    pllfd[0].events = POLLIN;
    
    while(1) {
        ret = poll(pllfd, 1, 500);
        
        #if USB_TX_LOG
        printf("[UR] usb poll ret: %d \n", ret);
        #endif
        
        if (ret <= 0) {
            printf("[UR] usb poll failed ret: %d\n", ret);
            break;
        }

        #if USB_TX_LOG
        printf("[UR] usb revents: 0x%.x / 0x%.x\n", pllfd[0].revents, pllfd[0].events);
        #endif
        
        if ((pllfd[0].revents & POLLIN) == POLLIN) {

            while (cnt < len) {
            //recv = read(usbfd, ptr, len);
            recv = read(usbfd, ptr, 1);
            
            #if USB_TX_LOG
            printf("[UR] usb read %d bytes, ret: %d (1) cnt: %d\n", len, recv, cnt);
            #endif   
            
            if (recv == 1) {
                cnt ++;
                ptr ++;
            }
            }

            break;
        }
    }
#else
    //usb_nonblock_set(usbfd);
    recv = read(usbfd, ptr, len);
    //printf("[USB] usb read %d bytes, ret: %d (2)\n", len, recv);
#endif
    
    return recv;    
}

#define DBG_PHY2VIR 0
static int phy2vir(uint32_t *pvir, uint32_t phy, int physize, int memfd)
{
    char *ps8_page_start_addr;
    char *curAddr;
    int fd , r, pageSize;
    unsigned int u32_start_addr , u32_len , u32_page_seek_cur , data;

    
    pageSize = getpagesize();
#if 0//DBG_PHY2VIR
    printf("[MEM] get page size: %d \n", pageSize);
#endif
    u32_start_addr = phy;
    u32_len = physize;
    u32_page_seek_cur = u32_start_addr % pageSize;

#if DBG_PHY2VIR
    printf("[MEM] get start addr: 0x%.8x, len: %d, seek: %d\n", u32_start_addr, u32_len, u32_page_seek_cur);
    printf("Start addr : 0x%.8x  , length : %d \n" , u32_start_addr - u32_page_seek_cur , u32_page_seek_cur + u32_len );
#endif

    //sync();
    
    #if 1
    ps8_page_start_addr = mmap( 0 ,                                   // Start addr in file
                           u32_page_seek_cur + u32_len , // len
                           PROT_READ | PROT_WRITE , // mode
                           MAP_SHARED ,                  // flag
                           memfd ,
                           u32_start_addr - u32_page_seek_cur ); // start addr in page system
  
    
    if( MAP_FAILED == ps8_page_start_addr ) {
        printf("mmap() errorn");
        close(memfd);      
        return -1;
    }

    curAddr = ps8_page_start_addr + u32_page_seek_cur;
    *pvir = (uint32_t)curAddr;
    #else
    *pvir = (uint32_t) aspSalloc(physize);
    #endif
    
#if DBG_PHY2VIR
    printf("[MEM] get addr s:0x%.8x c:0x%.8x\n", ps8_page_start_addr, curAddr);
#endif
    //munmap( ps8_page_start_addr , u32_len );
  
    return 0;
}

static int aspFatFormat(struct sdFatFormat_s *pffmt)
{
    float totSector=0, hidnSector=0, sectorPerCls=0;
    struct sdbootsec_s *pbootsec=0;
    struct sdFSinfo_s *pinfotsec=0;
    float szfat=0.0, sf0=0.0, nBU=0.0, rsc0=0.0, ssa=0.0;
    float maxcls0=0.0, maxcls1=0.0, sf1=0.0, rsc1=0.0;

    if (!pffmt) return -1;

    totSector = (float)pffmt->fmtTotSector;
    hidnSector = (float)pffmt->fmtHidnSector;
    sectorPerCls = (float)pffmt->fmtSectorPerCls;
    pbootsec = &pffmt->fmtBootsec;
    pinfotsec = &pffmt->fmtInfosec;

    maxcls0 = (totSector / sectorPerCls) * 4.0;
    sf0 = ceil(maxcls0 / 512.0);
    nBU = ceil(sf0 * 2 / hidnSector);
    rsc0 = (nBU * hidnSector) - (sf0 * 2);
    ssa = rsc0 + (sf0 * 2);
    maxcls1 = floor((totSector - hidnSector - ssa) / sectorPerCls) + 1;
    sf1 = ceil((((maxcls1 - 1) + 2) * 4) / 512.0);
    rsc1 = (nBU * hidnSector) - (sf1 * 2);

    memset(pbootsec, 0, sizeof(struct sdbootsec_s));

    pbootsec->secSt = 0;
    pbootsec->secJpcmd = 0x429058eb;
    sprintf(pbootsec->secSysid, "MSDOS");
    pbootsec->secSize = 512;                             // 512
    pbootsec->secPrClst = (int)sectorPerCls;       // 4 8 16 32 64
    pbootsec->secResv = (int)rsc1;                    // M 
    pbootsec->secNfat = 2;                                // should be 2
    pbootsec->secTotal = (int)totSector;             // total sectors
    pbootsec->secIDm = 0xF8;                          // must be 0xF8
    pbootsec->secPrfat = (int)sf1;                      // sectors per FAT
    pbootsec->secPrtrk = 63;                             // sectors per track
    pbootsec->secNsid = 255;                            // number of sides
    pbootsec->secNhid = (int)hidnSector;            // number of hidden sectors
    pbootsec->secExtf = 0;                                // extension flag, specify the status of FAT mirroring
    pbootsec->secVers = 0;                               // File system version
    pbootsec->secRtclst = 2;                              // indicate the cluster number of root dir
    pbootsec->secFSif = 1;                                 // indicate the sector number of FS info, will be 1 normally
    pbootsec->secBkbt = 6;                                // indicate the offset sector number of backup boot sector
    pbootsec->secPhdk = 0x80;                          // pyhsical disk number, should be 0x80
    pbootsec->secExtbt = 0x29;                          // extended boot record signature, should be 0x29
    pbootsec->secVoid = (uint32_t)pbootsec;       // volume ID number

    sprintf(pbootsec->secVola, "ASPDISK"); // volume label
    sprintf(pbootsec->secFtyp, "FAT32   ");   // file system type in ascii

    pbootsec->secSign = 0xaa55;          // shall be 0x55 (BP510) and 0xAA (BP511)

    pbootsec->secWhfat = pbootsec->secResv;
    pbootsec->secWhroot = pbootsec->secWhfat + pbootsec->secPrfat * 2;

    pbootsec->secBoffset = 0;

    pbootsec->secSt = 0;

    pinfotsec->finLdsn = 0x41615252;
    pinfotsec->finStsn = 0x61417272;
    pinfotsec->finFreClst = maxcls1 - 1;
    pinfotsec->finNxtFreClst = 3;
    pinfotsec->finTrsn = 0xaa550000;
    
    return 0;
}

static int aspSortD(CFLOAT * pdb, int size)
{
    int srtg[1024];
    CFLOAT srtf[1024][2];
    int is=0, in=0, ix=0, id=0;
    CFLOAT tmdb;

    if (size > 1024) {
        return -1;
    }

    for (is = 0; is < 1024; is++) {
        srtg[is] = is;
    }

    for (is = 0; is < size; is++) {
        srtf[is][0] = pdb[is*2+0];
        srtf[is][1] = pdb[is*2+1];
    }

    is = 1;
    while (is < size) {

        in = srtg[is];
        tmdb = srtf[in][1];

        //printf("[SORT] %d. %d[%lf] \n", is, in, tmdb);
        
        for (ix=0; ix < is; ix++) {
            id = srtg[ix];
            if (tmdb < srtf[id][1]) {
               srtg[ix] = in;
               in = id;
               tmdb = srtf[id][1];

               //printf("[SORT]     %d. %d[%lf] \n", is, in, tmdb);
            }        
        }
        srtg[is] = in;

        is++;
    }

    for (is = 0; is < size; is++) {
        id = srtg[is];
        pdb[is*2+0] = srtf[id][0];
        pdb[is*2+1] = srtf[id][1];

        //printf("[SORT] %d. %d[%lf, %lf] \n", is, id, srtf[id][0], srtf[id][1]);
    }
    

    return 0;
}

static int scanWidthConvert(int tag, int widt)
{
    int val=0;

    if (widt) {
        return widt;
    }
    
    switch (tag) {
    case DEFAULTWIDTH_NONE:
        val = -1;
        break;
    case DEFAULTWIDTH_1:
        val = DEFAULTWIDTH_VAL1;
        break;
    case DEFAULTWIDTH_2:
        val = DEFAULTWIDTH_VAL2;
        break;
    case DEFAULTWIDTH_3:
        val = DEFAULTWIDTH_VAL3;
        break;
    case DEFAULTWIDTH_4:
        val = DEFAULTWIDTH_VAL4;
        break;
    case DEFAULTWIDTH_5:
        val = DEFAULTWIDTH_VAL5;
        break;
    default:
        val = tag;
        break;
    }

    return val;
}

static int bin2hex(char *dst, char *src, int size)
{
    char hexmap[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
    char ch=0;
    int i=0, lw, hi;
    if (!dst) return -1;
    if (!src) return -2;
    if (!size) return -3;
    //printf("[B2H] start size: %d\n", size);
    
    for (i=0; i < size; i++) {
        ch = src[i];
        lw = ch & 0xf;
        hi = ch >> 4;
        
        dst[i*2+1] = hexmap[lw];
        dst[i*2+0] = hexmap[hi];

        //printf("[b2h] %d. 0x%.2x, [%c-%c] \n", i, ch, dst[i*2+0], dst[i*2+1]);
    }
    //printf("[B2H] end idx: %d \n", i);

    return 0;
}

static uint16_t lsb2Msb16(struct intMbs16_s *msb, uint16_t lsb)
{
    uint16_t org=0;
    int i=2;

    org = lsb;

    while (i) {
        i--;
        msb->d[i] = lsb & 0xff;

        //printf("[%d] :0x%.2x -> 0x%.2x \n", i, lsb & 0xff, msb->d[i]);
        
        lsb = lsb >> 8;
    }

    //printf("lsb2Msb16() lsb:0x%.8x -> msb:0x%.8x \n", org, msb->n);

    return msb->n;
}

static uint16_t msb2lsb16(struct intMbs16_s *msb)
{
    uint16_t lsb=0;
    int i=0;

    while (i < 2) {
        lsb = lsb << 8;
        
        lsb |= msb->d[i];
        
        //printf("[%d] :0x%.2x <- 0x%.2x \n", i, lsb & 0xff, msb->d[i]);
        
        i++;
    }

    //printf("msb2lsb16() msb:0x%.8x -> lsb:0x%.8x \n", msb->n, lsb);
    
    return lsb;
}

static uint32_t lsb2Msb32(struct intMbs32_s *msb, uint32_t lsb)
{
    uint32_t org=0;
    int i=4;

    org = lsb;

    while (i) {
        i--;
        msb->d[i] = lsb & 0xff;

        //printf("[%d] :0x%.2x -> 0x%.2x \n", i, lsb & 0xff, msb->d[i]);
        
        lsb = lsb >> 8;
    }

    //printf("lsb2Msb32() lsb:0x%.8x -> msb:0x%.8x \n", org, msb->n);

    return msb->n;
}

static uint32_t msb2lsb32(struct intMbs32_s *msb)
{
    uint32_t lsb=0;
    int i=0;

    while (i < 4) {
        lsb = lsb << 8;
        
        lsb |= msb->d[i];
        
        //printf("[%d] :0x%.2x <- 0x%.2x \n", i, lsb & 0xff, msb->d[i]);
        
        i++;
    }

    //printf("msb2lsb32() msb:0x%.8x -> lsb:0x%.8x \n", msb->n, lsb);
    
    return lsb;
}

static int aspBMPdecodeItemMax(struct bitmapDecodeItem_s *pditm)
{
    if (!pditm) return -1;

    msync(pditm, sizeof(struct bitmapDecodeItem_s), MS_SYNC);

    return pditm->aspDcMax;
}

static int aspBMPdecodeItemInit(struct bitmapDecodeItem_s *pditm)
{
    if (!pditm) return -1;

    asp_mem_barrier();
    
    pditm->aspDcWidth = 0;
    pditm->aspDcHeight = 0;
    pditm->aspDcLen = 0;

    pditm->aspDcData->mfourIdx = -1;
    memset(&pditm->aspDcData->mfourAttb, 0, sizeof(t_ImageParam));

    asp_mem_barrier();
    
    msync(&pditm->aspDcData->mfourAttb, sizeof(t_ImageParam), MS_SYNC);
    msync(pditm, sizeof(struct bitmapDecodeItem_s), MS_SYNC);
    
    return 0;
}

static int aspBMPdecodeItemSet(struct bitmapDecodeItem_s *pditm, int w, int h, int len)
{
    if (!pditm) return -1;

    asp_mem_barrier();
    
    pditm->aspDcWidth = w;
    pditm->aspDcHeight = h;
    pditm->aspDcLen = len;

    asp_mem_barrier();
    
    msync(pditm, sizeof(struct bitmapDecodeItem_s), MS_SYNC);
    
    return 0;
}

static int aspBMPdecodeItemRectGet(struct bitmapDecodeMfour_s *pdec, mfour_rect_st **rect, struct bitmapDecodeItem_s **item, int idx)
{
    if (!pdec) return -1;
    if (!rect) return -2;
    if (!item) return -3;
    if ((idx >= BMP_DECODE_PIC_SIZE) || (idx < 0)) return -4;

    msync(pdec, sizeof(struct bitmapDecodeMfour_s), MS_SYNC);

    asp_mem_barrier();
    
    *rect = &pdec->aspDecRect[idx];
    *item = &pdec->aspDecMfPiRaw[idx]; 

    asp_mem_barrier();
    
    return 0;
}

static int aspBMPdecodeItemGet(struct bitmapDecodeItem_s *pditm, char **data, int *uselen)
{
    if (!pditm) return -1;
    if (!data) return -2;

    msync(pditm->aspDcData, pditm->aspDcMax, MS_SYNC);

    asp_mem_barrier();
    
    *data = pditm->aspDcData->mfourData;

    if (uselen) {
        *uselen = pditm->aspDcLen;
    }

    asp_mem_barrier();
    
    return 0;
}

static int aspBMPdecodeBuffPagerstSet(struct bitmapDecodeMfour_s *pdec, int pagrst)
{
    if (!pdec) return -1;

    asp_mem_barrier();
    
    pdec->aspDecPagerst = pagrst;

    asp_mem_barrier();
    
    msync(pdec, sizeof(struct bitmapDecodeMfour_s), MS_SYNC);
        
    return 0;
}

static int aspBMPdecodeBuffPagerstGet(struct bitmapDecodeMfour_s *pdec, int *pparst)
{
    if (!pdec) return -1;
    if (!pparst) return -2;

    msync(pdec, sizeof(struct bitmapDecodeMfour_s), MS_SYNC);

    asp_mem_barrier();
    
    *pparst = pdec->aspDecPagerst;

    asp_mem_barrier();
    
    return 0;
}

static int aspBMPdecodeBuffSetIdx(struct bitmapDecodeMfour_s *pdec, int imgidx)
{
    if (!pdec) return -1;

    asp_mem_barrier();
    
    pdec->aspDecImgidx = imgidx;

    asp_mem_barrier();
    
    msync(pdec, sizeof(struct bitmapDecodeMfour_s), MS_SYNC);
        
    return 0;
}

static int aspBMPdecodeBuffGetIdx(struct bitmapDecodeMfour_s *pdec, int *pimgid)
{
    if (!pdec) return -1;
    if (!pimgid) return -2;

    msync(pdec, sizeof(struct bitmapDecodeMfour_s), MS_SYNC);
    
    asp_mem_barrier();    
    
    *pimgid = pdec->aspDecImgidx;

    asp_mem_barrier();
    
    return 0;
}

static int aspBMPdecodeBuffStatusSet(struct bitmapDecodeMfour_s *pdec, int status)
{
    if (!pdec) return -1;

    asp_mem_barrier();
    
    pdec->aspDecStatus = status;

    asp_mem_barrier();
    
    msync(pdec, sizeof(struct bitmapDecodeMfour_s), MS_SYNC);
        
    return 0;
}

static int aspBMPdecodeBuffTimeCostGet(struct bitmapDecodeMfour_s *pdec, int *timecost)
{
    int tmcost=0;
    if (!pdec) return -1;
    if (!timecost) return -2;

    msync(pdec, sizeof(struct bitmapDecodeMfour_s), MS_SYNC);

    asp_mem_barrier();
    
    clock_gettime(CLOCK_REALTIME, &pdec->aspDecPostime[1]);

    tmcost = time_diff(&pdec->aspDecPostime[0], &pdec->aspDecPostime[1], 1000);
    
    *timecost = tmcost;

    asp_mem_barrier();
    
    return 0;
}

static int aspBMPdecodeBuffStatusGet(struct bitmapDecodeMfour_s *pdec, int *pstat)
{
    int stat=0;
    if (!pdec) return -1;
    if (!pstat) return -2;

    msync(pdec, sizeof(struct bitmapDecodeMfour_s), MS_SYNC);

    asp_mem_barrier();
    
    stat = pdec->aspDecStatus;
    
    if (pdec->aspDecStatus == -1) {
        stat = 0;
    }
    
    *pstat = stat;

    asp_mem_barrier();

    return 0;
}

static int aspBMPdecodeBuffItemFree(struct bitmapDecodeItem_s *pitm)
{
    aspBMPdecodeItemSet(pitm, 0, 0, 0);
    return 0;
}

static int aspBMPdecodeBuffInit(struct bitmapDecodeMfour_s *pdec)
{  
    int ix=0;
    if (!pdec) return -1;

    asp_mem_barrier();
    
    pdec->aspDecStatus = -1;
    pdec->aspDecPagerst = 0;
    pdec->aspDecImgidx = -1;

    asp_mem_barrier();
        
    aspBMPdecodeItemInit(&pdec->aspDecJpeg);
    aspBMPdecodeItemInit(&pdec->aspDecMeta);
    aspBMPdecodeItemInit(&pdec->aspDecMetaex);
    aspBMPdecodeItemInit(&pdec->aspDecRaw);

    memset(pdec->aspDecRaw.aspDcData->mfourData, 0, pdec->aspDecRaw.aspDcMax);
    msync(pdec->aspDecRaw.aspDcData->mfourData, pdec->aspDecRaw.aspDcMax, MS_SYNC);

    asp_mem_barrier();  
      
    for (ix=0; ix< BMP_DECODE_PIC_SIZE; ix++) {
        aspBMPdecodeItemInit(&pdec->aspDecMfPiRaw[ix]);
        aspBMPdecodeItemInit(&pdec->aspDecMfPiJpg[ix]);
  
        pdec->aspDecRect[ix].mfourRectX = 0;
        pdec->aspDecRect[ix].mfourRectY = 0;
        pdec->aspDecRect[ix].mfourRectW = 0;
        pdec->aspDecRect[ix].mfourRectH= 0;
        pdec->aspDecRectSt[ix] = 0;
    }    

    asp_mem_barrier();
        
    msync(pdec, sizeof(struct bitmapDecodeMfour_s), MS_SYNC);

    //shmem_dump((char *)pdec, sizeof(struct bitmapDecodeMfour_s));
    
    return 0;
}

static int aspBMPdecodeBuffGet(struct bitmapDecodeMfour_s *pdcbuf, int *bidx, int bmax)
{
    int idx=0, find=-1;
    struct bitmapDecodeMfour_s *pdec=0;

    if (!pdcbuf) return -1;

    if (!bmax) return -2;

    asp_mem_barrier();
    
    for (idx=0; idx < bmax; idx++) {
        pdec = &pdcbuf[idx];
        msync(pdec, sizeof(struct bitmapDecodeMfour_s), MS_SYNC);

        //printf("[BIDX] search %d. %d (0x%.8x) \n", idx, pdec->aspDecStatus, pdec->aspDecStatus);
        
        if (pdec->aspDecStatus == -1) {
            clock_gettime(CLOCK_REALTIME, &pdec->aspDecPostime[0]);
            find = idx;
            break;
        }
    }

    *bidx = find;        

    asp_mem_barrier();
    
    if (find < 0) {
        return -3;
    }

    return 0;
}

static void aspBMPdecodeAllocate(struct mainRes_s *pmrs, int idx)
{
#define SCAN_IMAGE_SIZE (8 * 512 * 1024)

    int len=0, ix=0, totsz=0;
    struct bitmapDecodeMfour_s *pdec=0;
    int lens[BMP_DECODE_PIC_SIZE]={0};

    pdec = &pmrs->bmpDecMfour[idx];

    pipe2(pdec->aspPipeMfourRx, O_NONBLOCK);
    pipe2(pdec->aspPipeMfourTx, O_NONBLOCK);
    pipe2(pdec->aspPipeMfourCom, O_NONBLOCK);
    
    len = (SCAN_IMAGE_SIZE * 100) / 100;
    totsz = len + sizeof(mfour_image_param_st) + 32;
    pdec->aspDecJpeg.aspDcData = (mfour_image_param_st *)aspSalloc(totsz);
    if (pdec->aspDecJpeg.aspDcData) {
        //sprintf_f(pmrs->log, "allocate memory for M4 jpeg for id%d succeed !! size: %d KB\n", idx, len / 1024); 
        //print_f(pmrs->plog, "USB", pmrs->log);
        
        memset(pdec->aspDecJpeg.aspDcData, 0, len);
    } else {
        sprintf_f(pmrs->log, "allocate memory for M4 jpeg for id%d failed !! size: %d KB\n", idx, len / 1024); 
        print_f(pmrs->plog, "USB", pmrs->log);
    }
    pdec->aspDecJpeg.aspDcMax = len;

    len = 1024;
    totsz = len + sizeof(mfour_image_param_st) + 32;
    pdec->aspDecMeta.aspDcData = (mfour_image_param_st *)aspSalloc(totsz);
    if (pdec->aspDecMeta.aspDcData) {
        //sprintf_f(pmrs->log, "allocate memory for M4 jpeg for id%d succeed !! size: %dB\n", idx, len); 
        //print_f(pmrs->plog, "USB", pmrs->log);
        
        memset(pdec->aspDecMeta.aspDcData, 0, len);
    } else {
        sprintf_f(pmrs->log, "allocate memory for M4 jpeg for id%d failed !! size: %dB\n", idx, len); 
        print_f(pmrs->plog, "USB", pmrs->log);
    }
    pdec->aspDecMeta.aspDcMax = len;
    
    len = 65536;
    totsz = len + sizeof(mfour_image_param_st) + 32;
    pdec->aspDecMetaex.aspDcData = (mfour_image_param_st *)aspSalloc(totsz);
    if (pdec->aspDecMetaex.aspDcData) {
        //sprintf_f(pmrs->log, "allocate memory for M4 jpeg for id%d succeed !! size: %d KB\n", idx, len / 1024); 
        //print_f(pmrs->plog, "USB", pmrs->log);
        
        memset(pdec->aspDecMetaex.aspDcData, 0, len);
    } else {
        sprintf_f(pmrs->log, "allocate memory for M4 jpeg for id%d failed !! size: %d KB\n", idx, len / 1024); 
        print_f(pmrs->plog, "USB", pmrs->log);
    }
    pdec->aspDecMetaex.aspDcMax = len;
    
    len = SCAN_IMAGE_SIZE;
    totsz = len + sizeof(mfour_image_param_st) + 32;
    pdec->aspDecRaw.aspDcData = (mfour_image_param_st *)aspSalloc(totsz);
    if (pdec->aspDecRaw.aspDcData) {
        //sprintf_f(pmrs->log, "allocate memory for M4 raw for id%d succeed !! size: %d KB\n", idx, len / 1024); 
        //print_f(pmrs->plog, "USB", pmrs->log);
        
        memset(pdec->aspDecRaw.aspDcData, 0, len);
    } else {
        sprintf_f(pmrs->log, "allocate memory for M4 raw for id%d failed !! size: %d KB\n", idx, len / 1024); 
        print_f(pmrs->plog, "USB", pmrs->log);
    }
    pdec->aspDecRaw.aspDcMax = len;
    
    //len = 1024 * 100;
    #define M4_PIC_SIZE (12*1024)
    lens[0] = M4_PIC_SIZE;
    lens[1] = M4_PIC_SIZE;
    lens[2] = SCAN_IMAGE_SIZE;
    lens[3] = SCAN_IMAGE_SIZE;

    //len = SCAN_IMAGE_SIZE;
    
    for (ix=0; ix < BMP_DECODE_PIC_SIZE; ix++) {

        len = lens[ix];
        totsz = len + sizeof(mfour_image_param_st) + 32;
        
        pdec->aspDecMfPiRaw[ix].aspDcData = (mfour_image_param_st *)aspSalloc(totsz);
        if (pdec->aspDecMfPiRaw[ix].aspDcData) {
            //sprintf_f(pmrs->log, "allocate memory for M4 piece raw %.d for id%d succeed !! size: %d KB\n", ix, idx, len / 1024); 
            //print_f(pmrs->plog, "USB", pmrs->log);
        
            memset(pdec->aspDecMfPiRaw[ix].aspDcData, 0, len);
        } else {
            sprintf_f(pmrs->log, "allocate memory for M4 piece raw %.2d for id%d failed !! size: %d KB\n", ix, idx, len / 1024); 
            print_f(pmrs->plog, "USB", pmrs->log);
        }
        pdec->aspDecMfPiRaw[ix].aspDcMax = len;
    }

    //len = 1024 * 20;
    len = SCAN_IMAGE_SIZE;
    totsz = len + sizeof(mfour_image_param_st) + 32;
    for (ix=0; ix < BMP_DECODE_PIC_SIZE; ix++) {
        pdec->aspDecMfPiJpg[ix].aspDcData = (mfour_image_param_st *)aspSalloc(totsz);
        if (pdec->aspDecMfPiJpg[ix].aspDcData) {
            //sprintf_f(pmrs->log, "allocate memory for M4 piece jpg %.2d for id%d succeed !! size: %d KB\n", ix, idx, len / 1024); 
            //print_f(pmrs->plog, "USB", pmrs->log);
        
            memset(pdec->aspDecMfPiJpg[ix].aspDcData, 0, len);
        } else {
            sprintf_f(pmrs->log, "allocate memory for M4 piece raw %.2d for id%d failed !! size: %d KB\n", ix, idx, len / 1024); 
            print_f(pmrs->plog, "USB", pmrs->log);
        }
        pdec->aspDecMfPiJpg[ix].aspDcMax = len;
    }
    
}

static inline int setDefaultConfFile(struct aspConfig_s *conftb)
{
    int ix=0;
    struct aspConfig_s* ctb = 0;
    
    for (ix = 0; ix < ASPOP_CODE_MAX; ix++) {
        ctb = &conftb[ix];
        
        switch(ix) {
        case ASPOP_SCAN_SINGLE: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_SINGLE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SCAN_DOUBLE: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_DOUBLE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_ACTION: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_ACTION;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFAT_RD: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_SDRD;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFAT_WT: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_SDWT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFAT_STR01: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_00;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFAT_STR02: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFAT_STR03: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFAT_STR04: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFAT_LEN01: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_00;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFAT_LEN02: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFAT_LEN03: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFAT_LEN04: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFAT_SDAT: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_SDAT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_REG_RD: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_RGRD;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_REG_WT: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_RGWT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_REG_ADDRH: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_RGADD_H;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_REG_ADDRL: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_RGADD_L;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_REG_DAT: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_RGDAT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SUP_SAVE: 
            ctb->opStatus = ASPOP_STA_NONE; // for debug, should be ASPOP_STA_NONE
            ctb->opCode = OP_SUPBACK;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff; // for debug, should be 0xff
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFREE_FREESEC: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FREESEC;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFREE_STR01: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_00;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFREE_STR02: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFREE_STR03: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFREE_STR04: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFREE_LEN01: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_00;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFREE_LEN02: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFREE_LEN03: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFREE_LEN04: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDUSED_USEDSEC: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_USEDSEC;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDUSED_STR01: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_00;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDUSED_STR02: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDUSED_STR03: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDUSED_STR04: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDUSED_LEN01: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_00;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDUSED_LEN02: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDUSED_LEN03: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDUSED_LEN04: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_BLEEDTHROU_ADJUST: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_BLEEDTHROU_ADJUST;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_BLACKWHITE_THSHLD:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_BLACKWHITE_THSHLD;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SD_CLK_RATE_16: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_SD_CLK_RATE_16;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_PAPER_SIZE:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_PAPER_SIZE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_JPGRATE_ENG_17: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_JPGRATE_ENG_17;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNCTEST_18:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_18;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNCTEST_19: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_19;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNCTEST_20:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_20;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNCTEST_21:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_21;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNCTEST_22:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_22;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SKIP_LENGTH:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_SKIP_LENGTH;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_CROP_01: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_02: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_03: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_04: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_04;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_05: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_05;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_06: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_06;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_IMG_LEN: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_IMG_LEN;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_COOR_XH: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_00;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_CROP_COOR_XL: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_CROP_COOR_YH: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_CROP_COOR_YL: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_EG_DECT: 
            ctb->opStatus = ASPOP_STA_UPD; /* default enable to test CROP */
            ctb->opCode = OP_EG_DECT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0x1;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        #if 0 /* test AP mode */
        case ASPOP_AP_MODE: 
            ctb->opStatus = ASPOP_STA_APP; //default for debug ASPOP_STA_NONE;
            ctb->opCode = OP_AP_MODEN;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = APM_AP;  /* default ap mode */
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        #endif
        case ASPOP_XCROP_GAT: 
            ctb->opStatus = ASPOP_STA_NONE; /* set to ASPOP_STA_SCAN from scanner*/
            ctb->opCode = OP_META_DAT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0x0;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_XCROP_LINSTR: 
            ctb->opStatus = ASPOP_STA_NONE; /* set to ASPOP_STA_SCAN from scanner*/
            ctb->opCode = OP_META_DAT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0x0;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_XCROP_LINREC: 
            ctb->opStatus = ASPOP_STA_NONE; /* set to ASPOP_STA_SCAN from scanner*/
            ctb->opCode = OP_META_DAT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0x0;
            ctb->opMask = ASPOP_MASK_16;
            ctb->opBitlen = 16;
            break;
        case ASPOP_RAW_SIZE: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_01_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_02_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_03_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_04_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_04;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_05_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_05;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_06_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_06;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_07_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_08_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_09_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_10_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_04;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_11_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_05;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_12_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_06;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_13_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_14_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_15_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_16_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_04;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_17_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_05;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_18_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_06;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_IMG_LEN_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_IMG_LEN;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_XCROP_GAT_DUO: 
            ctb->opStatus = ASPOP_STA_NONE; /* set to ASPOP_STA_SCAN from scanner*/
            ctb->opCode = OP_META_DAT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0x0;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_XCROP_LINSTR_DUO: 
            ctb->opStatus = ASPOP_STA_NONE; /* set to ASPOP_STA_SCAN from scanner*/
            ctb->opCode = OP_META_DAT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0x0;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_XCROP_LINREC_DUO: 
            ctb->opStatus = ASPOP_STA_NONE; /* set to ASPOP_STA_SCAN from scanner*/
            ctb->opCode = OP_META_DAT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0x0;
            ctb->opMask = ASPOP_MASK_16;
            ctb->opBitlen = 16;
            break;
        case ASPOP_RAW_SIZE_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_MULTI_LOOP: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0x0;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_SCAN_STATUS:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0x0;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_SCAN_STATUS_DUO:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0x0;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_SCAN_WIDTH:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_SCAN_WIDTH_DUO:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_SCAN_SIDE:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_SCAN_SIDE_DUO:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_USBCROP_FP01: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_USBCROP_FP02: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_USBCROP_FP03: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_USBCROP_FP04: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_USBCROP_FP01_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_USBCROP_FP02_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_USBCROP_FP03_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_USBCROP_FP04_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        default: break;
        }
    }

    return ix;
}

static inline int setDefaultConf(struct aspConfig_s *conftb)
{
    int ix=0;
    struct aspConfig_s *ctb = 0;
    
    for (ix = 0; ix < ASPOP_CODE_MAX; ix++) {
        ctb = &conftb[ix];
        switch(ix) {
        case ASPOP_CODE_NONE:   
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = 0;
            ctb->opType = ASPOP_TYPE_NONE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_0;
            ctb->opBitlen = 0;
            break;
        case ASPOP_FILE_FORMAT: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FFORMAT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_COLOR_MODE:  
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_COLRMOD;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_COMPRES_RATE:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_COMPRAT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SCAN_SINGLE: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_SINGLE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SCAN_DOUBLE: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_DOUBLE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_ACTION: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_ACTION;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_RESOLUTION:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_RESOLTN;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SCAN_GRAVITY:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_SCANGAV;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_MAX_WIDTH:   
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_MAXWIDH;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_WIDTH_ADJ_H: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_WIDTHAD_H;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_WIDTH_ADJ_L: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_WIDTHAD_L;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SCAN_LENS_H: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_SCANLEN_H;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SCAN_LENS_L: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_SCANLEN_L;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_INTER_IMG: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_INTERIMG;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_AFEIC_SEL: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_AFEIC;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_EXT_PULSE: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_EXTPULSE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFAT_RD: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_SDRD;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFAT_WT: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_SDWT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFAT_STR01: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_00;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFAT_STR02: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFAT_STR03: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFAT_STR04: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFAT_LEN01: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_00;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFAT_LEN02: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFAT_LEN03: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFAT_LEN04: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFAT_SDAT: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_SDAT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_REG_RD: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_RGRD;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_REG_WT: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_RGWT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_REG_ADDRH: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_RGADD_H;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_REG_ADDRL: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_RGADD_L;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_REG_DAT: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_RGDAT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SUP_SAVE: 
            ctb->opStatus = ASPOP_STA_NONE; // for debug, should be ASPOP_STA_NONE
            ctb->opCode = OP_SUPBACK;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff; // for debug, should be 0xff
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFREE_FREESEC: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FREESEC;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFREE_STR01: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_00;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFREE_STR02: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFREE_STR03: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFREE_STR04: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFREE_LEN01: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_00;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFREE_LEN02: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFREE_LEN03: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDFREE_LEN04: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDUSED_USEDSEC: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_USEDSEC;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDUSED_STR01: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_00;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDUSED_STR02: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDUSED_STR03: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDUSED_STR04: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STSEC_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDUSED_LEN01: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_00;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDUSED_LEN02: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDUSED_LEN03: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SDUSED_LEN04: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNTEST_00: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_00;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNTEST_01: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNTEST_02: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNTEST_03: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNTEST_04: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_04;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNTEST_05: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_05;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNTEST_06: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_06;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNTEST_07: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_07;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNTEST_08: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_08;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNTEST_09: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_09;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNTEST_10: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_10;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNTEST_11: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_11;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNTEST_12: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_12;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNTEST_13: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_13;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNTEST_14: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_14;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNTEST_15: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_15;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_BLEEDTHROU_ADJUST: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_BLEEDTHROU_ADJUST;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_BLACKWHITE_THSHLD:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_BLACKWHITE_THSHLD;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SD_CLK_RATE_16: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_SD_CLK_RATE_16;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_PAPER_SIZE:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_PAPER_SIZE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_JPGRATE_ENG_17: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_JPGRATE_ENG_17;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNCTEST_18:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_18;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNCTEST_19: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_19;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNCTEST_20:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_20;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNCTEST_21:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_21;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_FUNCTEST_22:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_FUNCTEST_22;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_SKIP_LENGTH:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_SKIP_LENGTH;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_CROP_01: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_02: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_03: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_04: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_04;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_05: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_05;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_06: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_06;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_07: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_08: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_09: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_10: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_04;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_11: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_05;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_12: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_06;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_13: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_14: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_15: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_16: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_04;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_17: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_05;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_18: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_06;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_IMG_LEN: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_IMG_LEN;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_COOR_XH: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_00;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_CROP_COOR_XL: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_CROP_COOR_YH: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_CROP_COOR_YL: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_STLEN_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xff;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_EG_DECT: 
            ctb->opStatus = ASPOP_STA_UPD; /* default enable to test CROP */
            ctb->opCode = OP_EG_DECT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0x1;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_AP_MODE: 
            ctb->opStatus = ASPOP_STA_APP; //default for debug ASPOP_STA_NONE;
            ctb->opCode = OP_AP_MODEN;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = APM_AP;  /* default ap mode */
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_XCROP_GAT: 
            ctb->opStatus = ASPOP_STA_NONE; /* set to ASPOP_STA_SCAN from scanner*/
            ctb->opCode = OP_META_DAT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0x0;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_XCROP_LINSTR: 
            ctb->opStatus = ASPOP_STA_NONE; /* set to ASPOP_STA_SCAN from scanner*/
            ctb->opCode = OP_META_DAT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0x0;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_XCROP_LINREC: 
            ctb->opStatus = ASPOP_STA_NONE; /* set to ASPOP_STA_SCAN from scanner*/
            ctb->opCode = OP_META_DAT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0x0;
            ctb->opMask = ASPOP_MASK_16;
            ctb->opBitlen = 16;
            break;
        case ASPOP_RAW_SIZE: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_01_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_02_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_03_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_04_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_04;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_05_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_05;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_06_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_06;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_07_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_08_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_09_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_10_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_04;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_11_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_05;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_12_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_06;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_13_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_01;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_14_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_02;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_15_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_03;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_16_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_04;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_17_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_05;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_CROP_18_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_CROP_06;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_IMG_LEN_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_IMG_LEN;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_XCROP_GAT_DUO: 
            ctb->opStatus = ASPOP_STA_NONE; /* set to ASPOP_STA_SCAN from scanner*/
            ctb->opCode = OP_META_DAT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0x0;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_XCROP_LINSTR_DUO: 
            ctb->opStatus = ASPOP_STA_NONE; /* set to ASPOP_STA_SCAN from scanner*/
            ctb->opCode = OP_META_DAT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0x0;
            ctb->opMask = ASPOP_MASK_8;
            ctb->opBitlen = 8;
            break;
        case ASPOP_XCROP_LINREC_DUO: 
            ctb->opStatus = ASPOP_STA_NONE; /* set to ASPOP_STA_SCAN from scanner*/
            ctb->opCode = OP_META_DAT;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0x0;
            ctb->opMask = ASPOP_MASK_16;
            ctb->opBitlen = 16;
            break;
        case ASPOP_RAW_SIZE_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_MULTI_LOOP: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0x0;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_SCAN_STATUS:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_SCAN_STATUS_DUO:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_SCAN_WIDTH:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_SCAN_WIDTH_DUO:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_SCAN_SIDE:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_SCAN_SIDE_DUO:
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_USBCROP_FP01: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_USBCROP_FP02: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_USBCROP_FP03: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_USBCROP_FP04: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_USBCROP_FP01_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_USBCROP_FP02_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_USBCROP_FP03_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        case ASPOP_USBCROP_FP04_DUO: 
            ctb->opStatus = ASPOP_STA_NONE;
            ctb->opCode = OP_NONE;
            ctb->opType = ASPOP_TYPE_VALUE;
            ctb->opValue = 0xffffffff;
            ctb->opMask = ASPOP_MASK_32;
            ctb->opBitlen = 32;
            break;
        default: break;
        }
    }

    return ix;
}

static inline void printSysinfo(struct sysinfo *pminfo)
{
    sysinfo(pminfo);
    
    printf("   sysinfo free: %ld total: %ld unit: %d \n", pminfo->freeram, pminfo->totalram, pminfo->mem_unit);
    printf("   sysinfo freeswp: %ld totalswp: %ld buff: %ld \n", pminfo->freeswap, pminfo->totalswap, pminfo->bufferram);
    printf("   sysinfo freehi: %ld totalhi: %ld shd: %ld \n", pminfo->freehigh, pminfo->totalhigh, pminfo->sharedram);
}

static int dbgShowTimeStamp(char *str, struct mainRes_s *mrs, struct procRes_s *rs, int shift, char *bks) 
{
    uint32_t logconf;
    int tdiff=0;
    char *pstring=0;
    struct timespec *zot;
    struct timespec cur;

    if (!str) return -1;
    if ((!mrs) && (!rs)) return -2;
    
    if (mrs) {
        zot = &mrs->time[0];
        logconf = mrs->mspconfig & 0x7;
    }

    if (rs) {
        zot = rs->tm[0];
        logconf = *rs->pmsconfig & 0x7;
    }

    clock_gettime(CLOCK_REALTIME, &cur);    
    tdiff = time_diff(zot, &cur, 1000);
    if (logconf == 0) {
        pstring = str;
    } else if (logconf & 0x1) {
        pstring = str;
    } else if (logconf & 0x2) {
        if (bks) {
            pstring = bks;
        } else {
            pstring = str;
        }
    } else {
        return tdiff;
    }

#if 1

    printf("\n %*s[%s] (%d.%d) ms\n", shift, "", pstring, tdiff / 1000, tdiff % 1000);

#else
    char *wday[]={"Sun","Mon","Tue","Wed","Thu","Fri","Sat"}; 
    struct tm *p=0;
    time_t timep;

    time(&timep);
    p=localtime(&timep); /*oa*/ 

    printf("[%s] %.4d%.2d%.2d %s, %.2d:%.2d:%.2d\n", str, 
        (1900+p->tm_year),( 1+p-> tm_mon), p->tm_mday,
        wday[p->tm_wday],p->tm_hour, p->tm_min, p->tm_sec); 
    printf("\n[%s] %.2d:%.2d:%.2d\n", str, p->tm_hour, p->tm_min, p->tm_sec); 
#endif
    return tdiff;
}

static int bitmapColorTableSetup(char *p)
{
    int i=0;
    char val=0, *dst=0;
    if (!p) return -1;

    dst = p;

    for (i = 0; i < 256; i++) {
        dst[i*4+0] = val;
        dst[i*4+1] = val;
        dst[i*4+2] = val;
        dst[i*4+3] = 0;

        val++;
    }

    return 0;
}

static int bitmapHeaderSetup(struct bitmapHeader_s *ph, int clr, int w, int h, int dpi, int flen) 
{
    int rawoffset=0, totsize=0, numclrp=0, calcuraw=0, rawsize=0;
    float resH=0, resV=0, ratio=39.27, fval=0;
    //uint32_t cmpl=0xffffffff;

    if (!w) return -1;
    if (!h) return -2;
    if (!dpi) return -3;
    if (!flen) return -4;
    memset(ph, 0, sizeof(struct bitmapHeader_s));

    if (clr == 8) {
        numclrp = 256;
        rawoffset = 1078;
        //numclrp = 0;
        //rawoffset = 54;
        calcuraw = w * h;
    }
    else if (clr == 24) {
        numclrp = 0;
        rawoffset = 54;
        calcuraw = w * h * 3;
    } else {
        printf("[BMP] reset header ERROR!!! color bits is %d \n", clr);
        return -5;
    }

    if (calcuraw != flen) {
        //printf("[BMP] WARNNING!!! raw size %d is wrong, should be %d x %d x %d= %d \n", flen, w, h, clr / 8, calcuraw);
        if (flen > calcuraw) {
            rawsize = calcuraw;
        } else {
            rawsize = flen;
        }
    } else {
        rawsize = calcuraw;
    }

    totsize = rawsize + rawoffset;
    
    fval = dpi;
    resH = fval * ratio;
    fval = dpi;
    resV = fval * ratio;
    
    ph->aspbmpMagic[2] = 'B';
    ph->aspbmpMagic[3] = 'M';       
    ph->aspbhSize = totsize; // file total size
    ph->aspbhRawoffset = rawoffset; // header size include color table 54 + 1024 = 1078
    ph->aspbiSize = 40;
    ph->aspbiWidth = w; // W
    //cmpl = (cmpl - h) + 1;
    //ph->aspbiHeight = cmpl; // H
    ph->aspbiHeight = h; // H
    ph->aspbiCPP = 1;
    //ph->aspbiCPP = 0;
    ph->aspbiCPP |= clr << 16;  // 8 or 24
    ph->aspbiCompMethd = 0;
    ph->aspbiRawSize = rawsize; // size of raw
    ph->aspbiResoluH = (int)resH; // dpi x 39.27
    ph->aspbiResoluV = (int)resV; // dpi x 39.27
    ph->aspbiNumCinCP = numclrp;  // 24bit is 0, 8bit is 256
    ph->aspbiNumImpColor = 0;

    return 0;
}

static int dbgRjobCmd(mfour_rjob_cmd *rjcmd, int len)
{
    char mlog[256];

    msync(rjcmd, sizeof(mfour_rjob_cmd), MS_SYNC);
    
    sprintf_f(mlog, "********************************************\n");
    print_f(mlogPool, "CMD", mlog);

    sprintf_f(mlog, "RJCMD[0x%.8x] len: %d (%d) \n", (uint32_t)rjcmd, len, sizeof(rjcmd));
    print_f(mlogPool, "CMD", mlog);

    sprintf_f(mlog, "[0x%.8x]MSG_TYPE: [%ld](%d) \n", (uint32_t)&rjcmd->msgtype, rjcmd->msgtype, sizeof(rjcmd->msgtype));
    print_f(mlogPool, "CMD", mlog);

    sprintf_f(mlog, "[0x%.8x]TAG: [0x%.8x](%d) \n", (uint32_t)&rjcmd->tag, (uint32_t)rjcmd->tag, sizeof(rjcmd->tag));
    print_f(mlogPool, "CMD", mlog);

    sprintf_f(mlog, "[0x%.8x]COMMAND: [0x%.4x](%d) \n", (uint32_t)&rjcmd->cmd, rjcmd->cmd, sizeof(rjcmd->cmd));
    print_f(mlogPool, "CMD", mlog);

    sprintf_f(mlog, "[0x%.8x]RESPONSE: [%d](%d) \n", (uint32_t)&rjcmd->rsp, rjcmd->rsp, sizeof(rjcmd->rsp));
    print_f(mlogPool, "CMD", mlog);

    sprintf_f(mlog, "[0x%.8x]SIZE: [%d](%d) \n", (uint32_t)&rjcmd->dSize, rjcmd->dSize, sizeof(rjcmd->dSize));
    print_f(mlogPool, "CMD", mlog);

    sprintf_f(mlog, "[0x%.8x]DATA_PT: [0x%.8x](%d) \n", (uint32_t)&rjcmd->dPtr, (uint32_t)rjcmd->dPtr, sizeof(rjcmd->dPtr));
    print_f(mlogPool, "CMD", mlog);

    sprintf_f(mlog, "[0x%.8x]SHARE_PT: [0x%.8x](%d) \n", (uint32_t)&rjcmd->mPtr, (uint32_t)rjcmd->mPtr, sizeof(rjcmd->mPtr));
    print_f(mlogPool, "CMD", mlog);

    sprintf_f(mlog, "********************************************\n");
    print_f(mlogPool, "CMD", mlog);

    return 0;
}

static int dbgBitmapHeader(struct bitmapHeader_s *ph, int len) 
{
    char mlog[256];

    msync(ph, sizeof(struct bitmapHeader_s), MS_SYNC);

    sprintf_f(mlog, "********************************************\n");
    print_f(mlogPool, "BMP", mlog);

    sprintf_f(mlog, "debug print bitmap header length: %d\n", len);
    print_f(mlogPool, "BMP", mlog);

    sprintf_f(mlog, "MAGIC NUMBER: [%c] [%c] \n",ph->aspbmpMagic[2], ph->aspbmpMagic[3]);         
    print_f(mlogPool, "BMP", mlog);

    sprintf_f(mlog, "FILE TOTAL LENGTH: [%d] \n",ph->aspbhSize);                                                 // mod
    print_f(mlogPool, "BMP", mlog);

    sprintf_f(mlog, "HEADER TOTAL LENGTH: [%d] \n",ph->aspbhRawoffset);          
    print_f(mlogPool, "BMP", mlog);

    sprintf_f(mlog, "INFO HEADER LENGTH: [%d] \n",ph->aspbiSize);          
    print_f(mlogPool, "BMP", mlog);

    sprintf_f(mlog, "WIDTH: [%d] \n",ph->aspbiWidth);                                                          // mod
    print_f(mlogPool, "BMP", mlog);

    sprintf_f(mlog, "HEIGHT: [%d] \n",ph->aspbiHeight);                                                        // mod
    print_f(mlogPool, "BMP", mlog);
    
    sprintf_f(mlog, "NUM OF COLOR PLANES: [%d] \n",ph->aspbiCPP & 0xffff);          
    print_f(mlogPool, "BMP", mlog);

    sprintf_f(mlog, "BITS PER PIXEL: [%d] \n",ph->aspbiCPP >> 16);          
    print_f(mlogPool, "BMP", mlog);

    sprintf_f(mlog, "COMPRESSION METHOD: [%d] \n",ph->aspbiCompMethd);          
    print_f(mlogPool, "BMP", mlog);

    sprintf_f(mlog, "SIZE OF RAW: [%d] \n",ph->aspbiRawSize);                                            // mod
    print_f(mlogPool, "BMP", mlog);

    sprintf_f(mlog, "HORIZONTAL RESOLUTION: [%d] \n",ph->aspbiResoluH);          
    print_f(mlogPool, "BMP", mlog);

    sprintf_f(mlog, "VERTICAL RESOLUTION: [%d] \n",ph->aspbiResoluV);          
    print_f(mlogPool, "BMP", mlog);

    sprintf_f(mlog, "NUM OF COLORS IN CP: [%d] \n",ph->aspbiNumCinCP);          
    print_f(mlogPool, "BMP", mlog);

    sprintf_f(mlog, "NUM OF IMPORTANT COLORS: [%d] \n",ph->aspbiNumImpColor);          
    print_f(mlogPool, "BMP", mlog);

    sprintf_f(mlog, "********************************************\n");
    print_f(mlogPool, "BMP", mlog);

    return 0;
}

static void dbgprintRect(struct aspRectObj *rect)
{
    char mlog[256];
    
    sprintf_f(mlog, "LU[%.2lf, %.2lf] LD[%.2lf, %.2lf] RD[%.2lf, %.2lf] RU[%.2lf, %.2lf]\n", 
        rect->aspRectLU[0], rect->aspRectLU[1], 
        rect->aspRectLD[0], rect->aspRectLD[1], 
        rect->aspRectRD[0], rect->aspRectRD[1], 
        rect->aspRectRU[0], rect->aspRectRU[1]);
    print_f(mlogPool, "RECT", mlog);
}

static int dbgMetaUsb(struct aspMetaDataviaUSB_s *pmetausb) 
{
#define VERB_INFO_USB (0)
    char mlog[256];
    char *pch=0;
    uint32_t head=0;
    int ix=0;

    head = (uint32_t)pmetausb->ASP_MAGIC_ASPC;
    
    msync(pmetausb, sizeof(struct aspMetaDataviaUSB_s), MS_SYNC);
    
    sprintf_f(mlog, "********************************************\n");
    print_f(mlogPool, "METAU", mlog);
    
    sprintf_f(mlog, "(%.3d) ASP_MAGIC_ASPC: 0x%.2x 0x%.2x 0x%.2x 0x%.2x\n", (uint32_t)pmetausb->ASP_MAGIC_ASPC - head, pmetausb->ASP_MAGIC_ASPC[0], pmetausb->ASP_MAGIC_ASPC[1], 
                  pmetausb->ASP_MAGIC_ASPC[2], pmetausb->ASP_MAGIC_ASPC[3]);
    print_f(mlogPool, "METAU", mlog);

    sprintf_f(mlog, "(%.3d) IMG_HIGH: 0x%.2x 0x%.2x (%d)   \n",(uint32_t)&(pmetausb->IMG_HIGH)  - head, pmetausb->IMG_HIGH[0], pmetausb->IMG_HIGH[1], 
                   pmetausb->IMG_HIGH[0] | (pmetausb->IMG_HIGH[1] << 8)); 
    print_f(mlogPool, "METAU", mlog);

    #if VERB_INFO_USB
    for (ix=0; ix < 5; ix++) {
    sprintf_f(mlog, "(%.3d) WIDTH_RESERVE[%d]: 0x%.2x    \n",(uint32_t)&(pmetausb->WIDTH_RESERVE[ix])  - head, ix, pmetausb->WIDTH_RESERVE[ix]); 
    print_f(mlogPool, "METAU", mlog);
    }
    #endif

    sprintf_f(mlog, "(%.3d) IMG_WIDTH: 0x%.2x 0x%.2x (%d)   \n",(uint32_t)&(pmetausb->IMG_WIDTH)  - head, pmetausb->IMG_WIDTH[0], pmetausb->IMG_WIDTH[1], 
                   pmetausb->IMG_WIDTH[0] | (pmetausb->IMG_WIDTH[1] << 8)); 
    print_f(mlogPool, "METAU", mlog);

    sprintf_f(mlog, "(%.3d) MINGS_USE: 0x%.2x 0x%.2x   \n",(uint32_t)&(pmetausb->MINGS_USE) - head, pmetausb->MINGS_USE[0], pmetausb->MINGS_USE[1]); 
    print_f(mlogPool, "METAU", mlog);

    sprintf_f(mlog, "(%.3d) PRI_O_SEC: 0x%.2x    \n",(uint32_t)&(pmetausb->PRI_O_SEC) - head, pmetausb->PRI_O_SEC); 
    print_f(mlogPool, "METAU", mlog);

    sprintf_f(mlog, "(%.3d) Scaned_Page: %d    \n",(uint32_t)&(pmetausb->Scaned_Page) - head, (pmetausb->Scaned_Page[0] << 8) | pmetausb->Scaned_Page[1]); 
    print_f(mlogPool, "METAU", mlog);

    sprintf_f(mlog, "(%.3d) BKNote_Total_Layers: %d    \n",(uint32_t)&(pmetausb->BKNote_Total_Layers) - head, pmetausb->BKNote_Total_Layers); 
    print_f(mlogPool, "METAU", mlog);

    sprintf_f(mlog, "(%.3d) BKNote_Slice_idx: %d    \n",(uint32_t)&(pmetausb->BKNote_Slice_idx) - head, pmetausb->BKNote_Slice_idx); 
    print_f(mlogPool, "METAU", mlog);
    
    sprintf_f(mlog, "(%.3d) BKNote_Block_idx: %d    \n",(uint32_t)&(pmetausb->BKNote_Block_idx) - head, pmetausb->BKNote_Block_idx); 
    print_f(mlogPool, "METAU", mlog);

    #if VERB_INFO_USB
    for (ix=0; ix < 27; ix++) {
    sprintf_f(mlog, "(%.3d) MCROP_RESERVE[%d]: 0x%.2x    \n",(uint32_t)&(pmetausb->MCROP_RESERVE[ix]) - head, ix, pmetausb->MCROP_RESERVE[ix]); 
    print_f(mlogPool, "METAU", mlog);
    }
    #endif

    sprintf_f(mlog, "(%.3d) CROP_POSX_01: %d, %d\n", (uint32_t)(&pmetausb->CROP_POS_1) - head, msb2lsb32(&pmetausb->CROP_POS_1) >> 16, msb2lsb32(&pmetausb->CROP_POS_1) & 0xffff);                      //byte[68]
    print_f(mlogPool, "METAU", mlog);
    sprintf_f(mlog, "(%.3d) CROP_POSX_02: %d, %d\n", (uint32_t)&pmetausb->CROP_POS_2 - head, msb2lsb32(&pmetausb->CROP_POS_2) >> 16, msb2lsb32(&pmetausb->CROP_POS_2) & 0xffff);                      //byte[72]
    print_f(mlogPool, "METAU", mlog);
    sprintf_f(mlog, "(%.3d) CROP_POSX_03: %d, %d\n", (uint32_t)&pmetausb->CROP_POS_3 - head, msb2lsb32(&pmetausb->CROP_POS_3) >> 16, msb2lsb32(&pmetausb->CROP_POS_3) & 0xffff);                      //byte[76]
    print_f(mlogPool, "METAU", mlog);
    sprintf_f(mlog, "(%.3d) CROP_POSX_04: %d, %d\n", (uint32_t)&pmetausb->CROP_POS_4 - head, msb2lsb32(&pmetausb->CROP_POS_4) >> 16, msb2lsb32(&pmetausb->CROP_POS_4) & 0xffff);                      //byte[80]
    print_f(mlogPool, "METAU", mlog);
    sprintf_f(mlog, "(%.3d) CROP_POSX_05: %d, %d\n", (uint32_t)&pmetausb->CROP_POS_5 - head, msb2lsb32(&pmetausb->CROP_POS_5) >> 16, msb2lsb32(&pmetausb->CROP_POS_5) & 0xffff);                      //byte[84]
    print_f(mlogPool, "METAU", mlog);
    sprintf_f(mlog, "(%.3d) CROP_POSX_06: %d, %d\n", (uint32_t)&pmetausb->CROP_POS_6 - head, msb2lsb32(&pmetausb->CROP_POS_6) >> 16, msb2lsb32(&pmetausb->CROP_POS_6) & 0xffff);                      //byte[88]
    print_f(mlogPool, "METAU", mlog);
    sprintf_f(mlog, "(%.3d) CROP_POSX_07: %d, %d\n", (uint32_t)&pmetausb->CROP_POS_7 - head, msb2lsb32(&pmetausb->CROP_POS_7) >> 16, msb2lsb32(&pmetausb->CROP_POS_7) & 0xffff);                      //byte[92]
    print_f(mlogPool, "METAU", mlog);
    sprintf_f(mlog, "(%.3d) CROP_POSX_08: %d, %d\n", (uint32_t)&pmetausb->CROP_POS_8 - head, msb2lsb32(&pmetausb->CROP_POS_8) >> 16, msb2lsb32(&pmetausb->CROP_POS_8) & 0xffff);                      //byte[96]
    print_f(mlogPool, "METAU", mlog);
    sprintf_f(mlog, "(%.3d) CROP_POSX_09: %d, %d\n", (uint32_t)&pmetausb->CROP_POS_9 - head, msb2lsb32(&pmetausb->CROP_POS_9) >> 16, msb2lsb32(&pmetausb->CROP_POS_9) & 0xffff);                      //byte[100]
    print_f(mlogPool, "METAU", mlog);
    sprintf_f(mlog, "(%.3d) CROP_POSX_10: %d, %d\n", (uint32_t)&pmetausb->CROP_POS_10 - head, msb2lsb32(&pmetausb->CROP_POS_10) >> 16, msb2lsb32(&pmetausb->CROP_POS_10) & 0xffff);                      //byte[104]
    print_f(mlogPool, "METAU", mlog);
    sprintf_f(mlog, "(%.3d) CROP_POSX_11: %d, %d\n", (uint32_t)&pmetausb->CROP_POS_11 - head, msb2lsb32(&pmetausb->CROP_POS_11) >> 16, msb2lsb32(&pmetausb->CROP_POS_11) & 0xffff);                      //byte[108]
    print_f(mlogPool, "METAU", mlog);
    sprintf_f(mlog, "(%.3d) CROP_POSX_12: %d, %d\n", (uint32_t)&pmetausb->CROP_POS_12 - head, msb2lsb32(&pmetausb->CROP_POS_12) >> 16, msb2lsb32(&pmetausb->CROP_POS_12) & 0xffff);                      //byte[112]
    print_f(mlogPool, "METAU", mlog);
    sprintf_f(mlog, "(%.3d) CROP_POSX_13: %d, %d\n", (uint32_t)&pmetausb->CROP_POS_13 - head, msb2lsb32(&pmetausb->CROP_POS_13) >> 16, msb2lsb32(&pmetausb->CROP_POS_13) & 0xffff);                      //byte[116]
    print_f(mlogPool, "METAU", mlog);
    sprintf_f(mlog, "(%.3d) CROP_POSX_14: %d, %d\n", (uint32_t)&pmetausb->CROP_POS_14 - head, msb2lsb32(&pmetausb->CROP_POS_14) >> 16, msb2lsb32(&pmetausb->CROP_POS_14) & 0xffff);                      //byte[120]
    print_f(mlogPool, "METAU", mlog);
    sprintf_f(mlog, "(%.3d) CROP_POSX_15: %d, %d\n", (uint32_t)&pmetausb->CROP_POS_15 - head, msb2lsb32(&pmetausb->CROP_POS_15) >> 16, msb2lsb32(&pmetausb->CROP_POS_15) & 0xffff);                      //byte[124]
    print_f(mlogPool, "METAU", mlog);
    sprintf_f(mlog, "(%.3d) CROP_POSX_16: %d, %d\n", (uint32_t)&pmetausb->CROP_POS_16 - head, msb2lsb32(&pmetausb->CROP_POS_16) >> 16, msb2lsb32(&pmetausb->CROP_POS_16) & 0xffff);                      //byte[128]
    print_f(mlogPool, "METAU", mlog);
    sprintf_f(mlog, "(%.3d) CROP_POSX_17: %d, %d\n", (uint32_t)&pmetausb->CROP_POS_17 - head, msb2lsb32(&pmetausb->CROP_POS_17) >> 16, msb2lsb32(&pmetausb->CROP_POS_17) & 0xffff);                      //byte[132]
    print_f(mlogPool, "METAU", mlog);
    sprintf_f(mlog, "(%.3d) CROP_POSX_18: %d, %d\n", (uint32_t)&pmetausb->CROP_POS_18 - head, msb2lsb32(&pmetausb->CROP_POS_18) >> 16, msb2lsb32(&pmetausb->CROP_POS_18) & 0xffff);                      //byte[136]
    print_f(mlogPool, "METAU", mlog);
    sprintf_f(mlog, "(%.3d) YLine_Gap: %.d      \n", (uint32_t)&pmetausb->YLine_Gap - head, pmetausb->YLine_Gap); 
    print_f(mlogPool, "METAU", mlog);
    sprintf_f(mlog, "(%.3d) Start_YLine_No: %d      \n", (uint32_t)&pmetausb->Start_YLine_No - head, pmetausb->Start_YLine_No); 
    print_f(mlogPool, "METAU", mlog);
    pch = (char *)&pmetausb->YLines_Recorded;
    sprintf_f(mlog, "(%.3d) YLines_Recorded: %d      \n", (uint32_t)&pmetausb->YLines_Recorded - head, (pch[0] << 8) | pch[1]); 
    print_f(mlogPool, "METAU", mlog);

    sprintf_f(mlog, "(%.3d) CROP_POSX_F01: %d, %d\n", (uint32_t)(&pmetausb->CROP_POS_F1) - head, msb2lsb32(&pmetausb->CROP_POS_F1) >> 16, msb2lsb32(&pmetausb->CROP_POS_F1) & 0xffff);                      //byte[148]
    print_f(mlogPool, "METAU", mlog);
    sprintf_f(mlog, "(%.3d) CROP_POSX_F02: %d, %d\n", (uint32_t)&pmetausb->CROP_POS_F2 - head, msb2lsb32(&pmetausb->CROP_POS_F2) >> 16, msb2lsb32(&pmetausb->CROP_POS_F2) & 0xffff);                      //byte[152]
    print_f(mlogPool, "METAU", mlog);
    sprintf_f(mlog, "(%.3d) CROP_POSX_F03: %d, %d\n", (uint32_t)&pmetausb->CROP_POS_F3 - head, msb2lsb32(&pmetausb->CROP_POS_F3) >> 16, msb2lsb32(&pmetausb->CROP_POS_F3) & 0xffff);                      //byte[156]
    print_f(mlogPool, "METAU", mlog);
    sprintf_f(mlog, "(%.3d) CROP_POSX_F04: %d, %d\n", (uint32_t)&pmetausb->CROP_POS_F4 - head, msb2lsb32(&pmetausb->CROP_POS_F4) >> 16, msb2lsb32(&pmetausb->CROP_POS_F4) & 0xffff);                      //byte[160]
    print_f(mlogPool, "METAU", mlog);
    
    sprintf_f(mlog, "(%.3d) EPOINT_RESERVE1      \n", (uint32_t)pmetausb->EPOINT_RESERVE1 - head); 
    print_f(mlogPool, "METAU", mlog);

    sprintf_f(mlog, "(%.3d) ASP_MAGIC_YL: 0x%.2x 0x%.2x\n", (uint32_t)pmetausb->ASP_MAGIC_YL - head, pmetausb->ASP_MAGIC_YL[0], pmetausb->ASP_MAGIC_YL[1]);
    print_f(mlogPool, "METAU", mlog);

    sprintf_f(mlog, "(%.3d) MPIONT_LEN: %d      \n", (uint32_t)&pmetausb->MPIONT_LEN - head, pmetausb->MPIONT_LEN); 
    print_f(mlogPool, "METAU", mlog);

    sprintf_f(mlog, "(%.3d) EXTRA_POINT[4]: 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x  \n", (uint32_t)pmetausb->EXTRA_POINT - head, pmetausb->EXTRA_POINT[0], pmetausb->EXTRA_POINT[1], pmetausb->EXTRA_POINT[2], pmetausb->EXTRA_POINT[3]);
    print_f(mlogPool, "METAU", mlog);


    sprintf_f(mlog, "********************************************\n");
    print_f(mlogPool, "METAU", mlog);
    return 0;
}

static int dbgMeta(unsigned int funcbits, struct aspMetaData_s *pmeta) 
{
    char mlog[256];
    char *pch=0;
    int ix=0, num=0;
    
    msync(pmeta, sizeof(struct aspMetaData_s), MS_SYNC);
    sprintf_f(mlog, "********************************************\n");
    print_f(mlogPool, "META", mlog);
    sprintf_f(mlog, "_ debug print , funcBits: 0x%.8x, magic[0]: 0x%.2x magic[1]: 0x%.2x \n", funcbits, pmeta->ASP_MAGIC[0], pmeta->ASP_MAGIC[1]);
    print_f(mlogPool, "META", mlog);
    
    if ((pmeta->ASP_MAGIC[0] != 0x20) || (pmeta->ASP_MAGIC[1] != 0x14)) {
        sprintf_f(mlog, " Warning!!! magic[0]: 0x%.2x magic[1]: 0x%.2x \n", pmeta->ASP_MAGIC[0], pmeta->ASP_MAGIC[1]);
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "********************************************\n");
        print_f(mlogPool, "META", mlog);
        return -2;
    }
    
    if (funcbits == ASPMETA_FUNC_NONE) {
        sprintf_f(mlog, "********************************************\n");
        print_f(mlogPool, "META", mlog);
        return -3;
    }

    if (funcbits & ASPMETA_FUNC_CONF) {
        sprintf_f(mlog, "__ASPMETA_FUNC_CONF__(0x%x & 0x%x = 0x%x)\n", funcbits, ASPMETA_FUNC_CONF, (funcbits & ASPMETA_FUNC_CONF));
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "FILE_FORMAT: 0x%.2x    \n",pmeta->FILE_FORMAT     );          //0x31
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "COLOR_MODE: 0x%.2x      \n",pmeta->COLOR_MODE      );        //0x32
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "COMPRESSION_RATE: 0x%.2x\n",pmeta->COMPRESSION_RATE);   //0x33
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "RESOLUTION: 0x%.2x      \n",pmeta->RESOLUTION      );         //0x34
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "SCAN_GRAVITY: 0x%.2x    \n",pmeta->SCAN_GRAVITY    );       //0x35
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "CIS_MAX_Width: 0x%.2x   \n",pmeta->CIS_MAX_WIDTH   );        //0x36
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "WIDTH_ADJUST_H: 0x%.2x  \n",pmeta->WIDTH_ADJUST_H  );     //0x37
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "WIDTH_ADJUST_L: 0x%.2x  \n",pmeta->WIDTH_ADJUST_L  );      //0x38
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "SCAN_LENGTH_H: 0x%.2x   \n",pmeta->SCAN_LENGTH_H   );      //0x39
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "SCAN_LENGTH_L: 0x%.2x   \n",pmeta->SCAN_LENGTH_L   );       //0x3a
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "INTERNAL_IMG: 0x%.2x    \n",pmeta->INTERNAL_IMG    );         //0x3b
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "AFE_IC_SELEC: 0x%.2x    \n",pmeta->AFE_IC_SELEC    );         //0x3c
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "EXTNAL_PULSE: 0x%.2x    \n",pmeta->EXTNAL_PULSE    );         //0x3d
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "SUP_WRITEBK: 0x%.2x     \n",pmeta->SUP_WRITEBK     );       //0x3e
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "OP_FUNC_00: 0x%.2x      \n",pmeta->OP_FUNC_00      );     //0x70
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "OP_FUNC_01: 0x%.2x      \n",pmeta->OP_FUNC_01      );     //0x71
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "OP_FUNC_02: 0x%.2x      \n",pmeta->OP_FUNC_02      );     //0x72
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "OP_FUNC_03: 0x%.2x      \n",pmeta->OP_FUNC_03      );     //0x73
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "OP_FUNC_04: 0x%.2x      \n",pmeta->OP_FUNC_04      );     //0x74
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "OP_FUNC_05: 0x%.2x      \n",pmeta->OP_FUNC_05      );     //0x75
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "OP_FUNC_06: 0x%.2x      \n",pmeta->OP_FUNC_06      );     //0x76
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "OP_FUNC_07: 0x%.2x      \n",pmeta->OP_FUNC_07      );     //0x77
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "OP_FUNC_08: 0x%.2x      \n",pmeta->OP_FUNC_08      );     //0x78
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "OP_FUNC_09: 0x%.2x      \n",pmeta->OP_FUNC_09      );     //0x79
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "OP_FUNC_10: 0x%.2x      \n",pmeta->OP_FUNC_10      );     //0x7A
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "OP_FUNC_11: 0x%.2x      \n",pmeta->OP_FUNC_11      );     //0x7B
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "OP_FUNC_12: 0x%.2x      \n",pmeta->OP_FUNC_12      );     //0x7C
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "OP_FUNC_13: 0x%.2x      \n",pmeta->OP_FUNC_13      );     //0x7D
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "OP_FUNC_14: 0x%.2x      \n",pmeta->OP_FUNC_14      );     //0x7E
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "OP_FUNC_15: 0x%.2x      \n",pmeta->OP_FUNC_15      );     //0x7F  
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "BLEEDTHROU_ADJUST: 0x%.2x      \n",pmeta->BLEEDTHROU_ADJUST);
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "BLACKWHITE_THSHLD: 0x%.2x      \n",pmeta->BLACKWHITE_THSHLD);
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "SD_CLK_RATE_16: 0x%.2x      \n",pmeta->SD_CLK_RATE_16);
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "PAPER_SIZE: 0x%.2x      \n",pmeta->PAPER_SIZE);
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "JPGRATE_ENG_17: 0x%.2x      \n",pmeta->JPGRATE_ENG_17);
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "OP_FUNC_18: 0x%.2x      \n",pmeta->OP_FUNC_18);
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "OP_FUNC_19: 0x%.2x      \n",pmeta->OP_FUNC_19);
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "OP_FUNC_20: 0x%.2x      \n",pmeta->OP_FUNC_20);
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "OP_FUNC_21: 0x%.2x      \n",pmeta->OP_FUNC_21);
        print_f(mlogPool, "META", mlog);
    }

    #if 0
    if (funcbits & ASPMETA_FUNC_CROP) {
        sprintf_f(mlog, "__ASPMETA_FUNC_CROP__(0x%x & 0x%x = 0x%x)\n", funcbits, ASPMETA_FUNC_CROP, (funcbits & ASPMETA_FUNC_CROP));
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "CROP_POSX_01: %d, %d\n", msb2lsb32(&pmeta->CROP_POS_1) >> 16, msb2lsb32(&pmeta->CROP_POS_1) & 0xffff);                      //byte[68]
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "CROP_POSX_02: %d, %d\n", msb2lsb32(&pmeta->CROP_POS_2) >> 16, msb2lsb32(&pmeta->CROP_POS_2) & 0xffff);                      //byte[72]
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "CROP_POSX_03: %d, %d\n", msb2lsb32(&pmeta->CROP_POS_3) >> 16, msb2lsb32(&pmeta->CROP_POS_3) & 0xffff);                      //byte[76]
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "CROP_POSX_04: %d, %d\n", msb2lsb32(&pmeta->CROP_POS_4) >> 16, msb2lsb32(&pmeta->CROP_POS_4) & 0xffff);                      //byte[80]
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "CROP_POSX_05: %d, %d\n", msb2lsb32(&pmeta->CROP_POS_5) >> 16, msb2lsb32(&pmeta->CROP_POS_5) & 0xffff);                      //byte[84]
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "CROP_POSX_06: %d, %d\n", msb2lsb32(&pmeta->CROP_POS_6) >> 16, msb2lsb32(&pmeta->CROP_POS_6) & 0xffff);                      //byte[88]
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "CROP_POSX_07: %d, %d\n", msb2lsb32(&pmeta->CROP_POS_7) >> 16, msb2lsb32(&pmeta->CROP_POS_7) & 0xffff);                      //byte[92]
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "CROP_POSX_08: %d, %d\n", msb2lsb32(&pmeta->CROP_POS_8) >> 16, msb2lsb32(&pmeta->CROP_POS_8) & 0xffff);                      //byte[96]
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "CROP_POSX_09: %d, %d\n", msb2lsb32(&pmeta->CROP_POS_9) >> 16, msb2lsb32(&pmeta->CROP_POS_9) & 0xffff);                      //byte[100]
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "CROP_POSX_10: %d, %d\n", msb2lsb32(&pmeta->CROP_POS_10) >> 16, msb2lsb32(&pmeta->CROP_POS_10) & 0xffff);                      //byte[104]
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "CROP_POSX_11: %d, %d\n", msb2lsb32(&pmeta->CROP_POS_11) >> 16, msb2lsb32(&pmeta->CROP_POS_11) & 0xffff);                      //byte[108]
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "CROP_POSX_12: %d, %d\n", msb2lsb32(&pmeta->CROP_POS_12) >> 16, msb2lsb32(&pmeta->CROP_POS_12) & 0xffff);                      //byte[112]
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "CROP_POSX_13: %d, %d\n", msb2lsb32(&pmeta->CROP_POS_13) >> 16, msb2lsb32(&pmeta->CROP_POS_13) & 0xffff);                      //byte[116]
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "CROP_POSX_14: %d, %d\n", msb2lsb32(&pmeta->CROP_POS_14) >> 16, msb2lsb32(&pmeta->CROP_POS_14) & 0xffff);                      //byte[120]
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "CROP_POSX_15: %d, %d\n", msb2lsb32(&pmeta->CROP_POS_15) >> 16, msb2lsb32(&pmeta->CROP_POS_15) & 0xffff);                      //byte[124]
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "CROP_POSX_16: %d, %d\n", msb2lsb32(&pmeta->CROP_POS_16) >> 16, msb2lsb32(&pmeta->CROP_POS_16) & 0xffff);                      //byte[128]
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "CROP_POSX_17: %d, %d\n", msb2lsb32(&pmeta->CROP_POS_17) >> 16, msb2lsb32(&pmeta->CROP_POS_17) & 0xffff);                      //byte[132]
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "CROP_POSX_18: %d, %d\n", msb2lsb32(&pmeta->CROP_POS_18) >> 16, msb2lsb32(&pmeta->CROP_POS_18) & 0xffff);                      //byte[136]
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "YLine_Gap: %.d      \n",pmeta->YLine_Gap); 
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "Start_YLine_No: %d      \n",pmeta->Start_YLine_No); 
        print_f(mlogPool, "META", mlog);
        pch = (char *)&pmeta->YLines_Recorded;
        sprintf_f(mlog, "YLines_Recorded: %d      \n",(pch[0] << 8) | pch[1]); 
        print_f(mlogPool, "META", mlog);
    }

    if (funcbits & ASPMETA_FUNC_IMGLEN) {
        sprintf_f(mlog, "__ASPMETA_FUNC_IMGLEN__(0x%x & 0x%x = 0x%x)\n", funcbits, ASPMETA_FUNC_IMGLEN, (funcbits & ASPMETA_FUNC_IMGLEN));
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "SCAN_IMAGE_LEN: %d\n", msb2lsb32(&pmeta->SCAN_IMAGE_LEN));                      //byte[124]        
        print_f(mlogPool, "META", mlog);
    }

    if (funcbits & ASPMETA_FUNC_SDFREE) {      
        sprintf_f(mlog, "__ASPMETA_FUNC_SDFREE__(0x%x & 0x%x = 0x%x)\n", funcbits, ASPMETA_FUNC_SDFREE, (funcbits & ASPMETA_FUNC_SDFREE));
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "FREE_SECTOR_ADD: %d\n", msb2lsb32(&pmeta->FREE_SECTOR_ADD));                      //byte[128]            
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "FREE_SECTOR_LEN: %d\n", msb2lsb32(&pmeta->FREE_SECTOR_LEN));                      //byte[132]        
        print_f(mlogPool, "META", mlog);
    }

    if (funcbits & ASPMETA_FUNC_SDUSED) {
        sprintf_f(mlog, "__ASPMETA_FUNC_SDUSED__(0x%x & 0x%x = 0x%x)\n", funcbits, ASPMETA_FUNC_SDUSED, (funcbits & ASPMETA_FUNC_SDUSED));
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "USED_SECTOR_ADD: %d\n", msb2lsb32(&pmeta->USED_SECTOR_ADD));                      //byte[136]            
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "USED_SECTOR_LEN: %d\n", msb2lsb32(&pmeta->USED_SECTOR_LEN));                      //byte[140]        
        print_f(mlogPool, "META", mlog);
    }

    if (funcbits & ASPMETA_FUNC_SDRD) {
        sprintf_f(mlog, "__ASPMETA_FUNC_SDRD__(0x%x & 0x%x = 0x%x)\n", funcbits, ASPMETA_FUNC_SDRD, (funcbits & ASPMETA_FUNC_SDRD));
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "SD_RW_SECTOR_ADD: %d\n", msb2lsb32(&pmeta->SD_RW_SECTOR_ADD));                      //byte[144]            
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "SD_RW_SECTOR_LEN: %d\n", msb2lsb32(&pmeta->SD_RW_SECTOR_LEN));                      //byte[148]        
        print_f(mlogPool, "META", mlog);
    }

    if (funcbits & ASPMETA_FUNC_SDWT) {
        sprintf_f(mlog, "__ASPMETA_FUNC_SDWT__(0x%x & 0x%x = 0x%x)\n", funcbits, ASPMETA_FUNC_SDWT, (funcbits & ASPMETA_FUNC_SDWT));
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "SD_RW_SECTOR_ADD: %d\n", msb2lsb32(&pmeta->SD_RW_SECTOR_ADD));                      //byte[136]            
        print_f(mlogPool, "META", mlog);
        sprintf_f(mlog, "SD_RW_SECTOR_LEN: %d\n", msb2lsb32(&pmeta->SD_RW_SECTOR_LEN));                      //byte[140]        
        print_f(mlogPool, "META", mlog);
    }
    #else
    if (msb2lsb16(&pmeta->BKNA_NUM)) {
        num = msb2lsb16(&pmeta->BKNA_NUM);
        sprintf_f(mlog, "BKNA_NUM: %d\n", num);                      //byte[140]
        print_f(mlogPool, "META", mlog);

        for (ix=0; ix < num; ix++) {
            sprintf_f(mlog, "BKNA_ITEM[%d].bknax: %d\n", ix, msb2lsb16(&pmeta->BKNA_ITEM[ix].bknax));
            print_f(mlogPool, "META", mlog);

            sprintf_f(mlog, "BKNA_ITEM[%d].bknay: %d\n", ix, msb2lsb16(&pmeta->BKNA_ITEM[ix].bknaY));
            print_f(mlogPool, "META", mlog);

            sprintf_f(mlog, "BKNA_ITEM[%d].bknaw: %d\n", ix, msb2lsb16(&pmeta->BKNA_ITEM[ix].bknaw));
            print_f(mlogPool, "META", mlog);

            sprintf_f(mlog, "BKNA_ITEM[%d].bknah: %d\n", ix, msb2lsb16(&pmeta->BKNA_ITEM[ix].bknah));
            print_f(mlogPool, "META", mlog);

            sprintf_f(mlog, "BKNA_ITEM[%d].bknaside: %d\n", ix, pmeta->BKNA_ITEM[ix].bknaside);
            print_f(mlogPool, "META", mlog);

            sprintf_f(mlog, "BKNA_ITEM[%d].bknalayer: %d\n", ix, pmeta->BKNA_ITEM[ix].bknalayer);
            print_f(mlogPool, "META", mlog);
        }
    }
    #endif

    sprintf_f(mlog, "********************************************\n");
    print_f(mlogPool, "META", mlog);
    return 0;
}

#if 0
    ASPMETA_FUNC_NONE = 0,
    ASPMETA_FUNC_CONF = 0x1,       /* 0b00000001 */
    ASPMETA_FUNC_CROP = 0x2,       /* 0b00000010 */
    ASPMETA_FUNC_IMGLEN = 0x4,   /* 0b00000100 */
    ASPMETA_FUNC_SDFREE = 0x8,   /* 0b00001000 */
    ASPMETA_FUNC_SDUSED = 0x16, /* 0b00010000 */
    ASPMETA_FUNC_SDRD = 0x32,     /* 0b00100000 */
    ASPMETA_FUNC_SDWT = 0x64,    /* 0b01000000 */

    ASPOP_FILE_FORMAT,
    ASPOP_COLOR_MODE,
    ASPOP_COMPRES_RATE,
    ASPOP_SCAN_SINGLE,
    ASPOP_SCAN_DOUBLE,
    ASPOP_ACTION,
    ASPOP_RESOLUTION,
    ASPOP_SCAN_GRAVITY,
    ASPOP_MAX_WIDTH,
    ASPOP_WIDTH_ADJ_H,
    ASPOP_WIDTH_ADJ_L,
    ASPOP_SCAN_LENS_H,
    ASPOP_SCAN_LENS_L,
    ASPOP_INTER_IMG,     
    ASPOP_AFEIC_SEL,     
    ASPOP_EXT_PULSE,     /* 15 */

#endif

static int aspMetaClear(struct mainRes_s *mrs, struct procRes_s *rs, int out) 
{
    struct aspMetaData_s *pmeta;
    
    if ((!mrs) && (!rs)) return -1;
    
    if (mrs) {
        if (out) {
            pmeta = &mrs->metaout;
        } else {
            pmeta = &mrs->metain;        
        }
    } else {
        if (out) {
            pmeta = rs->pmetaout;
        } else {
            pmeta = rs->pmetain;
        }
    }

    memset(pmeta, 0, sizeof(struct aspMetaData_s));
    msync(pmeta, sizeof(struct aspMetaData_s), MS_SYNC);
    
    return 0;
}

#define LOG_METABUILD_EN (0)
static int aspMetaBuild(unsigned int funcbits, struct mainRes_s *mrs, struct procRes_s *rs) 
{
    uint32_t tbits=0;
    int opSt=0, opEd=0;
    int istr=0, iend=0, idx=0, ret=0;
    struct aspMetaData_s *pmeta;
    struct aspConfig_s *pct=0, *pdt=0;
    char *pvdst=0, *pvend=0;
    uint32_t val=0, b32=0, secStr=0, secLen=0;
    
    if ((!mrs) && (!rs)) return -1;
    
    if (mrs) {
        pmeta = &mrs->metaout;
        pct = mrs->configTable;
    } else {
        pmeta = rs->pmetaout;
        pct = rs->pcfgTable;
    }

    msync(pct, ASPOP_CODE_MAX * sizeof(struct aspConfig_s), MS_SYNC);

    if (funcbits == ASPMETA_FUNC_NONE) return -2;

    if (funcbits & ASPMETA_FUNC_CONF) {
        opSt = OP_FFORMAT;
        opEd = OP_SUPBACK;
        
        istr = ASPOP_FILE_FORMAT;
        iend = ASPOP_SUP_SAVE;
        
        pvdst = &pmeta->FILE_FORMAT;
        pvend = &pmeta->SUP_WRITEBK;

        for (idx = istr; idx <= iend; idx++) {
            if ((pct[idx].opStatus & ASPOP_STA_CON) && (pct[idx].opCode == opSt)) {
                *pvdst = pct[idx].opValue & 0xff;
                #if LOG_METABUILD_EN
                printf("[meta] 0x%.2x = 0x%.2x (0x%.2x)\n", pct[idx].opCode, pct[idx].opValue, pct[idx].opStatus);
                #endif

                pvdst++;
                opSt++;
            }

            if (pvend < pvdst) {
                 break;
            }
            
            if (opEd < opSt) {
                 break;
            }
        }

        opSt = OP_FUNCTEST_00;
        opEd = OP_FUNCTEST_15;

        istr = ASPOP_FUNTEST_00;
        iend = ASPOP_FUNTEST_15;
        
        pvdst = &pmeta->OP_FUNC_00;
        pvend = &pmeta->OP_FUNC_15;

        for (idx = istr; idx <= iend; idx++) {
            if ((pct[idx].opStatus & ASPOP_STA_CON) && (pct[idx].opCode == opSt)) {
                *pvdst = pct[idx].opValue & 0xff;
                #if LOG_METABUILD_EN
                printf("[meta] 0x%.2x = 0x%.2x (0x%.2x)\n", pct[idx].opCode, pct[idx].opValue, pct[idx].opStatus);
                #endif

                pvdst++;
                opSt++;
            }

            if (pvend < pvdst) {
                 break;
            }
            if (opEd < opSt) {
                 break;
            }
        }

        opSt = OP_BLEEDTHROU_ADJUST;
        opEd = OP_SKIP_LENGTH;

        istr = ASPOP_BLEEDTHROU_ADJUST;
        iend = ASPOP_SKIP_LENGTH;
        
        pvdst = &pmeta->BLEEDTHROU_ADJUST;
        pvend = &pmeta->SKIP_LENGTH;

        for (idx = istr; idx <= iend; idx++) {
            if ((pct[idx].opStatus & ASPOP_STA_CON) && (pct[idx].opCode == opSt)) {
                *pvdst = pct[idx].opValue & 0xff;
                #if LOG_METABUILD_EN
                printf("[meta] 0x%.2x = 0x%.2x (0x%.2x)\n", pct[idx].opCode, pct[idx].opValue, pct[idx].opStatus);
                #endif

                pvdst++;
                opSt++;
            }

            if (pvend < pvdst) {
                 break;
            }
            if (opEd < opSt) {
                 break;
            }
        }
    }
    
    if (funcbits & ASPMETA_FUNC_CROP) {
    
    }

    if (funcbits & ASPMETA_FUNC_IMGLEN) {
    
    }

    if (funcbits & ASPMETA_FUNC_SDFREE) {
    
    }

    if (funcbits & ASPMETA_FUNC_SDUSED) {
    
    }

    if (funcbits & ASPMETA_FUNC_SDRD) {

        b32 = 0;
        ret += cfgTableGet(pct, ASPOP_SDFAT_STR01, &val);
        b32 |= val << 24;

        ret += cfgTableGet(pct, ASPOP_SDFAT_STR02, &val);
        b32 |= val << 16;

       ret += cfgTableGet(pct, ASPOP_SDFAT_STR03, &val);
       b32 |= val << 8;

        ret += cfgTableGet(pct, ASPOP_SDFAT_STR04, &val);
        b32 |= val ;
        secStr = b32;

        b32 = 0;
        ret += cfgTableGet(pct, ASPOP_SDFAT_LEN01, &val);
        b32 |= val << 24;

        ret += cfgTableGet(pct, ASPOP_SDFAT_LEN02, &val);
        b32 |= val << 16;

       ret += cfgTableGet(pct, ASPOP_SDFAT_LEN03, &val);
       b32 |= val << 8;

        ret += cfgTableGet(pct, ASPOP_SDFAT_LEN04, &val);
        b32 |= val;
        secLen = b32;

        lsb2Msb32(&pmeta->SD_RW_SECTOR_ADD, secStr);
        lsb2Msb32(&pmeta->SD_RW_SECTOR_LEN, secLen);
    }

    if (funcbits & ASPMETA_FUNC_SDWT) {
    
        b32 = 0;
        ret += cfgTableGet(pct, ASPOP_SDFAT_STR01, &val);
        b32 |= val << 24;

        ret += cfgTableGet(pct, ASPOP_SDFAT_STR02, &val);
        b32 |= val << 16;

       ret += cfgTableGet(pct, ASPOP_SDFAT_STR03, &val);
       b32 |= val << 8;

        ret += cfgTableGet(pct, ASPOP_SDFAT_STR04, &val);
        b32 |= val ;
        secStr = b32;

        b32 = 0;
        ret += cfgTableGet(pct, ASPOP_SDFAT_LEN01, &val);
        b32 |= val << 24;

        ret += cfgTableGet(pct, ASPOP_SDFAT_LEN02, &val);
        b32 |= val << 16;

       ret += cfgTableGet(pct, ASPOP_SDFAT_LEN03, &val);
       b32 |= val << 8;

        ret += cfgTableGet(pct, ASPOP_SDFAT_LEN04, &val);
        b32 |= val;
        secLen = b32;

        lsb2Msb32(&pmeta->SD_RW_SECTOR_ADD, secStr);
        lsb2Msb32(&pmeta->SD_RW_SECTOR_LEN, secLen);
    
    }

    pmeta->ASP_MAGIC[0] = 0x20;
    pmeta->ASP_MAGIC[1] = 0x14;
    
    //pmeta->FUNC_BITS |= funcbits;
    tbits = msb2lsb32(&pmeta->FUNC_BITS);
    tbits |= funcbits;
    lsb2Msb32(&pmeta->FUNC_BITS, tbits);

    msync(pmeta, sizeof(struct aspMetaData_s), MS_SYNC);
    
    return 0;
}

static int aspMetaGetTagPosRange(struct aspMetaData_s *meta, int *pos, int *range, char side)
{
    int pagenum=0, ix=0;
    struct t_BKArea *pbka=0;

    pagenum = msb2lsb16(&meta->BKNA_NUM);

    for (ix=0; ix < pagenum; ix++) {
        pbka = &meta->BKNA_ITEM[ix];
        if ((pbka->bknalayer == 252) && (pbka->bknaside == side)) {

            pos[0] = msb2lsb16(&pbka->bknax);
            pos[1] = msb2lsb16(&pbka->bknaY);
            range[0] = msb2lsb16(&pbka->bknaw);
            range[1] = msb2lsb16(&pbka->bknah);
            
            return ix;
        }
    }

    pos[0] = -1;
    pos[1] = -1;
    range[0] = -1;
    range[1] = -1;
    
    return -1;
}

static int aspMetaGetTagRGBdiff(struct aspMetaData_s *meta, char *rgb, char side)
{
    int pagenum=0, ix=0;
    struct t_BKArea *pbka=0;

    pagenum = msb2lsb16(&meta->BKNA_NUM);

    for (ix=0; ix < pagenum; ix++) {
        pbka = &meta->BKNA_ITEM[ix];
        if ((pbka->bknalayer == 253) && (pbka->bknaside == side)) {

            rgb[0] = msb2lsb16(&pbka->bknax);
            rgb[1] = msb2lsb16(&pbka->bknaY);
            rgb[2] = msb2lsb16(&pbka->bknaw);

            return ix;
        }
    }

    rgb[0] = -1;
    rgb[1] = -1;
    rgb[2] = -1;
            
    return -1;
}

static int aspMetaGetTagRGB(struct aspMetaData_s *meta, char *rgb, char side)
{
    int pagenum=0, ix=0;
    struct t_BKArea *pbka=0;

    pagenum = msb2lsb16(&meta->BKNA_NUM);

    for (ix=0; ix < pagenum; ix++) {
        pbka = &meta->BKNA_ITEM[ix];
        if ((pbka->bknalayer == 254) && (pbka->bknaside == side)) {

            rgb[0] = msb2lsb16(&pbka->bknax);
            rgb[1] = msb2lsb16(&pbka->bknaY);
            rgb[2] = msb2lsb16(&pbka->bknaw);

            return ix;
        }
    }

    rgb[0] = -1;
    rgb[1] = -2;
    rgb[2] = -3;
    
    return -1;
}


static int aspMetaGetSrhCount(struct aspMetaData_s *meta, int *wsrh, int *hsrh, char side)
{
    int pagenum=0, ix=0;
    struct t_BKArea *pbka=0;

    pagenum = msb2lsb16(&meta->BKNA_NUM);

    for (ix=0; ix < pagenum; ix++) {
        pbka = &meta->BKNA_ITEM[ix];
        if ((pbka->bknalayer == 255) && (pbka->bknaside == side)) {
            *wsrh = msb2lsb16(&pbka->bknax);
            *hsrh = msb2lsb16(&pbka->bknaY);
            return ix;
        }
    }
    
    return -1;
}

static int aspMetaGetWH(struct aspMetaData_s *meta, int *wh, int *cnt, char side)
{
    int pagenum=0, ix=0;
    struct t_BKArea *pbka=0;

    pagenum = msb2lsb16(&meta->BKNA_NUM);

    for (ix=0; ix < pagenum; ix++) {
        pbka = &meta->BKNA_ITEM[ix];
        if ((pbka->bknalayer == 255) && (pbka->bknaside == side)) {
            cnt[0] = msb2lsb16(&pbka->bknax);
            cnt[1] = msb2lsb16(&pbka->bknaY);
            wh[0] = msb2lsb16(&pbka->bknaw);
            wh[1] = msb2lsb16(&pbka->bknah);
            return ix;
        }
    }

    cnt[0] = -1;
    cnt[1] = -1;
    wh[0] = -1;
    wh[1] = -1;
            
    return -1;
}

static int aspMetaGetPagePos(struct aspMetaData_s *meta, CFLOAT *pos, int idx)
{
    int pagenum=0;
    struct t_BKArea *pbka=0;

    pagenum = msb2lsb16(&meta->BKNA_NUM);

    pos[0] = -1;
    pos[1] = -1;
    pos[2] = -1;
    pos[3] = -1;

    if (idx > pagenum) return -1;

    pbka = &meta->BKNA_ITEM[idx];
    if (pbka->bknalayer & 0xf0) {
        return -2;
    }

    pos[0] = msb2lsb16(&pbka->bknax);
    pos[1] = msb2lsb16(&pbka->bknaY);
    pos[2] = msb2lsb16(&pbka->bknaw);
    pos[3] = msb2lsb16(&pbka->bknah);

    return 0;
}

static int aspMetaGetPages(struct aspMetaData_s *meta, int *sides, int *layers, int num)
{
    int pagenum=0, ix=0, cnta=0, cntb=0;
    struct t_BKArea *pbka=0;

    pagenum = msb2lsb16(&meta->BKNA_NUM);

    if (pagenum != num) return -1;

    for (ix=0; ix < pagenum; ix++) {
        pbka = &meta->BKNA_ITEM[ix];
        if (pbka->bknalayer & 0xf0) {
            continue;
        }

        if (pbka->bknaside == 0) {
            sides[cnta*2+0] = ix;
            layers[cnta*2+0] = pbka->bknalayer;
            cnta ++;
        } else {
            sides[cntb*2+1] = ix;
            layers[cntb*2+1] = pbka->bknalayer;
            cntb ++;
        }
    }

    if (cnta > cntb) {
        return cnta;
    } else {
        return cntb;
    }
}

static int aspMetaRelease(unsigned int funcbits, struct mainRes_s *mrs, struct procRes_s *rs) 
{
    int i=0, act=0;
    int opSt=0, opEd=0;
    int istr=0, iend=0, idx=0, ret=0;
    char *pvdst=0, *pvend=0;
    struct intMbs32_s *pt=0;
    struct aspMetaData_s *pmeta;
    struct aspMetaMass_s *pmass;
    struct aspConfig_s *pct=0, *pdt=0;
    unsigned char linGap, linStart;
    unsigned short linRec;
    unsigned int val;
    char *pch=0;

    if ((!mrs) && (!rs)) return -1;
    
    if (mrs) {
        pmeta = &mrs->metain;
        pct = mrs->configTable;
        pmass = &mrs->metaMass;
        #if LOG_METABUILD_EN
        printf("[aspMetaRelease] from mrs!!funcbits: 0x%x \n", funcbits);
        #endif
    } else {
        pmeta = rs->pmetain;
        pct = rs->pcfgTable;
        pmass = rs->pmetaMass;
        #if LOG_METABUILD_EN
        printf("[aspMetaRelease] from rs!!funcbits: 0x%x \n", funcbits);
        #endif
    }
    
    msync(pmeta, sizeof(struct aspMetaData_s), MS_SYNC);

    if ((pmeta->ASP_MAGIC[0] != 0x20) || (pmeta->ASP_MAGIC[1] != 0x14)) {
        return -2;
    }
    
    if (funcbits == ASPMETA_FUNC_NONE) return -3;

    #if USB_META
    if (funcbits & ASPMETA_FUNC_CONF) {
        opSt = OP_FFORMAT;
        opEd = OP_SUPBACK;
        
        istr = ASPOP_FILE_FORMAT;
        iend = ASPOP_SUP_SAVE;
        
        pvdst = &pmeta->FILE_FORMAT;
        pvend = &pmeta->SUP_WRITEBK;

        for (idx = istr; idx <= iend; idx++) {
            if (pct[idx].opCode == opSt) {
            
                pct[idx].opStatus |= ASPOP_STA_CON;
                pct[idx].opValue = (*pvdst) & 0xff;
                #if LOG_METABUILD_EN
                printf("[meta] 0x%.2x = 0x%.2x (0x%.2x)\n", pct[idx].opCode, pct[idx].opValue, pct[idx].opStatus);
                #endif

                pvdst++;
                opSt++;
            }
            else {
                #if LOG_METABUILD_EN
                printf("[meta] 0x%.2x (!0x%.2x) = 0x%.2x (0x%.2x)\n", pct[idx].opCode, opSt, pct[idx].opValue, pct[idx].opStatus);
                #endif
            }

            if (pvend < pvdst) {
                 break;
            }
            
            if (opEd < opSt) {
                 break;
            }
        }

        opSt = OP_FUNCTEST_00;
        opEd = OP_FUNCTEST_15;

        istr = ASPOP_FUNTEST_00;
        iend = ASPOP_FUNTEST_15;
        
        pvdst = &pmeta->OP_FUNC_00;
        pvend = &pmeta->OP_FUNC_15;

        for (idx = istr; idx <= iend; idx++) {
            if (pct[idx].opCode == opSt) {
            
                pct[idx].opStatus |= ASPOP_STA_CON;
                pct[idx].opValue = (*pvdst) & 0xff;
                #if LOG_METABUILD_EN
                printf("[meta] 0x%.2x = 0x%.2x (0x%.2x)\n", pct[idx].opCode, pct[idx].opValue, pct[idx].opStatus);
                #endif

                pvdst++;
                opSt++;
            }
            else {
                #if 1//LOG_METABUILD_EN
                printf("[meta] 0x%.2x (!0x%.2x) = 0x%.2x (0x%.2x)\n", pct[idx].opCode, opSt, pct[idx].opValue, pct[idx].opStatus);
                #endif
            }

            if (pvend < pvdst) {
                 break;
            }
            if (opEd < opSt) {
                 break;
            }
        }

        opSt = OP_BLEEDTHROU_ADJUST;
        opEd = OP_SKIP_LENGTH;

        istr = ASPOP_BLEEDTHROU_ADJUST;
        iend = ASPOP_SKIP_LENGTH;
        
        pvdst = &pmeta->BLEEDTHROU_ADJUST;
        pvend = &pmeta->SKIP_LENGTH;

        for (idx = istr; idx <= iend; idx++) {
            if (pct[idx].opCode == opSt) {
                pct[idx].opStatus |= ASPOP_STA_CON;
                pct[idx].opValue = (*pvdst) & 0xff;
                #if LOG_METABUILD_EN
                printf("[meta] 0x%.2x = 0x%.2x (0x%.2x)\n", pct[idx].opCode, pct[idx].opValue, pct[idx].opStatus);
                #endif

                pvdst++;
                opSt++;
            }
            else {
                #if 1//LOG_METABUILD_EN
                printf("[meta] 0x%.2x (!0x%.2x) = 0x%.2x (0x%.2x)\n", pct[idx].opCode, opSt, pct[idx].opValue, pct[idx].opStatus);
                #endif
            }

            if (pvend < pvdst) {
                 break;
            }
            if (opEd < opSt) {
                 break;
            }
        }
    }
    #endif
    
    if (funcbits & ASPMETA_FUNC_CROP) {
        pt = &(pmeta->CROP_POS_1);

        for (i = ASPOP_CROP_01; i <= ASPOP_CROP_06; i++) {
            pct[i].opValue = msb2lsb32(pt);
            pct[i].opStatus = ASPOP_STA_UPD;
            pt++;
        }

        for (i = ASPOP_CROP_07; i <= ASPOP_CROP_18; i++) {
            pct[i].opValue = msb2lsb32(pt);
            pct[i].opStatus = ASPOP_STA_UPD;
            pt++;
        }

        linGap = pmeta->YLine_Gap;
        linStart = pmeta->Start_YLine_No;
        
        pch = (char *)&(pmeta->YLines_Recorded);
        
        val = pch[0] << 8 | pch[1];
        linRec = val;

        act |= ASPMETA_FUNC_CROP;
        
        if (linRec) {
            pmass->massGap = linGap;
            pmass->massStart = linStart;
            pmass->massRecd = linRec;

            cfgTableSet(pct, ASPOP_XCROP_GAT, linGap);
            cfgTableSet(pct, ASPOP_XCROP_LINSTR, linStart);
            cfgTableSet(pct, ASPOP_XCROP_LINREC, linRec);
            
        } else {
            pmass->massGap = 0;
            pmass->massStart = 0;
            pmass->massRecd = 0;

            cfgTableSet(pct, ASPOP_XCROP_GAT, 0);
            cfgTableSet(pct, ASPOP_XCROP_LINSTR, 0);
            cfgTableSet(pct, ASPOP_XCROP_LINREC, 0);
        }
    }

    if (funcbits & ASPMETA_FUNC_IMGLEN) {
        pt = &(pmeta->SCAN_IMAGE_LEN);    

        pct[ASPOP_IMG_LEN].opValue = msb2lsb32(pt);
        pct[ASPOP_IMG_LEN].opStatus = ASPOP_STA_UPD;
    }

    if (funcbits & ASPMETA_FUNC_SDFREE) {
    
    }

    if (funcbits & ASPMETA_FUNC_SDUSED) {
    
    }

    if (funcbits & ASPMETA_FUNC_SDRD) {
    
    }

    if (funcbits & ASPMETA_FUNC_SDWT) {
    
    }
    
    msync(pct, ASPOP_CODE_MAX * sizeof(struct aspConfig_s), MS_SYNC);

    return act;
}

static int aspMetaReleaseDuo(unsigned int funcbits, struct mainRes_s *mrs, struct procRes_s *rs) 
{
    int i=0, act=0;
    struct intMbs32_s *pt=0;
    struct aspMetaData_s *pmetaDuo;
    struct aspMetaMass_s *pmassDuo;
    struct aspConfig_s *pct=0, *pdt=0;
    unsigned char linGap, linStart;
    unsigned short linRec;
    unsigned int val;
    char *pch=0;

    if ((!mrs) && (!rs)) return -1;
    
    if (mrs) {
        pmetaDuo= &mrs->metainDuo;
        pct = mrs->configTable;
        pmassDuo= &mrs->metaMassDuo;
    } else {
        pmetaDuo= rs->pmetainduo;
        pct = rs->pcfgTable;
        pmassDuo= rs->pmetaMassduo;
    }
    
    msync(pmetaDuo, sizeof(struct aspMetaData_s), MS_SYNC);

    if ((pmetaDuo->ASP_MAGIC[0] != 0x20) || (pmetaDuo->ASP_MAGIC[1] != 0x14)) {
        return -2;
    }
    
    if (funcbits == ASPMETA_FUNC_NONE) return -3;

    if (funcbits & ASPMETA_FUNC_CONF) {
    
    }
    
    if (funcbits & ASPMETA_FUNC_CROP) {
        pt = &(pmetaDuo->CROP_POS_1);

        for (i = ASPOP_CROP_01_DUO; i <= ASPOP_CROP_06_DUO; i++) {
            pct[i].opValue = msb2lsb32(pt);
            pct[i].opStatus = ASPOP_STA_UPD;
            pt++;
        }

        for (i = ASPOP_CROP_07_DUO; i <= ASPOP_CROP_18_DUO; i++) {
            pct[i].opValue = msb2lsb32(pt);
            pct[i].opStatus = ASPOP_STA_UPD;
            pt++;
        }

        linGap = pmetaDuo->YLine_Gap;
        linStart = pmetaDuo->Start_YLine_No;
        
        pch = (char *)&(pmetaDuo->YLines_Recorded);
        
        val = pch[0] << 8 | pch[1];
        linRec = val;

        act |= ASPMETA_FUNC_CROP;
            
        if (linRec) {
            pmassDuo->massGap = linGap;
            pmassDuo->massStart = linStart;
            pmassDuo->massRecd = linRec;

            cfgTableSet(pct, ASPOP_XCROP_GAT_DUO, linGap);
            cfgTableSet(pct, ASPOP_XCROP_LINSTR_DUO, linStart);
            cfgTableSet(pct, ASPOP_XCROP_LINREC_DUO, linRec);
            
        } else {
            pmassDuo->massGap = 0;
            pmassDuo->massStart = 0;
            pmassDuo->massRecd = 0;

            cfgTableSet(pct, ASPOP_XCROP_GAT_DUO, 0);
            cfgTableSet(pct, ASPOP_XCROP_LINSTR_DUO, 0);
            cfgTableSet(pct, ASPOP_XCROP_LINREC_DUO, 0);
        }
    }

    if (funcbits & ASPMETA_FUNC_IMGLEN) {
        pt = &(pmetaDuo->SCAN_IMAGE_LEN);    

        pct[ASPOP_IMG_LEN_DUO].opValue = msb2lsb32(pt);
        pct[ASPOP_IMG_LEN_DUO].opStatus = ASPOP_STA_UPD;
    }

    if (funcbits & ASPMETA_FUNC_SDFREE) {
    
    }

    if (funcbits & ASPMETA_FUNC_SDUSED) {
    
    }

    if (funcbits & ASPMETA_FUNC_SDRD) {
    
    }

    if (funcbits & ASPMETA_FUNC_SDWT) {
    
    }
    
    msync(pct, ASPOP_CODE_MAX * sizeof(struct aspConfig_s), MS_SYNC);

    return act;
}

static int aspMetafs145GetlenviaUsbDuo(struct mainRes_s *mrs) 
{
    struct aspMetaDataviaUSB_s *pmetausb=0;
    int val=0;

    if (!mrs) return -1;
    
    pmetausb = &mrs->metaUsbDuofs145;
    
    msync(pmetausb, sizeof(struct aspMetaDataviaUSB_s), MS_SYNC);
    
    if ((pmetausb->ASP_MAGIC_ASPC[0] != 'A') || (pmetausb->ASP_MAGIC_ASPC[1] != 'S') || 
        (pmetausb->ASP_MAGIC_ASPC[2] != 'P') || (pmetausb->ASP_MAGIC_ASPC[3] != 'C')) {
        return -3;
    }

    val = pmetausb->IMG_HIGH[0] | (pmetausb->IMG_HIGH[1] << 8);

    return val;
}

static int aspMetafs145GetlenviaUsb(struct mainRes_s *mrs)
{
    struct aspMetaDataviaUSB_s *pmetausb=0;
    int val=0;

    if (!mrs) return -1;
    
    pmetausb = &mrs->metaUsbfs145;
    
    msync(pmetausb, sizeof(struct aspMetaDataviaUSB_s), MS_SYNC);
    
    if ((pmetausb->ASP_MAGIC_ASPC[0] != 'A') || (pmetausb->ASP_MAGIC_ASPC[1] != 'S') || 
        (pmetausb->ASP_MAGIC_ASPC[2] != 'P') || (pmetausb->ASP_MAGIC_ASPC[3] != 'C')) {
        return -3;
    }

    val = pmetausb->IMG_HIGH[0] | (pmetausb->IMG_HIGH[1] << 8);

    return val;
}

static int aspMetaReleaseviaUsbdlBmpUpd(struct aspMetaDataviaUSB_s *pmetausb, int updw, int updh, int sid, int aid, int lyn, int clrocr) 
{
    struct intMbs32_s *pt=0;
    unsigned int val=0;

    
    if (!pmetausb) {
        return -1;
    }

    pmetausb->IMG_HIGH[0] = updh & 0xff;
    pmetausb->IMG_HIGH[1] = (updh >> 8) & 0xff;
    
    pmetausb->IMG_WIDTH[0] = updw & 0xff;
    pmetausb->IMG_WIDTH[1] = (updw >> 8) & 0xff;

    pmetausb->BKNote_Slice_idx = sid;
    pmetausb->BKNote_Block_idx = aid;

    if (lyn) {
        pmetausb->BKNote_Total_Layers = lyn;
    }

    if (clrocr) {
        pmetausb->OCR_strlen = 0;
    }
    
    msync(pmetausb, sizeof(struct aspMetaDataviaUSB_s), MS_SYNC);
    
    return 0;
}

static int aspMetaReleaseviaUsbdlBmp(struct mainRes_s *mrs, struct procRes_s *rs, char *pdata, int dmax) 
{
    int i=0, act=0;
    int opSt=0, opEd=0;
    int istr=0, iend=0, idx=0, ret=0;
    char *pvdst=0, *pvend=0;
    struct intMbs32_s *pt=0;
    struct aspMetaDataviaUSB_s *pmetausb=0, *pmetainput=0;
    struct aspMetaMass_s *pmass=0;
    struct aspConfig_s *pct=0, *pdt=0;
    unsigned char linGap=0, linStart=0;
    unsigned short linRec=0, linLength=0;
    unsigned int val=0;
    char *pch=0;

    if ((!mrs) && (!rs)) return -1;
    if ((!pdata) || (!dmax)) return -2;
    
    if (mrs) {
        pmetausb = &mrs->metaUsb;
        pct = mrs->configTable;
        pmass = &mrs->metaMass;
    } else {
        pmetausb = rs->pmetausb;
        pct = rs->pcfgTable;
        pmass = rs->pmetaMass;
    }
    
    msync(pmetausb, sizeof(struct aspMetaDataviaUSB_s), MS_SYNC);
    
    if ((pmetausb->ASP_MAGIC_ASPC[0] != 'A') || (pmetausb->ASP_MAGIC_ASPC[1] != 'S') || 
        (pmetausb->ASP_MAGIC_ASPC[2] != 'P') || (pmetausb->ASP_MAGIC_ASPC[3] != 'C')) {
        return -31;
    }

    pt = &(pmetausb->CROP_POS_1);
    for (i = ASPOP_CROP_01; i <= ASPOP_CROP_06; i++) {
        pct[i].opValue = msb2lsb32(pt);
        pct[i].opStatus = ASPOP_STA_UPD;

        //printf("%d. 0x%.8x \n", i, pct[i].opValue);
        
        pt++;
    }

    for (i = ASPOP_CROP_07; i <= ASPOP_CROP_18; i++) {
        pct[i].opValue = msb2lsb32(pt);
        pct[i].opStatus = ASPOP_STA_UPD;

        //printf("%d. 0x%.8x \n", i, pct[i].opValue);
        
        pt++;
    }

    pct[ASPOP_IMG_LEN].opValue = pmetausb->IMG_HIGH[0] | (pmetausb->IMG_HIGH[1] << 8);
    pct[ASPOP_IMG_LEN].opStatus = ASPOP_STA_UPD;    

    pct[ASPOP_SCAN_WIDTH].opValue = pmetausb->IMG_WIDTH[0] | (pmetausb->IMG_WIDTH[1] << 8);
    pct[ASPOP_SCAN_WIDTH].opStatus = ASPOP_STA_UPD;        

    pct[ASPOP_SCAN_SIDE].opValue = pmetausb->PRI_O_SEC;
    pct[ASPOP_SCAN_SIDE].opStatus = ASPOP_STA_UPD;        

    linGap = pmetausb->YLine_Gap;
    linStart = pmetausb->Start_YLine_No;

    pch = (char *)&(pmetausb->YLines_Recorded);
    val = pch[0] << 8 | pch[1];
    linRec = val;
    
    // shmem_dump((char *)&pmetausb->CROP_POS_1, 128);
    //printf(" gap: %d, startLin: %d yline: %d \n", linGap, linStart, linRec);

    if ((pdata[0] == 'Y') && (pdata[1] == 'L')) {
        pch = &pdata[2];
        val = pch[0] << 8 | pch[1];
        linLength = val;
    }
    
    if (linRec) {
        pmass->massGap = linGap;
        pmass->massStart = linStart;
        pmass->massRecd = linRec;
        pmass->massUsed = linLength;

        cfgTableSet(pct, ASPOP_XCROP_GAT, linGap);
        cfgTableSet(pct, ASPOP_XCROP_LINSTR, linStart);
        cfgTableSet(pct, ASPOP_XCROP_LINREC, linRec);
            
    }
    else if (linLength) {
        linRec = linLength / 4;
        pmass->massGap = linGap;
        pmass->massStart = linStart;
        pmass->massRecd = linRec;
        pmass->massUsed = linLength;

        cfgTableSet(pct, ASPOP_XCROP_GAT, linGap);
        cfgTableSet(pct, ASPOP_XCROP_LINSTR, linStart);
        cfgTableSet(pct, ASPOP_XCROP_LINREC, linRec);
            
    }
    else {
        pmass->massGap = 0;
        pmass->massStart = 0;
        pmass->massRecd = 0;
        pmass->massUsed = 0;
        
        cfgTableSet(pct, ASPOP_XCROP_GAT, 0);
        cfgTableSet(pct, ASPOP_XCROP_LINSTR, 0);
        cfgTableSet(pct, ASPOP_XCROP_LINREC, 0);
    }

    if (linLength) {
        pt = &(pmetausb->CROP_POS_F1);
        for (i = ASPOP_USBCROP_FP01; i <= ASPOP_USBCROP_FP04; i++) {
            pct[i].opValue = msb2lsb32(pt);
            pct[i].opStatus = ASPOP_STA_UPD;

            //printf("[META] F%d. = (%d, %d) \n", i - ASPOP_USBCROP_FP01 + 1, (pct[i].opValue >> 16) & 0xffff, (pct[i].opValue >> 0) & 0xffff);
        
            pt++;
        }
    }
    
    msync(pct, ASPOP_CODE_MAX * sizeof(struct aspConfig_s), MS_SYNC);

    return 0;
}

static int aspMetaReleaseviaUsb(struct mainRes_s *mrs, struct procRes_s *rs, char *pdata, int dmax) 
{
    int i=0, act=0;
    int opSt=0, opEd=0;
    int istr=0, iend=0, idx=0, ret=0;
    char *pvdst=0, *pvend=0;
    struct intMbs32_s *pt=0;
    struct aspMetaDataviaUSB_s *pmetausb=0, *pmetainput=0;
    struct aspMetaMass_s *pmass=0;
    struct aspConfig_s *pct=0, *pdt=0;
    unsigned char linGap=0, linStart=0;
    unsigned short linRec=0, linLength=0;
    unsigned int val=0;
    char *pch=0;

    if ((!mrs) && (!rs)) return -1;
    if ((!pdata) || (!dmax)) return -2;
    
    if (mrs) {
        pmetausb = &mrs->metaUsb;
        pct = mrs->configTable;
        pmass = &mrs->metaMass;
    } else {
        pmetausb = rs->pmetausb;
        pct = rs->pcfgTable;
        pmass = rs->pmetaMass;
    }
    
    msync(pmetausb, sizeof(struct aspMetaDataviaUSB_s), MS_SYNC);
    
    if ((pmetausb->ASP_MAGIC_ASPC[0] != 'A') || (pmetausb->ASP_MAGIC_ASPC[1] != 'S') || 
        (pmetausb->ASP_MAGIC_ASPC[2] != 'P') || (pmetausb->ASP_MAGIC_ASPC[3] != 'C')) {
        return -31;
    }

    pt = &(pmetausb->CROP_POS_1);
    for (i = ASPOP_CROP_01; i <= ASPOP_CROP_06; i++) {
        pct[i].opValue = msb2lsb32(pt);
        pct[i].opStatus = ASPOP_STA_UPD;

        //printf("%d. 0x%.8x \n", i, pct[i].opValue);
        
        pt++;
    }

    for (i = ASPOP_CROP_07; i <= ASPOP_CROP_18; i++) {
        pct[i].opValue = msb2lsb32(pt);
        pct[i].opStatus = ASPOP_STA_UPD;

        //printf("%d. 0x%.8x \n", i, pct[i].opValue);
        
        pt++;
    }

    pct[ASPOP_IMG_LEN].opValue = pmetausb->IMG_HIGH[0] | (pmetausb->IMG_HIGH[1] << 8);
    pct[ASPOP_IMG_LEN].opStatus = ASPOP_STA_UPD;    

    pct[ASPOP_SCAN_WIDTH].opValue = pmetausb->IMG_WIDTH[0] | (pmetausb->IMG_WIDTH[1] << 8);
    pct[ASPOP_SCAN_WIDTH].opStatus = ASPOP_STA_UPD;        

    pct[ASPOP_SCAN_SIDE].opValue = pmetausb->PRI_O_SEC;
    pct[ASPOP_SCAN_SIDE].opStatus = ASPOP_STA_UPD;        

    linGap = pmetausb->YLine_Gap;
    linStart = pmetausb->Start_YLine_No;

    pch = (char *)&(pmetausb->YLines_Recorded);
    val = pch[0] << 8 | pch[1];
    linRec = val;
    
    // shmem_dump((char *)&pmetausb->CROP_POS_1, 128);
    //printf(" gap: %d, startLin: %d yline: %d \n", linGap, linStart, linRec);

    if ((pdata[0] == 'Y') && (pdata[1] == 'L')) {
        pch = &pdata[2];
        val = pch[0] << 8 | pch[1];
        linLength = val;
    }
    
    if (linRec) {
        pmass->massGap = linGap;
        pmass->massStart = linStart;
        pmass->massRecd = linRec;
        pmass->massUsed = linLength;

        cfgTableSet(pct, ASPOP_XCROP_GAT, linGap);
        cfgTableSet(pct, ASPOP_XCROP_LINSTR, linStart);
        cfgTableSet(pct, ASPOP_XCROP_LINREC, linRec);
            
    }
    else if (linLength) {
        linRec = linLength / 4;
        pmass->massGap = linGap;
        pmass->massStart = linStart;
        pmass->massRecd = linRec;
        pmass->massUsed = linLength;

        cfgTableSet(pct, ASPOP_XCROP_GAT, linGap);
        cfgTableSet(pct, ASPOP_XCROP_LINSTR, linStart);
        cfgTableSet(pct, ASPOP_XCROP_LINREC, linRec);
            
    }
    else {
        pmass->massGap = 0;
        pmass->massStart = 0;
        pmass->massRecd = 0;
        pmass->massUsed = 0;
        
        cfgTableSet(pct, ASPOP_XCROP_GAT, 0);
        cfgTableSet(pct, ASPOP_XCROP_LINSTR, 0);
        cfgTableSet(pct, ASPOP_XCROP_LINREC, 0);
    }

    if (linLength) {
        pch = &pdata[4];
        if (linLength > (dmax - 4)) {
            linLength = dmax - 4;
        }

        memcpy(pmass->masspt, pch, linLength);

        pt = &(pmetausb->CROP_POS_F1);
        for (i = ASPOP_USBCROP_FP01; i <= ASPOP_USBCROP_FP04; i++) {
            pct[i].opValue = msb2lsb32(pt);
            pct[i].opStatus = ASPOP_STA_UPD;

            //printf("[META] F%d. = (%d, %d) \n", i - ASPOP_USBCROP_FP01 + 1, (pct[i].opValue >> 16) & 0xffff, (pct[i].opValue >> 0) & 0xffff);
        
            pt++;
        }
    }
    
    msync(pct, ASPOP_CODE_MAX * sizeof(struct aspConfig_s), MS_SYNC);

    return 0;
}

static int aspMetaReleaseviaUsbDuo(struct mainRes_s *mrs, struct procRes_s *rs, char *pdata, int dmax) 
{
    int i=0, act=0;
    int opSt=0, opEd=0;
    int istr=0, iend=0, idx=0, ret=0;
    char *pvdst=0, *pvend=0;
    struct intMbs32_s *pt=0;
    struct aspMetaDataviaUSB_s *pmetausbduo=0, *pmetainput=0;
    struct aspMetaMass_s *pmassduo=0;
    struct aspConfig_s *pct=0, *pdt=0;
    unsigned char linGap=0, linStart=0;
    unsigned short linRec=0, linLength=0;
    unsigned int val=0;
    char *pch=0;

    if ((!mrs) && (!rs)) return -1;
    if ((!pdata) || (!dmax)) return -2;
    
    if (mrs) {
        pmetausbduo = &mrs->metaUsbDuo;
        pct = mrs->configTable;
        pmassduo = &mrs->metaMassDuo;
    } else {
        pmetausbduo = rs->pmetausbduo;
        pct = rs->pcfgTable;
        pmassduo = rs->pmetaMassduo;
    }
    
    msync(pmetausbduo, sizeof(struct aspMetaDataviaUSB_s), MS_SYNC);
    
    if ((pmetausbduo->ASP_MAGIC_ASPC[0] != 'A') || (pmetausbduo->ASP_MAGIC_ASPC[1] != 'S') || 
        (pmetausbduo->ASP_MAGIC_ASPC[2] != 'P') || (pmetausbduo->ASP_MAGIC_ASPC[3] != 'C')) {
        return -31;
    }

    pt = &(pmetausbduo->CROP_POS_1);
    for (i = ASPOP_CROP_01_DUO; i <= ASPOP_CROP_06_DUO; i++) {
        pct[i].opValue = msb2lsb32(pt);
        pct[i].opStatus = ASPOP_STA_UPD;
        pt++;
    }

    for (i = ASPOP_CROP_07_DUO; i <= ASPOP_CROP_18_DUO; i++) {
        pct[i].opValue = msb2lsb32(pt);
        pct[i].opStatus = ASPOP_STA_UPD;
        pt++;
    }

    pct[ASPOP_IMG_LEN_DUO].opValue = pmetausbduo->IMG_HIGH[0] | (pmetausbduo->IMG_HIGH[1] << 8);
    pct[ASPOP_IMG_LEN_DUO].opStatus = ASPOP_STA_UPD;   
    
    pct[ASPOP_SCAN_WIDTH_DUO].opValue = pmetausbduo->IMG_WIDTH[0] | (pmetausbduo->IMG_WIDTH[1] << 8);
    pct[ASPOP_SCAN_WIDTH_DUO].opStatus = ASPOP_STA_UPD;        

    pct[ASPOP_SCAN_SIDE_DUO].opValue = pmetausbduo->PRI_O_SEC;
    pct[ASPOP_SCAN_SIDE_DUO].opStatus = ASPOP_STA_UPD;        

    linGap = pmetausbduo->YLine_Gap;
    linStart = pmetausbduo->Start_YLine_No;

    pch = (char *)&(pmetausbduo->YLines_Recorded);
    val = pch[0] << 8 | pch[1];
    linRec = val;

    //shmem_dump((char *)&pmetausbduo->CROP_POS_1, 128);
    //printf(" gap: %d, startLin: %d yline: %d \n", linGap, linStart, linRec);

    if ((pdata[0] == 'Y') && (pdata[1] == 'L')) {
        pch = &pdata[2];
        val = pch[0] << 8 | pch[1];
        linLength = val;
    }
    
    if (linRec) {
        pmassduo->massGap = linGap;
        pmassduo->massStart = linStart;
        pmassduo->massRecd = linRec;
        pmassduo->massUsed = linLength;

        cfgTableSet(pct, ASPOP_XCROP_GAT_DUO, linGap);
        cfgTableSet(pct, ASPOP_XCROP_LINSTR_DUO, linStart);
        cfgTableSet(pct, ASPOP_XCROP_LINREC_DUO, linRec);
            
    }
    else if (linLength) {
        linRec = linLength / 4;
        pmassduo->massGap = linGap;
        pmassduo->massStart = linStart;
        pmassduo->massRecd = linRec;
        pmassduo->massUsed = linLength;

        cfgTableSet(pct, ASPOP_XCROP_GAT_DUO, linGap);
        cfgTableSet(pct, ASPOP_XCROP_LINSTR_DUO, linStart);
        cfgTableSet(pct, ASPOP_XCROP_LINREC_DUO, linRec);
            
    }
    else {
        pmassduo->massGap = 0;
        pmassduo->massStart = 0;
        pmassduo->massRecd = 0;
        pmassduo->massUsed = 0;
        
        cfgTableSet(pct, ASPOP_XCROP_GAT_DUO, 0);
        cfgTableSet(pct, ASPOP_XCROP_LINSTR_DUO, 0);
        cfgTableSet(pct, ASPOP_XCROP_LINREC_DUO, 0);
    }

    if (linLength) {
        pch = &pdata[4];
        if (linLength > (dmax - 4)) {
            linLength = dmax - 4;
        }

        memcpy(pmassduo->masspt, pch, linLength);

        pt = &(pmetausbduo->CROP_POS_F1);
        for (i = ASPOP_USBCROP_FP01_DUO; i <= ASPOP_USBCROP_FP04_DUO; i++) {
            pct[i].opValue = msb2lsb32(pt);
            pct[i].opStatus = ASPOP_STA_UPD;

            //printf("[META] duo F%d. = (%d, %d) \n", i - ASPOP_USBCROP_FP01_DUO + 1, (pct[i].opValue >> 16) & 0xffff, (pct[i].opValue >> 0) & 0xffff);
        
            pt++;
        }
    }
    
    msync(pct, ASPOP_CODE_MAX * sizeof(struct aspConfig_s), MS_SYNC);

    return 0;
}

#define LOG_DEBUG_MEMALLOC (0)
static int aspMemClear(struct aspMemAsign_s *msa, int *memtot, int pidx)
{
    char mlog[256];
    uint32_t ad32=0;
    struct aspMemAsign_s *ms;
    int mi=0, tot=0, asz=0;
    char *pfree;

    if (msa == 0) return -1;
    if (memtot == 0) return -2;
    if (pidx >= MSP_P_NUM) return -3;

    msync(msa, sizeof(struct aspMemAsign_s) * MSP_P_NUM, MS_SYNC);
    msync(memtot, sizeof(int) * MSP_P_NUM, MS_SYNC);

    ms = &msa[pidx];
    tot = memtot[pidx];

    for (mi = 0; mi < ASP_MEM_SLOT_NUM; mi++) {

        asp_mem_barrier();
        
        if (ms->aspMemAddr[mi] != 0) {
            asz = ms->aspMemSize[mi];
            ad32 = ms->aspMemAddr[mi];

            pfree = (char *)ad32;

            tot -= asz;
            memtot[pidx] = tot;

            #if LOG_DEBUG_MEMALLOC
            sprintf_f(mlog, "[%d] FREE [%d] ADDR: 0x%.8x, SIZE: %d, TOTAL: %d\n", pidx, mi, ad32, asz, tot);
            print_f(mlogPool, "MEM", mlog);
            #endif

            ms->aspMemAddr[mi] = 0;
            ms->aspMemSize[mi] = 0;

            //memset(pfree, 0, asz);
            #if 1
            free(pfree);
            #endif
            //memset(pfree, 0xff, asz);
        }
    }
    
    msync(ms, sizeof(struct aspMemAsign_s), MS_SYNC);
    msync(memtot, sizeof(int) * MSP_P_NUM, MS_SYNC);

    sync();
    
    return 0;
}

static int aspMemDebug(struct aspMemAsign_s *msa, int *memtot, int *shmemtot)
{
    char mlog[256];
    int level = 2;
    int pi=0, tot=0, mi=0, stot=0;
    struct aspMemAsign_s *ms;
    if (msa == 0) return -1;
    if (memtot == 0) return -2;
    if (shmemtot == 0) return -3;

#if LOG_DEBUG_MEMALLOC
    stot = *shmemtot;

    sprintf_f(mlog, "********************************************%d\n", level);
    print_f(mlogPool, "MEM", mlog);

    sprintf_f(mlog, "SHARE MEM TOTAL_SIZE: %d\n", stot);
    print_f(mlogPool, "MEM", mlog);

    msync(msa, sizeof(struct aspMemAsign_s) * MSP_P_NUM, MS_SYNC);
    msync(memtot, sizeof(int) * MSP_P_NUM, MS_SYNC);
    
    for (pi = 0; pi < MSP_P_NUM; pi++) {
        ms = &msa[pi];
        tot = memtot[pi];
        
        switch (level) {
        case 1:
            sprintf_f(mlog, "P%d TOTAL_SIZE: %d\n", pi, tot);
            print_f(mlogPool, "MEM", mlog);
            break;
        case 2:
            sprintf_f(mlog, "P%d VMEM TOTAL_SIZE: %d\n", pi, tot);
            print_f(mlogPool, "MEM", mlog);

            for (mi = 0; mi < ASP_MEM_SLOT_NUM; mi++) {
                if (ms->aspMemAddr[mi] != 0) {
                    sprintf_f(mlog, "    [%d] ADDR: 0x%.8x, SIZE: %d\n", mi, ms->aspMemAddr[mi], ms->aspMemSize[mi]);
                    print_f(mlogPool, "MEM", mlog);
                }
            }
            break;

        default:
            break;
        }
    }

    sprintf_f(mlog, "********************************************%d\n", level);
    print_f(mlogPool, "MEM", mlog);
#endif

    return 0;
}

static void* aspMemalloc(uint32_t asz, int pidx) 
{
    char mlog[256];
    char *addr=0;
    struct aspMemAsign_s *ms=0;
    int mi=0, tot=0, rst, mlen, num;
    if (pidx >= MSP_P_NUM) return 0;
    if (asz == 0 || asz < 0) return 0;

    mlen = asz;
    rst = mlen % MIN_MEM_ALLOC_SIZE;
#if LOG_DEBUG_MEMALLOC
    sprintf_f(mlog, "malloc rst: %d, asz:%d, mlen: %d\n", rst, asz, mlen);
    print_f(mlogPool, "MEM", mlog);
#endif
    if (rst != 0) {
        num = mlen / MIN_MEM_ALLOC_SIZE;
        mlen = (num + 1) * MIN_MEM_ALLOC_SIZE;
#if LOG_DEBUG_MEMALLOC
        sprintf_f(mlog, "malloc num: %d, mlen: %d\n", num, mlen);
        print_f(mlogPool, "MEM", mlog);
#endif
    }
    
    //asm volatile("" ::: "memory");
    asp_mem_barrier();
    
    tot = asptotMalloc[pidx];
    ms = &aspMemAsign[pidx];
    
    msync(ms, sizeof(struct aspMemAsign_s), MS_SYNC);
    
    for (mi = 0; mi < ASP_MEM_SLOT_NUM; mi++) {
        if (ms->aspMemAddr[mi] == 0) {
#if LOG_DEBUG_MEMALLOC
            sprintf_f(mlog, "malloc [%d] SIZE: %d\n", mi, mlen);
            print_f(mlogPool, "MEM", mlog);
#endif
            addr = malloc(mlen);
            
            if (!addr) break;
            
            ms->aspMemSize[mi] = mlen;
            ms->aspMemAddr[mi] = (uint32_t)addr;

            tot += mlen;

            asp_mem_barrier();
            
            asptotMalloc[pidx] = tot;

            msync(ms, sizeof(struct aspMemAsign_s), MS_SYNC);
            msync(asptotMalloc, sizeof(int) * MSP_P_NUM, MS_SYNC);
#if LOG_DEBUG_MEMALLOC
            sprintf_f(mlog, "[%d ] ALLOC [%d] ADDR: 0x%.8x, SIZE: %d TOT: %d\n", pidx, mi, ms->aspMemAddr[mi], ms->aspMemSize[mi], tot);
            print_f(mlogPool, "MEM", mlog);
#endif
            return addr;
        }
    }

    if (!addr) {
        printf("[MEM] ERROR!!! out of memory slot, the max number of slot is %d \n", ASP_MEM_SLOT_NUM);
    }

    return addr;
}

static int aspMemFree(void *dval, int pidx)
{
    return 0;
#if 0
    char mlog[256];
    struct aspMemAsign_s *ms;
    int i=0, tot=0;
    uint32_t asz=0, ad32=0;
    char *pfree;
    if (pidx >= MSP_P_NUM) return -1;
    if (dval == 0) return -2;

    ad32 = (uint32_t) dval;

    sprintf_f(mlog, " FREE [%d] ADDR: 0x%.8x\n", pidx, ad32);
    print_f(mlogPool, "MEM", mlog);

    tot = asptotMalloc[pidx];
    ms = &aspMemAsign[pidx];

    msync(ms, sizeof(struct aspMemAsign_s), MS_SYNC);
    
    for (i = 0; i < ASP_MEM_SLOT_NUM; i++) {
        if (ms->aspMemAddr[i] == ad32) {
            asz = ms->aspMemSize[i];

            ms->aspMemSize[i] = 0;
            ms->aspMemAddr[i] = 0;

            tot -= asz;
            asptotMalloc[pidx] = tot;

            pfree = (char *)ad32;
            
            free(pfree);

            return tot;
        }
    }

    return -3;
#endif
}

inline int tiffGetDot(char *img, int *dot, char *pta, int *scale)
{
    uint8_t *dst, val=0;
    int rowsz, height, max, bpp;
    int dotx=0, doty=0;

    dotx = dot[0];
    doty = dot[1];

    rowsz = scale[0];
    height = scale[1];
    max = scale[2];
    bpp = scale[3] / 8;

    if (dotx >= rowsz) {
        dotx = rowsz -1;
    }
    
    if (dotx < 0) {
        dotx = 0;
    }
    
    if (doty >= height) {
        doty = height -1;
    }

    if (doty < 0) {
        doty = 0;
    }

    dst = img + (dotx*bpp + doty*rowsz);

    while (bpp > 0) {

        *pta = *dst;

        bpp --;
        pta++;
        dst++;
    }

    //printf("(%d, %d)get dot, org: 0x%.2x, val: 0x%.2x - x:%d, y:%d, res:%d (%d)\n", dotx, doty, org, val, offsetX, offsetY, resX, (offsetX + offsetY*estWid));

    return val;
}

static int tiffDrawDot(char *img, int *dot, char *pta, int *scale)
{
    uint8_t *dst, val=0;
    int rowsz, height, max, bpp;
    int dotx=0, doty=0;

    dotx = dot[0];
    doty = dot[1];

    rowsz = scale[0];
    height = scale[1];
    max = scale[2];
    bpp = scale[3] / 8;

    if (dotx >= rowsz) {
        dotx = rowsz -1;
    }
    
    if (dotx < 0) {
        dotx = 0;
    }
    
    if (doty >= height) {
        doty = height -1;
    }

    if (doty < 0) {
        doty = 0;
    }

    dst = img + (dotx*bpp + doty*rowsz);
    
    //printf(" draw dot x:%d, y:%d\n", dotx, doty);

    val = 0;
    while (bpp > 0) {
        val <<= 8;
        
        *dst = *pta;
        val |= *pta;
        
        bpp --;
        pta++;
        dst++;
    }

    return val;
}

static int tiffDrawLine(char *img, int *cord, int *scale)
{
    int ret=0, cnt=0;
    int estMax, srcx, srcy, dstx, dsty, lstx, lsty;
    int dot[2];
    int bpp=0;
    char dat[3];
    CFLOAT stx=0, sty=0, edx=0, edy=0;
    CFLOAT offx=0, offy=0;
    if (!img) return -1;
    if (!cord) return -2;

    srcx = cord[0]; 
    srcy = cord[1]; 
    dstx = cord[2];
    dsty = cord[3];
    
    stx = (CFLOAT)cord[0];
    sty = (CFLOAT)cord[1];
    edx = (CFLOAT)cord[2];
    edy = (CFLOAT)cord[3];

    offx = edx - stx;
    offy = edy - sty;

    bpp = scale[3] / 8;
    
    if (fabs(offx) < 0.0001) {
        offx = 0;
    } else if (fabs(offy) < 0.0001) {
        offy = 0;
    } 

    if (fabs(offx) > fabs(offy)) {
        offy = offy / fabs(offx);
        offx = offx / fabs(offx);
    } else if (fabs(offy) > fabs(offx)) {
        offx = offx / fabs(offy);
        offy = offy / fabs(offy);
    } else {
        if (fabs(offy) > 0) {
            offx = offx / fabs(offx);
            offy = offy / fabs(offy);
        }
    }

    printf("draw line  (%d, %d) -> (%d, %d) (%f, %f)\n", srcx, srcy, dstx, dsty, offx, offy);

    switch (bpp) {
    case 1:
        dat[0] = 0xff;
        dat[1] = 0;
        dat[2] = 0;
        break;
    case 3:
        dat[0] = 0xff;
        dat[1] = 0xff;
        dat[2] = 0xff;
        break;
    default:
        printf("ERROR!!! draw line  bpp = %d \n", bpp);
        break;
    }
    
    while ((srcx != dstx) || (srcy != dsty)) {
         ret = tiffDrawDot(img, dot, dat, scale);

         lstx = srcx;
         lsty = srcy;
         
         stx += offx;
         sty += offy;
         srcx = (int)round(stx);
         srcy = (int)round(sty);
         
         if ((lstx == srcx) && (lsty == srcy)) {
             cnt++;
         } else {
             cnt = 0;
         }

         if (cnt > 3) {
             srcx = (int)round(stx);
             srcy = (int)round(sty);
         }
         
         dot[0] = srcx;
         dot[1] = srcy;

         //printf("draw %d, %d - %d, %lf, %lf\n", srcx, srcy,cnt, stx, sty);
     }
     
     ret = tiffDrawDot(img, dot, dat, scale);
     
    return cnt;
}

static int tiffDrawBox(char *img, int *cord, int *scale)
{
    int estMax, i;
    int stx=0, sty=0, edx=0, edy=0;
    int rcord[4];
    if (!img) return -1;
    if (!cord) return -2;

    stx = cord[0];
    sty = cord[1];
    edx = cord[2];
    edy = cord[3];

    rcord[0] = stx;
    rcord[1] = sty;
    rcord[2] = edx;
    rcord[3] = edy;

    for (i = stx; i <= edx; i++) {
        rcord[0] = i;
        rcord[2] = i;
        tiffDrawLine(img, rcord, scale);
    }

    return 0;
}

static CFLOAT getAngle(CFLOAT *pSrc, CFLOAT *p1, CFLOAT *p2)
{
    CFLOAT angle = 0.0f;
    
    if ((p1[0] == p2[0]) && (p1[1] == p2[1])) return -1;
    if ((p1[0] == pSrc[0]) && (p1[1] == pSrc[1])) return -1;
    if ((p2[0] == pSrc[0]) && (p2[1] == pSrc[1])) return -1;
    
    CFLOAT va_x = p1[0] - pSrc[0];
    CFLOAT va_y = p1[1] - pSrc[1];

    CFLOAT vb_x = p2[0] - pSrc[0];
    CFLOAT vb_y = p2[1] - pSrc[1];

    CFLOAT productValue = (va_x * vb_x) + (va_y * vb_y);  
    CFLOAT va_val = sqrt(va_x * va_x + va_y * va_y);  
    CFLOAT vb_val = sqrt(vb_x * vb_x + vb_y * vb_y);  
    CFLOAT cosValue = productValue / (va_val * vb_val);      

    //printf("[AnG] cos: %.2lf \n", cosValue);

    if(cosValue < -1 && cosValue > -2) {
        cosValue = -1;
    } else if (cosValue > 1 && cosValue < 2) {
        cosValue = 1;
    }

    angle = acos(cosValue) * 180.0 / M_PI; 
    
    return angle;
}

inline int calcuRotateCoordFast(CFLOAT *out, CFLOAT *in) 
{
    CFLOAT r=0;
    CFLOAT x1, y1;
    CFLOAT x2, y2;
    CFLOAT dx, dy;
    
    x1 = in[0];
    x2 = in[1];
    y1 = in[2];
    y2 = in[3];
    
    dx = x1 - x2;
    dy = y1 + y2;
    
    out[0] = dx;
    out[1] = dy;

    //printf("calcu rotate input :%lf, %lf, output: (%d, %d) (%lf, %lf) \n", in[0], in[1], outi[0], outi[1], out[0], out[1]);
    
    return 0;
}

static int calcuRotateCoordinates(int *outi, CFLOAT *out, CFLOAT *in, CFLOAT *angle) 
{
    CFLOAT r=0;
    CFLOAT x1, y1;
    CFLOAT x2, y2;
    CFLOAT cosA, sinA;

    if (!out) return -1;
    if (!in) return -2;
    if (!outi) return -3;
    if (!angle) return -4;

    //printf("calcu rotate input :%lf, %lf, cos:%lf sin:%lf\n", in[0], in[1], angle[0], angle[1]);

    x1 = in[0];
    y1 = in[1];

    cosA = angle[0];
    sinA = angle[1];

    //r = angle * M_PI / piAngle;
    //x2 = x1*cos(r) - y1*sin(r);
    //y2 = x1*sin(r) + y1*cos(r);
    
    x2 = x1*cosA - y1*sinA;
    y2 = x1*sinA + y1*cosA;
    
    out[0] = x2;
    out[1] = y2;

    outi[0] = (int)(x2);
    outi[1] = (int)(y2);

    //printf("calcu rotate input :%lf, %lf, output: (%d, %d) (%lf, %lf) \n", in[0], in[1], outi[0], outi[1], out[0], out[1]);
    
    return 0;
}

static int aspCrp36GetBoundry(struct aspCrop36_s *pcrp36, int max, CFLOAT *exlf, CFLOAT *exrt, int ex_len) 
{
#define SKIP_HEAD_TAIL_LEN (10)
    CFLOAT *ptn;
    CFLOAT lups[3] = {0.0, 0.0, 0.0};
    CFLOAT lrt[3] = {0.0, 0.0, 0.0};
    CFLOAT llf[3] = {0.0, 0.0, 0.0};
    CFLOAT ltop[3] = {0.0, 0.0, 0.0};
    CFLOAT lbtn[3] = {0.0, 0.0, 0.0};
    int i, ret, p1, p2, p3, skewflag;
    CFLOAT up[2] = {-1,-1}, dn[2] = {-1,-1}, rt[2] = {-1,-1}, lf[2] = {-1,-1};
    CFLOAT diff=0, angleLf, angleRt;
    CFLOAT aRange = 1.0, rlRange = 3.0, lfRange = 3.0;
    CFLOAT cs[4][2];
    CFLOAT w, h, r, l, tmf1, tmf2, d1=0, d2=0, cnt=0, acu1, acu2;
    CFLOAT rtrun[2]={-1,-1} , lfrun[2]={-1,-1};
    
    if (!pcrp36) return -1;
    if (!exlf) return -2;
    if (!exrt) return -3;

    if (max > 20) max = 20;

    //memcpy(ptn, pcrp36->crp36Pots, sizeof(CFLOAT) * 40);
    ptn = pcrp36->crp36Pots;
    
#if LOG_P6_CROP_EN
    for (i=0; i < max; i++) {
        printf("[crp36] %d. %lf, %lf \n", i, ptn[i*2+0], ptn[i*2+1]);
    }
#endif

    p1 = 5;
    up[0] = ptn[p1 * 2];
    up[1] = ptn[p1 * 2 + 1];
    
    p1 = 2;
    dn[0] = ptn[p1 * 2];
    dn[1] = ptn[p1 * 2 + 1];

    for (i = 1; i <= CROP_MAX_NUM_META; i++) {
        if (up[1] > 0) {
            if (up[1] > ptn[i * 2 + 1]) {
                up[0] = ptn[i * 2];
                up[1] = ptn[i * 2 + 1];
            }
        } else {
            up[0] = ptn[i * 2];
            up[1] = ptn[i * 2 + 1];
        }

        if (dn[1] > 0) {
            if (dn[1] < ptn[i * 2 + 1]) {
                dn[0] = ptn[i * 2];
                dn[1] = ptn[i * 2 + 1];
            }
        } else {
            dn[0] = ptn[i * 2];
            dn[1] = ptn[i * 2 + 1];
        }

        if ((lf[0] > 0) && (i != 1) && (i != 6)) {
            if (lf[0] > ptn[i * 2 + 0]) {
                lf[0] = ptn[i * 2];
                lf[1] = ptn[i * 2 + 1];
            }
        } else {
            lf[0] = ptn[i * 2];
            lf[1] = ptn[i * 2 + 1];
        }

        if ((rt[0] > 0) && (i != 4) && (i != 5)) {
            if (rt[0] < ptn[i * 2 + 0]) {
                rt[0] = ptn[i * 2];
                rt[1] = ptn[i * 2 + 1];
            }
        } else {
            rt[0] = ptn[i * 2];
            rt[1] = ptn[i * 2 + 1];
        }
    }

    for (i = 0; i < ex_len; i++) {
        if (lf[0] > exlf[i * 2]) {
            lf[0] = exlf[i * 2];
            lf[1] = exlf[i * 2 + 1];
        }

        if (rt[0] < exrt[i * 2]) {
            rt[0] = exrt[i * 2];
            rt[1] = exrt[i * 2 + 1];
        }
    }

    w = rt[0] - lf[0];
    h = dn[1] - up[1];

    tmf1=0;
    tmf2=0;
    cnt=0;
    acu1 = 0;
    acu2 = 0;
    
    for (i = SKIP_HEAD_TAIL_LEN; i < (ex_len-SKIP_HEAD_TAIL_LEN); i++) {
        d1 = exlf[i * 2] - lf[0];
        d2 = rt[0] - exrt[i * 2];

        acu1 += d1;
        acu2 += d2;

        if (tmf1 == 0) {
            tmf1 = d1;
        } else {
            if (tmf1 < d1) {
                tmf1 = d1;
            }
        }

        
        if (tmf2 == 0) {
            tmf2 = d2;
        } else {
            if (tmf2 < d2) {
                tmf2 = d2;
            }
        }

        cnt += 1;
    }

    d1 = acu1/cnt;
    d2 = acu2/cnt;

#if LOG_P6_CROP_EN
    printf("[crp36] acu1: %.2lf, acu2: %.2lf, d1:%.2lf d2:%.2lf tmf1: %.2lf tmf2: %.2lf w:%.2lf, h: %.2lf\n", acu1, acu2, d1, d2, tmf1, tmf2, w, h);
#endif

    diff = fabs(tmf1 - d1);
    if (diff < (w/3)) {
        d1 = tmf1;
    }

    diff = fabs(tmf2 - d2);
    if (diff < (w/3)) {
        d2 = tmf2;
    }
    
    p1 = 5;
    p2 = 6;
    diff = ptn[p1*2] - ptn[p2*2];

    if (diff > w) {
        p1 = 7;
        p2 = 8;
        diff = ptn[p1*2] - ptn[p2*2];
    }

    rlRange = w / 200.0;
    lfRange = w / 200.0;

#if LOG_P6_CROP_EN
    printf("[crp36] 1. diff: %.2lf, limit: %.2lf, d1:%.2lf d2:%.2lf\n", diff, (w / 2), d1, d2);
#endif

    if (diff < (w / 2)) {
        tmf1 = rt[0] - ptn[p2*2];
        tmf2 = ptn[p1*2] - lf[0];
        if (tmf1 == tmf2) {
            skewflag = 0;
        } else if (tmf1 > tmf2) {
            skewflag = 1;
        } else {
            skewflag = 2;
        }
    } else {
        p1 = 3;
        p2 = 2;
        diff = ptn[p1*2] - ptn[p2*2];
        tmf1 = rt[0] - ptn[p2*2];
        tmf2 = ptn[p1*2] - lf[0];

        #if LOG_P6_CROP_EN
        printf("[crp36] 2. diff: %.2lf, limit: %.2lf\n", diff, (w / 2));
        #endif

        if (diff < (w / 10)) {
            if (tmf1 == tmf2) {
                skewflag = 0;
            } else if (tmf1 > tmf2) {
                skewflag = 2;
            } else {
                skewflag = 1;
            }
        } else {
            //rlRange = 100.0;
            //rlRange = (w / 5.0) - 1;
            rlRange = d2;
            lfRange = d1;
            if (tmf1 == tmf2) {
                skewflag = 1;
            } else if (tmf1 < tmf2) {
                skewflag = 1;
            } else {
                skewflag = 2;
            }
        }
    }

    #if LOG_P6_CROP_EN
    printf("[crp36] skewflag: %d, rlRange: %.2lf, lfRange: %.2lf\n", skewflag, rlRange, lfRange);
    #endif

    if (skewflag) {
        p1 = 0;
        rtrun[0] = exrt[p1 * 2];
        rtrun[1] = exrt[p1 * 2 + 1];
        
        lfrun[0] = exlf[p1 * 2];
        lfrun[1] = exlf[p1 * 2 + 1];
        
        if (skewflag == 1) { //rt up, lf dn
            r = rtrun[0] + rlRange;
            l = lfrun[0] + lfRange;
        } else {// rt dn lf up
            r = rtrun[0] - rlRange;
            l = lfrun[0] - lfRange;
        }
        for (i = 0; i < ex_len; i++) {
            //__android_log_print(ANDROID_LOG_VERBOSE, "calculate", "sflag: %d, %d - rt: (%.2lf, %.2lf) lf: (%.2lf, %.2lf) r:%.2lf, l:%.2lf  (%.2lf, %.2lf) (%.2lf, %.2lf)\n"
            //, skewflag, i, exrt[i * 2], exrt[i * 2+1], exlf[i * 2], exlf[i * 2+1], r, l, rt[0], rt[1], lf[0], lf[1]);
            if (skewflag == 1) { //rt up, lf dn
                if (r <= exrt[i * 2]) {
                    rtrun[0] = exrt[i * 2];
                    rtrun[1] = exrt[i * 2 + 1];

                    r = rtrun[0] + rlRange;
                }

                if (l >= exlf[i * 2]) {
                    lfrun[0] = exlf[i * 2];
                    lfrun[1] = exlf[i * 2 + 1];

                    l = lfrun[0] + lfRange;
                }

            } else {  // rt dn lf up
                if (r <= exrt[i * 2]) {
                    rtrun[0] = exrt[i * 2];
                    rtrun[1] = exrt[i * 2 + 1];

                    r = rtrun[0] - rlRange;
                }

                if (l >= exlf[i * 2]) {
                    lfrun[0] = exlf[i * 2];
                    lfrun[1] = exlf[i * 2 + 1];

                    l = lfrun[0] - lfRange;
                }
            }
        }
    }

    p1 = 1;
    p2 = 2;
    p3 = 6;
    angleLf = getAngle(&ptn[p1 * 2], &ptn[p2 * 2], &ptn[p3 * 2]);

    p1 = 4;
    p2 = 3;
    p3 = 5;
    angleRt = getAngle(&ptn[p1 * 2], &ptn[p2 * 2], &ptn[p3 * 2]);

    #if LOG_P6_CROP_EN
    printf("[crp36] angleLf = %.2lf, angleRt = %.2lf \n", angleLf, angleRt);
    #endif

    p1 = 1;
    if ((angleLf < (90.0 + aRange)) && (angleLf > (90.0 - aRange))) {
        if (ptn[p1 * 2] < lf[0]) {
            diff = lf[0] - ptn[p1 * 2];

            if (diff > 1.0) {
                lf[0] = ptn[p1 * 2];
                lf[1] = ptn[p1 * 2 + 1];
            }
        }
    } else {
        lf[0] = lfrun[0];
        lf[1] = lfrun[1];
    
        ptn[p1 * 2] = lf[0];
        ptn[p1 * 2 + 1] = lf[1];
    }

    p1 = 4;
    if ((angleRt < (90.0 + aRange)) && (angleRt > (90.0 - aRange))) {
        if (ptn[p1 * 2] > rt[0]) {
            diff = ptn[p1 * 2] - rt[0];

            if (diff > 1.0) {
                rt[0] = ptn[p1 * 2];
                rt[1] = ptn[p1 * 2 + 1];
            }
        }
    } else {
        rt[0] = rtrun[0];
        rt[1] = rtrun[1];
    
        ptn[p1 * 2] = rt[0];
        ptn[p1 * 2 + 1] = rt[1];
    }

    p1 = 0; 
    p2 = CROP_MAX_NUM_META+1;
    ret = getVectorFromP(lups, &ptn[p1*2], &ptn[p2*2]);
    if (ret != 0) {
        printf("[crp36] Error!!!!get up side line failed!!!");
        return -4;
    }        

    ret = getRectVectorFromV(llf, lf, lups);
    if (ret != 0) {
        printf("[crp36] Error!!!!get left line failed!!!");
        return -7;
    }

    ret = getRectVectorFromV(lrt, rt, lups);
    if (ret != 0) {
        printf("[crp36] Error!!!!get right line failed!!!");
        return -8;
    }

    ret = getRectVectorFromV(ltop, up, lrt);
    if (ret != 0) {
        printf("[crp36] Error!!!!get top line failed!!!");
        return -7;
    }

    ret = getRectVectorFromV(lbtn, dn, lrt);
    if (ret != 0) {
        printf("[crp36] Error!!!!get botton line failed!!!");
        return -7;
    }

    memcpy(pcrp36->crp36LineUpbnd, lups, sizeof(CFLOAT) * 3);
    memcpy(pcrp36->crp36LineTop, ltop, sizeof(CFLOAT) * 3);
    memcpy(pcrp36->crp36LineBotn, lbtn, sizeof(CFLOAT) * 3);
    memcpy(pcrp36->crp36LineLeft, llf, sizeof(CFLOAT) * 3);
    memcpy(pcrp36->crp36LineRight, lrt, sizeof(CFLOAT) * 3);
    
    pcrp36->crp36Up = (int)up[1];
    pcrp36->crp36Dn = (int)dn[1];
    pcrp36->crp36Rt = (int)rt[0];
    pcrp36->crp36Lf = (int)lf[0];
    
#if LOG_P6_CROP_EN
    printf("[crp36] up = %d, dn = %d , lf = %d, rt = %d \n", pcrp36->crp36Up, pcrp36->crp36Dn, pcrp36->crp36Lf, pcrp36->crp36Rt);
#endif

    getCross(lbtn, llf, cs[0]);
    getCross(lbtn, lrt, cs[1]);
    getCross(ltop, lrt, cs[2]);
    getCross(ltop, llf, cs[3]);

#if LOG_P6_CROP_EN
    printf("[crp36] cs0 = (%f, %f), cs1 = (%f, %f), cs2 = (%f, %f), cs3 = (%f, %f) \n", cs[0][0], cs[0][1], cs[1][0], cs[1][1], cs[2][0], cs[2][1], cs[3][0], cs[3][1]);
#endif

    return 0;
}

static int getParallelVectorFromV(CFLOAT *vec, CFLOAT *p, CFLOAT *vecIn)
{
    CFLOAT a=0, b=0, c=0, aIn=0, cIn=0;
    CFLOAT x, y;

    if (vec == 0) return -1;
    if (p == 0) return -2;
    if (vecIn == 0) return -3;

    a = vecIn[0];
    c = vecIn[2];
    x = p[0];
    y = p[1];

    b = y - (a * x);

    vec[0] = a;
    vec[1] = b;
    vec[2] = c;
    
#if CROP_CALCU_DETAIL
    printf("[vectPV] output - a = %f , b = %f, c = %f\n", a, b, c);
#endif

    return 0;
}

static int getRectVectorFromV(CFLOAT *vec, CFLOAT *p, CFLOAT *vecIn)
{
    CFLOAT a=0, b=0, c=0, aIn=0, cIn=0;
    CFLOAT x, y;

    if (vec == 0) return -1;
    if (p == 0) return -2;
    if (vecIn == 0) return -3;

    aIn = vecIn[0];
    cIn = vecIn[2];
    x = p[0];
    y = p[1];

    if (aIn == 0) {
        c = 1;
    } else if (cIn == 1) {
        a = 0;
    } else {
        a = -1 / aIn;
    }
    
    if (c == 1) {
        a = 1;
        b = -x;
    } else {
        b = y - (a * x);
    }
    vec[0] = a;
    vec[1] = b;
    vec[2] = c;

#if CROP_CALCU_DETAIL
    printf("[vectRV] output - a = %f, b = %f, c = %f\n", a, b, c);
#endif

    return 0;
}

static int getVectorFromP(CFLOAT *vec, CFLOAT *p1, CFLOAT *p2)
{
    CFLOAT a1, b, a2;
    CFLOAT x1, y1, x2, y2;

    if (vec == 0) return -1;
    if (p1 == 0) return -2;
    if (p2 == 0) return -3;

    x1 = p1[0];
    y1 = p1[1];

    x2 = p2[0];
    y2 = p2[1];


    vec[2] = 0;
#if CROP_CALCU_DETAIL
    printf("[vectP] input - p1 = (%lf, %lf), p2 = (%lf, %lf)\n", x1, y1, x2, y2);
#endif
    if (x1 == x2) {
    	if (y1 == y2) {
    	    return -4;
    	} else {
    	    a1 = 1;
    	    a2 = 1;
    	    b = -x1;
    	    vec[2] = 1;
    	}
    } else {
        b = ((x2 * y1) - (x1 * y2)) / (x2 - x1);

        if (x1 == 0) {
            a1 = 0;
        } else {
            a1 = ((x1 * y2) - (x1 * y1)) / ((x1 * x2) - (x1 * x1));
        }

        if (x2 == 0) {
            a2 = 0;
        } else {
            a2 = ((x2 * y2) - (x2 * y1)) / ((x2 * x2) - (x2 * x1));
        }
    }
#if CROP_CALCU_DETAIL
    printf("[vectP] output - a = %lf/%lf, b = %lf\n", a1, a2, b);
#endif

    if (a1 == 0) {
        vec[0] = a2;
    } else {
        vec[0] = a1;
    }

    vec[1] = b;

    return 0;

}

static int getCross(CFLOAT *v1, CFLOAT *v2, CFLOAT *pt)
{
    CFLOAT a1, a2, b1, b2, c1, c2;
    CFLOAT x, y;

    if (v1 == 0) return -1;
    if (v2 == 0) return -2;
    if (pt == 0) return -3;

    a1 = v1[0];
    b1 = v1[1];
    c1 = v1[2];

    a2 = v2[0];
    b2 = v2[1];
    c2 = v2[2];
#if CROP_CALCU_DETAIL
    printf("[Cross] input - v1 = (%lf, %lf, %lf) v2 = (%lf, %lf, %lf)\n", a1, b1, c1, a2, b2, c2);
#endif
    if (a1 == a2) return -4;

    if ((c1 == 1) && (c2 == 1)) {
        return -5;
    } else if (c1 == 1) {
        x = -(b1/a1);
        y = a2 * x + b2;
    } else if (c2 == 1) {
        x = -(b2/a2);
        y = a1 * x + b1;
    } else {
        y = ((a1 * b2) - (a2 * b1)) / (a1 - a2);
        x = (b2 - b1) / (a1 - a2);
    }
#if CROP_CALCU_DETAIL
    printf("[Cross] output - pt = (%lf, %lf)\n", x, y);
#endif
    pt[0] = x;
    pt[1] = y;
    
    return 0;
}

static CFLOAT calcuDistance(CFLOAT *p1, CFLOAT *p2) 
{
    CFLOAT x1, y1, x2, y2;
    CFLOAT dx, dy, ds, dt;

    if (p1 == 0) return -2;
    if (p2 == 0) return -3;

    x1 = p1[0];
    y1 = p1[1];

    x2 = p2[0];
    y2 = p2[1];

    dx = x1 - x2;
    dy = y1 - y2;

    ds = dx * dx + dy * dy;
    
    dt = sqrt(ds);
#if CROP_CALCU_DETAIL
    printf("[DISN] output - ds = %lf \n", ds);    
#endif
    return dt;
}

static CFLOAT calcuVectorDistancePoint(CFLOAT *vec, CFLOAT *p) 
{
    CFLOAT dist=0;
    int ret=0;
    CFLOAT rectVect[3];
    CFLOAT crossPnt[3];
    
    ret = getRectVectorFromV(rectVect, p, vec);
    if (ret < 0) {
        return -1;
    }

    ret = getCross(vec, rectVect, crossPnt);
    if (ret < 0) {
        return -2;
    }

    dist = calcuDistance(p, crossPnt);

    return dist;
}

static CFLOAT calcuLineGroupDist(CFLOAT *pGrp, CFLOAT *vecTr, int gpLen) 
{
    CFLOAT dist=0, sumDist=0, cnt=0, avgDist=0;
    int i=0, len=0;

    if (vecTr == 0) return -1;
    if (pGrp == 0) return -2;

    len = gpLen;
    if (len == 0) return -3;
    
    for (i = 0; i < len; i++) {
        dist = calcuVectorDistancePoint(vecTr, pGrp + i*2);
        sumDist += dist;
        cnt += 1;
    }
    avgDist = sumDist / cnt;

    return avgDist;
}

static CFLOAT calcuLineGroupDistAlign(CFLOAT *pGrp, CFLOAT *vecTr, int gpLen, CFLOAT limit, int *limcnt) {
    CFLOAT dist = 0, sumDist = 0, cnt = 0, avgDist = 0;
    int i = 0, len = 0, lmcnt=0;

    if (vecTr == 0) return -1;
    if (pGrp == 0) return -2;

    len = gpLen;
    if (len == 0) return -3;

    for (i = 0; i < len; i++) {
        dist = calcuVectorDistancePoint(vecTr, pGrp + i * 2);

        if (dist < limit) {
            lmcnt += 1;
        }

        sumDist += dist;

        #if CROP_CALCU_DETAIL
        printf("[Gline] align %d - dist = %.2lf \n", i, dist);
        #endif
		
        cnt += 1;
    }

    *limcnt = lmcnt;

    avgDist = sumDist / cnt;

    return avgDist;
}

static int calcuGroupLineAlign(CFLOAT *pGrp, CFLOAT *vecTr, CFLOAT *div, int gpLen, CFLOAT limit, int midx) {
    CFLOAT dist = 0, sumDist = 0, avgDist = 0;
    int head = 0, tail = 0, cur = 0;
    int len = 0, ret = 0, idx = 0;
    int i = 0, cnt = 0, cntDist = 0;
    int gbegin = 0, gend = 0;
    CFLOAT *p1, *p2, minDist;
    int limtcnt=0, maxcnt=0;

    len = gpLen;
    if (vecTr == 0) return -1;

    if (len == 0) return -2;

    head = 0;
    tail = len - 1;
#if CROP_CALCU_DETAIL
    printf("[Gline] gplen = %d ,head = %d, tail = %d\n", len, head, tail);
#endif
    CFLOAT *avd = (CFLOAT *) aspMemalloc(sizeof(CFLOAT) * (tail - head), midx);
    int *avcnt = (int *) aspMemalloc(sizeof(int) * (tail - head), midx);
    int *avList = (int *) aspMemalloc(sizeof(int) * (tail - head) * 2, midx);
	memset(avd, 0, sizeof(CFLOAT) * (tail - head));
	memset(avList, 0, sizeof(int) * (tail - head) * 2);

    cntDist = 0;
    while ((tail - head) > 3) {
        p1 = &pGrp[head * 2];
        p2 = &pGrp[tail * 2];

        ret = getVectorFromP(vecTr, p1, p2);
        if (ret < 0) {
            return -3;
        }

        //avgDist = calcuLineGroupDist(pGrp, vecTr, len);
        avgDist = calcuLineGroupDistAlign(pGrp, vecTr, len, limit, &limtcnt);

        avcnt[cntDist] = limtcnt;
        avd[cntDist] = avgDist;
        avList[cntDist * 2 + 0] = head;
        avList[cntDist * 2 + 1] = tail;
        cntDist++;

        if (cur == head) {
            tail -= 1;
            cur = tail;
        } else {
            head += 1;
            cur = head;
        }

        //Log.e(TAG, "group head = "+head+", tail = "+tail);

    }

    idx = -1;
    minDist = 0;
    maxcnt = 0;
    for (i = 0; i < cntDist; i++) {
        if (idx < 0) {
            idx = i;
            maxcnt = avcnt[i];
        } else {
            if (maxcnt < avcnt[i]) {
                maxcnt = avcnt[i];
                idx = i;
            }
        }
#if CROP_CALCU_DETAIL
        printf("[Gline] group limit count= %d, head = %d, tail = %d \n", avcnt[i], avList[i * 2 + 0], avList[i * 2 + 1]);
#endif
    }

#if CROP_CALCU_DETAIL
    printf("[Gline] max cnt idx = %d, max cnt = %d, head = %d, tail = %d dist: %.2lf\n",
                        idx, maxcnt, avList[idx * 2 + 0], avList[idx * 2 + 1], avd[idx]);
#endif

    if (idx < 0) {
        return -5;
    }
    
    div[0] = avd[idx];

    head = avList[idx * 2 + 0];
    tail = avList[idx * 2 + 1];

    p1 = &pGrp[head * 2];
    p2 = &pGrp[tail * 2];
    aspMemFree(avd, midx);
    aspMemFree(avcnt, midx);
    aspMemFree(avList, midx);

    ret = getVectorFromP(vecTr, p1, p2);
    if (ret < 0) {
        return -4;
    }

    return maxcnt;
}

static int calcuGroupLine(CFLOAT *pGrp, CFLOAT *vecTr, CFLOAT *div, int gpLen, int midx) 
{
    CFLOAT dist=0, sumDist=0, avgDist=0;
    int head=0, tail=0, cur=0;
    int len=0, ret=0, minIdx=0;
    int i=0, cnt=0, cntDist=0;
    int gbegin=0, gend=0;
    CFLOAT *p1, *p2, minDist;

    len = gpLen;
    if (vecTr == 0) return -1;
    
    if (len == 0) return -2;
    
    head = 0;
    tail = len - 1;
#if CROP_CALCU_DETAIL
    printf("[Gline] gplen = %d ,head = %d, tail = %d\n", len, head, tail);    
#endif
    CFLOAT *avd;
    avd = (CFLOAT *)aspMemalloc(sizeof(CFLOAT) * (tail - head), midx);
    int *avList;
    avList = (int *)aspMemalloc(sizeof(int) * (tail - head) * 2, midx);
    
    cntDist = 0;
    while ((tail - head) > 1) {
        p1 = &pGrp[head * 2];
        p2 = &pGrp[tail * 2];
        
        ret = getVectorFromP(vecTr,  p1,  p2);
        if (ret < 0) {
            return -3;
        }

        avgDist = calcuLineGroupDist(pGrp, vecTr, len);

        avd[cntDist] = avgDist;
        avList[cntDist * 2 + 0] = head;
        avList[cntDist * 2 + 1] = tail;
        cntDist++;

        if (cur == head) {
            tail -= 1;
            cur = tail;
        } else {
            head += 1;
            cur = head;
        }

        //Log.e(TAG, "group head = "+head+", tail = "+tail);    
        
    }

    minIdx = -1;
    minDist = 0;
    for (i = 0; i < cntDist; i++) {
        if (minIdx < 0) {
            minIdx = i;
            minDist = avd[i];
        } else {
            if (minDist > avd[i]) {
                minDist = avd[i];
                minIdx = i;
            }
        }
#if CROP_CALCU_DETAIL
        printf("[Gline] group avg= %lf, head = %d, tail = %d \n", avd[i], avList[i*2+0], avList[i*2+1]);    
#endif
    }

#if CROP_CALCU_DETAIL
    printf("[Gline] min idx = %d, min avg = %d, head = %d, tail = %d limit: %lf\n", minIdx, (int)minDist, avList[minIdx*2+0], avList[minIdx*2+1], (1.333  * (CFLOAT) len));    
#endif

    div[0] = minDist;

    #if 0
    if (minDist > (1.333  * (CFLOAT) len)) {
        return (0 - (int)round(minDist));
    }
    #endif

    head = avList[minIdx*2+0];
    tail = avList[minIdx*2+1];

    p1 = &pGrp[head*2];
    p2 = &pGrp[tail*2];

    aspMemFree(avd, midx);
    aspMemFree(avList, midx);
    
    ret = getVectorFromP(vecTr,  p1,  p2);
    if (ret < 0) {
        return -4;
    }

    return 0;
}

static int calcuCrossUpAph(struct aspCrop36_s *pcp36, int midx) 
{
#define UP_NUM 3
#define PT_NUM 40
    int idxALLLf[] = {6, 7, 9, 11, 13, 15, 17, 2};
    int idxALLRt[] = {5, 8, 10, 12, 14, 16, 18, 3};
    
    int ret=0;
    int i=0, j=0, Lc=0, Rc=0;
    CFLOAT pn[PT_NUM];
    CFLOAT plu[UP_NUM*2];
    CFLOAT pru[UP_NUM*2];

    if (!pcp36) return -1;
    msync(pcp36, sizeof(struct aspCrop36_s), MS_SYNC);
    
    memcpy(pn, pcp36->crp36Pots, sizeof(CFLOAT)*PT_NUM);
    
    for (i = 0, j = 0; i < UP_NUM; i++, j++) {
        Lc = idxALLLf[i];
        Rc = idxALLRt[i];
        plu[j*2+0] = pn[Lc*2+0];
        plu[j*2+1] = pn[Lc*2+1];

        pru[j*2+0] = pn[Rc*2+0];
        pru[j*2+1] = pn[Rc*2+1];
#if LOG_CROP_CROSUP
        printf( "[csUP] %d. (LU) copy (%d), %lf,  %lf (RU) copy (%d), %lf,  %lf\n", j, Lc, round(plu[j*2+0]), round(plu[j*2+1]), Rc, round(pru[j*2+0]), round(pru[j*2+1]));    
#endif

    }

    CFLOAT vlu[3];
    CFLOAT divLU;
    CFLOAT vru[3];
    CFLOAT divRU;

    ret = calcuGroupLine(plu, vlu, &divLU, UP_NUM, midx);
    if (ret == 0) {
#if LOG_CROP_CROSUP
        printf("[csUP] succeed to get group line vLU, divLU = %lf \n", divLU);    
#endif
    } else {
#if LOG_CROP_CROSUP
        printf("[csUP] failed to get group line vLU, ret = %d \n", ret);    
#endif
        return -2;
    }

    ret = calcuGroupLine(pru, vru, &divRU, UP_NUM, midx);
    if (ret == 0) {
#if LOG_CROP_CROSUP
        printf("[csUP] succeed to get group line vRU, divRU = %lf\n", divRU);
#endif
    } else {
#if LOG_CROP_CROSUP
        printf("[csUP] WARNNING!!! failed to get group line vRU, ret = %d \n", ret);    
#endif
        return -3;
    }

    CFLOAT cosUp[2];

    ret = getCross(vlu, vru, cosUp);
    if (ret == 0) {
#if LOG_CROP_CROSUP
        printf("[csUP ]succeed to get cross up = (%lf, %lf)\n", cosUp[0], cosUp[1]);
#endif
    } else {
#if LOG_CROP_CROSUP
        printf("[csUP] WARNNING!!! failed to get cross up, ret = %d\n", ret);
#endif
        return -4;
    }

    memcpy(pcp36->crp36CsUp, cosUp, sizeof(CFLOAT)*2);

    return 0;
}

#define LOG_RECTALIGN_RT_EN (1)
static CFLOAT getRectAlignRT(struct aspRectObj *pRectin, CFLOAT *p1, CFLOAT *p2, struct aspRectObj *pRectout)
{
    int fArea=-1, ret=0;
    CFLOAT dh=0, dv=0, dg=-1;
    CFLOAT plf[2]={0};
    CFLOAT piAngle = 180.0, thacos=0, thasin=0, rangle[2], theta=0;
    CFLOAT *pLU, *pLD, *pRU, *pRD;
    CFLOAT *LUn, *RUn, *LDn, *RDn;
    int LUt[2], RUt[2], LDt[2], RDt[2], dht, dvt, p1t[2];

    
    dh = p2[0] - p1[0];
    dv = p2[1] - p1[1];

    if ((dh > 0) && (dh < 0.01)) {
        dh = 0.0;
    }

    if ((dh < 0) && (dh > -0.01)) {
        dh = 0.0;
    }

    if ((dv > 0) && (dv < 0.01)) {
        dv = 0.0;
    }

    if ((dv < 0) && (dv > -0.01)) {
        dv = 0.0;
    }
    
    if ((dh == 0.0) && (dv == 0.0)) {
        return -1;
    }
    
    #if LOG_RECTALIGN_RT_EN
    printf("[RectAlignRT] p1: (%.2lf, %.2lf) p2: (%.2lf, %.2lf) dh: %.2lf dv: %.2lf \n", p1[0], p1[1], p2[0], p2[1], dh, dv);
    #endif

    if (dh == 0.0) {
        if (dv > 0.0) {
            dg = 90.0;
        } else {
            dg = 270.0;
        }
    }
    else if (dv == 0.0) {
        if (dh > 0.0) {
            dg = 0.0;
        } else {
            dg = 180.0;
        }
    } 
    else {
        plf[0] = p1[0];
        plf[1] = p1[1] - 200.0;
        dg = getAngle(p1, plf, p2);

        if ((dh > 0.0) && (dv > 0.0)) {
            dg += 0.0;
            //dg = 360.0 - dg;
        }
        else if ((dh < 0.0) && (dv > 0.0)) {
            //dg += 0.0;
            dg = 360.0 - dg;
        }
        else if ((dh < 0.0) && (dv < 0.0)) {
            //dg += 0.0;
            dg = 360.0 - dg;
        }
        else if ((dh > 0.0) && (dv < 0.0)) {
            dg += 0.0;
            //dg = 360.0 - dg;
        }
    }

    #if LOG_RECTALIGN_RT_EN
    printf("[RectAlignRT] p1: (%.2lf, %.2lf) p2: (%.2lf, %.2lf) plf: (%.2lf, %.2lf) angle: %.2lf \n", p1[0], p1[1], p2[0], p2[1], plf[0], plf[1], dg);
    #endif

    theta = 360.0 - dg;

    theta = theta * M_PI / piAngle;

    thacos = cos(theta);
    thasin = sin(theta);
    
    rangle[0] = thacos;
    rangle[1] = thasin;

    pLU = pRectin->aspRectLU;
    pRU = pRectin->aspRectRU;
    pLD = pRectin->aspRectLD;
    pRD = pRectin->aspRectRD;

    LUn = pRectout->aspRectLU;
    RUn = pRectout->aspRectRU;
    LDn = pRectout->aspRectLD;
    RDn = pRectout->aspRectRD;
    
    ret = calcuRotateCoordinates(LUt, LUn, pLU, rangle);
    #if LOG_RECTALIGN_RT_EN
    printf("[RectAlignRT] pLU: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", pLU[0], pLU[1], LUn[0], LUn[1], ret);
    #endif
    
    ret = calcuRotateCoordinates(RUt, RUn, pRU, rangle);
    #if LOG_RECTALIGN_RT_EN
    printf("[RectAlignRT] pRU: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", pRU[0], pRU[1], RUn[0], RUn[1], ret);
    #endif
    
    ret = calcuRotateCoordinates(LDt, LDn, pLD, rangle);
    #if LOG_RECTALIGN_RT_EN
    printf("[RectAlignRT] pLD: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", pLD[0], pLD[1], LDn[0], LDn[1], ret);
    #endif
    
    ret = calcuRotateCoordinates(RDt, RDn, pRD, rangle);
    #if LOG_RECTALIGN_RT_EN
    printf("[RectAlignRT] pRD: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", pRD[0], pRD[1], RDn[0], RDn[1], ret);
    printf("[RectAlignRT] LU(%d, %d) LD(%d, %d) RD(%d, %d) RU(%d, %d) \n", LUt[0], LUt[1], LDt[0], LDt[1], RDt[0], RDt[1], RUt[0], RUt[1]);
    #endif

    ret = calcuRotateCoordinates(p1t, plf, p1, rangle);
    #if LOG_RECTALIGN_RT_EN
    printf("[RectAlignRT] p1: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", p1[0], p1[1], plf[0], plf[1], ret);
    printf("[RectAlignRT] (%d, %d) (%d, %d) (%d, %d) (%d, %d) \n", LUt[0], LUt[1], LDt[0], LDt[1], RDt[0], RDt[1], RUt[0], RUt[1]);
    #endif
    
    return dg;
}

#define LOG_RECTALIGN_LF_EN (1)
static CFLOAT getRectAlignLF(struct aspRectObj *pRectin, CFLOAT *p1, CFLOAT *p2, struct aspRectObj *pRectout)
{
    int fArea=-1, ret=0;
    CFLOAT dh=0, dv=0, dg=-1;
    CFLOAT plf[2]={0};
    CFLOAT piAngle = 180.0, thacos=0, thasin=0, rangle[2], theta=0;
    CFLOAT *pLU, *pLD, *pRU, *pRD;
    CFLOAT *LUn, *RUn, *LDn, *RDn;
    int LUt[2], RUt[2], LDt[2], RDt[2], dht, dvt, p1t[2];

    
    dh = p2[0] - p1[0];
    dv = p2[1] - p1[1];

    if ((dh > 0) && (dh < 0.01)) {
        dh = 0.0;
    }

    if ((dh < 0) && (dh > -0.01)) {
        dh = 0.0;
    }

    if ((dv > 0) && (dv < 0.01)) {
        dv = 0.0;
    }

    if ((dv < 0) && (dv > -0.01)) {
        dv = 0.0;
    }
    
    if ((dh == 0.0) && (dv == 0.0)) {
        return -1;
    }
    
    #if LOG_RECTALIGN_LF_EN
    printf("[RectAlignLF] p1: (%.2lf, %.2lf) p2: (%.2lf, %.2lf) dh: %.2lf dv: %.2lf \n", p1[0], p1[1], p2[0], p2[1], dh, dv);
    #endif

    if (dh == 0.0) {
        if (dv > 0.0) {
            dg = 90.0;
        } else {
            dg = 270.0;
        }
    }
    else if (dv == 0.0) {
        if (dh > 0.0) {
            dg = 0.0;
        } else {
            dg = 180.0;
        }
    } 
    else {
        plf[0] = p1[0];
        plf[1] = p1[1] + 200.0;
        dg = getAngle(p1, plf, p2);

        if ((dh > 0.0) && (dv > 0.0)) {
            dg = 360.0 - dg;
            //dg += 0.0;
        }
        else if ((dh < 0.0) && (dv > 0.0)) {
            //dg = 360.0 - dg;
            dg += 0.0;
        }
        else if ((dh < 0.0) && (dv < 0.0)) {
            //dg = 360.0 - dg;
            dg += 0.0;
        }
        else if ((dh > 0.0) && (dv < 0.0)) {
            dg = 360.0 - dg;
            //dg += 0.0;
        }
    }

    #if LOG_RECTALIGN_LF_EN
    printf("[RectAlignLF] p1: (%.2lf, %.2lf) p2: (%.2lf, %.2lf) plf: (%.2lf, %.2lf) angle: %.2lf \n", p1[0], p1[1], p2[0], p2[1], plf[0], plf[1], dg);
    #endif

    theta = 360.0 - dg;

    theta = theta * M_PI / piAngle;

    thacos = cos(theta);
    thasin = sin(theta);
    
    rangle[0] = thacos;
    rangle[1] = thasin;

    pLU = pRectin->aspRectLU;
    pRU = pRectin->aspRectRU;
    pLD = pRectin->aspRectLD;
    pRD = pRectin->aspRectRD;

    LUn = pRectout->aspRectLU;
    RUn = pRectout->aspRectRU;
    LDn = pRectout->aspRectLD;
    RDn = pRectout->aspRectRD;
    
    ret = calcuRotateCoordinates(LUt, LUn, pLU, rangle);
    #if LOG_RECTALIGN_LF_EN
    printf("[RectAlignLF] pLU: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", pLU[0], pLU[1], LUn[0], LUn[1], ret);
    #endif
    
    ret = calcuRotateCoordinates(RUt, RUn, pRU, rangle);
    #if LOG_RECTALIGN_LF_EN
    printf("[RectAlignLF] pRU: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", pRU[0], pRU[1], RUn[0], RUn[1], ret);
    #endif
    
    ret = calcuRotateCoordinates(LDt, LDn, pLD, rangle);
    #if LOG_RECTALIGN_LF_EN
    printf("[RectAlignLF] pLD: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", pLD[0], pLD[1], LDn[0], LDn[1], ret);
    #endif
    
    ret = calcuRotateCoordinates(RDt, RDn, pRD, rangle);
    #if LOG_RECTALIGN_LF_EN
    printf("[RectAlignLF] pRD: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", pRD[0], pRD[1], RDn[0], RDn[1], ret);
    printf("[RectAlignLF] LU(%d, %d) LD(%d, %d) RD(%d, %d) RU(%d, %d) \n", LUt[0], LUt[1], LDt[0], LDt[1], RDt[0], RDt[1], RUt[0], RUt[1]);
    #endif

    ret = calcuRotateCoordinates(p1t, plf, p1, rangle);
    #if LOG_RECTALIGN_LF_EN
    printf("[RectAlignLF] p1: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", p1[0], p1[1], plf[0], plf[1], ret);
    printf("[RectAlignLF] (%d, %d) (%d, %d) (%d, %d) (%d, %d) \n", LUt[0], LUt[1], LDt[0], LDt[1], RDt[0], RDt[1], RUt[0], RUt[1]);
    #endif
    
    return dg;
}

#define LOG_RECTALIGN_DN_EN (0)
static CFLOAT getRectAlignDN(struct aspRectObj *pRectin, CFLOAT *p1, CFLOAT *p2, struct aspRectObj *pRectout)
{
    int fArea=-1, ret=0;
    CFLOAT dh=0, dv=0, dg=-1;
    CFLOAT plf[2]={0};
    CFLOAT piAngle = 180.0, thacos=0, thasin=0, rangle[2], theta=0;
    CFLOAT *pLU, *pLD, *pRU, *pRD;
    CFLOAT *LUn, *RUn, *LDn, *RDn;
    int LUt[2], RUt[2], LDt[2], RDt[2], dht, dvt, p1t[2];

    
    dh = p2[0] - p1[0];
    dv = p2[1] - p1[1];

    if ((dh > 0) && (dh < 0.01)) {
        dh = 0.0;
    }

    if ((dh < 0) && (dh > -0.01)) {
        dh = 0.0;
    }

    if ((dv > 0) && (dv < 0.01)) {
        dv = 0.0;
    }

    if ((dv < 0) && (dv > -0.01)) {
        dv = 0.0;
    }
    
    if ((dh == 0.0) && (dv == 0.0)) {
        return -1;
    }
    
    #if LOG_RECTALIGN_DN_EN
    printf("[RectAlignDN] p1: (%.2lf, %.2lf) p2: (%.2lf, %.2lf) dh: %.2lf dv: %.2lf \n", p1[0], p1[1], p2[0], p2[1], dh, dv);
    #endif

    if (dh == 0.0) {
        if (dv > 0.0) {
            dg = 90.0;
        } else {
            dg = 270.0;
        }
    }
    else if (dv == 0.0) {
        if (dh > 0.0) {
            dg = 0.0;
        } else {
            dg = 180.0;
        }
    } 
    else {
        plf[0] = p1[0] - 200.0;
        plf[1] = p1[1];
        dg = getAngle(p1, plf, p2);

        if ((dh > 0.0) && (dv > 0.0)) {
            //dg += 0.0;
            dg = 360.0 - dg;
        }
        else if ((dh < 0.0) && (dv > 0.0)) {
            //dg += 0.0;
            dg = 360.0 - dg;
        }
        else if ((dh < 0.0) && (dv < 0.0)) {
            dg += 0.0;
            //dg = 360.0 - dg;
        }
        else if ((dh > 0.0) && (dv < 0.0)) {
            dg += 0.0;
            //dg = 360.0 - dg;
        }
    }

    #if LOG_RECTALIGN_DN_EN
    printf("[RectAlignDN] p1: (%.2lf, %.2lf) p2: (%.2lf, %.2lf) plf: (%.2lf, %.2lf) angle: %.2lf \n", p1[0], p1[1], p2[0], p2[1], plf[0], plf[1], dg);
    #endif

    theta = 360.0 - dg;

    theta = theta * M_PI / piAngle;

    thacos = cos(theta);
    thasin = sin(theta);
    
    rangle[0] = thacos;
    rangle[1] = thasin;

    pLU = pRectin->aspRectLU;
    pRU = pRectin->aspRectRU;
    pLD = pRectin->aspRectLD;
    pRD = pRectin->aspRectRD;

    LUn = pRectout->aspRectLU;
    RUn = pRectout->aspRectRU;
    LDn = pRectout->aspRectLD;
    RDn = pRectout->aspRectRD;
    
    ret = calcuRotateCoordinates(LUt, LUn, pLU, rangle);
    #if LOG_RECTALIGN_DN_EN
    printf("[RectAlignDN] pLU: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", pLU[0], pLU[1], LUn[0], LUn[1], ret);
    #endif
    
    ret = calcuRotateCoordinates(RUt, RUn, pRU, rangle);
    #if LOG_RECTALIGN_DN_EN
    printf("[RectAlignDN] pRU: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", pRU[0], pRU[1], RUn[0], RUn[1], ret);
    #endif
    
    ret = calcuRotateCoordinates(LDt, LDn, pLD, rangle);
    #if LOG_RECTALIGN_DN_EN
    printf("[RectAlignDN] pLD: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", pLD[0], pLD[1], LDn[0], LDn[1], ret);
    #endif
    
    ret = calcuRotateCoordinates(RDt, RDn, pRD, rangle);
    #if LOG_RECTALIGN_DN_EN
    printf("[RectAlignDN] pRD: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", pRD[0], pRD[1], RDn[0], RDn[1], ret);
    printf("[RectAlignDN] LU(%d, %d) LD(%d, %d) RD(%d, %d) RU(%d, %d) \n", LUt[0], LUt[1], LDt[0], LDt[1], RDt[0], RDt[1], RUt[0], RUt[1]);
    #endif

    ret = calcuRotateCoordinates(p1t, plf, p1, rangle);
    #if LOG_RECTALIGN_DN_EN
    printf("[RectAlignDN] p1: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", p1[0], p1[1], plf[0], plf[1], ret);
    printf("[RectAlignDN] (%d, %d) (%d, %d) (%d, %d) (%d, %d) \n", LUt[0], LUt[1], LDt[0], LDt[1], RDt[0], RDt[1], RUt[0], RUt[1]);
    #endif
    
    return dg;
}

#define LOG_RECTALIGN_TP_EN (0)
static CFLOAT getRectAlignTP(struct aspRectObj *pRectin, CFLOAT *p1, CFLOAT *p2, struct aspRectObj *pRectout)
{
    int fArea=-1, ret=0;
    CFLOAT dh=0, dv=0, dg=-1;
    CFLOAT plf[2]={0};
    CFLOAT piAngle = 180.0, thacos=0, thasin=0, rangle[2], theta=0;
    CFLOAT *pLU, *pLD, *pRU, *pRD;
    CFLOAT *LUn, *RUn, *LDn, *RDn;
    int LUt[2], RUt[2], LDt[2], RDt[2], dht, dvt, p1t[2];

    
    dh = p2[0] - p1[0];
    dv = p2[1] - p1[1];

    if ((dh > 0) && (dh < 0.01)) {
        dh = 0.0;
    }

    if ((dh < 0) && (dh > -0.01)) {
        dh = 0.0;
    }

    if ((dv > 0) && (dv < 0.01)) {
        dv = 0.0;
    }

    if ((dv < 0) && (dv > -0.01)) {
        dv = 0.0;
    }
    
    if ((dh == 0.0) && (dv == 0.0)) {
        return -1;
    }
    
    #if LOG_RECTALIGN_TP_EN
    printf("[RectAlignTP] p1: (%.2lf, %.2lf) p2: (%.2lf, %.2lf) dh: %.2lf dv: %.2lf \n", p1[0], p1[1], p2[0], p2[1], dh, dv);
    #endif

    if (dh == 0.0) {
        if (dv > 0.0) {
            dg = 90.0;
        } else {
            dg = 270.0;
        }
    }
    else if (dv == 0.0) {
        if (dh > 0.0) {
            dg = 0.0;
        } else {
            dg = 180.0;
        }
    } 
    else {
        plf[0] = p1[0] + 200.0;
        plf[1] = p1[1];
        dg = getAngle(p1, plf, p2);

        if ((dh > 0.0) && (dv > 0.0)) {
            dg += 0.0;
            //dg = 360.0 - dg;
        }
        else if ((dh < 0.0) && (dv > 0.0)) {
            dg += 0.0;
            //dg = 360.0 - dg;
        }
        else if ((dh < 0.0) && (dv < 0.0)) {
            //dg += 0.0;
            dg = 360.0 - dg;
        }
        else if ((dh > 0.0) && (dv < 0.0)) {
            //dg += 0.0;
            dg = 360.0 - dg;
        }
    }

    #if LOG_RECTALIGN_TP_EN
    printf("[RectAlignTP] p1: (%.2lf, %.2lf) p2: (%.2lf, %.2lf) plf: (%.2lf, %.2lf) angle: %.2lf \n", p1[0], p1[1], p2[0], p2[1], plf[0], plf[1], dg);
    #endif

    theta = 360.0 - dg;

    theta = theta * M_PI / piAngle;

    thacos = cos(theta);
    thasin = sin(theta);
    
    rangle[0] = thacos;
    rangle[1] = thasin;

    pLU = pRectin->aspRectLU;
    pRU = pRectin->aspRectRU;
    pLD = pRectin->aspRectLD;
    pRD = pRectin->aspRectRD;

    LUn = pRectout->aspRectLU;
    RUn = pRectout->aspRectRU;
    LDn = pRectout->aspRectLD;
    RDn = pRectout->aspRectRD;
    
    ret = calcuRotateCoordinates(LUt, LUn, pLU, rangle);
    #if LOG_RECTALIGN_TP_EN
    printf("[RectAlignTP] pLU: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", pLU[0], pLU[1], LUn[0], LUn[1], ret);
    #endif
    
    ret = calcuRotateCoordinates(RUt, RUn, pRU, rangle);
    #if LOG_RECTALIGN_TP_EN
    printf("[RectAlignTP] pRU: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", pRU[0], pRU[1], RUn[0], RUn[1], ret);
    #endif
    
    ret = calcuRotateCoordinates(LDt, LDn, pLD, rangle);
    #if LOG_RECTALIGN_TP_EN
    printf("[RectAlignTP] pLD: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", pLD[0], pLD[1], LDn[0], LDn[1], ret);
    #endif
    
    ret = calcuRotateCoordinates(RDt, RDn, pRD, rangle);
    #if LOG_RECTALIGN_TP_EN
    printf("[RectAlignTP] pRD: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", pRD[0], pRD[1], RDn[0], RDn[1], ret);
    printf("[RectAlignTP] LU(%d, %d) LD(%d, %d) RD(%d, %d) RU(%d, %d) \n", LUt[0], LUt[1], LDt[0], LDt[1], RDt[0], RDt[1], RUt[0], RUt[1]);
    #endif

    ret = calcuRotateCoordinates(p1t, plf, p1, rangle);
    #if LOG_RECTALIGN_TP_EN
    printf("[RectAlignTP] p1: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", p1[0], p1[1], plf[0], plf[1], ret);
    printf("[RectAlignTP] (%d, %d) (%d, %d) (%d, %d) (%d, %d) \n", LUt[0], LUt[1], LDt[0], LDt[1], RDt[0], RDt[1], RUt[0], RUt[1]);
    #endif
    
    return dg;
}

#define LOG_RECTALIGN_ORG_EN (0)
static CFLOAT getRectAlignOrg(struct aspRectObj *pRectin, CFLOAT *p1, CFLOAT *p2, struct aspRectObj *pRectout)
{
    int fArea=-1, ret=0;
    CFLOAT dh=0, dv=0, dg=-1;
    CFLOAT plf[2]={0};
    CFLOAT piAngle = 180.0, thacos=0, thasin=0, rangle[2], theta=0;
    CFLOAT *pLU, *pLD, *pRU, *pRD;
    CFLOAT *LUn, *RUn, *LDn, *RDn;
    int LUt[2], RUt[2], LDt[2], RDt[2], dht, dvt, p1t[2];

    
    dh = p2[0] - p1[0];
    dv = p2[1] - p1[1];

    if ((dh > 0) && (dh < 0.01)) {
        dh = 0.0;
    }

    if ((dh < 0) && (dh > -0.01)) {
        dh = 0.0;
    }

    if ((dv > 0) && (dv < 0.01)) {
        dv = 0.0;
    }

    if ((dv < 0) && (dv > -0.01)) {
        dv = 0.0;
    }
    
    if ((dh == 0.0) && (dv == 0.0)) {
        return -1;
    }
    
    #if LOG_RECTALIGN_ORG_EN
    printf("[RectAlign] p1: (%.2lf, %.2lf) p2: (%.2lf, %.2lf) dh: %.2lf dv: %.2lf \n", p1[0], p1[1], p2[0], p2[1], dh, dv);
    #endif

    if (dh == 0.0) {
        if (dv > 0.0) {
            dg = 90.0;
        } else {
            dg = 270.0;
        }
    }
    else if (dv == 0.0) {
        if (dh > 0.0) {
            dg = 0.0;
        } else {
            dg = 180.0;
        }
    } 
    else {
        plf[0] = p1[0] + 200.0;
        plf[1] = p1[1];
        dg = getAngle(p1, plf, p2);

        if ((dh > 0.0) && (dv > 0.0)) {
            dg += 0.0;
            //dg = 360.0 - dg;
        }
        else if ((dh < 0.0) && (dv > 0.0)) {
            dg += 0.0;
            //dg = 360.0 - dg;
        }
        else if ((dh < 0.0) && (dv < 0.0)) {
            //dg += 0.0;
            dg = 360.0 - dg;
        }
        else if ((dh > 0.0) && (dv < 0.0)) {
            //dg += 0.0;
            dg = 360.0 - dg;
        }
    }

    #if LOG_RECTALIGN_ORG_EN
    printf("[RectAlign] p1: (%.2lf, %.2lf) p2: (%.2lf, %.2lf) plf: (%.2lf, %.2lf) angle: %.2lf \n", p1[0], p1[1], p2[0], p2[1], plf[0], plf[1], dg);
    #endif

    theta = 360.0 - dg;

    theta = theta * M_PI / piAngle;

    thacos = cos(theta);
    thasin = sin(theta);
    
    rangle[0] = thacos;
    rangle[1] = thasin;

    pLU = pRectin->aspRectLU;
    pRU = pRectin->aspRectRU;
    pLD = pRectin->aspRectLD;
    pRD = pRectin->aspRectRD;

    LUn = pRectout->aspRectLU;
    RUn = pRectout->aspRectRU;
    LDn = pRectout->aspRectLD;
    RDn = pRectout->aspRectRD;
    
    ret = calcuRotateCoordinates(LUt, LUn, pLU, rangle);
    #if LOG_RECTALIGN_ORG_EN
    printf("[RectAlign] pLU: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", pLU[0], pLU[1], LUn[0], LUn[1], ret);
    #endif
    
    ret = calcuRotateCoordinates(RUt, RUn, pRU, rangle);
    #if LOG_RECTALIGN_ORG_EN
    printf("[RectAlign] pRU: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", pRU[0], pRU[1], RUn[0], RUn[1], ret);
    #endif
    
    ret = calcuRotateCoordinates(LDt, LDn, pLD, rangle);
    #if LOG_RECTALIGN_ORG_EN
    printf("[RectAlign] pLD: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", pLD[0], pLD[1], LDn[0], LDn[1], ret);
    #endif
    
    ret = calcuRotateCoordinates(RDt, RDn, pRD, rangle);
    #if LOG_RECTALIGN_ORG_EN
    printf("[RectAlign] pRD: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", pRD[0], pRD[1], RDn[0], RDn[1], ret);
    printf("[RectAlign] LU(%d, %d) LD(%d, %d) RD(%d, %d) RU(%d, %d) \n", LUt[0], LUt[1], LDt[0], LDt[1], RDt[0], RDt[1], RUt[0], RUt[1]);
    #endif

    ret = calcuRotateCoordinates(p1t, plf, p1, rangle);
    #if LOG_RECTALIGN_ORG_EN
    printf("[RectAlign] p1: (%4.2lf, %4.2lf) -> (%4.2lf, %4.2lf) ret: %d\n", p1[0], p1[1], plf[0], plf[1], ret);
    printf("[RectAlign] (%d, %d) (%d, %d) (%d, %d) (%d, %d) \n", LUt[0], LUt[1], LDt[0], LDt[1], RDt[0], RDt[1], RUt[0], RUt[1]);
    #endif
    
    return dg;
}

#define LOG_RECTOFFSET_EN (0)
static CFLOAT getRectOffsetOrg(struct aspRectObj *pRectout, struct aspRectObj *pRectin, struct aspRectObj *pRectorg, CFLOAT *offset)
{
    CFLOAT offsetH, offsetV;
    CFLOAT *pLU, *pLD, *pRD, *pRU;
    CFLOAT *LUn, *RUn, *LDn, *RDn;
    CFLOAT divH=0, divV=0, diff=0;
    CFLOAT minH, minV;

    pLU = pRectout->aspRectLU;
    pRU = pRectout->aspRectRU;
    pLD = pRectout->aspRectLD;
    pRD = pRectout->aspRectRD;
    
    LUn = pRectin->aspRectLU;
    RUn = pRectin->aspRectRU;
    LDn = pRectin->aspRectLD;
    RDn = pRectin->aspRectRD;
    
    offsetH = LDn[0] - 1;
    offsetV = LDn[1] - 1;

    pLU[0] = LUn[0] - offsetH;
    pLU[1] = LUn[1] - offsetV;

    pLD[0] = LDn[0] - offsetH;
    pLD[1] = LDn[1] - offsetV;

    pRD[0] = RDn[0] - offsetH;
    pRD[1] = RDn[1] - offsetV;

    pRU[0] = RUn[0] - offsetH;
    pRU[1] = RUn[1] - offsetV;

    #if LOG_RECTOFFSET_EN
    printf("[offset] simulate LU(%4.2lf, %4.2lf) LD(%4.2lf, %4.2lf) RD(%4.2lf, %4.2lf) RU(%4.2lf, %4.2lf) offH: %.2lf offV: %.2lf \n", 
        pLU[0], pLU[1], pLD[0], pLD[1], pRD[0], pRD[1], pRU[0], pRU[1], offsetH, offsetV);
    #endif

    diff = fabs(pLU[0] - pRectorg->aspRectLU[0]);
    divH += diff;

    diff = fabs(pLD[0] - pRectorg->aspRectLD[0]);
    divH += diff;

    diff = fabs(pRD[0] - pRectorg->aspRectRD[0]);
    divH += diff;

    diff = fabs(pRU[0] - pRectorg->aspRectRU[0]);
    divH += diff;

    diff = fabs(pLU[1] - pRectorg->aspRectLU[1]);
    divV += diff;

    diff = fabs(pLD[1] - pRectorg->aspRectLD[1]);
    divV += diff;

    diff = fabs(pRD[1] - pRectorg->aspRectRD[1]);
    divV += diff;

    diff = fabs(pRU[1] - pRectorg->aspRectRU[1]);
    divV += diff;

    diff = (divH + divV) / 2.0;

    offset[0] = offsetH;
    offset[1] = offsetV;
    
    return diff;
}

#define LOG_RECTOFFSET_TP_EN (0)
static CFLOAT getRectOffsetTP(struct aspRectObj *pRectout, struct aspRectObj *pRectin, struct aspRectObj *pRectorg, CFLOAT *offset)
{
    CFLOAT offsetH, offsetV;
    CFLOAT *pLU, *pLD, *pRD, *pRU;
    CFLOAT *LUn, *RUn, *LDn, *RDn;
    CFLOAT divH=0, divV=0, diff=0;
    CFLOAT minH, minV;

    pLU = pRectout->aspRectLU;
    pRU = pRectout->aspRectRU;
    pLD = pRectout->aspRectLD;
    pRD = pRectout->aspRectRD;
    
    LUn = pRectin->aspRectLU;
    RUn = pRectin->aspRectRU;
    LDn = pRectin->aspRectLD;
    RDn = pRectin->aspRectRD;

    offsetH = LUn[0] - pRectorg->aspRectLU[0];
    offsetV = LUn[1] - pRectorg->aspRectLU[1];

    #if LOG_RECTOFFSET_TP_EN
    printf("[offsetTp] select LU(%4.2lf, %4.2lf) LD(%4.2lf, %4.2lf) RD(%4.2lf, %4.2lf) RU(%4.2lf, %4.2lf) offH: %.2lf offV: %.2lf \n", 
        pLU[0], pLU[1], pLD[0], pLD[1], pRD[0], pRD[1], pRU[0], pRU[1], offsetH, offsetV);
    #endif

    pLU[0] = LUn[0] - offsetH;
    pLU[1] = LUn[1] - offsetV;

    pLD[0] = LDn[0] - offsetH;
    pLD[1] = LDn[1] - offsetV;

    pRD[0] = RDn[0] - offsetH;
    pRD[1] = RDn[1] - offsetV;

    pRU[0] = RUn[0] - offsetH;
    pRU[1] = RUn[1] - offsetV;

    #if LOG_RECTOFFSET_TP_EN
    printf("[offsetTp] simulate LU(%4.2lf, %4.2lf) LD(%4.2lf, %4.2lf) RD(%4.2lf, %4.2lf) RU(%4.2lf, %4.2lf) offH: %.2lf offV: %.2lf \n", 
        pLU[0], pLU[1], pLD[0], pLD[1], pRD[0], pRD[1], pRU[0], pRU[1], offsetH, offsetV);
    #endif

    diff = fabs(pLU[0] - pRectorg->aspRectLU[0]);
    divH += diff;

    diff = fabs(pLD[0] - pRectorg->aspRectLD[0]);
    divH += diff;

    diff = fabs(pRD[0] - pRectorg->aspRectRD[0]);
    divH += diff;

    diff = fabs(pRU[0] - pRectorg->aspRectRU[0]);
    divH += diff;

    diff = fabs(pLU[1] - pRectorg->aspRectLU[1]);
    divV += diff;

    diff = fabs(pLD[1] - pRectorg->aspRectLD[1]);
    divV += diff;

    diff = fabs(pRD[1] - pRectorg->aspRectRD[1]);
    divV += diff;

    diff = fabs(pRU[1] - pRectorg->aspRectRU[1]);
    divV += diff;

    diff = (divH + divV) / 2.0;

    offset[0] = offsetH;
    offset[1] = offsetV;
    
    return diff;
}

#define LOG_RECTOFFSET_DN_EN (0)
static CFLOAT getRectOffsetDn(struct aspRectObj *pRectout, struct aspRectObj *pRectin, struct aspRectObj *pRectorg, CFLOAT *offset)
{
    CFLOAT offsetH, offsetV;
    CFLOAT *pLU, *pLD, *pRD, *pRU;
    CFLOAT *LUn, *RUn, *LDn, *RDn;
    CFLOAT divH=0, divV=0, diff=0;
    CFLOAT minH, minV;

    pLU = pRectout->aspRectLU;
    pRU = pRectout->aspRectRU;
    pLD = pRectout->aspRectLD;
    pRD = pRectout->aspRectRD;
    
    LUn = pRectin->aspRectLU;
    RUn = pRectin->aspRectRU;
    LDn = pRectin->aspRectLD;
    RDn = pRectin->aspRectRD;
    
    offsetH = LDn[0] - pRectorg->aspRectLD[0];
    offsetV = LDn[1] - pRectorg->aspRectLD[1];

    pLU[0] = LUn[0] - offsetH;
    pLU[1] = LUn[1] - offsetV;

    pLD[0] = LDn[0] - offsetH;
    pLD[1] = LDn[1] - offsetV;

    pRD[0] = RDn[0] - offsetH;
    pRD[1] = RDn[1] - offsetV;

    pRU[0] = RUn[0] - offsetH;
    pRU[1] = RUn[1] - offsetV;

    #if LOG_RECTOFFSET_DN_EN
    printf("[offsetDn] simulate LU(%4.2lf, %4.2lf) LD(%4.2lf, %4.2lf) RD(%4.2lf, %4.2lf) RU(%4.2lf, %4.2lf) offH: %.2lf offV: %.2lf \n", 
        pLU[0], pLU[1], pLD[0], pLD[1], pRD[0], pRD[1], pRU[0], pRU[1], offsetH, offsetV);
    #endif

    diff = fabs(pLU[0] - pRectorg->aspRectLU[0]);
    divH += diff;

    diff = fabs(pLD[0] - pRectorg->aspRectLD[0]);
    divH += diff;

    diff = fabs(pRD[0] - pRectorg->aspRectRD[0]);
    divH += diff;

    diff = fabs(pRU[0] - pRectorg->aspRectRU[0]);
    divH += diff;

    diff = fabs(pLU[1] - pRectorg->aspRectLU[1]);
    divV += diff;

    diff = fabs(pLD[1] - pRectorg->aspRectLD[1]);
    divV += diff;

    diff = fabs(pRD[1] - pRectorg->aspRectRD[1]);
    divV += diff;

    diff = fabs(pRU[1] - pRectorg->aspRectRU[1]);
    divV += diff;

    diff = (divH + divV) / 2.0;

    offset[0] = offsetH;
    offset[1] = offsetV;
    
    return diff;
}

#define LOG_RECTOFFSET_LF_EN (0)
static CFLOAT getRectOffsetLf(struct aspRectObj *pRectout, struct aspRectObj *pRectin, struct aspRectObj *pRectorg, CFLOAT *offset)
{
    CFLOAT offsetH, offsetV;
    CFLOAT *pLU, *pLD, *pRD, *pRU;
    CFLOAT *LUn, *RUn, *LDn, *RDn;
    CFLOAT divH=0, divV=0, diff=0;
    CFLOAT minH, minV;

    pLU = pRectout->aspRectLU;
    pRU = pRectout->aspRectRU;
    pLD = pRectout->aspRectLD;
    pRD = pRectout->aspRectRD;
    
    LUn = pRectin->aspRectLU;
    RUn = pRectin->aspRectRU;
    LDn = pRectin->aspRectLD;
    RDn = pRectin->aspRectRD;
    
    offsetH = LUn[0] - pRectorg->aspRectLU[0];
    offsetV = LUn[1] - pRectorg->aspRectLU[1];

    pLU[0] = LUn[0] - offsetH;
    pLU[1] = LUn[1] - offsetV;

    pLD[0] = LDn[0] - offsetH;
    pLD[1] = LDn[1] - offsetV;

    pRD[0] = RDn[0] - offsetH;
    pRD[1] = RDn[1] - offsetV;

    pRU[0] = RUn[0] - offsetH;
    pRU[1] = RUn[1] - offsetV;

    #if LOG_RECTOFFSET_LF_EN
    printf("[offsetLf] simulate LU(%4.2lf, %4.2lf) LD(%4.2lf, %4.2lf) RD(%4.2lf, %4.2lf) RU(%4.2lf, %4.2lf) offH: %.2lf offV: %.2lf \n", 
        pLU[0], pLU[1], pLD[0], pLD[1], pRD[0], pRD[1], pRU[0], pRU[1], offsetH, offsetV);
    #endif

    diff = fabs(pLU[0] - pRectorg->aspRectLU[0]);
    divH += diff;

    diff = fabs(pLD[0] - pRectorg->aspRectLD[0]);
    divH += diff;

    diff = fabs(pRD[0] - pRectorg->aspRectRD[0]);
    divH += diff;

    diff = fabs(pRU[0] - pRectorg->aspRectRU[0]);
    divH += diff;

    diff = fabs(pLU[1] - pRectorg->aspRectLU[1]);
    divV += diff;

    diff = fabs(pLD[1] - pRectorg->aspRectLD[1]);
    divV += diff;

    diff = fabs(pRD[1] - pRectorg->aspRectRD[1]);
    divV += diff;

    diff = fabs(pRU[1] - pRectorg->aspRectRU[1]);
    divV += diff;

    diff = (divH + divV) / 2.0;

    offset[0] = offsetH;
    offset[1] = offsetV;
    
    return diff;
}

#define LOG_RECTOFFSET_RT_EN (0)
static CFLOAT getRectOffsetRt(struct aspRectObj *pRectout, struct aspRectObj *pRectin, struct aspRectObj *pRectorg, CFLOAT *offset)
{
    CFLOAT offsetH, offsetV;
    CFLOAT *pLU, *pLD, *pRD, *pRU;
    CFLOAT *LUn, *RUn, *LDn, *RDn;
    CFLOAT divH=0, divV=0, diff=0;
    CFLOAT minH, minV;

    pLU = pRectout->aspRectLU;
    pRU = pRectout->aspRectRU;
    pLD = pRectout->aspRectLD;
    pRD = pRectout->aspRectRD;
    
    LUn = pRectin->aspRectLU;
    RUn = pRectin->aspRectRU;
    LDn = pRectin->aspRectLD;
    RDn = pRectin->aspRectRD;
    
    offsetH = RUn[0] - pRectorg->aspRectRU[0];
    offsetV = RUn[1] - pRectorg->aspRectRU[1];

    pLU[0] = LUn[0] - offsetH;
    pLU[1] = LUn[1] - offsetV;

    pLD[0] = LDn[0] - offsetH;
    pLD[1] = LDn[1] - offsetV;

    pRD[0] = RDn[0] - offsetH;
    pRD[1] = RDn[1] - offsetV;

    pRU[0] = RUn[0] - offsetH;
    pRU[1] = RUn[1] - offsetV;

    #if LOG_RECTOFFSET_RT_EN
    printf("[offsetRt] simulate LU(%4.2lf, %4.2lf) LD(%4.2lf, %4.2lf) RD(%4.2lf, %4.2lf) RU(%4.2lf, %4.2lf) offH: %.2lf offV: %.2lf \n", 
        pLU[0], pLU[1], pLD[0], pLD[1], pRD[0], pRD[1], pRU[0], pRU[1], offsetH, offsetV);
    #endif

    diff = fabs(pLU[0] - pRectorg->aspRectLU[0]);
    divH += diff;

    diff = fabs(pLD[0] - pRectorg->aspRectLD[0]);
    divH += diff;

    diff = fabs(pRD[0] - pRectorg->aspRectRD[0]);
    divH += diff;

    diff = fabs(pRU[0] - pRectorg->aspRectRU[0]);
    divH += diff;

    diff = fabs(pLU[1] - pRectorg->aspRectLU[1]);
    divV += diff;

    diff = fabs(pLD[1] - pRectorg->aspRectLD[1]);
    divV += diff;

    diff = fabs(pRD[1] - pRectorg->aspRectRD[1]);
    divV += diff;

    diff = fabs(pRU[1] - pRectorg->aspRectRU[1]);
    divV += diff;

    diff = (divH + divV) / 2.0;

    offset[0] = offsetH;
    offset[1] = offsetV;
    
    return diff;
}

static int getPtTranRvs(CFLOAT *ptout, CFLOAT dg, CFLOAT *offset, CFLOAT *ptin)
{
    int ret=0, ptn[2];
    CFLOAT piAngle = 180.0, thacos=0, thasin=0, rangle[2], theta=0;
    CFLOAT ptf[2];

    theta = dg;

    theta = theta * M_PI / piAngle;

    thacos = cos(theta);
    thasin = sin(theta);
    
    rangle[0] = thacos;
    rangle[1] = thasin;
    
    //printf("[RVS] getPtTranRvs() degree: %4.2lf, offset: (%4.2lf, %4.2lf) \n", dg, offset[0], offset[1]);

    ret = calcuRotateCoordinates(ptn, ptf, ptin, rangle);

    ptout[0] = ptf[0] + offset[0];
    ptout[1] = ptf[1] + offset[1];
    
    //printf("[RVS] LU: (%4.2lf, %4.2lf) ->  (%4.2lf, %4.2lf) ret: %d\n", ptin[0], ptin[1], ptout[0], ptout[1], ret);

    return 0;
}

static inline int getPtTran(CFLOAT *ptout, CFLOAT *rangle, CFLOAT *offset, CFLOAT *ptin)
{
    CFLOAT pLU[2];
    int ret=0, LUt[2];
    
    pLU[0] = ptin[0] + offset[0];
    pLU[1] = ptin[1] + offset[1];
    
    ret = calcuRotateCoordinates(LUt, ptout, pLU, rangle);
    
    //printf("[PT] in:(%4.2lf, %4.2lf), out:(%4.2lf, %4.2lf) ret: %d\n", ptin[0], ptin[1], ptout[0], ptout[1], ret);

    return ret;
}

#define LOG_GETRECTRAN_EN (0)
static int getRectTran(struct aspRectObj *pRectin, CFLOAT dg, CFLOAT *offset, struct aspRectObj *pRectout)
{
    int ret=0;
    CFLOAT piAngle = 180.0, thacos=0, thasin=0, rangle[2], theta=0;
    CFLOAT pLU[2], pLD[2], pRU[2], pRD[2];
    CFLOAT *LUn, *RUn, *LDn, *RDn;
    int LUt[2], RUt[2], LDt[2], RDt[2];

    theta = dg;

    theta = theta * M_PI / piAngle;

    thacos = cos(theta);
    thasin = sin(theta);
    
    rangle[0] = thacos;
    rangle[1] = thasin;

    #if LOG_GETRECTRAN_EN
    printf("[CHR] getRectTran() degree: %4.2lf, offset: (%4.2lf, %4.2lf) \n", dg, offset[0], offset[1]);
    #endif
    
    ret = getPtTran(pRectout->aspRectLU, rangle, offset, pRectin->aspRectLU);
    #if LOG_GETRECTRAN_EN
    printf("[CHR] LU: (%4.2lf, %4.2lf) ->  (%4.2lf, %4.2lf) ret: %d\n", 
        pRectin->aspRectLU[0], pRectin->aspRectLU[1], pRectout->aspRectLU[0], pRectout->aspRectLU[1], ret);
    #endif
    
    ret = getPtTran(pRectout->aspRectLD, rangle, offset, pRectin->aspRectLD);
    #if LOG_GETRECTRAN_EN
    printf("[CHR] LD: (%4.2lf, %4.2lf) ->  (%4.2lf, %4.2lf) ret: %d\n", 
        pRectin->aspRectLD[0], pRectin->aspRectLD[1], pRectout->aspRectLD[0], pRectout->aspRectLD[1], ret);
    #endif
        
    ret = getPtTran(pRectout->aspRectRD, rangle, offset, pRectin->aspRectRD);
    #if LOG_GETRECTRAN_EN
    printf("[CHR] RD: (%4.2lf, %4.2lf) ->  (%4.2lf, %4.2lf) ret: %d\n", 
        pRectin->aspRectRD[0], pRectin->aspRectRD[1], pRectout->aspRectRD[0], pRectout->aspRectRD[1], ret);
    #endif
        
    ret = getPtTran(pRectout->aspRectRU, rangle, offset, pRectin->aspRectRU);
    #if LOG_GETRECTRAN_EN
    printf("[CHR] RU: (%4.2lf, %4.2lf) ->  (%4.2lf, %4.2lf) ret: %d\n", 
        pRectin->aspRectRU[0], pRectin->aspRectRU[1], pRectout->aspRectRU[0], pRectout->aspRectRU[1], ret);
    #endif

    return 0;
}

static void setRectPoint(struct aspRectObj *pRectin, CFLOAT edwidth, CFLOAT edheight, CFLOAT *pst) 
{
    pRectin->aspRectLD[0] = pst[0];
    pRectin->aspRectLD[1] = pst[1];
    
    pRectin->aspRectLU[0] = pst[0];
    pRectin->aspRectLU[1] = pst[1] + edheight;

    pRectin->aspRectRU[0] = pst[0] + edwidth;
    pRectin->aspRectRU[1] = pst[1] + edheight;

    pRectin->aspRectRD[0] = pst[0] + edwidth;
    pRectin->aspRectRD[1] = pst[1];

}

#define LOG_ADJCIRCLEDN_8_BITS_EN (0)
static int adjCircleRect8BitsDn(struct procRes_s *rs, int *real, CFLOAT *pfound, CFLOAT dg, CFLOAT *offset, char *colr, char *bmp, int oldRowsz, int bpp, int pidx)
{
#define SRH_DRAW_COLORDN_8_BITS (1)
#define SRH_RANGEDN_8_BITS (40)
#define SRH_COUNT_MINDN_8_BITS (15)
#define SRH_CROSSDN_W (12)//(48)
#define SRH_CROSSDN_H (12)//(31)
    int dx=0, dy=0, ix=0, bitset=0, ret=0, flag=0x100;
    CFLOAT piAngle = 180.0, thacos=0, thasin=0, rangle[2], theta=0;
    CFLOAT fval[2]={0}, rval[2]={0}, tmp=0, calcu[2]={0};
    char *src=0;
    int colrcross[12];
    int colravg=0;
    char drgb=0, orgb=0;
    CFLOAT ptup[2]={0}, ptdn[2]={0}, ptrt[2]={0}, ptlf[2]={0};
    int srhcount=1, srhcountw=0, srhcounth=0, shrtimes=0, repeatcont=0;;

    #if LOG_ADJCIRCLEDN_8_BITS_EN
    sprintf_f(rs->logs, "org center (%4lf, %4lf) (%d, %d, %d) - 8 bits(%d)\n", pfound[0], pfound[1], colr[0], colr[1], colr[2], bpp);
    print_f(rs->plogs, "ADJDN", rs->logs);
    #endif
 
    calcu[0] = pfound[0];
    calcu[1] = pfound[1];
    
    bitset = bpp / 8;
    
    theta = dg;

    theta = theta * M_PI / piAngle;

    thacos = cos(theta);
    thasin = sin(theta);
    
    rangle[0] = thacos;
    rangle[1] = thasin;

    fval[0] = calcu[0];
    fval[1] = calcu[1];

    getPtTran(rval, rangle, offset, fval);    

    dx = round(rval[0]);
    dy = round(rval[1]);

    src = getPixel(bmp, dx, dy, oldRowsz, bitset);
    //memcpy(orgb, src, 3);
    orgb = *src;

repeat:
    repeatcont ++;

    #if LOG_ADJCIRCLEDN_8_BITS_EN
    sprintf_f(rs->logs, "org (%4d, %4d) [0x%.8x]grayscale(%d) - %d\n", dx, dy, (uint32_t)src, orgb, shrtimes++);
    print_f(rs->plogs, "ADJDN", rs->logs);
    #endif
    
    for (ix=1; ix < SRH_RANGEDN_8_BITS; ix++) {
        tmp = ix;
        fval[0] = calcu[0] + (tmp * 1.0);
        fval[1] = calcu[1];

        getPtTran(rval, rangle, offset, fval);    

        dx = round(rval[0]);
        dy = round(rval[1]);

        src = getPixel(bmp, dx, dy, oldRowsz, bitset);

        drgb = abs(src[0] - orgb);
        
        #if 0//LOG_ADJCIRCLEDN_8_BITS_EN
        sprintf_f(rs->logs, "%d. (%4lf, %4lf) (%d, %d) gray(%d) diff(%d) - rt\n", ix, fval[0], fval[1], dx, dy, src[0], drgb);
        print_f(rs->plogs, "ADJDN", rs->logs);
        #endif

        if (drgb > colr[0]) {
            ptrt[0] = fval[0];
            ptrt[1] = fval[1];

            flag |= 0x1;
            break;
        }
        srhcount++;
        srhcountw++;
    }

    for (ix=1; ix < SRH_RANGEDN_8_BITS; ix++) {
        tmp = ix;
        fval[0] = calcu[0] - (tmp * 1.0);
        fval[1] = calcu[1];

        getPtTran(rval, rangle, offset, fval);    

        dx = round(rval[0]);
        dy = round(rval[1]);

        src = getPixel(bmp, dx, dy, oldRowsz, bitset);

        drgb = abs(src[0] - orgb);
        
        #if 0//LOG_ADJCIRCLEDN_8_BITS_EN
        sprintf_f(rs->logs, "%d. (%4lf, %4lf) (%d, %d) gray(%d) diff(%d) - lf\n", ix, fval[0], fval[1], dx, dy, src[0], drgb);
        print_f(rs->plogs, "ADJDN", rs->logs);
        #endif

        if (drgb > colr[0]) {
            ptlf[0] = fval[0];
            ptlf[1] = fval[1];

            flag |= 0x2;
            break;
        }
        srhcount++;
        srhcountw++;
    }

    for (ix=1; ix < SRH_RANGEDN_8_BITS; ix++) {
        tmp = ix;
        fval[0] = calcu[0];
        fval[1] = calcu[1] - (tmp * 1.0);

        getPtTran(rval, rangle, offset, fval);    

        dx = round(rval[0]);
        dy = round(rval[1]);

        src = getPixel(bmp, dx, dy, oldRowsz, bitset);

        drgb = abs(src[0] - orgb);

        #if 0//LOG_ADJCIRCLEDN_8_BITS_EN
        sprintf_f(rs->logs, "%d. (%4lf, %4lf) (%d, %d) gray(%d) diff(%d) - up\n", ix, fval[0], fval[1], dx, dy, src[0], drgb);
        print_f(rs->plogs, "ADJDN", rs->logs);
        #endif

        if (drgb > colr[0]) {
            ptup[0] = fval[0];
            ptup[1] = fval[1];

            flag |= 0x4;
            break;
        }
        srhcount++;
        srhcounth++;
    }

    for (ix=1; ix < SRH_RANGEDN_8_BITS; ix++) {
        tmp = ix;
        fval[0] = calcu[0];
        fval[1] = calcu[1] + (tmp * 1.0);

        getPtTran(rval, rangle, offset, fval);    

        dx = round(rval[0]);
        dy = round(rval[1]);

        src = getPixel(bmp, dx, dy, oldRowsz, bitset);

        drgb = abs(src[0] - orgb);

        #if 0//LOG_ADJCIRCLEDN_8_BITS_EN
        sprintf_f(rs->logs, "%d. (%4lf, %4lf) (%d, %d) gray(%d) diff(%d) - dn\n", ix, fval[0], fval[1], dx, dy, src[0], drgb);
        print_f(rs->plogs, "ADJDN", rs->logs);
        #endif

        if (drgb > colr[0]) {
            ptdn[0] = fval[0];
            ptdn[1] = fval[1];

            flag |= 0x8;
            break;
        }
        srhcount++;
        srhcounth++;
    }

    #if LOG_ADJCIRCLEDN_8_BITS_EN
    sprintf_f(rs->logs, "search count: %d w: %d h: %d flag: 0x%.2x \n", srhcount, srhcountw, srhcounth, flag);
    print_f(rs->plogs, "ADJDN", rs->logs);
    #endif

    if ((flag & 0xff) != 0xf) {
        return flag;
    }


    if (srhcount < SRH_COUNT_MINDN_8_BITS) {
        sprintf_f(rs->logs, "Warning!! search count: %d < %d \n", srhcount, SRH_COUNT_MINDN_8_BITS);
        print_f(rs->plogs, "ADJDN", rs->logs);

        return srhcount;
    }
        
    fval[0] = (ptlf[0] + ptrt[0]) / 2;
    fval[1] = (ptup[1] + ptdn[1]) / 2;

    rval[0] = fabs(calcu[0] - fval[0]);
    rval[1] = fabs(calcu[1] - fval[1]);
    
    if ((srhcounth < SRH_CROSSDN_H) || (srhcountw < SRH_CROSSDN_W)) {

        if ((rval[0] < 3.0) && (rval[1] < 3.0)) {
            return srhcount;
        }

        if (repeatcont > 16) {
            return 0 - repeatcont;
        }

        calcu[0] = fval[0];
        calcu[1] = fval[1];

        srhcount=1;
        srhcountw=0;
        srhcounth=0;
        flag=0x100;

        goto repeat;
    }

    if ((srhcounth == (SRH_RANGEDN_8_BITS*2)) && (srhcountw == (SRH_RANGEDN_8_BITS*2))) {
        return srhcount;
    }

    getPtTran(rval, rangle, offset, fval);    
    
    dx = round(rval[0]);
    dy = round(rval[1]);

    #if SRH_DRAW_COLORDN_8_BITS
    src = getPixel(bmp, dx, dy, oldRowsz, bitset);

    src[0] = 255;
    #endif
    
    src = getPixel(bmp, dx+1, dy, oldRowsz, bitset);
    colrcross[0] = src[0];
    src = getPixel(bmp, dx-1, dy, oldRowsz, bitset);
    colrcross[1] = src[0];
    src = getPixel(bmp, dx, dy+1, oldRowsz, bitset);
    colrcross[2] = src[0];
    src = getPixel(bmp, dx, dy-1, oldRowsz, bitset);
    colrcross[3] = src[0];

    src = getPixel(bmp, dx+2, dy, oldRowsz, bitset);
    colrcross[4] = src[0];
    src = getPixel(bmp, dx-2, dy, oldRowsz, bitset);
    colrcross[5] = src[0];
    src = getPixel(bmp, dx, dy+2, oldRowsz, bitset);
    colrcross[6] = src[0];
    src = getPixel(bmp, dx, dy-2, oldRowsz, bitset);
    colrcross[7] = src[0];

    src = getPixel(bmp, dx+3, dy, oldRowsz, bitset);
    colrcross[8] = src[0];
    src = getPixel(bmp, dx-3, dy, oldRowsz, bitset);
    colrcross[9] = src[0];
    src = getPixel(bmp, dx, dy+3, oldRowsz, bitset);
    colrcross[10] = src[0];
    src = getPixel(bmp, dx, dy-3, oldRowsz, bitset);
    colrcross[11] = src[0];

    colravg = (colrcross[0] + colrcross[1] + colrcross[2] + colrcross[3]+colrcross[4] + colrcross[5] + colrcross[6] + colrcross[7]+colrcross[8] + colrcross[9] + colrcross[10] + colrcross[11]) / 12;
    
    #if 1//LOG_ADJCIRCLEDN_8_BITS_EN
    sprintf_f(rs->logs, "get tag black color (%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d) avg (%d) \n", colrcross[0], colrcross[1], colrcross[2], colrcross[3], 
        colrcross[4], colrcross[5], colrcross[6], colrcross[7], colrcross[8], colrcross[9], colrcross[10], colrcross[11], colravg);
    print_f(rs->plogs, "ADJDN", rs->logs);
    #endif

    if ((colravg > 240) || (colravg < 210)) {
        return (0 - colravg);
    }

    src = getPixel(bmp, dx+19, dy, oldRowsz, bitset);
    colrcross[0] = src[0];
    src = getPixel(bmp, dx-19, dy, oldRowsz, bitset);
    colrcross[1] = src[0];
    src = getPixel(bmp, dx, dy+19, oldRowsz, bitset);
    colrcross[2] = src[0];
    src = getPixel(bmp, dx, dy-19, oldRowsz, bitset);
    colrcross[3] = src[0];

    src = getPixel(bmp, dx+18, dy, oldRowsz, bitset);
    colrcross[4] = src[0];
    src = getPixel(bmp, dx-18, dy, oldRowsz, bitset);
    colrcross[5] = src[0];
    src = getPixel(bmp, dx, dy+18, oldRowsz, bitset);
    colrcross[6] = src[0];
    src = getPixel(bmp, dx, dy-18, oldRowsz, bitset);
    colrcross[7] = src[0];

    src = getPixel(bmp, dx+20, dy, oldRowsz, bitset);
    colrcross[8] = src[0];
    src = getPixel(bmp, dx-20, dy, oldRowsz, bitset);
    colrcross[9] = src[0];
    src = getPixel(bmp, dx, dy+20, oldRowsz, bitset);
    colrcross[10] = src[0];
    src = getPixel(bmp, dx, dy-20, oldRowsz, bitset);
    colrcross[11] = src[0];

    for (ix=0; ix< 4; ix++) {
        if ((colrcross[ix] > 150) && (colrcross[ix] < 210)) {
            if ((colrcross[ix+4] > 150) && (colrcross[ix+4] < 210)) {
                if ((colrcross[ix+8] > 150) && (colrcross[ix+8] < 210)) {
                    real[0] = round(fval[0]);
                    real[1] = round(fval[1]);

                    #if 1//LOG_ADJCIRCLEDN_8_BITS_EN
                    sprintf_f(rs->logs, "get adj (%d, %d) org (%d, %d) \n", real[0], real[1], dx, dy);
                    print_f(rs->plogs, "ADJDN", rs->logs);
                    #endif

                    return 0;
                }
            }
        }
    }
    
    #if 1//LOG_ADJCIRCLEDN_8_BITS_EN
    sprintf_f(rs->logs, "get tag center color (%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d)\n", colrcross[0], colrcross[1], colrcross[2], colrcross[3], colrcross[4], colrcross[5], 
        colrcross[6], colrcross[7], colrcross[8], colrcross[9], colrcross[10], colrcross[11]);
    print_f(rs->plogs, "ADJDN", rs->logs);
    #endif
    
    return -9;
}

#define LOG_ADJCIRCLE_8_BITS_EN (0)
static int adjCircleRect8Bits(struct procRes_s *rs, int *real, CFLOAT *pfound, CFLOAT dg, CFLOAT *offset, char *colr, char *bmp, int oldRowsz, int bpp, int pidx)
{
#define SRH_DRAW_COLOR_8_BITS (1)
#define SRH_RANGE_8_BITS (45)
#define SRH_COUNT_MIN_8_BITS (30)
#define SRH_CROSS_W (25)//(48)
#define SRH_CROSS_H (25)//(31)
    int dx=0, dy=0, ix=0, bitset=0, ret=0, flag=0x100;
    CFLOAT piAngle = 180.0, thacos=0, thasin=0, rangle[2], theta=0;
    CFLOAT fval[2]={0}, rval[2]={0}, tmp=0, calcu[2]={0};
    char *src=0;
    int colrcross[8];
    int colravg=0;
    char drgb=0, orgb=0;
    CFLOAT ptup[2]={0}, ptdn[2]={0}, ptrt[2]={0}, ptlf[2]={0};
    int srhcount=1, srhcountw=0, srhcounth=0, shrtimes=0, repeatcont=0;;

    #if LOG_ADJCIRCLE_8_BITS_EN
    sprintf_f(rs->logs, "org center (%4lf, %4lf) (%d, %d, %d) - 8 bits(%d)\n", pfound[0], pfound[1], colr[0], colr[1], colr[2], bpp);
    print_f(rs->plogs, "ADJ", rs->logs);
    #endif
 
    calcu[0] = pfound[0];
    calcu[1] = pfound[1];
    
    bitset = bpp / 8;
    
    theta = dg;

    theta = theta * M_PI / piAngle;

    thacos = cos(theta);
    thasin = sin(theta);
    
    rangle[0] = thacos;
    rangle[1] = thasin;

    fval[0] = calcu[0];
    fval[1] = calcu[1];

    getPtTran(rval, rangle, offset, fval);    

    dx = round(rval[0]);
    dy = round(rval[1]);

    src = getPixel(bmp, dx, dy, oldRowsz, bitset);
    //memcpy(orgb, src, 3);
    orgb = *src;

repeat:
    repeatcont ++;

    #if LOG_ADJCIRCLE_8_BITS_EN
    sprintf_f(rs->logs, "org (%4d, %4d) [0x%.8x]grayscale(%d) - %d\n", dx, dy, (uint32_t)src, orgb, shrtimes++);
    print_f(rs->plogs, "ADJ", rs->logs);
    #endif
    
    for (ix=1; ix < SRH_RANGE_8_BITS; ix++) {
        tmp = ix;
        fval[0] = calcu[0] + (tmp * 1.0);
        fval[1] = calcu[1];

        getPtTran(rval, rangle, offset, fval);    

        dx = round(rval[0]);
        dy = round(rval[1]);

        src = getPixel(bmp, dx, dy, oldRowsz, bitset);

        drgb = abs(src[0] - orgb);
        
        //sprintf_f(rs->logs, "%d. (%4lf, %4lf) RGB(%d, %d, %d) diff(%d, %d, %d) - rt\n", ix, fval[0], fval[1], src[0], src[1], src[2], drgb[0], drgb[1], drgb[2]);
        //print_f(rs->plogs, "ADJ", rs->logs);

        if (drgb > colr[0]) {
            ptrt[0] = fval[0];
            ptrt[1] = fval[1];

            flag |= 0x1;
            break;
        }
        srhcount++;
        srhcountw++;
    }

    for (ix=1; ix < SRH_RANGE_8_BITS; ix++) {
        tmp = ix;
        fval[0] = calcu[0] - (tmp * 1.0);
        fval[1] = calcu[1];

        getPtTran(rval, rangle, offset, fval);    

        dx = round(rval[0]);
        dy = round(rval[1]);

        src = getPixel(bmp, dx, dy, oldRowsz, bitset);

        drgb = abs(src[0] - orgb);
        
        //sprintf_f(rs->logs, "%d. (%4lf, %4lf) RGB(%d, %d, %d) diff(%d, %d, %d) - lf\n", ix, fval[0], fval[1], src[0], src[1], src[2], drgb[0], drgb[1], drgb[2]);
        //print_f(rs->plogs, "ADJ", rs->logs);

        if (drgb > colr[0]) {
            ptlf[0] = fval[0];
            ptlf[1] = fval[1];

            flag |= 0x2;
            break;
        }
        srhcount++;
        srhcountw++;
    }

    for (ix=1; ix < SRH_RANGE_8_BITS; ix++) {
        tmp = ix;
        fval[0] = calcu[0];
        fval[1] = calcu[1] - (tmp * 1.0);

        getPtTran(rval, rangle, offset, fval);    

        dx = round(rval[0]);
        dy = round(rval[1]);

        src = getPixel(bmp, dx, dy, oldRowsz, bitset);

        drgb = abs(src[0] - orgb);
        
        //sprintf_f(rs->logs, "%d. (%4lf, %4lf) RGB(%d, %d, %d) diff(%d, %d, %d) - up\n", ix, fval[0], fval[1], src[0], src[1], src[2], drgb[0], drgb[1], drgb[2]);
        //print_f(rs->plogs, "ADJ", rs->logs);

        if (drgb > colr[0]) {
            ptup[0] = fval[0];
            ptup[1] = fval[1];

            flag |= 0x4;
            break;
        }
        srhcount++;
        srhcounth++;
    }

    for (ix=1; ix < SRH_RANGE_8_BITS; ix++) {
        tmp = ix;
        fval[0] = calcu[0];
        fval[1] = calcu[1] + (tmp * 1.0);

        getPtTran(rval, rangle, offset, fval);    

        dx = round(rval[0]);
        dy = round(rval[1]);

        src = getPixel(bmp, dx, dy, oldRowsz, bitset);

        drgb = abs(src[0] - orgb);
        
        //sprintf_f(rs->logs, "%d. (%4lf, %4lf) RGB(%d, %d, %d) diff(%d, %d, %d) - dn\n", ix, fval[0], fval[1], src[0], src[1], src[2], drgb[0], drgb[1], drgb[2]);
        //print_f(rs->plogs, "ADJ", rs->logs);

        if (drgb > colr[0]) {
            ptdn[0] = fval[0];
            ptdn[1] = fval[1];

            flag |= 0x8;
            break;
        }
        srhcount++;
        srhcounth++;
    }

    if ((flag & 0xff) != 0xf) {
        return flag;
    }

    #if LOG_ADJCIRCLE_8_BITS_EN
    sprintf_f(rs->logs, "search count: %d w: %d h: %d\n", srhcount, srhcountw, srhcounth);
    print_f(rs->plogs, "ADJ", rs->logs);
    #endif

    if (srhcount < SRH_COUNT_MIN_8_BITS) {
        sprintf_f(rs->logs, "Warning!! search count: %d < %d \n", srhcount, SRH_COUNT_MIN_8_BITS);
        print_f(rs->plogs, "ADJ", rs->logs);

        return srhcount;
    }
        
    fval[0] = (ptlf[0] + ptrt[0]) / 2;
    fval[1] = (ptup[1] + ptdn[1]) / 2;

    rval[0] = fabs(calcu[0] - fval[0]);
    rval[1] = fabs(calcu[1] - fval[1]);
    
    if ((srhcounth < SRH_CROSS_H) || (srhcountw < SRH_CROSS_W)) {

        if ((rval[0] < 3.0) && (rval[1] < 3.0)) {
            return srhcount;
        }

        if (repeatcont > 16) {
            return 0 - repeatcont;
        }

        calcu[0] = fval[0];
        calcu[1] = fval[1];

        srhcount=1;
        srhcountw=0;
        srhcounth=0;
        flag=0x100;

        goto repeat;
    }

    if ((srhcounth == (SRH_RANGE_8_BITS*2)) && (srhcountw == (SRH_RANGE_8_BITS*2))) {
        return srhcount;
    }

    getPtTran(rval, rangle, offset, fval);    
    
    dx = round(rval[0]);
    dy = round(rval[1]);

    #if SRH_DRAW_COLOR_8_BITS
    src = getPixel(bmp, dx, dy, oldRowsz, bitset);

    src[0] = 255;
    #endif
    
    src = getPixel(bmp, dx+1, dy, oldRowsz, bitset);
    colrcross[0] = src[0];
    src = getPixel(bmp, dx-1, dy, oldRowsz, bitset);
    colrcross[1] = src[0];
    src = getPixel(bmp, dx, dy+1, oldRowsz, bitset);
    colrcross[2] = src[0];
    src = getPixel(bmp, dx, dy-1, oldRowsz, bitset);
    colrcross[3] = src[0];

    src = getPixel(bmp, dx+12, dy, oldRowsz, bitset);
    colrcross[4] = src[0];
    src = getPixel(bmp, dx-12, dy, oldRowsz, bitset);
    colrcross[5] = src[0];
    src = getPixel(bmp, dx, dy+12, oldRowsz, bitset);
    colrcross[6] = src[0];
    src = getPixel(bmp, dx, dy-12, oldRowsz, bitset);
    colrcross[7] = src[0];

    colravg = (colrcross[0] + colrcross[1] + colrcross[2] + colrcross[3]+colrcross[4] + colrcross[5] + colrcross[6] + colrcross[7]) / 8;
    
    #if 1//LOG_ADJCIRCLE_8_BITS_EN
    sprintf_f(rs->logs, "get tag black color (%d, %d, %d, %d, %d, %d, %d, %d) avg (%d) \n", colrcross[0], colrcross[1], colrcross[2], colrcross[3], colrcross[4], colrcross[5], colrcross[6], colrcross[7], colravg);
    print_f(rs->plogs, "ADJ", rs->logs);
    #endif

    if ((colravg > 85) || (colravg < 51)) {
        return (0 - colravg);
    }

    src = getPixel(bmp, dx+17, dy, oldRowsz, bitset);
    colrcross[0] = src[0];
    src = getPixel(bmp, dx-17, dy, oldRowsz, bitset);
    colrcross[1] = src[0];
    src = getPixel(bmp, dx, dy+17, oldRowsz, bitset);
    colrcross[2] = src[0];
    src = getPixel(bmp, dx, dy-17, oldRowsz, bitset);
    colrcross[3] = src[0];

    src = getPixel(bmp, dx+21, dy, oldRowsz, bitset);
    colrcross[4] = src[0];
    src = getPixel(bmp, dx-21, dy, oldRowsz, bitset);
    colrcross[5] = src[0];
    src = getPixel(bmp, dx, dy+21, oldRowsz, bitset);
    colrcross[6] = src[0];
    src = getPixel(bmp, dx, dy-21, oldRowsz, bitset);
    colrcross[7] = src[0];

    colravg = (colrcross[0] + colrcross[1] + colrcross[2] + colrcross[3]+colrcross[4] + colrcross[5] + colrcross[6] + colrcross[7]) / 8;
    
    #if 1//LOG_ADJCIRCLE_8_BITS_EN
    sprintf_f(rs->logs, "get tag white color (%d, %d, %d, %d, %d, %d, %d, %d) avg (%d) \n", colrcross[0], colrcross[1], colrcross[2], colrcross[3], colrcross[4], colrcross[5], colrcross[6], colrcross[7], colravg);
    print_f(rs->plogs, "ADJ", rs->logs);
    #endif

    if ((colravg < 200) || (colravg > 250)) {
        return (0 - colravg);
    }
    
    real[0] = round(fval[0]);
    real[1] = round(fval[1]);

    #if 1//LOG_ADJCIRCLE_8_BITS_EN
    sprintf_f(rs->logs, "get adj (%d, %d) org (%d, %d) \n", real[0], real[1], dx, dy);
    print_f(rs->plogs, "ADJ", rs->logs);
    #endif

    return 0;
}

#define LOG_ADJCIRCLE_EN (1)
static int adjCircleRect(struct procRes_s *rs, int *real, CFLOAT *pfound, CFLOAT dg, CFLOAT *offset, char *colr, char *bmp, int oldRowsz, int bpp, int pidx)
{
#define SRH_DRAW_COLOR (0)
#define SRH_RANGE (80)
#define SRH_COUNT_MIN (95)
    int dx=0, dy=0, ix=0, bitset=0, ret=0, flag=0x100;
    CFLOAT piAngle = 180.0, thacos=0, thasin=0, rangle[2], theta=0;
    CFLOAT fval[2]={0}, rval[2]={0}, tmp=0;
    char *src;
    char drgb[3], orgb[3];
    CFLOAT ptup[2]={0}, ptdn[2]={0}, ptrt[2]={0}, ptlf[2]={0};
    int srhcount=1;

    #if LOG_ADJCIRCLE_EN
    sprintf_f(rs->logs, "org center (%4lf, %4lf) (%d, %d, %d)\n", pfound[0], pfound[1], colr[0], colr[1], colr[2]);
    print_f(rs->plogs, "SRH", rs->logs);
    #endif
    
    bitset = bpp / 8;
    
    theta = dg;

    theta = theta * M_PI / piAngle;

    thacos = cos(theta);
    thasin = sin(theta);
    
    rangle[0] = thacos;
    rangle[1] = thasin;

    fval[0] = pfound[0];
    fval[1] = pfound[1];

    getPtTran(rval, rangle, offset, fval);    

    dx = round(rval[0]);
    dy = round(rval[1]);

    src = getPixel(bmp, dx, dy, oldRowsz, bitset);
    memcpy(orgb, src, 3);

    #if LOG_ADJCIRCLE_EN
    sprintf_f(rs->logs, "org (%4d, %4d) RGB(%d, %d, %d)\n", dx, dy, orgb[0], orgb[1], orgb[2]);
    print_f(rs->plogs, "SRH", rs->logs);
    #endif
    
    for (ix=1; ix < SRH_RANGE; ix++) {
        tmp = ix;
        fval[0] = pfound[0] + (tmp * 1.0);
        fval[1] = pfound[1];

        getPtTran(rval, rangle, offset, fval);    

        dx = round(rval[0]);
        dy = round(rval[1]);

        src = getPixel(bmp, dx, dy, oldRowsz, bitset);

        drgb[0] = abs(src[0] - orgb[0]);
        drgb[1] = abs(src[1] - orgb[1]);
        drgb[2] = abs(src[2] - orgb[2]);
        
        //sprintf_f(rs->logs, "%d. (%4lf, %4lf) RGB(%d, %d, %d) diff(%d, %d, %d) - rt\n", ix, fval[0], fval[1], src[0], src[1], src[2], drgb[0], drgb[1], drgb[2]);
        //print_f(rs->plogs, "SRH", rs->logs);

        if ((drgb[0] > colr[0]) && (drgb[1] > colr[1]) && (drgb[2] > colr[2])) {
            ptrt[0] = fval[0];
            ptrt[1] = fval[1];

            flag |= 0x1;
            break;
        }
        srhcount++;
    }

    for (ix=1; ix < SRH_RANGE; ix++) {
        tmp = ix;
        fval[0] = pfound[0] - (tmp * 1.0);
        fval[1] = pfound[1];

        getPtTran(rval, rangle, offset, fval);    

        dx = round(rval[0]);
        dy = round(rval[1]);

        src = getPixel(bmp, dx, dy, oldRowsz, bitset);

        drgb[0] = abs(src[0] - orgb[0]);
        drgb[1] = abs(src[1] - orgb[1]);
        drgb[2] = abs(src[2] - orgb[2]);
        
        //sprintf_f(rs->logs, "%d. (%4lf, %4lf) RGB(%d, %d, %d) diff(%d, %d, %d) - lf\n", ix, fval[0], fval[1], src[0], src[1], src[2], drgb[0], drgb[1], drgb[2]);
        //print_f(rs->plogs, "SRH", rs->logs);

        if ((drgb[0] > colr[0]) && (drgb[1] > colr[1]) && (drgb[2] > colr[2])) {
            ptlf[0] = fval[0];
            ptlf[1] = fval[1];

            flag |= 0x2;
            break;
        }
        srhcount++;
    }

    for (ix=1; ix < SRH_RANGE; ix++) {
        tmp = ix;
        fval[0] = pfound[0];
        fval[1] = pfound[1] - (tmp * 1.0);

        getPtTran(rval, rangle, offset, fval);    

        dx = round(rval[0]);
        dy = round(rval[1]);

        src = getPixel(bmp, dx, dy, oldRowsz, bitset);

        drgb[0] = abs(src[0] - orgb[0]);
        drgb[1] = abs(src[1] - orgb[1]);
        drgb[2] = abs(src[2] - orgb[2]);
        
        //sprintf_f(rs->logs, "%d. (%4lf, %4lf) RGB(%d, %d, %d) diff(%d, %d, %d) - up\n", ix, fval[0], fval[1], src[0], src[1], src[2], drgb[0], drgb[1], drgb[2]);
        //print_f(rs->plogs, "SRH", rs->logs);

        if ((drgb[0] > colr[0]) && (drgb[1] > colr[1]) && (drgb[2] > colr[2])) {
            ptup[0] = fval[0];
            ptup[1] = fval[1];

            flag |= 0x4;
            break;
        }
        srhcount++;
    }

    for (ix=1; ix < SRH_RANGE; ix++) {
        tmp = ix;
        fval[0] = pfound[0];
        fval[1] = pfound[1] + (tmp * 1.0);

        getPtTran(rval, rangle, offset, fval);    

        dx = round(rval[0]);
        dy = round(rval[1]);

        src = getPixel(bmp, dx, dy, oldRowsz, bitset);

        drgb[0] = abs(src[0] - orgb[0]);
        drgb[1] = abs(src[1] - orgb[1]);
        drgb[2] = abs(src[2] - orgb[2]);
        
        //sprintf_f(rs->logs, "%d. (%4lf, %4lf) RGB(%d, %d, %d) diff(%d, %d, %d) - dn\n", ix, fval[0], fval[1], src[0], src[1], src[2], drgb[0], drgb[1], drgb[2]);
        //print_f(rs->plogs, "SRH", rs->logs);

        if ((drgb[0] > colr[0]) && (drgb[1] > colr[1]) && (drgb[2] > colr[2])) {
            ptdn[0] = fval[0];
            ptdn[1] = fval[1];

            flag |= 0x8;
            break;
        }
        srhcount++;
    }

    if ((flag & 0xff) != 0xf) {
        return flag;
    }

    #if LOG_ADJCIRCLE_EN
    sprintf_f(rs->logs, "search count: %d\n", srhcount);
    print_f(rs->plogs, "SRH", rs->logs);
    #endif

    if (srhcount < SRH_COUNT_MIN) {
        sprintf_f(rs->logs, "Warning!! search count: %d\n", srhcount);
        print_f(rs->plogs, "SRH", rs->logs);

        return srhcount;
    }
        
    fval[0] = (ptlf[0] + ptrt[0]) / 2;
    fval[1] = (ptup[1] + ptdn[1]) / 2;

    getPtTran(rval, rangle, offset, fval);    

    dx = round(rval[0]);
    dy = round(rval[1]);
    src = getPixel(bmp, dx, dy, oldRowsz, bitset);

    #if SRH_DRAW_COLOR
    src[0] = 255;
    src[1] = 255;
    src[2] = 255;
    #endif
    
    real[0] = round(fval[0]);
    real[1] = round(fval[1]);

    #if LOG_ADJCIRCLE_EN
    sprintf_f(rs->logs, "get adj (%d, %d)\n", real[0], real[1]);
    print_f(rs->plogs, "SRH", rs->logs);
    #endif

    return 0;
}

static int srhRotRectTran(struct procRes_s *rs, CFLOAT *pfound, struct aspRectObj *pRect, CFLOAT dg, CFLOAT *offset, char *colr, char *bmp, int oldRowsz, int bpp, int pidx, CFLOAT wcnt, CFLOAT hcnt)
{
    struct aspRectObj *pRectsrh=0;
    CFLOAT piAngle = 180.0, thacos=0, thasin=0, rangle[2], theta=0;
    CFLOAT width=0, high=0, tmp=0, wshif=0, hshif=0, fval[2]={0}, rval[2]={0};
    int *ptU=0, *ptD=0, *ptL=0, *ptR=0;
    int wsize=0, hsize=0, ix=0;

    wsize = (int)wcnt;
    hsize = (int)hcnt;
    
    pRectsrh = aspMemalloc(sizeof(struct aspRectObj), pidx);
    ptU = aspMemalloc(sizeof(int) * wsize * 2, pidx);
    ptD = aspMemalloc(sizeof(int) * wsize * 2, pidx);
    ptL = aspMemalloc(sizeof(int) * hsize * 2, pidx);
    ptR = aspMemalloc(sizeof(int) * hsize * 2, pidx);
    
    dbgprintRect(pRect);

    width = pRect->aspRectRD[0] - pRect->aspRectLD[0];
    high = pRect->aspRectRD[1] - pRect->aspRectRU[1];

    sprintf_f(rs->logs, "width: %4.2lf high: %4.2lf, wcnt: %4.2lf hcnt: %4.2lf \n", width, high, wcnt, hcnt);
    print_f(rs->plogs, "SRH", rs->logs);    

    getRectTran(pRect, dg, offset, pRectsrh);
    dbgprintRect(pRectsrh);
    
    theta = dg;

    theta = theta * M_PI / piAngle;

    thacos = cos(theta);
    thasin = sin(theta);
    
    rangle[0] = thacos;
    rangle[1] = thasin;

    width = pRect->aspRectRD[0] - pRect->aspRectLD[0];
    high = pRect->aspRectRD[1] - pRect->aspRectLD[1];

    wshif = width / wcnt;
    hshif = high / wcnt;

    sprintf_f(rs->logs, "width: %4.2lf high: %4.2lf, wcnt: %4.2lf hcnt: %4.2lf wshif: %4.2lf hshif: %4.2lf - DN\n", width, high, wcnt, hcnt, wshif, hshif);
    print_f(rs->plogs, "SRH", rs->logs);    

    for (ix=0; ix < wsize; ix++) {
        tmp = ix;
        fval[0] = pRect->aspRectLD[0] + (tmp * wshif);
        fval[1] = pRect->aspRectLD[1] + (tmp * hshif);

        getPtTran(rval, rangle, offset, fval);
        
        ptD[ix*2] = round(rval[0]);
        ptD[ix*2+1] = round(rval[1]);
    }

    width = pRect->aspRectRU[0] - pRect->aspRectRD[0];
    high = pRect->aspRectRU[1] - pRect->aspRectRD[1];

    wshif = width / hcnt;
    hshif = high / hcnt;

    sprintf_f(rs->logs, "width: %4.2lf high: %4.2lf, wcnt: %4.2lf hcnt: %4.2lf wshif: %4.2lf hshif: %4.2lf - RT\n", width, high, wcnt, hcnt, wshif, hshif);
    print_f(rs->plogs, "SRH", rs->logs);    

    for (ix=0; ix < hsize; ix++) {
        tmp = ix;
        fval[0] = pRect->aspRectRD[0] + (tmp * wshif);
        fval[1] = pRect->aspRectRD[1] + (tmp * hshif);

        getPtTran(rval, rangle, offset, fval);
        
        ptR[ix*2] = round(rval[0]);
        ptR[ix*2+1] = round(rval[1]);
    }

    width = pRect->aspRectLU[0] - pRect->aspRectRU[0];
    high = pRect->aspRectLU[1] - pRect->aspRectRU[1];

    wshif = width / wcnt;
    hshif = high / wcnt;

    sprintf_f(rs->logs, "width: %4.2lf high: %4.2lf, wcnt: %4.2lf hcnt: %4.2lf wshif: %4.2lf hshif: %4.2lf - UP\n", width, high, wcnt, hcnt, wshif, hshif);
    print_f(rs->plogs, "SRH", rs->logs);    

    for (ix=0; ix < wsize; ix++) {
        tmp = ix;

        fval[0] = pRect->aspRectRU[0] + (tmp * wshif);
        fval[1] = pRect->aspRectRU[1] + (tmp * hshif);

        getPtTran(rval, rangle, offset, fval);
        
        ptU[ix*2] = round(rval[0]);
        ptU[ix*2+1] = round(rval[1]);
    }

    width = pRect->aspRectLD[0] - pRect->aspRectLU[0];
    high = pRect->aspRectLD[1] - pRect->aspRectLU[1];

    wshif = width / hcnt;
    hshif = high / hcnt;

    sprintf_f(rs->logs, "width: %4.2lf high: %4.2lf, wcnt: %4.2lf hcnt: %4.2lf wshif: %4.2lf hshif: %4.2lf - LF\n", width, high, wcnt, hcnt, wshif, hshif);
    print_f(rs->plogs, "SRH", rs->logs);    

    for (ix=0; ix < hsize; ix++) {
        tmp = ix;
        fval[0] = pRect->aspRectLU[0] + (tmp * wshif);
        fval[1] = pRect->aspRectLU[1] + (tmp * hshif);

        getPtTran(rval, rangle, offset, fval);
        
        ptL[ix*2] = round(rval[0]);
        ptL[ix*2+1] = round(rval[1]);
    }

    for (ix=0; ix < wsize; ix++) {
        sprintf_f(rs->logs, "%d. D: (%4d, %4d), U: (%4d, %4d)\n", ix, ptD[ix*2], ptD[ix*2+1], ptU[ix*2], ptU[ix*2+1]);
        print_f(rs->plogs, "SRH", rs->logs);    
    }

    for (ix=0; ix < hsize; ix++) {
        sprintf_f(rs->logs, "%d. L: (%4d, %4d), R: (%4d, %4d)\n", ix, ptL[ix*2], ptL[ix*2+1], ptR[ix*2], ptR[ix*2+1]);
        print_f(rs->plogs, "SRH", rs->logs);    
    }
    
    return 0;
}

#define LOG_SEARCHRECT_8_BITSDN_EN (0)
static int srhRotRect8BitsDn(struct procRes_s *rs, int *real, struct aspRectObj *pRect, CFLOAT dg, CFLOAT *offset, char *colr, char *colrdiff, char *bmp, int oldRowsz, int bpp, int pidx, CFLOAT wcnt, CFLOAT hcnt)
{
#define DRAW_COLORDN_8_BITS (1)
#define DRAW_COLORDN_8_BITS_RECOVER (0)
#define ORG_COLORDN_8_BITS_RECOVER (0)
#define COLOR_RANGEDN_8_BITS (50)
    struct aspRectObj *pRectsrh=0;
    CFLOAT piAngle = 180.0, thacos=0, thasin=0, rangle[2], theta=0;
    CFLOAT width=0, high=0, tmp=0, wshif=0, hshif=0, fval=0;
    int *ptU=0, *ptD=0, *ptL=0, *ptR=0;
    CFLOAT *ptUf=0, *ptDf=0, *ptLf=0, *ptRf=0;
    int wsize=0, hsize=0, ix=0, bitset=0, ret=0, err=0;
    char *src=0;
    int dx=0, dy=0;
    int *drgbU=0, *drgbD=0, *drgbL=0, *drgbR=0;
    char *orgbU=0, *orgbD=0, *orgbL=0, *orgbR=0;
    int mindrgb=0;
    CFLOAT minfound[2]={0};
    CFLOAT roffset[2]={0};
    CFLOAT rvdg=0.0;
    CFLOAT pfound[2]={0};
    
    int preal[2]={0};
    #if 1 //DRAW_COLORDN_8_BITS
    uint8_t drawclor = 50, bkupclor=0;
    #endif
    
    int sumdiff=0, summin=0; 

    bitset = bpp / 8;
    
    theta = dg;

    theta = theta * M_PI / piAngle;

    thacos = cos(theta);
    thasin = sin(theta);
    
    rangle[0] = thacos;
    rangle[1] = thasin;
    
    wsize = (int)wcnt;
    hsize = (int)hcnt;
    
    pRectsrh = aspMemalloc(sizeof(struct aspRectObj), pidx);
    ptU = aspMemalloc(sizeof(int) * wsize * 2, pidx);
    ptD = aspMemalloc(sizeof(int) * wsize * 2, pidx);
    ptL = aspMemalloc(sizeof(int) * hsize * 2, pidx);
    ptR = aspMemalloc(sizeof(int) * hsize * 2, pidx);

    ptUf = aspMemalloc(sizeof(CFLOAT) * wsize * 2, pidx);
    ptDf = aspMemalloc(sizeof(CFLOAT) * wsize * 2, pidx);
    ptLf = aspMemalloc(sizeof(CFLOAT) * hsize * 2, pidx);
    ptRf = aspMemalloc(sizeof(CFLOAT) * hsize * 2, pidx);

    drgbU = aspMemalloc(sizeof(int) * wsize * 1, pidx);
    drgbD = aspMemalloc(sizeof(int) * wsize * 1, pidx);
    drgbL = aspMemalloc(sizeof(int) * hsize * 1, pidx);
    drgbR = aspMemalloc(sizeof(int) * hsize * 1, pidx);

    orgbU = aspMemalloc(sizeof(char) * wsize * 1, pidx);
    orgbD = aspMemalloc(sizeof(char) * wsize * 1, pidx);
    orgbL = aspMemalloc(sizeof(char) * hsize * 1, pidx);
    orgbR = aspMemalloc(sizeof(char) * hsize * 1, pidx);
    
    dbgprintRect(pRect);

    width = pRect->aspRectRD[0] - pRect->aspRectLD[0];
    high = pRect->aspRectRU[1] - pRect->aspRectRD[1];

    #if LOG_SEARCHRECT_8_BITSDN_EN
    sprintf_f(rs->logs, "width: %4.2lf high: %4.2lf, wcnt: %4.2lf hcnt: %4.2lf \n", width, high, wcnt, hcnt);
    print_f(rs->plogs, "SRHDN", rs->logs);    
    #endif

    getRectTran(pRect, dg, offset, pRectsrh);

    //dbgprintRect(pRectsrh);

    width = pRectsrh->aspRectRD[0] - pRectsrh->aspRectLD[0];
    high = pRectsrh->aspRectRD[1] - pRectsrh->aspRectLD[1];

    wshif = width / wcnt;
    hshif = high / wcnt;

    #if LOG_SEARCHRECT_8_BITSDN_EN
    sprintf_f(rs->logs, "width: %4.2lf high: %4.2lf, wcnt: %4.2lf hcnt: %4.2lf wshif: %4.2lf hshif: %4.2lf - DN\n", width, high, wcnt, hcnt, wshif, hshif);
    print_f(rs->plogs, "SRHDN", rs->logs);    
    #endif

    for (ix=0; ix < wsize; ix++) {
        tmp = ix;
        fval = pRectsrh->aspRectLD[0] + (tmp * wshif);
        ptDf[ix*2] = fval;
        ptD[ix*2] = round(fval);
        fval = pRectsrh->aspRectLD[1] + (tmp * hshif);
        ptDf[ix*2+1] = fval;
        ptD[ix*2+1] = round(fval);

        if ((ptD[ix*2] < 0) || (ptD[ix*2+1] < 0)) {
            orgbD[ix] = -1;
            drgbD[ix] = -1;
            continue;
        }

        src = getPixel(bmp, ptD[ix*2], ptD[ix*2+1], oldRowsz, bitset);

        //memcpy(&orgbD[ix*3], src, 3);
        orgbD[ix] = *src;

        drgbD[ix] = abs(src[0] - colr[0]);
        //drgbD[ix*3+1] = abs(src[1] - colr[1]);
        //drgbD[ix*3+2] = abs(src[2] - colr[2]);
        
        #if DRAW_COLORDN_8_BITS
        //sprintf_f(rs->logs, "(%d, %d) [0x%.8x] draw color org: %d change to %d \n", ptD[ix*2], ptD[ix*2+1], (uint32_t)src, src[0], drawclor);
        //print_f(rs->plogs, "SRHDN", rs->logs);

        src[0] = drawclor;
        #endif
    }

    width = pRectsrh->aspRectRU[0] - pRectsrh->aspRectRD[0];
    high = pRectsrh->aspRectRU[1] - pRectsrh->aspRectRD[1];

    wshif = width / hcnt;
    hshif = high / hcnt;

    #if LOG_SEARCHRECT_8_BITSDN_EN
    sprintf_f(rs->logs, "width: %4.2lf high: %4.2lf, wcnt: %4.2lf hcnt: %4.2lf wshif: %4.2lf hshif: %4.2lf - RT\n", width, high, wcnt, hcnt, wshif, hshif);
    print_f(rs->plogs, "SRHDN", rs->logs);    
    #endif

    for (ix=0; ix < hsize; ix++) {
        tmp = ix;
        fval = pRectsrh->aspRectRD[0] + (tmp * wshif);
        ptRf[ix*2] = fval;
        ptR[ix*2] = round(fval);
        fval = pRectsrh->aspRectRD[1] + (tmp * hshif);
        ptRf[ix*2+1] = fval;
        ptR[ix*2+1] = round(fval);

        if ((ptR[ix*2] < 0) || (ptR[ix*2+1] < 0)) {
            orgbR[ix] = -1;
            drgbR[ix] = -1;
            continue;
        }

        src = getPixel(bmp, ptR[ix*2], ptR[ix*2+1], oldRowsz, bitset);

        //memcpy(&orgbR[ix*3], src, 3);
        orgbR[ix] = *src;

        drgbR[ix] = abs(src[0] - colr[0]);
        //drgbR[ix*3+1] = abs(src[1] - colr[1]);
        //drgbR[ix*3+2] = abs(src[2] - colr[2]);
        
        #if DRAW_COLORDN_8_BITS
        //sprintf_f(rs->logs, "(%d, %d) [0x%.8x] draw color org: %d change to %d \n", ptR[ix*2], ptR[ix*2+1], (uint32_t)src, src[0], drawclor);
        //print_f(rs->plogs, "SRHDN", rs->logs);

        src[0] = drawclor;
        #endif
    }

    width = pRectsrh->aspRectLU[0] - pRectsrh->aspRectRU[0];
    high = pRectsrh->aspRectLU[1] - pRectsrh->aspRectRU[1];

    wshif = width / wcnt;
    hshif = high / wcnt;

    #if LOG_SEARCHRECT_8_BITSDN_EN
    sprintf_f(rs->logs, "width: %4.2lf high: %4.2lf, wcnt: %4.2lf hcnt: %4.2lf wshif: %4.2lf hshif: %4.2lf - UP\n", width, high, wcnt, hcnt, wshif, hshif);
    print_f(rs->plogs, "SRHDN", rs->logs);    
    #endif

    for (ix=0; ix < wsize; ix++) {
        tmp = ix;
        fval = pRectsrh->aspRectRU[0] + (tmp * wshif);
        ptUf[ix*2] = fval;
        ptU[ix*2] = round(fval);
        fval = pRectsrh->aspRectRU[1] + (tmp * hshif);
        ptUf[ix*2+1] = fval;
        ptU[ix*2+1] = round(fval);

        if ((ptU[ix*2] < 0) || (ptU[ix*2+1] < 0)) {
            orgbU[ix] = -1;
            drgbU[ix] = -1;
            continue;
        }
        
        src = getPixel(bmp, ptU[ix*2], ptU[ix*2+1], oldRowsz, bitset);

        //memcpy(&orgbU[ix*3], src, 3);
        orgbU[ix] = *src;

        drgbU[ix] = abs(src[0] - colr[0]);
        //drgbU[ix*3+1] = abs(src[1] - colr[1]);
        //drgbU[ix*3+2] = abs(src[2] - colr[2]);
        
        #if DRAW_COLORDN_8_BITS
        //sprintf_f(rs->logs, "(%d, %d) [0x%.8x] draw color org: %d change to %d \n", ptU[ix*2], ptU[ix*2+1], (uint32_t)src, src[0], drawclor);
        //print_f(rs->plogs, "SRHDN", rs->logs);

        src[0] = drawclor;
        #endif
    }

    width = pRectsrh->aspRectLD[0] - pRectsrh->aspRectLU[0];
    high = pRectsrh->aspRectLD[1] - pRectsrh->aspRectLU[1];

    wshif = width / hcnt;
    hshif = high / hcnt;

    #if LOG_SEARCHRECT_8_BITSDN_EN
    sprintf_f(rs->logs, "width: %4.2lf high: %4.2lf, wcnt: %4.2lf hcnt: %4.2lf wshif: %4.2lf hshif: %4.2lf - LF\n", width, high, wcnt, hcnt, wshif, hshif);
    print_f(rs->plogs, "SRHDN", rs->logs);    
    #endif

    for (ix=0; ix < hsize; ix++) {
        tmp = ix;
        fval = pRectsrh->aspRectLU[0] + (tmp * wshif);
        ptLf[ix*2] = fval;
        ptL[ix*2] = round(fval);
        fval = pRectsrh->aspRectLU[1] + (tmp * hshif);
        ptLf[ix*2+1] = fval;
        ptL[ix*2+1] = round(fval);

        if ((ptL[ix*2] < 0) || (ptL[ix*2+1] < 0)) {
            orgbL[ix] = -1;
            drgbL[ix] = -1;
            continue;
        }
        
        src = getPixel(bmp, ptL[ix*2], ptL[ix*2+1], oldRowsz, bitset);
        
        //memcpy(&orgbL[ix*3], src, 3);
        orgbL[ix] = *src;

        drgbL[ix] = abs(src[0] - colr[0]);
        //drgbL[ix*3+1] = abs(src[1] - colr[1]);
        //drgbL[ix*3+2] = abs(src[2] - colr[2]);
        
        #if DRAW_COLORDN_8_BITS
        //sprintf_f(rs->logs, "(%d, %d) [0x%.8x] draw color org: %d change to %d \n", ptL[ix*2], ptL[ix*2+1], (uint32_t)src, src[0], drawclor);
        //print_f(rs->plogs, "SRHDN", rs->logs);

        src[0] = drawclor;
        #endif
    }

    mindrgb = colrdiff[0];

    roffset[0] = 0.0 - offset[0];
    roffset[1] = 0.0 - offset[1];
    rvdg = 360.0 - dg;
    
    for (ix=0; ix < wsize; ix++) {
        #if LOG_SEARCHRECT_8_BITSDN_EN
        sprintf_f(rs->logs, "%d. D: (%4d, %4d), org(%3d) diff(%3d) min(%d)\n", ix, ptD[ix*2], ptD[ix*2+1], orgbD[ix], drgbD[ix], mindrgb);
        print_f(rs->plogs, "SRHDN", rs->logs);
        #endif

        if ((mindrgb >= drgbD[ix]) && (drgbD[ix] > 0)) {

            minfound[0] = ptDf[ix*2];
            minfound[1] = ptDf[ix*2+1];

            src = getPixel(bmp, ptD[ix*2], ptD[ix*2+1], oldRowsz, bitset);    
            
            #if LOG_SEARCHRECT_8_BITSDN_EN
            sprintf_f(rs->logs, "D set color to default (%2lf, %2lf) [0x%.8x] (%d) -> (%d) \n", minfound[0], minfound[1], (uint32_t)src, src[0], colr[0]);
            print_f(rs->plogs, "SRHDN", rs->logs);
            #endif

            bkupclor = src[0];
            src[0] = colr[0];    
            msync(src, 1, MS_SYNC);
            
            getPtTranRvs(pfound, rvdg, roffset, minfound);
            
            err = adjCircleRect8BitsDn(rs, preal, pfound, dg, offset, colrdiff, bmp, oldRowsz, bpp, pidx);

            #if DRAW_COLORDN_8_BITS_RECOVER
            src[0] = bkupclor;
            msync(src, 1, MS_SYNC);
            #endif

            #if DRAW_COLORDN_8_BITS_RECOVER
            src[0] = drawclor;
            msync(src, 1, MS_SYNC);
            #endif
            
            if (err == 0) {

                sprintf_f(rs->logs, "D preal(%4d, %4d) 8bits \n", preal[0], preal[1]);
                print_f(rs->plogs, "SRHDN", rs->logs);

                real[0] = preal[0];
                real[1] = preal[1];

                return 0;
            }
        }
    }

    for (ix=0; ix < wsize; ix++) {
        #if LOG_SEARCHRECT_8_BITSDN_EN
        sprintf_f(rs->logs, "%d. U: (%4d, %4d), org(%3d) diff(%3d) min(%d)\n", ix, ptU[ix*2], ptU[ix*2+1], orgbU[ix], drgbU[ix], mindrgb);
        print_f(rs->plogs, "SRHDN", rs->logs);    
        #endif
        
        if ((mindrgb >= drgbU[ix]) && (drgbU[ix] > 0)) {

            minfound[0] = ptUf[ix*2];
            minfound[1] = ptUf[ix*2+1];

            src = getPixel(bmp, ptU[ix*2], ptU[ix*2+1], oldRowsz, bitset);    
            
            #if LOG_SEARCHRECT_8_BITSDN_EN
            sprintf_f(rs->logs, "U set color to default (%2lf, %2lf) [0x%.8x] (%d) -> (%d) \n", minfound[0], minfound[1], (uint32_t)src, src[0], colr[0]);
            print_f(rs->plogs, "SRHDN", rs->logs);
            #endif

            bkupclor = src[0];
            src[0] = colr[0];
            msync(src, 1, MS_SYNC);

            getPtTranRvs(pfound, rvdg, roffset, minfound);

            err = adjCircleRect8BitsDn(rs, preal, pfound, dg, offset, colrdiff, bmp, oldRowsz, bpp, pidx);

            #if DRAW_COLORDN_8_BITS_RECOVER
            src[0] = bkupclor;
            msync(src, 1, MS_SYNC);
            #endif

            #if DRAW_COLORDN_8_BITS_RECOVER
            src[0] = drawclor;
            msync(src, 1, MS_SYNC);
            #endif

            if (err == 0) {

                sprintf_f(rs->logs, "U preal(%4d, %4d) 8bits \n", preal[0], preal[1]);
                print_f(rs->plogs, "SRHDN", rs->logs);

                real[0] = preal[0];
                real[1] = preal[1];

                return 0;
            }
        }
    }

    for (ix=0; ix < hsize; ix++) {
        #if LOG_SEARCHRECT_8_BITSDN_EN
        sprintf_f(rs->logs, "%d. L: (%4d, %4d), org(%3d) diff(%3d) min(%d)\n", ix, ptL[ix*2], ptL[ix*2+1], orgbL[ix], drgbL[ix], mindrgb);
        print_f(rs->plogs, "SRHDN", rs->logs);   
        #endif
        
        if ((mindrgb >= drgbL[ix]) && (drgbL[ix] > 0)) {
        
            minfound[0] = ptLf[ix*2];
            minfound[1] = ptLf[ix*2+1];
            
            src = getPixel(bmp, ptL[ix*2], ptL[ix*2+1], oldRowsz, bitset);    

            #if LOG_SEARCHRECT_8_BITSDN_EN
            sprintf_f(rs->logs, "L set color to default (%2lf, %2lf) [0x%.8x] (%d) -> (%d) \n", minfound[0], minfound[1], (uint32_t)src, src[0], colr[0]);
            print_f(rs->plogs, "SRHDN", rs->logs);
            #endif
            
            bkupclor = src[0];
            src[0] = colr[0];
            msync(src, 1, MS_SYNC);
            
            getPtTranRvs(pfound, rvdg, roffset, minfound);

            err = adjCircleRect8BitsDn(rs, preal, pfound, dg, offset, colrdiff, bmp, oldRowsz, bpp, pidx);

            #if DRAW_COLORDN_8_BITS_RECOVER
            src[0] = bkupclor;
            msync(src, 1, MS_SYNC);
            #endif

            #if DRAW_COLORDN_8_BITS_RECOVER
            src[0] = drawclor;
            msync(src, 1, MS_SYNC);
            #endif

            if (err == 0) {

                sprintf_f(rs->logs, "L preal(%4d, %4d) 8bits \n", preal[0], preal[1]);
                print_f(rs->plogs, "SRHDN", rs->logs);

                real[0] = preal[0];
                real[1] = preal[1];

                return 0;
            }
        }
    }

    for (ix=0; ix < hsize; ix++) {
        #if LOG_SEARCHRECT_8_BITSDN_EN
        sprintf_f(rs->logs, "%d. R: (%4d, %4d), org(%3d) diff(%3d) min(%d)\n", ix, ptR[ix*2], ptR[ix*2+1], orgbR[ix], drgbR[ix], mindrgb);
        print_f(rs->plogs, "SRHDN", rs->logs);      
        #endif

        if ((mindrgb >= drgbR[ix]) && (drgbR[ix] > 0)) {

            minfound[0] = ptRf[ix*2];
            minfound[1] = ptRf[ix*2+1];

            src = getPixel(bmp, ptR[ix*2], ptR[ix*2+1], oldRowsz, bitset);    

            #if LOG_SEARCHRECT_8_BITSDN_EN
            sprintf_f(rs->logs, "R set color to default (%2lf, %2lf) [0x%.8x] (%d) -> (%d) \n", minfound[0], minfound[1], (uint32_t)src, src[0], colr[0]);
            print_f(rs->plogs, "SRHDN", rs->logs);
            #endif

            bkupclor = src[0];
            src[0] = colr[0];
            msync(src, 1, MS_SYNC);
            
            getPtTranRvs(pfound, rvdg, roffset, minfound);

            err = adjCircleRect8BitsDn(rs, preal, pfound, dg, offset, colrdiff, bmp, oldRowsz, bpp, pidx);

            #if DRAW_COLORDN_8_BITS_RECOVER
            src[0] = bkupclor;
            msync(src, 1, MS_SYNC);
            #endif

            #if DRAW_COLORDN_8_BITS_RECOVER
            src[0] = drawclor;
            msync(src, 1, MS_SYNC);
            #endif

            if (err == 0) {

                sprintf_f(rs->logs, "R preal(%4d, %4d) 8bits \n", preal[0], preal[1]);
                print_f(rs->plogs, "SRHDN", rs->logs);

                real[0] = preal[0];
                real[1] = preal[1];

                return 0;
            }
        }
    }

    #if 0 /* debug */
    return -8;
    #endif


    //pfound[0] = minfound[0];
    //pfound[1] = minfound[1];
    
    return -9;
}

#define LOG_SEARCHRECT_8_BITS_EN (0)
static int srhRotRect8Bits(struct procRes_s *rs, int *real, struct aspRectObj *pRect, CFLOAT dg, CFLOAT *offset, char *colr, char *colrdiff, char *bmp, int oldRowsz, int bpp, int pidx, CFLOAT wcnt, CFLOAT hcnt)
{
#define DRAW_COLOR_8_BITS (1)
#define DRAW_COLOR_8_BITS_RECOVER (1)
#define ORG_COLOR_8_BITS_RECOVER (0)
#define COLOR_RANGE_8_BITS (25)
    struct aspRectObj *pRectsrh=0;
    CFLOAT piAngle = 180.0, thacos=0, thasin=0, rangle[2], theta=0;
    CFLOAT width=0, high=0, tmp=0, wshif=0, hshif=0, fval=0;
    int *ptU=0, *ptD=0, *ptL=0, *ptR=0;
    CFLOAT *ptUf=0, *ptDf=0, *ptLf=0, *ptRf=0;
    int wsize=0, hsize=0, ix=0, bitset=0, ret=0, err=0;
    char *src=0;
    int dx=0, dy=0;
    int *drgbU=0, *drgbD=0, *drgbL=0, *drgbR=0;
    char *orgbU=0, *orgbD=0, *orgbL=0, *orgbR=0;
    int mindrgb=0;
    CFLOAT minfound[2]={0};
    CFLOAT roffset[2]={0};
    CFLOAT rvdg=0.0;
    CFLOAT pfound[2]={0};
    
    int preal[2]={0};
    #if 1 //DRAW_COLOR_8_BITS
    uint8_t drawclor = 0, bkupclor=0;
    #endif
    
    int sumdiff=0, summin=0; 

    bitset = bpp / 8;
    
    theta = dg;

    theta = theta * M_PI / piAngle;

    thacos = cos(theta);
    thasin = sin(theta);
    
    rangle[0] = thacos;
    rangle[1] = thasin;
    
    wsize = (int)wcnt;
    hsize = (int)hcnt;
    
    pRectsrh = aspMemalloc(sizeof(struct aspRectObj), pidx);
    ptU = aspMemalloc(sizeof(int) * wsize * 2, pidx);
    ptD = aspMemalloc(sizeof(int) * wsize * 2, pidx);
    ptL = aspMemalloc(sizeof(int) * hsize * 2, pidx);
    ptR = aspMemalloc(sizeof(int) * hsize * 2, pidx);

    ptUf = aspMemalloc(sizeof(CFLOAT) * wsize * 2, pidx);
    ptDf = aspMemalloc(sizeof(CFLOAT) * wsize * 2, pidx);
    ptLf = aspMemalloc(sizeof(CFLOAT) * hsize * 2, pidx);
    ptRf = aspMemalloc(sizeof(CFLOAT) * hsize * 2, pidx);

    drgbU = aspMemalloc(sizeof(int) * wsize * 1, pidx);
    drgbD = aspMemalloc(sizeof(int) * wsize * 1, pidx);
    drgbL = aspMemalloc(sizeof(int) * hsize * 1, pidx);
    drgbR = aspMemalloc(sizeof(int) * hsize * 1, pidx);

    orgbU = aspMemalloc(sizeof(char) * wsize * 1, pidx);
    orgbD = aspMemalloc(sizeof(char) * wsize * 1, pidx);
    orgbL = aspMemalloc(sizeof(char) * hsize * 1, pidx);
    orgbR = aspMemalloc(sizeof(char) * hsize * 1, pidx);
    
    dbgprintRect(pRect);

    width = pRect->aspRectRD[0] - pRect->aspRectLD[0];
    high = pRect->aspRectRU[1] - pRect->aspRectRD[1];

    #if LOG_SEARCHRECT_8_BITS_EN
    sprintf_f(rs->logs, "width: %4.2lf high: %4.2lf, wcnt: %4.2lf hcnt: %4.2lf \n", width, high, wcnt, hcnt);
    print_f(rs->plogs, "SRH", rs->logs);    
    #endif

    getRectTran(pRect, dg, offset, pRectsrh);

    //dbgprintRect(pRectsrh);

    width = pRectsrh->aspRectRD[0] - pRectsrh->aspRectLD[0];
    high = pRectsrh->aspRectRD[1] - pRectsrh->aspRectLD[1];

    wshif = width / wcnt;
    hshif = high / wcnt;

    #if LOG_SEARCHRECT_8_BITS_EN
    sprintf_f(rs->logs, "width: %4.2lf high: %4.2lf, wcnt: %4.2lf hcnt: %4.2lf wshif: %4.2lf hshif: %4.2lf - DN\n", width, high, wcnt, hcnt, wshif, hshif);
    print_f(rs->plogs, "SRH", rs->logs);    
    #endif

    for (ix=0; ix < wsize; ix++) {
        tmp = ix;
        fval = pRectsrh->aspRectLD[0] + (tmp * wshif);
        ptDf[ix*2] = fval;
        ptD[ix*2] = round(fval);
        fval = pRectsrh->aspRectLD[1] + (tmp * hshif);
        ptDf[ix*2+1] = fval;
        ptD[ix*2+1] = round(fval);

        if ((ptD[ix*2] < 0) || (ptD[ix*2+1] < 0)) {
            orgbD[ix] = -1;
            drgbD[ix] = -1;
            continue;
        }

        src = getPixel(bmp, ptD[ix*2], ptD[ix*2+1], oldRowsz, bitset);

        //memcpy(&orgbD[ix*3], src, 3);
        orgbD[ix] = *src;

        drgbD[ix] = abs(src[0] - colr[0]);
        //drgbD[ix*3+1] = abs(src[1] - colr[1]);
        //drgbD[ix*3+2] = abs(src[2] - colr[2]);
        
        #if DRAW_COLOR_8_BITS
        //sprintf_f(rs->logs, "(%d, %d) [0x%.8x] draw color org: %d change to %d \n", ptD[ix*2], ptD[ix*2+1], (uint32_t)src, src[0], drawclor);
        //print_f(rs->plogs, "SRH", rs->logs);

        src[0] = drawclor;
        #endif
    }

    width = pRectsrh->aspRectRU[0] - pRectsrh->aspRectRD[0];
    high = pRectsrh->aspRectRU[1] - pRectsrh->aspRectRD[1];

    wshif = width / hcnt;
    hshif = high / hcnt;

    #if LOG_SEARCHRECT_8_BITS_EN
    sprintf_f(rs->logs, "width: %4.2lf high: %4.2lf, wcnt: %4.2lf hcnt: %4.2lf wshif: %4.2lf hshif: %4.2lf - RT\n", width, high, wcnt, hcnt, wshif, hshif);
    print_f(rs->plogs, "SRH", rs->logs);    
    #endif

    for (ix=0; ix < hsize; ix++) {
        tmp = ix;
        fval = pRectsrh->aspRectRD[0] + (tmp * wshif);
        ptRf[ix*2] = fval;
        ptR[ix*2] = round(fval);
        fval = pRectsrh->aspRectRD[1] + (tmp * hshif);
        ptRf[ix*2+1] = fval;
        ptR[ix*2+1] = round(fval);

        if ((ptR[ix*2] < 0) || (ptR[ix*2+1] < 0)) {
            orgbR[ix] = -1;
            drgbR[ix] = -1;
            continue;
        }

        src = getPixel(bmp, ptR[ix*2], ptR[ix*2+1], oldRowsz, bitset);

        //memcpy(&orgbR[ix*3], src, 3);
        orgbR[ix] = *src;

        drgbR[ix] = abs(src[0] - colr[0]);
        //drgbR[ix*3+1] = abs(src[1] - colr[1]);
        //drgbR[ix*3+2] = abs(src[2] - colr[2]);
        
        #if DRAW_COLOR_8_BITS
        //sprintf_f(rs->logs, "(%d, %d) [0x%.8x] draw color org: %d change to %d \n", ptR[ix*2], ptR[ix*2+1], (uint32_t)src, src[0], drawclor);
        //print_f(rs->plogs, "SRH", rs->logs);

        src[0] = drawclor;
        #endif
    }

    width = pRectsrh->aspRectLU[0] - pRectsrh->aspRectRU[0];
    high = pRectsrh->aspRectLU[1] - pRectsrh->aspRectRU[1];

    wshif = width / wcnt;
    hshif = high / wcnt;

    #if LOG_SEARCHRECT_8_BITS_EN
    sprintf_f(rs->logs, "width: %4.2lf high: %4.2lf, wcnt: %4.2lf hcnt: %4.2lf wshif: %4.2lf hshif: %4.2lf - UP\n", width, high, wcnt, hcnt, wshif, hshif);
    print_f(rs->plogs, "SRH", rs->logs);    
    #endif

    for (ix=0; ix < wsize; ix++) {
        tmp = ix;
        fval = pRectsrh->aspRectRU[0] + (tmp * wshif);
        ptUf[ix*2] = fval;
        ptU[ix*2] = round(fval);
        fval = pRectsrh->aspRectRU[1] + (tmp * hshif);
        ptUf[ix*2+1] = fval;
        ptU[ix*2+1] = round(fval);

        if ((ptU[ix*2] < 0) || (ptU[ix*2+1] < 0)) {
            orgbU[ix] = -1;
            drgbU[ix] = -1;
            continue;
        }
        
        src = getPixel(bmp, ptU[ix*2], ptU[ix*2+1], oldRowsz, bitset);

        //memcpy(&orgbU[ix*3], src, 3);
        orgbU[ix] = *src;

        drgbU[ix] = abs(src[0] - colr[0]);
        //drgbU[ix*3+1] = abs(src[1] - colr[1]);
        //drgbU[ix*3+2] = abs(src[2] - colr[2]);
        
        #if DRAW_COLOR_8_BITS
        //sprintf_f(rs->logs, "(%d, %d) [0x%.8x] draw color org: %d change to %d \n", ptU[ix*2], ptU[ix*2+1], (uint32_t)src, src[0], drawclor);
        //print_f(rs->plogs, "SRH", rs->logs);

        src[0] = drawclor;
        #endif
    }

    width = pRectsrh->aspRectLD[0] - pRectsrh->aspRectLU[0];
    high = pRectsrh->aspRectLD[1] - pRectsrh->aspRectLU[1];

    wshif = width / hcnt;
    hshif = high / hcnt;

    #if LOG_SEARCHRECT_8_BITS_EN
    sprintf_f(rs->logs, "width: %4.2lf high: %4.2lf, wcnt: %4.2lf hcnt: %4.2lf wshif: %4.2lf hshif: %4.2lf - LF\n", width, high, wcnt, hcnt, wshif, hshif);
    print_f(rs->plogs, "SRH", rs->logs);    
    #endif

    for (ix=0; ix < hsize; ix++) {
        tmp = ix;
        fval = pRectsrh->aspRectLU[0] + (tmp * wshif);
        ptLf[ix*2] = fval;
        ptL[ix*2] = round(fval);
        fval = pRectsrh->aspRectLU[1] + (tmp * hshif);
        ptLf[ix*2+1] = fval;
        ptL[ix*2+1] = round(fval);

        if ((ptL[ix*2] < 0) || (ptL[ix*2+1] < 0)) {
            orgbL[ix] = -1;
            drgbL[ix] = -1;
            continue;
        }
        
        src = getPixel(bmp, ptL[ix*2], ptL[ix*2+1], oldRowsz, bitset);
        
        //memcpy(&orgbL[ix*3], src, 3);
        orgbL[ix] = *src;

        drgbL[ix] = abs(src[0] - colr[0]);
        //drgbL[ix*3+1] = abs(src[1] - colr[1]);
        //drgbL[ix*3+2] = abs(src[2] - colr[2]);
        
        #if DRAW_COLOR_8_BITS
        //sprintf_f(rs->logs, "(%d, %d) [0x%.8x] draw color org: %d change to %d \n", ptL[ix*2], ptL[ix*2+1], (uint32_t)src, src[0], drawclor);
        //print_f(rs->plogs, "SRH", rs->logs);

        src[0] = drawclor;
        #endif
    }

    mindrgb = colrdiff[0];

    roffset[0] = 0.0 - offset[0];
    roffset[1] = 0.0 - offset[1];
    rvdg = 360.0 - dg;
    
    for (ix=0; ix < wsize; ix++) {
        #if LOG_SEARCHRECT_8_BITS_EN
        sprintf_f(rs->logs, "%d. D: (%4d, %4d), org(%3d) diff(%3d) min(%d)\n", ix, ptD[ix*2], ptD[ix*2+1], orgbD[ix], drgbD[ix], mindrgb);
        print_f(rs->plogs, "SRH", rs->logs);
        #endif

        if ((mindrgb >= drgbD[ix]) && (drgbD[ix] > 0)) {

            minfound[0] = ptDf[ix*2];
            minfound[1] = ptDf[ix*2+1];

            src = getPixel(bmp, ptD[ix*2], ptD[ix*2+1], oldRowsz, bitset);    
            
            #if LOG_SEARCHRECT_8_BITS_EN
            sprintf_f(rs->logs, "D set color to default (%2lf, %2lf) [0x%.8x] (%d) -> (%d) \n", minfound[0], minfound[1], (uint32_t)src, src[0], colr[0]);
            print_f(rs->plogs, "SRH", rs->logs);
            #endif

            bkupclor = src[0];
            src[0] = colr[0];    
            msync(src, 1, MS_SYNC);
            
            getPtTranRvs(pfound, rvdg, roffset, minfound);
            
            err = adjCircleRect8Bits(rs, preal, pfound, dg, offset, colrdiff, bmp, oldRowsz, bpp, pidx);

            #if ORG_COLOR_8_BITS_RECOVER
            src[0] = bkupclor;
            msync(src, 1, MS_SYNC);
            #endif

            #if DRAW_COLOR_8_BITS_RECOVER
            src[0] = drawclor;
            msync(src, 1, MS_SYNC);
            #endif
            
            if (err == 0) {

                sprintf_f(rs->logs, "D preal(%4d, %4d) 8bits \n", preal[0], preal[1]);
                print_f(rs->plogs, "SRH", rs->logs);

                real[0] = preal[0];
                real[1] = preal[1];

                return 0;
            }
        }
    }

    for (ix=0; ix < wsize; ix++) {
        #if LOG_SEARCHRECT_8_BITS_EN
        sprintf_f(rs->logs, "%d. U: (%4d, %4d), org(%3d) diff(%3d) min(%d)\n", ix, ptU[ix*2], ptU[ix*2+1], orgbU[ix], drgbU[ix], mindrgb);
        print_f(rs->plogs, "SRH", rs->logs);    
        #endif
        
        if ((mindrgb >= drgbU[ix]) && (drgbU[ix] > 0)) {

            minfound[0] = ptUf[ix*2];
            minfound[1] = ptUf[ix*2+1];

            src = getPixel(bmp, ptU[ix*2], ptU[ix*2+1], oldRowsz, bitset);    
            
            #if LOG_SEARCHRECT_8_BITS_EN
            sprintf_f(rs->logs, "U set color to default (%2lf, %2lf) [0x%.8x] (%d) -> (%d) \n", minfound[0], minfound[1], (uint32_t)src, src[0], colr[0]);
            print_f(rs->plogs, "SRH", rs->logs);
            #endif

            bkupclor = src[0];
            src[0] = colr[0];
            msync(src, 1, MS_SYNC);

            getPtTranRvs(pfound, rvdg, roffset, minfound);

            err = adjCircleRect8Bits(rs, preal, pfound, dg, offset, colrdiff, bmp, oldRowsz, bpp, pidx);

            #if ORG_COLOR_8_BITS_RECOVER
            src[0] = bkupclor;
            msync(src, 1, MS_SYNC);
            #endif

            #if DRAW_COLOR_8_BITS_RECOVER
            src[0] = drawclor;
            msync(src, 1, MS_SYNC);
            #endif

            if (err == 0) {

                sprintf_f(rs->logs, "U preal(%4d, %4d) 8bits \n", preal[0], preal[1]);
                print_f(rs->plogs, "SRH", rs->logs);

                real[0] = preal[0];
                real[1] = preal[1];

                return 0;
            }
        }
    }

    for (ix=0; ix < hsize; ix++) {
        #if LOG_SEARCHRECT_8_BITS_EN
        sprintf_f(rs->logs, "%d. L: (%4d, %4d), org(%3d) diff(%3d) min(%d)\n", ix, ptL[ix*2], ptL[ix*2+1], orgbL[ix], drgbL[ix], mindrgb);
        print_f(rs->plogs, "SRH", rs->logs);   
        #endif
        
        if ((mindrgb >= drgbL[ix]) && (drgbL[ix] > 0)) {
        
            minfound[0] = ptLf[ix*2];
            minfound[1] = ptLf[ix*2+1];
            
            src = getPixel(bmp, ptL[ix*2], ptL[ix*2+1], oldRowsz, bitset);    

            #if LOG_SEARCHRECT_8_BITS_EN
            sprintf_f(rs->logs, "L set color to default (%2lf, %2lf) [0x%.8x] (%d) -> (%d) \n", minfound[0], minfound[1], (uint32_t)src, src[0], colr[0]);
            print_f(rs->plogs, "SRH", rs->logs);
            #endif
            
            bkupclor = src[0];
            src[0] = colr[0];
            msync(src, 1, MS_SYNC);
            
            getPtTranRvs(pfound, rvdg, roffset, minfound);

            err = adjCircleRect8Bits(rs, preal, pfound, dg, offset, colrdiff, bmp, oldRowsz, bpp, pidx);

            #if ORG_COLOR_8_BITS_RECOVER
            src[0] = bkupclor;
            msync(src, 1, MS_SYNC);
            #endif

            #if DRAW_COLOR_8_BITS_RECOVER
            src[0] = drawclor;
            msync(src, 1, MS_SYNC);
            #endif

            if (err == 0) {

                sprintf_f(rs->logs, "L preal(%4d, %4d) 8bits \n", preal[0], preal[1]);
                print_f(rs->plogs, "SRH", rs->logs);

                real[0] = preal[0];
                real[1] = preal[1];

                return 0;
            }
        }
    }

    for (ix=0; ix < hsize; ix++) {
        #if LOG_SEARCHRECT_8_BITS_EN
        sprintf_f(rs->logs, "%d. R: (%4d, %4d), org(%3d) diff(%3d) min(%d)\n", ix, ptR[ix*2], ptR[ix*2+1], orgbR[ix], drgbR[ix], mindrgb);
        print_f(rs->plogs, "SRH", rs->logs);      
        #endif

        if ((mindrgb >= drgbR[ix]) && (drgbR[ix] > 0)) {

            minfound[0] = ptRf[ix*2];
            minfound[1] = ptRf[ix*2+1];

            src = getPixel(bmp, ptR[ix*2], ptR[ix*2+1], oldRowsz, bitset);    

            #if LOG_SEARCHRECT_8_BITS_EN
            sprintf_f(rs->logs, "R set color to default (%2lf, %2lf) [0x%.8x] (%d) -> (%d) \n", minfound[0], minfound[1], (uint32_t)src, src[0], colr[0]);
            print_f(rs->plogs, "SRH", rs->logs);
            #endif

            bkupclor = src[0];
            src[0] = colr[0];
            msync(src, 1, MS_SYNC);
            
            getPtTranRvs(pfound, rvdg, roffset, minfound);

            err = adjCircleRect8Bits(rs, preal, pfound, dg, offset, colrdiff, bmp, oldRowsz, bpp, pidx);

            #if ORG_COLOR_8_BITS_RECOVER
            src[0] = bkupclor;
            msync(src, 1, MS_SYNC);
            #endif

            #if DRAW_COLOR_8_BITS_RECOVER
            src[0] = drawclor;
            msync(src, 1, MS_SYNC);
            #endif

            if (err == 0) {

                sprintf_f(rs->logs, "R preal(%4d, %4d) 8bits \n", preal[0], preal[1]);
                print_f(rs->plogs, "SRH", rs->logs);

                real[0] = preal[0];
                real[1] = preal[1];

                return 0;
            }
        }
    }

    #if 0 /* debug */
    return -8;
    #endif


    //pfound[0] = minfound[0];
    //pfound[1] = minfound[1];
    
    return -9;
}

#define LOG_SEARCHRECT_EN (0)
static int srhRotRect(struct procRes_s *rs, CFLOAT *pfound, struct aspRectObj *pRect, CFLOAT dg, CFLOAT *offset, char *colr, char *bmp, int oldRowsz, int bpp, int pidx, CFLOAT wcnt, CFLOAT hcnt)
{
#define DRAW_COLOR (0)
#define COLOR_RANGE (15)
    struct aspRectObj *pRectsrh=0;
    CFLOAT piAngle = 180.0, thacos=0, thasin=0, rangle[2], theta=0;
    CFLOAT width=0, high=0, tmp=0, wshif=0, hshif=0, fval=0;
    int *ptU=0, *ptD=0, *ptL=0, *ptR=0;
    CFLOAT *ptUf=0, *ptDf=0, *ptLf=0, *ptRf=0;
    int wsize=0, hsize=0, ix=0, bitset=0, ret=0;
    char *src=0;
    int dx=0, dy=0;
    int *drgbU=0, *drgbD=0, *drgbL=0, *drgbR=0;
    char *orgbU=0, *orgbD=0, *orgbL=0, *orgbR=0;
    int mindrgb[3]={0};
    CFLOAT minfound[2]={0};
    CFLOAT roffset[2]={0};

    #if DRAW_COLOR
    char drawclor[3] = {0,0,0};
    #endif
    
    int sumdiff=0, summin=0; 

    bitset = bpp / 8;
    
    theta = dg;

    theta = theta * M_PI / piAngle;

    thacos = cos(theta);
    thasin = sin(theta);
    
    rangle[0] = thacos;
    rangle[1] = thasin;
    
    wsize = (int)wcnt;
    hsize = (int)hcnt;
    
    pRectsrh = aspMemalloc(sizeof(struct aspRectObj), pidx);
    ptU = aspMemalloc(sizeof(int) * wsize * 2, pidx);
    ptD = aspMemalloc(sizeof(int) * wsize * 2, pidx);
    ptL = aspMemalloc(sizeof(int) * hsize * 2, pidx);
    ptR = aspMemalloc(sizeof(int) * hsize * 2, pidx);

    ptUf = aspMemalloc(sizeof(CFLOAT) * wsize * 2, pidx);
    ptDf = aspMemalloc(sizeof(CFLOAT) * wsize * 2, pidx);
    ptLf = aspMemalloc(sizeof(CFLOAT) * hsize * 2, pidx);
    ptRf = aspMemalloc(sizeof(CFLOAT) * hsize * 2, pidx);

    drgbU = aspMemalloc(sizeof(int) * wsize * 3, pidx);
    drgbD = aspMemalloc(sizeof(int) * wsize * 3, pidx);
    drgbL = aspMemalloc(sizeof(int) * hsize * 3, pidx);
    drgbR = aspMemalloc(sizeof(int) * hsize * 3, pidx);

    orgbU = aspMemalloc(sizeof(char) * wsize * 3, pidx);
    orgbD = aspMemalloc(sizeof(char) * wsize * 3, pidx);
    orgbL = aspMemalloc(sizeof(char) * hsize * 3, pidx);
    orgbR = aspMemalloc(sizeof(char) * hsize * 3, pidx);
    
    //dbgprintRect(pRect);

    width = pRect->aspRectRD[0] - pRect->aspRectLD[0];
    high = pRect->aspRectRU[1] - pRect->aspRectRD[1];

    #if LOG_SEARCHRECT_EN
    sprintf_f(rs->logs, "width: %4.2lf high: %4.2lf, wcnt: %4.2lf hcnt: %4.2lf \n", width, high, wcnt, hcnt);
    print_f(rs->plogs, "SRH", rs->logs);    
    #endif

    getRectTran(pRect, dg, offset, pRectsrh);

    //dbgprintRect(pRectsrh);

    width = pRectsrh->aspRectRD[0] - pRectsrh->aspRectLD[0];
    high = pRectsrh->aspRectRD[1] - pRectsrh->aspRectLD[1];

    wshif = width / wcnt;
    hshif = high / wcnt;

    #if LOG_SEARCHRECT_EN
    sprintf_f(rs->logs, "width: %4.2lf high: %4.2lf, wcnt: %4.2lf hcnt: %4.2lf wshif: %4.2lf hshif: %4.2lf - DN\n", width, high, wcnt, hcnt, wshif, hshif);
    print_f(rs->plogs, "SRH", rs->logs);    
    #endif

    for (ix=0; ix < wsize; ix++) {
        tmp = ix;
        fval = pRectsrh->aspRectLD[0] + (tmp * wshif);
        ptDf[ix*2] = fval;
        ptD[ix*2] = round(fval);
        fval = pRectsrh->aspRectLD[1] + (tmp * hshif);
        ptDf[ix*2+1] = fval;
        ptD[ix*2+1] = round(fval);

        src = getPixel(bmp, ptD[ix*2], ptD[ix*2+1], oldRowsz, bitset);

        memcpy(&orgbD[ix*3], src, 3);

        drgbD[ix*3+0] = abs(src[0] - colr[0]);
        drgbD[ix*3+1] = abs(src[1] - colr[1]);
        drgbD[ix*3+2] = abs(src[2] - colr[2]);
        
        #if DRAW_COLOR
        //memcpy(src, drawclor, 3);
        //src[0] = drawclor[0];
        src[1] = drawclor[1];
        //src[2] = drawclor[2];
        #endif
    }

    width = pRectsrh->aspRectRU[0] - pRectsrh->aspRectRD[0];
    high = pRectsrh->aspRectRU[1] - pRectsrh->aspRectRD[1];

    wshif = width / hcnt;
    hshif = high / hcnt;

    #if LOG_SEARCHRECT_EN
    sprintf_f(rs->logs, "width: %4.2lf high: %4.2lf, wcnt: %4.2lf hcnt: %4.2lf wshif: %4.2lf hshif: %4.2lf - RT\n", width, high, wcnt, hcnt, wshif, hshif);
    print_f(rs->plogs, "SRH", rs->logs);    
    #endif

    for (ix=0; ix < hsize; ix++) {
        tmp = ix;
        fval = pRectsrh->aspRectRD[0] + (tmp * wshif);
        ptRf[ix*2] = fval;
        ptR[ix*2] = round(fval);
        fval = pRectsrh->aspRectRD[1] + (tmp * hshif);
        ptRf[ix*2+1] = fval;
        ptR[ix*2+1] = round(fval);
        
        src = getPixel(bmp, ptR[ix*2], ptR[ix*2+1], oldRowsz, bitset);

        memcpy(&orgbR[ix*3], src, 3);

        drgbR[ix*3+0] = abs(src[0] - colr[0]);
        drgbR[ix*3+1] = abs(src[1] - colr[1]);
        drgbR[ix*3+2] = abs(src[2] - colr[2]);
        #if DRAW_COLOR
        //memcpy(src, drawclor, 3);
        //src[0] = drawclor[0];
        src[1] = drawclor[1];
        //src[2] = drawclor[2];
        #endif
    }

    width = pRectsrh->aspRectLU[0] - pRectsrh->aspRectRU[0];
    high = pRectsrh->aspRectLU[1] - pRectsrh->aspRectRU[1];

    wshif = width / wcnt;
    hshif = high / wcnt;

    #if LOG_SEARCHRECT_EN
    sprintf_f(rs->logs, "width: %4.2lf high: %4.2lf, wcnt: %4.2lf hcnt: %4.2lf wshif: %4.2lf hshif: %4.2lf - UP\n", width, high, wcnt, hcnt, wshif, hshif);
    print_f(rs->plogs, "SRH", rs->logs);    
    #endif

    for (ix=0; ix < wsize; ix++) {
        tmp = ix;
        fval = pRectsrh->aspRectRU[0] + (tmp * wshif);
        ptUf[ix*2] = fval;
        ptU[ix*2] = round(fval);
        fval = pRectsrh->aspRectRU[1] + (tmp * hshif);
        ptUf[ix*2+1] = fval;
        ptU[ix*2+1] = round(fval);

        src = getPixel(bmp, ptU[ix*2], ptU[ix*2+1], oldRowsz, bitset);

        memcpy(&orgbU[ix*3], src, 3);

        drgbU[ix*3+0] = abs(src[0] - colr[0]);
        drgbU[ix*3+1] = abs(src[1] - colr[1]);
        drgbU[ix*3+2] = abs(src[2] - colr[2]);
        #if DRAW_COLOR
        //memcpy(src, drawclor, 3);
        //src[0] = drawclor[0];
        src[1] = drawclor[1];
        //src[2] = drawclor[2];
        #endif
    }

    width = pRectsrh->aspRectLD[0] - pRectsrh->aspRectLU[0];
    high = pRectsrh->aspRectLD[1] - pRectsrh->aspRectLU[1];

    wshif = width / hcnt;
    hshif = high / hcnt;

    #if LOG_SEARCHRECT_EN
    sprintf_f(rs->logs, "width: %4.2lf high: %4.2lf, wcnt: %4.2lf hcnt: %4.2lf wshif: %4.2lf hshif: %4.2lf - LF\n", width, high, wcnt, hcnt, wshif, hshif);
    print_f(rs->plogs, "SRH", rs->logs);    
    #endif

    for (ix=0; ix < hsize; ix++) {
        tmp = ix;
        fval = pRectsrh->aspRectLU[0] + (tmp * wshif);
        ptLf[ix*2] = fval;
        ptL[ix*2] = round(fval);
        fval = pRectsrh->aspRectLU[1] + (tmp * hshif);
        ptLf[ix*2+1] = fval;
        ptL[ix*2+1] = round(fval);

        src = getPixel(bmp, ptL[ix*2], ptL[ix*2+1], oldRowsz, bitset);
        
        memcpy(&orgbL[ix*3], src, 3);

        drgbL[ix*3+0] = abs(src[0] - colr[0]);
        drgbL[ix*3+1] = abs(src[1] - colr[1]);
        drgbL[ix*3+2] = abs(src[2] - colr[2]);
        #if DRAW_COLOR
        //memcpy(src, drawclor, 3);
        //src[0] = drawclor[0];
        src[1] = drawclor[1];
        //src[2] = drawclor[2];
        #endif
    }

    mindrgb[0] = drgbL[0];
    mindrgb[1] = drgbL[1];
    mindrgb[2] = drgbL[2];

    minfound[0] = ptLf[0];
    minfound[1] = ptLf[1];
    
    for (ix=0; ix < wsize; ix++) {
        #if LOG_SEARCHRECT_EN
        sprintf_f(rs->logs, "%d. D: (%4d, %4d), org(%3d, %3d, %3d) diff(%3d, %3d, %3d) min(%d, %d, %d)\n", ix, ptD[ix*2], ptD[ix*2+1], orgbD[ix*3], orgbD[ix*3+1], orgbD[ix*3+2],
            drgbD[ix*3], drgbD[ix*3+1], drgbD[ix*3+2], mindrgb[0], mindrgb[1], mindrgb[2]);
        print_f(rs->plogs, "SRH", rs->logs);
        #endif

        if ((mindrgb[0] >= drgbD[ix*3]) || (mindrgb[1] >= drgbD[ix*3+1]) || (mindrgb[2] >= drgbD[ix*3+2])) {
            summin = mindrgb[0]+mindrgb[1]+mindrgb[2];
            sumdiff = drgbD[ix*3] + drgbD[ix*3+1] + drgbD[ix*3+2];
            if (summin > sumdiff) {
                mindrgb[0] = drgbD[ix*3];
                mindrgb[1] = drgbD[ix*3+1];
                mindrgb[2] = drgbD[ix*3+2];

                minfound[0] = ptDf[ix*2];
                minfound[1] = ptDf[ix*2+1];
            }
        }
    }

    for (ix=0; ix < wsize; ix++) {
        #if LOG_SEARCHRECT_EN
        sprintf_f(rs->logs, "%d. U: (%4d, %4d), org(%3d, %3d, %3d) diff(%3d, %3d, %3d) min(%d, %d, %d)\n", ix, ptU[ix*2], ptU[ix*2+1], orgbU[ix*3], orgbU[ix*3+1], orgbU[ix*3+2],
            drgbU[ix*3], drgbU[ix*3+1], drgbU[ix*3+2], mindrgb[0], mindrgb[1], mindrgb[2]);
        print_f(rs->plogs, "SRH", rs->logs);    
        #endif
        
        if ((mindrgb[0] >= drgbU[ix*3]) || (mindrgb[1] >= drgbU[ix*3+1]) || (mindrgb[2] >= drgbU[ix*3+2])) {
            summin = mindrgb[0]+mindrgb[1]+mindrgb[2];
            sumdiff = drgbU[ix*3] + drgbU[ix*3+1] + drgbU[ix*3+2];
            if (summin > sumdiff) {
            mindrgb[0] = drgbU[ix*3];
            mindrgb[1] = drgbU[ix*3+1];
            mindrgb[2] = drgbU[ix*3+2];

            minfound[0] = ptUf[ix*2];
            minfound[1] = ptUf[ix*2+1];
            }
        }
    }

    for (ix=0; ix < hsize; ix++) {
        #if LOG_SEARCHRECT_EN
        sprintf_f(rs->logs, "%d. L: (%4d, %4d), org(%3d, %3d, %3d) diff(%3d, %3d, %3d) min(%d, %d, %d)\n", ix, ptL[ix*2], ptL[ix*2+1], orgbL[ix*3], orgbL[ix*3+1], orgbL[ix*3+2],
            drgbL[ix*3], drgbL[ix*3+1], drgbL[ix*3+2], mindrgb[0], mindrgb[1], mindrgb[2]);
        print_f(rs->plogs, "SRH", rs->logs);   
        #endif
        
        if ((mindrgb[0] >= drgbL[ix*3]) || (mindrgb[1] >= drgbL[ix*3+1]) || (mindrgb[2] >= drgbL[ix*3+2])) {
            summin = mindrgb[0]+mindrgb[1]+mindrgb[2];
            sumdiff = drgbL[ix*3] + drgbL[ix*3+1] + drgbL[ix*3+2];
            if (summin > sumdiff) {
            mindrgb[0] = drgbL[ix*3];
            mindrgb[1] = drgbL[ix*3+1];
            mindrgb[2] = drgbL[ix*3+2];

            minfound[0] = ptLf[ix*2];
            minfound[1] = ptLf[ix*2+1];
            }
        }
    }

    for (ix=0; ix < hsize; ix++) {
        #if LOG_SEARCHRECT_EN
        sprintf_f(rs->logs, "%d. R: (%4d, %4d), org(%3d, %3d, %3d) diff(%3d, %3d, %3d) min(%d, %d, %d)\n", ix, ptR[ix*2], ptR[ix*2+1], orgbR[ix*3], orgbR[ix*3+1], orgbR[ix*3+2],
            drgbR[ix*3], drgbR[ix*3+1], drgbR[ix*3+2], mindrgb[0], mindrgb[1], mindrgb[2]);
        print_f(rs->plogs, "SRH", rs->logs);      
        #endif

        if ((mindrgb[0] >= drgbR[ix*3]) || (mindrgb[1] >= drgbR[ix*3+1]) || (mindrgb[2] >= drgbR[ix*3+2])) {
            summin = mindrgb[0]+mindrgb[1]+mindrgb[2];
            sumdiff = drgbR[ix*3] + drgbR[ix*3+1] + drgbR[ix*3+2];
            if (summin > sumdiff) {
            mindrgb[0] = drgbR[ix*3];
            mindrgb[1] = drgbR[ix*3+1];
            mindrgb[2] = drgbR[ix*3+2];

            minfound[0] = ptRf[ix*2];
            minfound[1] = ptRf[ix*2+1];
            }
        }
    }

    #if 0 /* debug */
    return -8;
    #endif

    if ((mindrgb[0] > COLOR_RANGE) || (mindrgb[1] > COLOR_RANGE) || (mindrgb[2] > COLOR_RANGE)) {
        return -9;
    }

    roffset[0] = 0.0 - offset[0];
    roffset[1] = 0.0 - offset[1];
    
    ret = getPtTranRvs(pfound, 360.0 - dg, roffset, minfound);
    
    //pfound[0] = minfound[0];
    //pfound[1] = minfound[1];
    
    return 0;
}

#define LOG_ROTRECT_MF_EN (0)
static int getRotRectPointMf(int *cropinfo, struct aspRectObj *pRectroi, CFLOAT *pdeg, int oldRowsz, int bpp, struct aspRectObj *pRectin, int pidx) 
{
#define DF_IMG_W (cropinfo[4])
#define DF_IMG_H (cropinfo[5])
    int ret=0, err=0, bitset=0, dx=0, dy=0, ix=0, ic=0;
    int LUt[2], RUt[2], LDt[2], RDt[2];
    CFLOAT piAngle = 180.0, thacos=0, thasin=0, rangle[2], theta=0;
    CFLOAT *pLU, *pLD, *pRU, *pRD;
    CFLOAT pT1[4], pT2[4], pT5[2];
    CFLOAT *LUn, *RUn, *LDn, *RDn;
    CFLOAT d12, d23, d34, d41;
    CFLOAT v12, v23, v34, v41;
    CFLOAT o12[2], o23[2], o34[2], o41[2];
    CFLOAT vmin, vmin1;
    CFLOAT pfound[2];
    CFLOAT ptStart[4][2], dgs[4], *offsets[4], ptEnd[4][4], correct[2], ptShift[4][2];
    CFLOAT srhnum[4][2]={0}, srhlen[4][2]={0}, srhran[4][2]={0};
    int edwhA[2]={0}, edwhB[2]={0};
    
    int ptreal[2];
    struct aspRectObj *pRectout12=0, *pRectout23=0, *pRectout34=0, *pRectout41=0, *pRectorg=0;
    struct aspRectObj *pRectorgi=0, *pRectorgv=0, *pRectorgc=0, *pRectorgk=0, *pRectorgcOut=0, *pRectorgkOut=0;
    struct aspRectObj *pRectout12R=0, *pRectout23R=0, *pRectout34R=0, *pRectout41R=0;
    struct aspRectObj *pRectout12Ro=0, *pRectout23Ro=0, *pRectout34Ro=0, *pRectout41Ro=0;
    struct aspRectObj *pRectTga=0;
    char *src=0;
    char rgb[4][3];
    char *rgbtga[4];
    char *rgbdiff[4];
    int srhcntA[2]={0}, srhcntB[2]={0};
    CFLOAT srhcntmax[4][2]={0}, fdiff=0.0, vdiff=0.0;
    int srhtotal=0;
    int idxA=0, idxB=0;
    int side=0;
    
    bitset = bpp / 8;
    
    pLU = pRectin->aspRectLU;
    pRU = pRectin->aspRectRU;
    pLD = pRectin->aspRectLD;
    pRD = pRectin->aspRectRD;
    
    pRectout12 = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectout23 = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectout34 = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectout41 = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectorg = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectorgi = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectorgv = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectorgc = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectorgk = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectorgcOut = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectorgkOut = aspMemalloc(sizeof(struct aspRectObj), pidx);
    
    pRectout12R = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectout23R = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectout34R = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectout41R = aspMemalloc(sizeof(struct aspRectObj), pidx);

    pRectout12Ro = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectout23Ro = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectout34Ro = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectout41Ro = aspMemalloc(sizeof(struct aspRectObj), pidx);

    pRectTga = aspMemalloc(sizeof(struct aspRectObj), pidx);

    edwhA[0] = DF_IMG_W;
    edwhA[1] = DF_IMG_H;
    pT1[0] = (CFLOAT)cropinfo[0];
    pT1[1] = (CFLOAT)(edwhA[1]  - (cropinfo[1] + cropinfo[3]));
    pT1[2] = (CFLOAT)cropinfo[2];
    pT1[3] = (CFLOAT)cropinfo[3];

    edwhB[0] = DF_IMG_W;
    edwhB[1] = DF_IMG_H;
    pT2[0] = (CFLOAT)cropinfo[0];
    pT2[1] = (CFLOAT)(edwhB[1] - (cropinfo[1] + cropinfo[3]));
    pT2[2] = (CFLOAT)cropinfo[2];
    pT2[3] = (CFLOAT)cropinfo[3];

    #if LOG_ROTRECT_MF_EN
    printf("get A side pos %.2lf, %.2lf, %.2lf, %.2lf w: %4d h: %4d !!! \n", pT1[0], pT1[1], pT1[2], pT1[3], edwhA[0], edwhA[1]);
    printf("get B side pos %.2lf, %.2lf, %.2lf, %.2lf w: %4d h: %4d  !!! \n", pT2[0], pT2[1], pT2[2], pT2[3], edwhB[0], edwhB[1]);
    #endif
    
    pRectorg->aspRectLU[0] = (CFLOAT)1;
    pRectorg->aspRectLU[1] = (CFLOAT)edwhA[1];

    pRectorg->aspRectLD[0] = (CFLOAT)1;
    pRectorg->aspRectLD[1] = (CFLOAT)1;
    
    pRectorg->aspRectRD[0] = (CFLOAT)edwhA[0];
    pRectorg->aspRectRD[1] = (CFLOAT)1;

    pRectorg->aspRectRU[0] = (CFLOAT)edwhA[0];
    pRectorg->aspRectRU[1] = (CFLOAT)edwhA[1];

    #if LOG_ROTRECT_MF_EN
    printf("pLU:(%.2lf, %.2lf) pRU:(%.2lf, %.2lf) pLD:(%.2lf, %.2lf) pRD:(%.2lf, %.2lf) w:%d h:%d \n", pLU[0], pLU[1], pRU[0], pRU[1], pLD[0], pLD[1], pRD[0], pRD[1], edwhA[0], edwhA[1]);
    #endif
    
    d12 = getRectAlignTP(pRectin, pRectin->aspRectLD, pRectin->aspRectLU, pRectout12);
    #if LOG_ROTRECT_MF_EN    
    printf(" d12: %.2lf aspRectLU:(%.2lf, %.2lf) aspRectLD:(%.2lf, %.2lf) \n", d12, pRectin->aspRectLU[0], pRectin->aspRectLU[1], pRectin->aspRectLD[0], pRectin->aspRectLD[1]);
    #endif
    
    d23 = getRectAlignDN(pRectin, pRectin->aspRectRD, pRectin->aspRectLD, pRectout23);
    #if LOG_ROTRECT_MF_EN
    printf(" d23: %.2lf aspRectLD:(%.2lf, %.2lf) aspRectRD:(%.2lf, %.2lf) \n", d23, pRectin->aspRectLD[0], pRectin->aspRectLD[1], pRectin->aspRectRD[0], pRectin->aspRectRD[1]);
    #endif
    
    d34 = getRectAlignTP(pRectin, pRectin->aspRectRU, pRectin->aspRectRD, pRectout34);
    #if LOG_ROTRECT_MF_EN
    printf(" d34: %.2lf aspRectRD:(%.2lf, %.2lf) aspRectRU:(%.2lf, %.2lf) \n", d34, pRectin->aspRectRD[0], pRectin->aspRectRD[1], pRectin->aspRectRU[0], pRectin->aspRectRU[1]);
    #endif
    
    d41 = getRectAlignTP(pRectin, pRectin->aspRectLU, pRectin->aspRectRU, pRectout41);
    #if LOG_ROTRECT_MF_EN
    printf(" d41: %.2lf aspRectRU:(%.2lf, %.2lf) aspRectLU:(%.2lf, %.2lf) \n", d41, pRectin->aspRectRU[0], pRectin->aspRectRU[1], pRectin->aspRectLU[0], pRectin->aspRectLU[1]);
    #endif

    msync(pRectout12, sizeof(struct aspRectObj), MS_SYNC);
    msync(pRectout23, sizeof(struct aspRectObj), MS_SYNC);
    msync(pRectout34, sizeof(struct aspRectObj), MS_SYNC);
    msync(pRectout41, sizeof(struct aspRectObj), MS_SYNC);
    
    findRectOrient(pRectout12R, pRectout12);
    findRectOrient(pRectout23R, pRectout23);
    findRectOrient(pRectout34R, pRectout34);
    findRectOrient(pRectout41R, pRectout41);

    #if LOG_ROTRECT_MF_EN
    dbgprintRect(pRectout12);
    dbgprintRect(pRectout12R);


    dbgprintRect(pRectout23);
    dbgprintRect(pRectout23R);


    dbgprintRect(pRectout34);
    dbgprintRect(pRectout34R);


    dbgprintRect(pRectout41);
    dbgprintRect(pRectout41R);

    dbgprintRect(pRectorg);
    #endif

    memcpy(pRectout12Ro, pRectin, sizeof(struct aspRectObj));
    memcpy(pRectout23Ro, pRectin, sizeof(struct aspRectObj));
    memcpy(pRectout34Ro, pRectin, sizeof(struct aspRectObj));
    memcpy(pRectout41Ro, pRectin, sizeof(struct aspRectObj));
    
    v12 = getRectOffsetLf(pRectout12Ro, pRectout12R, pRectorg, o12);
    v23 = getRectOffsetDn(pRectout23Ro, pRectout23R, pRectorg, o23);
    v34 = getRectOffsetRt(pRectout34Ro, pRectout34R, pRectorg, o34);
    v41 = getRectOffsetTP(pRectout41Ro, pRectout41R, pRectorg, o41);

    if (pRectin->aspRectLU[1] > pRectin->aspRectRU[1]) {
        vmin = aspMin(v41, v12);
    } else {
        vmin = aspMin(v41, v34);
    }

    vdiff = 0;
    if (vmin < v41) {
        vdiff = v41 - vmin;
    }

    if (vdiff < 50.0) {
        vmin = v41;
    }
   
    #if LOG_ROTRECT_MF_EN
    printf(" min: %.4lf v12:%.4lf v23:%.4lf v34:%.4lf v41:%.4lf vdiff:%.4lf\n", vmin, v12, v23, v34, v41, vdiff);
    printf(" v12: %.2lf o12:(%.2lf, %.2lf) d12: %.2lf \n", v12, o12[0], o12[1], d12);
    printf(" v23: %.2lf o23:(%.2lf, %.2lf) d23: %.2lf \n", v23, o23[0], o23[1], d23);
    printf(" v34: %.2lf o34:(%.2lf, %.2lf) d34: %.2lf \n", v34, o34[0], o34[1], d34);
    printf(" v41: %.2lf o41:(%.2lf, %.2lf) d41: %.2lf \n", v41, o41[0], o41[1], d41);
    #endif

    if (vmin == v41) {
        #if LOG_ROTRECT_MF_EN
        printf(" v41 \n");
        #endif
        
        memcpy(&ptEnd[0][0], &pT1[0], 4*sizeof(CFLOAT));
        memcpy(&ptEnd[1][0], &pT2[0], 4*sizeof(CFLOAT));
        memcpy(&ptEnd[2][0], &pT1[0], 4*sizeof(CFLOAT));
        memcpy(&ptEnd[3][0], &pT2[0], 4*sizeof(CFLOAT));
        
        dgs[0] = d41;
        dgs[1] = d41;
        dgs[2] = d23;
        dgs[3] = d23;

        offsets[0] = o41;
        offsets[1] = o41;
        offsets[2] = o23;
        offsets[3] = o23;

        ptreal[0] = 0;
        ptreal[1] = 0;
    }
    else {
        if (pRectin->aspRectLU[1] > pRectin->aspRectRU[1]) {
            if (vmin == v12) {
                #if LOG_ROTRECT_MF_EN
                printf(" v12 \n");
                #endif
                
                memcpy(&ptEnd[0][0], &pT1[0], 4*sizeof(CFLOAT));
                memcpy(&ptEnd[1][0], &pT2[0], 4*sizeof(CFLOAT));
                memcpy(&ptEnd[2][0], &pT1[0], 4*sizeof(CFLOAT));
                memcpy(&ptEnd[3][0], &pT2[0], 4*sizeof(CFLOAT));
                
                dgs[0] = d12;
                dgs[1] = d12;
                dgs[2] = d34;
                dgs[3] = d34;
            
                offsets[0] = o12;
                offsets[1] = o12;
                offsets[2] = o34;
                offsets[3] = o34;
            
                ptreal[0] = 0;
                ptreal[1] = 0;
            } 
            else if (vmin == v34) {
                #if LOG_ROTRECT_MF_EN
                printf(" v34 \n");
                #endif

                memcpy(&ptEnd[0][0], &pT1[0], 4*sizeof(CFLOAT));
                memcpy(&ptEnd[1][0], &pT2[0], 4*sizeof(CFLOAT));
                memcpy(&ptEnd[2][0], &pT1[0], 4*sizeof(CFLOAT));
                memcpy(&ptEnd[3][0], &pT2[0], 4*sizeof(CFLOAT));
                
                dgs[0] = d34;
                dgs[1] = d34;
                dgs[2] = d12;
                dgs[3] = d12;
            
                offsets[0] = o34;
                offsets[1] = o34;
                offsets[2] = o12;
                offsets[3] = o12;

                ptreal[0] = 0;
                ptreal[1] = 0;
            
            }
            else {
                #if LOG_ROTRECT_MF_EN
                printf(" v23 \n");
                #endif
                
                memcpy(&ptEnd[0][0], &pT1[0], 4*sizeof(CFLOAT));
                memcpy(&ptEnd[1][0], &pT2[0], 4*sizeof(CFLOAT));
                memcpy(&ptEnd[2][0], &pT1[0], 4*sizeof(CFLOAT));
                memcpy(&ptEnd[3][0], &pT2[0], 4*sizeof(CFLOAT));
                
                dgs[0] = d23;
                dgs[1] = d23;
                dgs[2] = d41;
                dgs[3] = d41;
            
                offsets[0] = o23;
                offsets[1] = o23;
                offsets[2] = o41;
                offsets[3] = o41;
            
                ptreal[0] = 0;
                ptreal[1] = 0;
            }
        }
        else {
            if (vmin == v34) {
                #if LOG_ROTRECT_MF_EN
                printf(" v34 \n");
                #endif

                memcpy(&ptEnd[0][0], &pT1[0], 4*sizeof(CFLOAT));
                memcpy(&ptEnd[1][0], &pT2[0], 4*sizeof(CFLOAT));
                memcpy(&ptEnd[2][0], &pT1[0], 4*sizeof(CFLOAT));
                memcpy(&ptEnd[3][0], &pT2[0], 4*sizeof(CFLOAT));
                
                dgs[0] = d34;
                dgs[1] = d34;
                dgs[2] = d12;
                dgs[3] = d12;
            
                offsets[0] = o34;
                offsets[1] = o34;
                offsets[2] = o12;
                offsets[3] = o12;
            
                ptreal[0] = 0;
                ptreal[1] = 0;
            
            }
            else if (vmin == v12) {
            
                #if LOG_ROTRECT_MF_EN
                printf(" v12 \n");
                #endif

                memcpy(&ptEnd[0][0], &pT1[0], 4*sizeof(CFLOAT));
                memcpy(&ptEnd[1][0], &pT2[0], 4*sizeof(CFLOAT));
                memcpy(&ptEnd[2][0], &pT1[0], 4*sizeof(CFLOAT));
                memcpy(&ptEnd[3][0], &pT2[0], 4*sizeof(CFLOAT));
                
                dgs[0] = d12;
                dgs[1] = d12;
                dgs[2] = d34;
                dgs[3] = d34;
            
                offsets[0] = o12;
                offsets[1] = o12;
                offsets[2] = o34;
                offsets[3] = o34;

                ptreal[0] = 0;
                ptreal[1] = 0;
            } 
            else {
                #if LOG_ROTRECT_MF_EN
                printf(" v23 \n");
                #endif
                
                memcpy(&ptEnd[0][0], &pT1[0], 4*sizeof(CFLOAT));
                memcpy(&ptEnd[1][0], &pT2[0], 4*sizeof(CFLOAT));
                memcpy(&ptEnd[2][0], &pT1[0], 4*sizeof(CFLOAT));
                memcpy(&ptEnd[3][0], &pT2[0], 4*sizeof(CFLOAT));
                
                dgs[0] = d23;
                dgs[1] = d23;
                dgs[2] = d41;
                dgs[3] = d41;
            
                offsets[0] = o23;
                offsets[1] = o23;
                offsets[2] = o41;
                offsets[3] = o41;
            
                ptreal[0] = 0;
                ptreal[1] = 0;
            }
        }
    }


    ix = 0;

    setRectPoint(pRectorgk, ptEnd[ix][2] - 1, ptEnd[ix][3] - 1, &ptEnd[ix][0]);
    getRectTran(pRectorgk, dgs[ix], offsets[ix], pRectroi);

    *pdeg = dgs[ix];

    #if LOG_ROTRECT_MF_EN
    dbgprintRect(pRectroi);
    #endif

    aspFree(pRectout12, pidx);
    aspFree(pRectout23, pidx);
    aspFree(pRectout34, pidx);
    aspFree(pRectout41, pidx);
    aspFree(pRectorg, pidx);
    aspFree(pRectorgi, pidx);
    aspFree(pRectorgv, pidx);
    aspFree(pRectorgc, pidx);
    aspFree(pRectorgk, pidx);
    aspFree(pRectorgcOut, pidx);
    aspFree(pRectorgkOut, pidx);
    aspFree(pRectout12R, pidx);
    aspFree(pRectout23R, pidx);
    aspFree(pRectout34R, pidx);
    aspFree(pRectout41R, pidx);
    aspFree(pRectout12Ro, pidx);
    aspFree(pRectout23Ro, pidx);
    aspFree(pRectout34Ro, pidx);
    aspFree(pRectout41Ro, pidx);
    aspFree(pRectTga, pidx);
    
    #if LOG_ROTRECT_MF_EN
    printf("tran end ! !\n");       
    #endif
    
    return 0;
}

#define LOG_ROTRECT_EN (0)
static int getRotRectPoint(struct procRes_s *rs, struct aspRectObj *pRectin, int *page, struct aspMetaData_s *meta, int pidx, struct aspRectObj *pRectroi, CFLOAT *pdeg, struct aspRectObj *pRectroc, char *bmp, int oldRowsz, int bpp, int *pside, int *pmreal) 
{
#define GRAY_THD_H (170)
#define GRAY_THD_L (120)
    int ret=0, err=0, bitset=0, dx=0, dy=0, ix=0, ic=0;
    int LUt[2], RUt[2], LDt[2], RDt[2];
    CFLOAT piAngle = 180.0, thacos=0, thasin=0, rangle[2], theta=0;
    CFLOAT *pLU, *pLD, *pRU, *pRD;
    CFLOAT pT1[4], pT2[4], pT3[2], pT4[2], pT5[2];
    CFLOAT *LUn, *RUn, *LDn, *RDn;
    CFLOAT d12, d23, d34, d41;
    CFLOAT v12, v23, v34, v41;
    CFLOAT o12[2], o23[2], o34[2], o41[2];
    CFLOAT vmin, vmin1;
    CFLOAT pfound[2];
    CFLOAT ptStart[4][2], dgs[4], *offsets[4], ptEnd[4][4], correct[2], ptShift[4][2];
    CFLOAT srhnum[4][2]={0}, srhlen[4][2]={0}, srhran[4][2]={0};
    int edwhA[2]={0}, edwhB[2]={0};
    
    int ptreal[2];
    struct aspRectObj *pRectout12=0, *pRectout23=0, *pRectout34=0, *pRectout41=0, *pRectorg=0;
    struct aspRectObj *pRectorgi=0, *pRectorgv=0, *pRectorgc=0, *pRectorgk=0, *pRectorgcOut=0, *pRectorgkOut=0;
    struct aspRectObj *pRectout12R=0, *pRectout23R=0, *pRectout34R=0, *pRectout41R=0;
    struct aspRectObj *pRectout12Ro=0, *pRectout23Ro=0, *pRectout34Ro=0, *pRectout41Ro=0;
    struct aspRectObj *pRectTga=0;
    char *src=0;
    char rgb[4][3];
    char *rgbtga[4];
    char *rgbdiff[4];
    int ctaga[2], ctagb[2];
    int crana[2], cranb[2];
    char tagrgba[3], tagrgbb[3];
    char tagrgbdiffa[3], tagrgbdiffb[3];
    int srhcntA[2]={0}, srhcntB[2]={0};
    CFLOAT srhcntmax[4][2]={0};
    int srhtotal=0;
    int idxA=0, idxB=0;
    int side=0;

    side = *pside;
    
    bitset = bpp / 8;
    
    pLU = pRectin->aspRectLU;
    pRU = pRectin->aspRectRU;
    pLD = pRectin->aspRectLD;
    pRD = pRectin->aspRectRD;
    
    pRectout12 = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectout23 = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectout34 = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectout41 = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectorg = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectorgi = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectorgv = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectorgc = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectorgk = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectorgcOut = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectorgkOut = aspMemalloc(sizeof(struct aspRectObj), pidx);
    
    pRectout12R = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectout23R = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectout34R = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectout41R = aspMemalloc(sizeof(struct aspRectObj), pidx);

    pRectout12Ro = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectout23Ro = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectout34Ro = aspMemalloc(sizeof(struct aspRectObj), pidx);
    pRectout41Ro = aspMemalloc(sizeof(struct aspRectObj), pidx);

    pRectTga = aspMemalloc(sizeof(struct aspRectObj), pidx);

    idxA = page[0];
    idxB = page[1];

    /*
    if ((idxA == 0) && (idxB == 0)) {
        return -1;
    }
    */
    
    ret = aspMetaGetTagPosRange(meta, ctaga, crana, 0);
    if (ret < 0) {
        sprintf_f(rs->logs, "Errir!!! get A side tag pos and range wrong ret: %d !!! \n", ret);
        print_f(rs->plogs, "MCUT", rs->logs);
    }

    ret = aspMetaGetTagPosRange(meta, ctagb, cranb, 1);
    if (ret < 0) {
        sprintf_f(rs->logs, "Errir!!! get B side tag pos and range wrong ret: %d !!! \n", ret);
        print_f(rs->plogs, "MCUT", rs->logs);
    }

    ret = aspMetaGetTagRGB(meta, tagrgba, 0);
    if (ret < 0) {
        sprintf_f(rs->logs, "Errir!!! get A side tag rgb wrong ret: %d !!! \n", ret);
        print_f(rs->plogs, "MCUT", rs->logs);
    }

    ret = aspMetaGetTagRGB(meta, tagrgbb, 1);
    if (ret < 0) {
        sprintf_f(rs->logs, "Errir!!! get B side tag rgb wrong ret: %d !!! \n", ret);
        print_f(rs->plogs, "MCUT", rs->logs);
    }

    ret = aspMetaGetTagRGBdiff(meta, tagrgbdiffa, 0);
    if (ret < 0) {
        sprintf_f(rs->logs, "Errir!!! get A side tag rgb diff wrong ret: %d !!! \n", ret);
        print_f(rs->plogs, "MCUT", rs->logs);
    }

    ret = aspMetaGetTagRGBdiff(meta, tagrgbdiffb, 1);
    if (ret < 0) {
        sprintf_f(rs->logs, "Errir!!! get B side tag rgb diff wrong ret: %d !!! \n", ret);
        print_f(rs->plogs, "MCUT", rs->logs);

        memcpy(tagrgbdiffb, tagrgbdiffa, 3);
    }
    
    ret = aspMetaGetWH(meta, edwhA, srhcntA, 0);
    if (ret < 0) {
        sprintf_f(rs->logs, "Errir!!! get A side tag wh & search count wrong ret: %d !!! \n", ret);
        print_f(rs->plogs, "MCUT", rs->logs);
    }

    ret = aspMetaGetWH(meta, edwhB, srhcntB, 1);
    if (ret < 0) {
        sprintf_f(rs->logs, "Errir!!! get B side tag wh & search count wrong ret: %d !!! \n", ret);
        print_f(rs->plogs, "MCUT", rs->logs);
    }

    if ((idxA == -1) && (idxB == -1)) {
        pT1[0] = 1.0;
        pT1[1] = 1.0;
        pT1[2] = edwhA[0] - 1;
        pT1[3] = edwhA[1] - 1;


        pT2[0] = 1.0;
        pT2[1] = 1.0;
        pT2[2] = edwhB[0] - 1;
        pT2[3] = edwhB[1] - 1;
    } else if ((idxA > 0) || (idxB > 0)) {
        ret = aspMetaGetPagePos(meta, pT1, idxA);
        if (ret < 0) {
            sprintf_f(rs->logs, "Errir!!! get A side pos wrong ret: %d !!! \n", ret);
            print_f(rs->plogs, "MCUT", rs->logs);
        } else {
            sprintf_f(rs->logs, "get A side idx: %d pos %.2lf, %.2lf, %.2lf, %.2lf !!! \n", idxA, pT1[0], pT1[1], pT1[2], pT1[3]);
            print_f(rs->plogs, "MCUT", rs->logs);
        }
        
        ret = aspMetaGetPagePos(meta, pT2, idxB);
        if (ret < 0) {
            sprintf_f(rs->logs, "Errir!!! get B side pos wrong ret: %d !!! \n", ret);
            print_f(rs->plogs, "MCUT", rs->logs);
        } else {
            sprintf_f(rs->logs, "get B side idx: %d pos %.2lf, %.2lf, %.2lf, %.2lf !!! \n", idxB, pT2[0], pT2[1], pT2[2], pT2[3]);
            print_f(rs->plogs, "MCUT", rs->logs);
        }
    }
    else {
        return -1;
    }

    pT3[0] = ctaga[0];
    pT3[1] = ctaga[1];
    setRectPoint(pRectorgc, 2.0, 2.0, pT3);

    pT4[0] = ctagb[0];
    pT4[1] = ctagb[1];
    setRectPoint(pRectorgk, 2.0, 2.0, pT4);
    
    pRectorg->aspRectLU[0] = (CFLOAT)1;
    pRectorg->aspRectLU[1] = (CFLOAT)edwhA[1];

    pRectorg->aspRectLD[0] = (CFLOAT)1;
    pRectorg->aspRectLD[1] = (CFLOAT)1;
    
    pRectorg->aspRectRD[0] = (CFLOAT)edwhA[0];
    pRectorg->aspRectRD[1] = (CFLOAT)1;

    pRectorg->aspRectRU[0] = (CFLOAT)edwhA[0];
    pRectorg->aspRectRU[1] = (CFLOAT)edwhA[1];

    #if LOG_ROTRECT_EN
    sprintf_f(rs->logs, "pLU:(%.2lf, %.2lf) pRU:(%.2lf, %.2lf) pLD:(%.2lf, %.2lf) pRD:(%.2lf, %.2lf) w:%d h:%d \n", pLU[0], pLU[1], pRU[0], pRU[1], pLD[0], pLD[1], pRD[0], pRD[1], edwhA[0], edwhA[1]);
    print_f(rs->plogs, "RECT", rs->logs);
    #endif
    
    d12 = getRectAlignOrg(pRectin, pRectin->aspRectLU, pRectin->aspRectLD, pRectout12);
    #if LOG_ROTRECT_EN    
    sprintf_f(rs->logs, " d12: %.2lf aspRectLU:(%.2lf, %.2lf) aspRectLD:(%.2lf, %.2lf) \n", d12, 
        pRectin->aspRectLU[0], pRectin->aspRectLU[1], pRectin->aspRectLD[0], pRectin->aspRectLD[1]);
    print_f(rs->plogs, "RECT", rs->logs);
    #endif
    
    d23 = getRectAlignOrg(pRectin, pRectin->aspRectLD, pRectin->aspRectRD, pRectout23);
    #if LOG_ROTRECT_EN
    sprintf_f(rs->logs, " d23: %.2lf aspRectLD:(%.2lf, %.2lf) aspRectRD:(%.2lf, %.2lf) \n", d23, 
        pRectin->aspRectLD[0], pRectin->aspRectLD[1], pRectin->aspRectRD[0], pRectin->aspRectRD[1]);
    print_f(rs->plogs, "RECT", rs->logs);
    #endif
    
    d34 = getRectAlignOrg(pRectin, pRectin->aspRectRD, pRectin->aspRectRU, pRectout34);
    #if LOG_ROTRECT_EN
    sprintf_f(rs->logs, " d34: %.2lf aspRectRD:(%.2lf, %.2lf) aspRectRU:(%.2lf, %.2lf) \n", d34, 
        pRectin->aspRectRD[0], pRectin->aspRectRD[1], pRectin->aspRectRU[0], pRectin->aspRectRU[1]);
    print_f(rs->plogs, "RECT", rs->logs);
    #endif
    
    d41 = getRectAlignOrg(pRectin, pRectin->aspRectRU, pRectin->aspRectLU, pRectout41);
    #if LOG_ROTRECT_EN
    sprintf_f(rs->logs, " d41: %.2lf aspRectRU:(%.2lf, %.2lf) aspRectLU:(%.2lf, %.2lf) \n", d41, 
        pRectin->aspRectRU[0], pRectin->aspRectRU[1], pRectin->aspRectLU[0], pRectin->aspRectLU[1]);
    print_f(rs->plogs, "RECT", rs->logs);
    #endif

    msync(pRectout12, sizeof(struct aspRectObj), MS_SYNC);
    msync(pRectout23, sizeof(struct aspRectObj), MS_SYNC);
    msync(pRectout34, sizeof(struct aspRectObj), MS_SYNC);
    msync(pRectout41, sizeof(struct aspRectObj), MS_SYNC);
    
    findRectOrient(pRectout12R, pRectout12);
    findRectOrient(pRectout23R, pRectout23);
    findRectOrient(pRectout34R, pRectout34);
    findRectOrient(pRectout41R, pRectout41);

    #if LOG_ROTRECT_EN
    dbgprintRect(pRectout12);
    dbgprintRect(pRectout12R);


    dbgprintRect(pRectout23);
    dbgprintRect(pRectout23R);


    dbgprintRect(pRectout34);
    dbgprintRect(pRectout34R);


    dbgprintRect(pRectout41);
    dbgprintRect(pRectout41R);

    dbgprintRect(pRectorg);
    #endif
    
    v12 = getRectOffsetOrg(pRectout12Ro, pRectout12R, pRectorg, o12);
    v23 = getRectOffsetOrg(pRectout23Ro, pRectout23R, pRectorg, o23);
    v34 = getRectOffsetOrg(pRectout34Ro, pRectout34R, pRectorg, o34);
    v41 = getRectOffsetOrg(pRectout41Ro, pRectout41R, pRectorg, o41);

    //findRectOrient(pRectout, pRectin);
    vmin = aspMin(v12, v23);
    vmin = aspMin(vmin, v34);
    vmin = aspMin(vmin, v41);

    #if LOG_ROTRECT_EN
    sprintf_f(rs->logs, " v12: %.2lf o12:(%.2lf, %.2lf) d12: %.2lf \n", v12, o12[0], o12[1], d12);
    print_f(rs->plogs, "RECT", rs->logs);
    sprintf_f(rs->logs, " v23: %.2lf o23:(%.2lf, %.2lf) d23: %.2lf \n", v23, o23[0], o23[1], d23);
    print_f(rs->plogs, "RECT", rs->logs);
    sprintf_f(rs->logs, " v34: %.2lf o34:(%.2lf, %.2lf) d34: %.2lf \n", v34, o34[0], o34[1], d34);
    print_f(rs->plogs, "RECT", rs->logs);
    sprintf_f(rs->logs, " v41: %.2lf o41:(%.2lf, %.2lf) d41: %.2lf \n", v41, o41[0], o41[1], d41);
    print_f(rs->plogs, "RECT", rs->logs);
    #endif
    
    if (vmin == v12) {

        #if LOG_ROTRECT_EN
        sprintf_f(rs->logs, " v12 + v34 \n");
        print_f(rs->plogs, "RECT", rs->logs);
        #endif

        ptStart[0][0] = pT3[0];
        ptStart[0][1] = pT3[1];

        ptStart[1][0] = pT4[0];
        ptStart[1][1] = pT4[1];

        ptStart[2][0] = pT3[0];
        ptStart[2][1] = pT3[1];

        ptStart[3][0] = pT4[0];
        ptStart[3][1] = pT4[1];
        
        memcpy(&ptEnd[0][0], &pT1[0], 4*sizeof(CFLOAT));
        memcpy(&ptEnd[1][0], &pT2[0], 4*sizeof(CFLOAT));
        memcpy(&ptEnd[2][0], &pT1[0], 4*sizeof(CFLOAT));
        memcpy(&ptEnd[3][0], &pT2[0], 4*sizeof(CFLOAT));
        
        dgs[0] = d12;
        dgs[1] = d12;
        dgs[2] = d34;
        dgs[3] = d34;

        offsets[0] = o12;
        offsets[1] = o12;
        offsets[2] = o34;
        offsets[3] = o34;

        rgbtga[0] = tagrgba;
        rgbtga[1] = tagrgbb;
        rgbtga[2] = tagrgba;
        rgbtga[3] = tagrgbb;

        rgbdiff[0] = tagrgbdiffa;
        rgbdiff[1] = tagrgbdiffb;
        rgbdiff[2] = tagrgbdiffa;
        rgbdiff[3] = tagrgbdiffb;

        ptreal[0] = 0;
        ptreal[1] = 0;
    } 
    else if (vmin == v23) {
        #if LOG_ROTRECT_EN
        sprintf_f(rs->logs, " v23 + v41 \n");
        print_f(rs->plogs, "RECT", rs->logs);
        #endif
 
        ptStart[0][0] = pT3[0];
        ptStart[0][1] = pT3[1];

        ptStart[1][0] = pT4[0];
        ptStart[1][1] = pT4[1];

        ptStart[2][0] = pT3[0];
        ptStart[2][1] = pT3[1];

        ptStart[3][0] = pT4[0];
        ptStart[3][1] = pT4[1];
        
        memcpy(&ptEnd[0][0], &pT1[0], 4*sizeof(CFLOAT));
        memcpy(&ptEnd[1][0], &pT2[0], 4*sizeof(CFLOAT));
        memcpy(&ptEnd[2][0], &pT1[0], 4*sizeof(CFLOAT));
        memcpy(&ptEnd[3][0], &pT2[0], 4*sizeof(CFLOAT));
        
        dgs[0] = d23;
        dgs[1] = d23;
        dgs[2] = d41;
        dgs[3] = d41;

        offsets[0] = o23;
        offsets[1] = o23;
        offsets[2] = o41;
        offsets[3] = o41;

        rgbtga[0] = tagrgba;
        rgbtga[1] = tagrgbb;
        rgbtga[2] = tagrgba;
        rgbtga[3] = tagrgbb;

        rgbdiff[0] = tagrgbdiffa;
        rgbdiff[1] = tagrgbdiffb;
        rgbdiff[2] = tagrgbdiffa;
        rgbdiff[3] = tagrgbdiffb;

        ptreal[0] = 0;
        ptreal[1] = 0;
    }
    else if (vmin == v34) {
        #if LOG_ROTRECT_EN
        sprintf_f(rs->logs, " v34 + v12 \n");
        print_f(rs->plogs, "RECT", rs->logs);
        #endif

        ptStart[0][0] = pT3[0];
        ptStart[0][1] = pT3[1];

        ptStart[1][0] = pT4[0];
        ptStart[1][1] = pT4[1];

        ptStart[2][0] = pT3[0];
        ptStart[2][1] = pT3[1];

        ptStart[3][0] = pT4[0];
        ptStart[3][1] = pT4[1];
        
        memcpy(&ptEnd[0][0], &pT1[0], 4*sizeof(CFLOAT));
        memcpy(&ptEnd[1][0], &pT2[0], 4*sizeof(CFLOAT));
        memcpy(&ptEnd[2][0], &pT1[0], 4*sizeof(CFLOAT));
        memcpy(&ptEnd[3][0], &pT2[0], 4*sizeof(CFLOAT));
        
        dgs[0] = d34;
        dgs[1] = d34;
        dgs[2] = d12;
        dgs[3] = d12;

        offsets[0] = o34;
        offsets[1] = o34;
        offsets[2] = o12;
        offsets[3] = o12;

        rgbtga[0] = tagrgba;
        rgbtga[1] = tagrgbb;
        rgbtga[2] = tagrgba;
        rgbtga[3] = tagrgbb;

        rgbdiff[0] = tagrgbdiffa;
        rgbdiff[1] = tagrgbdiffb;
        rgbdiff[2] = tagrgbdiffa;
        rgbdiff[3] = tagrgbdiffb;

        ptreal[0] = 0;
        ptreal[1] = 0;

    }
    else {
        #if LOG_ROTRECT_EN
        sprintf_f(rs->logs, " v41 + v23 \n");
        print_f(rs->plogs, "RECT", rs->logs);
        #endif

        ptStart[0][0] = pT3[0];
        ptStart[0][1] = pT3[1];

        ptStart[1][0] = pT4[0];
        ptStart[1][1] = pT4[1];

        ptStart[2][0] = pT3[0];
        ptStart[2][1] = pT3[1];

        ptStart[3][0] = pT4[0];
        ptStart[3][1] = pT4[1];

        /*
        ptEnd[0][0] = pT1[0];
        ptEnd[0][1] = pT1[1];
        ptEnd[0][2] = pT1[2];
        ptEnd[0][3] = pT1[3];
        ptEnd[1][0] = pT2[0];
        ptEnd[1][1] = pT2[1];
        ptEnd[1][2] = pT2[2];
        ptEnd[1][3] = pT2[3];
        ptEnd[2][0] = pT1[0];
        ptEnd[2][1] = pT1[1];
        ptEnd[2][2] = pT1[2];
        ptEnd[2][3] = pT1[3];
        ptEnd[3][0] = pT2[0];
        ptEnd[3][1] = pT2[1];
        ptEnd[3][2] = pT2[2];
        ptEnd[3][3] = pT2[3];
        */
        
        memcpy(&ptEnd[0][0], &pT1[0], 4*sizeof(CFLOAT));
        memcpy(&ptEnd[1][0], &pT2[0], 4*sizeof(CFLOAT));
        memcpy(&ptEnd[2][0], &pT1[0], 4*sizeof(CFLOAT));
        memcpy(&ptEnd[3][0], &pT2[0], 4*sizeof(CFLOAT));
        
        dgs[0] = d41;
        dgs[1] = d41;
        dgs[2] = d23;
        dgs[3] = d23;

        offsets[0] = o41;
        offsets[1] = o41;
        offsets[2] = o23;
        offsets[3] = o23;

        rgbtga[0] = tagrgba;
        rgbtga[1] = tagrgbb;
        rgbtga[2] = tagrgba;
        rgbtga[3] = tagrgbb;

        rgbdiff[0] = tagrgbdiffa;
        rgbdiff[1] = tagrgbdiffb;
        rgbdiff[2] = tagrgbdiffa;
        rgbdiff[3] = tagrgbdiffb;

        ptreal[0] = 0;
        ptreal[1] = 0;
    }

    if (side > 0) {

        ix = side - 1;

        if ((ix < 4) && (pmreal[0] > 0) && (pmreal[1] > 0)) {

            ptShift[ix][0] = pmreal[0];
            ptShift[ix][1] = pmreal[1];
            correct[0] = ptShift[ix][0] - ptStart[ix][0];
            correct[1] = ptShift[ix][1] - ptStart[ix][1];
            sprintf_f(rs->logs, "ptreal(%4d, %4d), page shift: (%4.2lf, %4.2lf) 8bits - %d cont\n", pmreal[0], pmreal[1], correct[0], correct[1], ix);
            print_f(rs->plogs, "RECT", rs->logs);       

            ptEnd[ix][0] += correct[0];
            ptEnd[ix][1] += correct[1];

            setRectPoint(pRectorgk, ptEnd[ix][2], ptEnd[ix][3], &ptEnd[ix][0]);
            getRectTran(pRectorgk, dgs[ix], offsets[ix], pRectroi);

            *pdeg = dgs[ix];

            return 0;
        }


        sprintf_f(rs->logs, "Error!! the side idx is wrong val: %d \n", ix);
        print_f(rs->plogs, "RECT", rs->logs);       
    }

    srhcntmax[0][0] = srhcntA[0];
    srhcntmax[0][1] = srhcntA[1];
    srhcntmax[1][0] = srhcntB[0];
    srhcntmax[1][1] = srhcntB[1];
    srhcntmax[2][0] = srhcntA[0];
    srhcntmax[2][1] = srhcntA[1];
    srhcntmax[3][0] = srhcntB[0];
    srhcntmax[3][1] = srhcntB[1];

    srhnum[0][0] = 1.0;
    srhnum[0][1] = 1.0;
    srhnum[1][0] = 1.0;
    srhnum[1][1] = 1.0;
    srhnum[2][0] = 1.0;
    srhnum[2][1] = 1.0;
    srhnum[3][0] = 1.0;
    srhnum[3][1] = 1.0;

    
    srhlen[0][0] = crana[0];
    srhlen[0][1] = crana[1];
    srhlen[1][0] = cranb[0];
    srhlen[1][1] = cranb[1];
    srhlen[2][0] = crana[0];
    srhlen[2][1] = crana[1];
    srhlen[3][0] = cranb[0];
    srhlen[3][1] = cranb[1];

    srhran[0][0] = crana[0];
    srhran[0][1] = crana[1];
    srhran[1][0] = cranb[0];
    srhran[1][1] = cranb[1];
    srhran[2][0] = crana[0];
    srhran[2][1] = crana[1];
    srhran[3][0] = cranb[0];
    srhran[3][1] = cranb[1];

    memcpy(ptShift, ptStart, sizeof(CFLOAT)*8);
    
    if (srhcntA[0] > srhcntA[1]) {
        srhtotal = srhcntA[0];
    } else {
        srhtotal = srhcntA[1];
    }

    if (srhcntB[0] > srhtotal) {
        srhtotal = srhcntB[0];
    }
    
    if (srhcntB[1] > srhtotal) {
        srhtotal = srhcntB[1];
    }
    
    for (ic=0; ic < srhtotal; ic++) {
        for (ix=0; ix < 4; ix++) {
            if ((srhnum[ix][0] >= srhcntmax[ix][0]) && (srhnum[ix][0] >= srhcntmax[ix][0])) {
                continue;
            }
        
            pT5[0] = ptShift[ix][0];
            pT5[1] = ptShift[ix][1];
            setRectPoint(pRectTga, srhlen[ix][0], srhlen[ix][1], pT5);
            #if LOG_ROTRECT_EN
            dbgprintRect(pRectTga);
            #endif
            
            #if 1
            if (bpp == 8) {
                if ((ix % 2) == 0) {
                    ret = srhRotRect8Bits(rs, ptreal, pRectTga, dgs[ix], offsets[ix], rgbtga[ix], rgbdiff[ix], bmp, oldRowsz, bpp, pidx, srhnum[ix][0], srhnum[ix][1]);
                    if (ret == 0) {

                        ptShift[ix][0] = ptreal[0];
                        ptShift[ix][1] = ptreal[1];
                        correct[0] = ptShift[ix][0] - ptStart[ix][0];
                        correct[1] = ptShift[ix][1] - ptStart[ix][1];
                        sprintf_f(rs->logs, "ptreal(%4d, %4d), page shift: (%4.2lf, %4.2lf) 8bits - %d\n", ptreal[0], ptreal[1], correct[0], correct[1], ix);
                        print_f(rs->plogs, "RECT", rs->logs);       
        
                        ptEnd[ix][0] += correct[0];
                        ptEnd[ix][1] += correct[1];
                    
                        setRectPoint(pRectorgk, ptEnd[ix][2], ptEnd[ix][3], &ptEnd[ix][0]);
        
                        getRectTran(pRectorgk, dgs[ix], offsets[ix], pRectroi);
                        *pdeg = dgs[ix];
                    
                        break;
                    }
                }
                else {
                    ret = srhRotRect8BitsDn(rs, ptreal, pRectTga, dgs[ix], offsets[ix], rgbtga[ix], rgbdiff[ix], bmp, oldRowsz, bpp, pidx, srhnum[ix][0], srhnum[ix][1]);
                    if (ret == 0) {

                        ptShift[ix][0] = ptreal[0];
                        ptShift[ix][1] = ptreal[1];
                        correct[0] = ptShift[ix][0] - ptStart[ix][0];
                        correct[1] = ptShift[ix][1] - ptStart[ix][1];
                        sprintf_f(rs->logs, "ptreal(%4d, %4d), start(%4.2lf, %4.2lf), page shift: (%4.2lf, %4.2lf) 8bits - %d\n", ptreal[0], ptreal[1], ptStart[ix][0], ptStart[ix][1], correct[0], correct[1], ix);
                        print_f(rs->plogs, "RECT", rs->logs);       
        
                        ptEnd[ix][0] += correct[0];
                        ptEnd[ix][1] += correct[1];
                    
                        setRectPoint(pRectorgk, ptEnd[ix][2], ptEnd[ix][3], &ptEnd[ix][0]);
        
                        getRectTran(pRectorgk, dgs[ix], offsets[ix], pRectroi);
                        *pdeg = dgs[ix];
                    
                        break;
                    }
                }
            } else {
                ret = srhRotRect(rs, pfound, pRectTga, dgs[ix], offsets[ix], rgbtga[ix], bmp, oldRowsz, bpp, pidx, srhnum[ix][0], srhnum[ix][1]);
                if (ret == 0) {
                    err = adjCircleRect(rs, ptreal, pfound, dgs[ix], offsets[ix], rgbdiff[ix], bmp, oldRowsz, bpp, pidx);
                    if (err == 0) {
        
                        correct[0] = ptreal[0] - ptStart[ix][0];
                        correct[1] = ptreal[1] - ptStart[ix][1];
                        sprintf_f(rs->logs, "ptreal(%4d, %4d), page shift: (%4.2lf, %4.2lf) \n", ptreal[0], ptreal[1], correct[0], correct[1]);
                        print_f(rs->plogs, "RECT", rs->logs);       
        
                        ptEnd[ix][0] += correct[0];
                        ptEnd[ix][1] += correct[1];
                    
                        setRectPoint(pRectorgk, ptEnd[ix][2], ptEnd[ix][3], &ptEnd[ix][0]);
        
                        getRectTran(pRectorgk, dgs[ix], offsets[ix], pRectroi);
                        *pdeg = dgs[ix];
                    
                        break;
                    }
                }
            }
            #else
            if (ret == 0) {
                #if 1 /* disable the position adjust */
                setRectPoint(pRectorgk, ptEnd[ix][2], ptEnd[ix][3], &ptEnd[ix][0]);

                getRectTran(pRectorgk, dgs[ix], offsets[ix], pRectroi);
                *pdeg = dgs[ix];

                ptreal[0] = 1;
                ptreal[1] = 1;
                break;
                #else
                err = adjCircleRect(rs, ptreal, pfound, dgs[ix], offsets[ix], rgbdiff[ix], bmp, oldRowsz, bpp, pidx);
                if (err == 0) {
        
                    correct[0] = ptreal[0] - ptStart[ix][0];
                    correct[1] = ptreal[1] - ptStart[ix][1];
                    sprintf_f(rs->logs, "ptreal(%4d, %4d), page shift: (%4.2lf, %4.2lf) \n", ptreal[0], ptreal[1], correct[0], correct[1]);
                    print_f(rs->plogs, "RECT", rs->logs);       
        
                    ptEnd[ix][0] += correct[0];
                    ptEnd[ix][1] += correct[1];
                    
                    setRectPoint(pRectorgk, ptEnd[ix][2], ptEnd[ix][3], &ptEnd[ix][0]);
        
                    getRectTran(pRectorgk, dgs[ix], offsets[ix], pRectroi);
                    *pdeg = dgs[ix];
                    
                    break;
                }
                #endif
            }
            #endif

            srhnum[ix][0] += 2.0;
            srhnum[ix][1] += 2.0;

            srhlen[ix][0] += 2.0 * srhran[ix][0];
            srhlen[ix][1] += 2.0 * srhran[ix][1];
            
            ptShift[ix][0] -= srhran[ix][0];
            ptShift[ix][1] -= srhran[ix][1];
        }

        if ((ret == 0) && (err == 0)) {
            break;
        }        
    
    }

    if ((!ptreal[0]) && (!ptreal[1])) {

        #if 0
        ix = 0;

        pmreal[0] = ptStart[ix][0];
        pmreal[1] = ptStart[ix][1];

        *pside = ix + 1;                

        sprintf_f(rs->logs, "tag search failed real: (%d, %d) side: %d !!\n", pmreal[0], pmreal[1], *pside);
        print_f(rs->plogs, "RECT", rs->logs);       

        return 0;
        #endif
    
        *pdeg = 0.0;

        sprintf_f(rs->logs, "tag search failed !!\n");
        print_f(rs->plogs, "RECT", rs->logs);       

        return -9;
    }
    
    #if LOG_ROTRECT_EN
    dbgprintRect(pRectroi);
    #endif

    pmreal[0] = ptreal[0];
    pmreal[1] = ptreal[1];

    *pside = ix + 1;


    sprintf_f(rs->logs, "tag search succeed real: (%d, %d) side: %d !!\n", pmreal[0], pmreal[1], *pside);
    print_f(rs->plogs, "RECT", rs->logs);       
    
    return 0;
}

static int getTagOrient(struct aspRectObj *pRectin, int edwidth, int edheight, int pidx, int *tag)
{

    return 0;
}

static int getRectPoint(struct aspCrop36_s *pcp36) 
{
    int ret=0, err=0;
    CFLOAT ttline[3], bbline[3], llline[3], rrline[3];
    CFLOAT pLU[2], pLD[2], pRU[2], pRD[2];
    
    if (!pcp36) return -2;

    msync(pcp36, sizeof(struct aspCrop36_s), MS_SYNC);

    memcpy(ttline, pcp36->crp36LineTop, sizeof(CFLOAT)*3);
    memcpy(bbline, pcp36->crp36LineBotn, sizeof(CFLOAT)*3);
    memcpy(llline, pcp36->crp36LineLeft, sizeof(CFLOAT)*3);
    memcpy(rrline, pcp36->crp36LineRight, sizeof(CFLOAT)*3);

#if LOG_CROP_RECT
    printf("[rect] get rect top line = (%lf, %lf, %lf) \n", ttline[0], ttline[1], ttline[2]);
    printf("[rect] get rect bot line = (%lf, %lf, %lf) \n", bbline[0], bbline[1], bbline[2]);
    printf("[rect] get rect left line = (%lf, %lf, %lf) \n", llline[0], llline[1], llline[2]);
    printf("[rect] get rect right line = (%lf, %lf, %lf) \n", rrline[0], rrline[1], rrline[2]);
#endif

    ret = getCross(ttline, llline, pLU);
    if (ret != 0) {
        printf("[rect] Error!!! get rect cross LU failed!!!!\n");
        err++;
    }

    ret = getCross(ttline, rrline, pRU);
    if (ret != 0) {
        printf("[rect] Error!!! get rect cross RU failed!!!!\n");
        err++;
    }

    ret = getCross(bbline, llline, pLD);
    if (ret != 0) {
        printf("[rect] Error!!! get rect cross LD failed!!!!\n");
        err++;
    }

    ret = getCross(bbline, rrline, pRD);
    if (ret != 0) {
        printf("[rect] Error!!! get rect cross RD failed!!!!\n");
        err++;
    }
    
#if LOG_CROP_RECT
    printf("[rect] get rect LU = (%lf, %lf) \n", pLU[0], pLU[1]);
    printf("[rect] get rect RU = (%lf, %lf) \n", pRU[0], pRU[1]);
    printf("[rect] get rect RD = (%lf, %lf) \n", pRD[0], pRD[1]);
    printf("[rect] get rect LD = (%lf, %lf) \n", pLD[0], pLD[1]);
#endif
    if (err) {
        return err;
    }

    memcpy(pcp36->crp36P1, pLU, sizeof(CFLOAT)*2);
    memcpy(pcp36->crp36P2, pRU, sizeof(CFLOAT)*2);
    memcpy(pcp36->crp36P3, pRD, sizeof(CFLOAT)*2);
    memcpy(pcp36->crp36P4, pLD, sizeof(CFLOAT)*2);

    return 0;
}

static int calcuCrossUpLine(struct aspCrop36_s *pcp36) 
{
    CFLOAT angleCsUp;
    CFLOAT cslineLU[3];
    CFLOAT cslineRU[3];
    CFLOAT *csUp;
    CFLOAT *pn;
    int err=0, ret=0;

    if (!pcp36) return -1;
    msync(pcp36, sizeof(struct aspCrop36_s), MS_SYNC);

    csUp = pcp36->crp36CsUp;
    pn = pcp36->crp36Pots;
#if LOG_CROP_CROSSUPLINE
    printf( "[csULine] cross Down = (%lf, %lf)\n", round(csUp[0]), round(csUp[1]));
#endif
    angleCsUp = getAngle(csUp, &pn[1*2], &pn[4*2]);
    pcp36->crp36AngleDn = angleCsUp;
    
    ret = getVectorFromP(cslineLU, &pn[1*2], csUp);
    if (ret != 0) {
#if LOG_CROP_CROSSUPLINE
        printf( "[csULine] get cslineLU vector fauled!!!\n"); 
#endif
        err++;
    } else {
#if LOG_CROP_CROSSUPLINE
        printf( "[csULine] get cslineLU vector succeed!!!\n");
#endif
        memcpy(pcp36->crp36CsLineLU, cslineLU, sizeof(CFLOAT)*3);
    }
    
    ret = getVectorFromP(cslineRU, &pn[4*2], csUp);
    if (ret != 0) {
#if LOG_CROP_CROSSUPLINE
        printf( "[csULine] get cslineRU vector fauled!!!\n"); 
#endif
        err++;
    } else {
#if LOG_CROP_CROSSUPLINE
        printf( "[csULine] get cslineRU vector succeed!!!\n");
#endif
        memcpy(pcp36->crp36CsLineRU, cslineRU, sizeof(CFLOAT)*3);
    }
            
    return err;
}

static int calcuCrossDnLine(struct aspCrop36_s *pcp36) 
{
    CFLOAT angleCsDn;
    CFLOAT cslineLD[3];
    CFLOAT cslineRD[3];
    CFLOAT *csDn;
    CFLOAT *pn;
    int err=0, ret=0;

    if (!pcp36) return -1;
    msync(pcp36, sizeof(struct aspCrop36_s), MS_SYNC);

    csDn = pcp36->crp36CsDn;
    pn = pcp36->crp36Pots;
#if LOG_CROP_CROSSDNLINE
    printf( "[csDLine] cross Down = (%lf, %lf) \n", round(csDn[0]), round(csDn[1]));
#endif    
    angleCsDn = getAngle(csDn, &pn[1*2], &pn[4*2]);
    pcp36->crp36AngleDn = angleCsDn;

    
    ret = getVectorFromP(cslineLD, &pn[1*2], csDn);
    if (ret != 0) {
        printf( "[csDLine] get cslineLD vector fauled!!!\n"); 
        err++;
    } else {
#if LOG_CROP_CROSSDNLINE
        printf( "[csDLine] get cslineLD vector succeed!!!\n");
#endif
        memcpy(pcp36->crp36CsLineLD, cslineLD, sizeof(CFLOAT)*3);
    }
    
    ret = getVectorFromP(cslineRD, &pn[4*2], csDn);
    if (ret != 0) {
        printf( "[csDLine] get cslineRD vector fauled!!!\n"); 
        err++;
    } else {
#if LOG_CROP_CROSSDNLINE
        printf( "[csDLine] get cslineRD vector succeed!!!\n");
#endif
        memcpy(pcp36->crp36CsLineRD, cslineRD, sizeof(CFLOAT)*3);
    }

    return err;
}

static int calcuMostRtLf(struct aspCrop36_s *pcp36)
{
    int mrtset=0, mlfset=0, csupset=0, csdnset=0;
    int ret=0, err=0;
    CFLOAT maxD= 30.0;
    CFLOAT angleCrosU=0;
    CFLOAT angleCrosD=0;
    CFLOAT angleMosR=0;
    CFLOAT angleMosL=0;
    CFLOAT distUp=0;
    CFLOAT distDn=0;      
    CFLOAT distLf=0;
    CFLOAT distRt=0;
    CFLOAT offset=0;
    CFLOAT vectorHT[3];
    CFLOAT vectorHB[3];
    CFLOAT vectorC[3];
    CFLOAT rtpoint[2];
    CFLOAT csUp[2];
    CFLOAT csDn[2];
    CFLOAT pn[40];

    if (!pcp36) return -1;
    msync(pcp36, sizeof(struct aspCrop36_s), MS_SYNC);

    memcpy(pn, pcp36->crp36Pots, sizeof(CFLOAT)*40);
    memcpy(vectorHT, pcp36->crp36LineTop, sizeof(CFLOAT)*3);
    memcpy(vectorHB, pcp36->crp36LineBotn, sizeof(CFLOAT)*3);
    memcpy(csUp, pcp36->crp36CsUp, sizeof(CFLOAT)*2);
    memcpy(csDn, pcp36->crp36CsDn, sizeof(CFLOAT)*2);
    
    ret = getRectVectorFromV(vectorC, csUp, vectorHT);
    if (ret != 0) {
        printf("[RTLF] Error!!! get vertical vector to cross failed!!!!\n");
        err++;
        return -2;
    }
    
    ret = getCross(vectorHT, vectorC, rtpoint);
    if (ret != 0) {
        printf("[RTLF] Error!!! get cross failed!!!!\n");
        err++;
        return -3;
    }
    
    distUp = calcuDistance(csUp, rtpoint);    
    
    ret = getRectVectorFromV(vectorC, csDn, vectorHB);
    if (ret != 0) {
        printf("[RTLF] Error!!! get vertical vector to cross failed!!!!\n");
        err++;
        return -4;
    }
    
    ret = getCross(vectorHB, vectorC, rtpoint);
    if (ret != 0) {
        printf("[RTLF] Error!!! get cross failed!!!!\n");
        err++;
        return -5;
    }
    
    distDn = calcuDistance(csDn, rtpoint);
#if LOG_CROP_MOSTRL
    printf("[RTLF] distance Up = %lf, distance Down = %lf, max distance = %lf\n", distUp, distDn, maxD);
#endif    

    #if 0
    if ((distUp > maxD) && (distDn > maxD)) {
        printf("[RTLF] distance Up or Dn out of range !!!!!!\n");
        err++;
        return 6;
        
        ret = getRectPoint(pcp36);
        if (ret != 0) {
            printf("[RTLF] Error!!! get new rect four points failed!!!, ret: %d\n", ret);
        }    
    }
    #endif
    
    if (distUp > maxD) {
        distLf = calcuDistance(&pn[6*2], csDn);
        distRt = calcuDistance(&pn[5*2], csDn);
    
        if (distLf > distRt) {
            csUp[0] = pn[6*2+0];
            csUp[1] = pn[6*2+1];
            csupset = 1;
    
            offset = fabs(pn[4*2+0] - pn[5*2+0]);
            if (offset < 100) {
                memcpy(pcp36->crp36MsRt, &pn[5*2], sizeof(CFLOAT)*2);

                mrtset = 1;
            }
        } else {
            csUp[0] = pn[5*2+0];
            csUp[1] = pn[5*2+1];
            csupset = 1;
            
            offset = fabs(pn[1*2+0] - pn[6*2+0]);
            if (offset < 100) {
                memcpy(pcp36->crp36MsLf, &pn[6*2], sizeof(CFLOAT)*2);
                
                mlfset = 1;
            }
        }
    }
    
    if (distDn > maxD) {
        distLf = calcuDistance(&pn[2*2], csUp);
        distRt = calcuDistance(&pn[3*2], csUp);
    
        if (distLf > distRt) {
            csDn[0] = pn[2*2+0];
            csDn[1] = pn[2*2+1];
            csdnset = 1;
            
            offset = fabs(pn[4*2+0] - pn[3*2+0]);
            if (offset < 100) {
                memcpy(pcp36->crp36MsRt, &pn[3*2], sizeof(CFLOAT)*2);

                mrtset = 1;
            }
        } else {
            csDn[0] = pn[3*2+0];
            csDn[1] = pn[3*2+1];
            csdnset = 1;
    
            offset = fabs(pn[1*2+0] - pn[2*2+0]);
            if (offset < 100) {    
                memcpy(pcp36->crp36MsLf, &pn[2*2], sizeof(CFLOAT)*2);
                
                mlfset = 1;
            }
        }
    }
        
    if (!mlfset) {
        memcpy(pcp36->crp36MsLf, &pn[1*2], sizeof(CFLOAT)*2);
    }
    
    if (!mrtset) {
        memcpy(pcp36->crp36MsRt, &pn[4*2], sizeof(CFLOAT)*2);
    }

    if (csdnset) {
        memcpy(pcp36->crp36CsDn, csDn, sizeof(CFLOAT)*2);
    }

    if (csupset) {
        memcpy(pcp36->crp36CsUp, csUp, sizeof(CFLOAT)*2);
    }

    msync(pcp36, sizeof(struct aspCrop36_s), MS_SYNC);
    CFLOAT up[2], dn[2], lf[2], rt[2];
    CFLOAT aup, adn, alf, art;
    memcpy(up, pcp36->crp36CsUp, sizeof(CFLOAT)*2);
    memcpy(dn, pcp36->crp36CsDn, sizeof(CFLOAT)*2);
    memcpy(lf, pcp36->crp36MsLf, sizeof(CFLOAT)*2);
    memcpy(rt, pcp36->crp36MsRt, sizeof(CFLOAT)*2);

    angleCrosU= getAngle(csUp, lf, rt);
    angleCrosD= getAngle(csDn, lf, rt);
    angleMosL = getAngle(lf, csUp, csDn);
    angleMosR = getAngle(rt, csUp, csDn);

    pcp36->crp36AngleLf = angleMosL;
    pcp36->crp36AngleRt = angleMosR;
    pcp36->crp36AngleUp= angleCrosU;
    pcp36->crp36AngleDn= angleCrosD;

    msync(pcp36, sizeof(struct aspCrop36_s), MS_SYNC);
    
    aup = pcp36->crp36AngleUp;
    adn = pcp36->crp36AngleDn;
    alf = pcp36->crp36AngleLf;
    art = pcp36->crp36AngleRt;
#if LOG_CROP_MOSTRL
    printf("[RTLF] angle Up = %lf, Dn = %lf, Lf = %lf, Rt = %lf \n", round(aup), round(adn), round(alf), round(art));
    
    printf("[RTLF] pos up(%d, %d), dn(%d, %d), lf(%d, %d), rt(%d, %d)\n", (int)round(up[0]), (int)round(up[1])
            , (int)round(dn[0]), (int)round(dn[1]), (int)round(lf[0]), (int)round(lf[1]), (int)round(rt[0]), (int)round(rt[1]));
#endif
    return 0;
}

static int calcuCrossDnAph(struct aspCrop36_s *pcp36, int midx) 
{
#define DN_NUM 5
#define PT_NUM 40
    int idxALLLf[] = {6, 7, 9, 11, 13, 15, 17, 2};
    int idxALLRt[] = {5, 8, 10, 12, 14, 16, 18, 3};

    int ret=0;
    int i=0, j=0, Lc=0, Rc=0;
    CFLOAT pn[PT_NUM];
    CFLOAT pld[DN_NUM*2];
    CFLOAT prd[DN_NUM*2];

    if (!pcp36) return -1;
    msync(pcp36, sizeof(struct aspCrop36_s), MS_SYNC);
    
    memcpy(pn, pcp36->crp36Pots, sizeof(CFLOAT)*PT_NUM);

    for (i = 3, j = 0; i < (DN_NUM+3); i++, j++) {
        Lc = idxALLLf[i];
        Rc = idxALLRt[i];
        pld[j*2+0] = pn[Lc*2+0];
        pld[j*2+1] = pn[Lc*2+1];

        prd[j*2+0] = pn[Rc*2+0];
        prd[j*2+1] = pn[Rc*2+1];
#if LOG_CROP_CROSSDNAPH
        printf( "[csDN] %d. (LD) copy (%d), %lf,  %lf (RD) copy (%d), %lf,  %lf \n", j, Lc, round(pld[j*2+0]), round(pld[j*2+1]), Rc, round(prd[j*2+0]), round(prd[j*2+1]));    
#endif
    }

    CFLOAT vld[3];
    CFLOAT divLD;
    CFLOAT vrd[3];
    CFLOAT divRD;

    ret = calcuGroupLine(pld, vld, &divLD, DN_NUM, midx);
    if (ret == 0) {
#if LOG_CROP_CROSSDNAPH
        printf("[csDN] succeed to get group line vLD, divLD = %lf \n", divLD);    
#endif
    } else {
#if LOG_CROP_CROSSDNAPH
        printf("[csDN] failed to get group line vLD, ret = %d \n", ret);    
#endif
        return -2;
    }

    ret = calcuGroupLine(prd, vrd, &divRD, DN_NUM, midx);
    if (ret == 0) {
#if LOG_CROP_CROSSDNAPH
        printf("[csDN] succeed to get group line vRD, divRD = %lf \n", divRD);    
#endif
    } else {
#if LOG_CROP_CROSSDNAPH
        printf("[csDN] failed to get group line vRD, ret = %d \n", ret);    
#endif
        return -3;
    }

    CFLOAT csDown[2];

    ret = getCross(vld, vrd, csDown);
    if (ret == 0) {
#if LOG_CROP_CROSSDNAPH
        printf("[csDN] succeed to get cross down = (%lf, %lf)\n", csDown[0], csDown[1]);
#endif
    } else {
#if LOG_CROP_CROSSDNAPH
        printf("[csDN] failed to get cross down, ret = %d\n", ret);
#endif
        return -4;
    }

    memcpy(pcp36->crp36CsDn, csDown, sizeof(CFLOAT)*2);

    return 0;
}    

static int getCrop36RotatePoints(struct aspCrop36_s *pcp36) 
{
    int ret=0;
    int solidFlag = 0;
    int talR = 5;
    int talH = 60;
    CFLOAT honMin = 50.0;
    int rdegL = 90 - talR;
    int rdegH = 90 + talR;
    int pdegL = 180 - talH;
    int pdegH = 180 + talH;
    
    int angCsUp= 0;
    int angCsDn= 0;
    int angMsLf= 0;
    int angMsRt= 0;
    
    int angUpL= 0;
    int angDnL= 0;
    int angUpR= 0;
    int angDnR= 0;

    if (!pcp36) return -1;
    msync(pcp36, sizeof(struct aspCrop36_s), MS_SYNC);

    angCsUp= (int) round(pcp36->crp36AngleUp);
    angCsDn= (int) round(pcp36->crp36AngleDn);
    angMsLf= (int) round(pcp36->crp36AngleLf);
    angMsRt= (int) round(pcp36->crp36AngleRt);
    
    
    if ((angCsUp > rdegL) && (angCsUp < rdegH)) {
        solidFlag |= 0x1;
    }
    if ((angCsDn > rdegL) && (angCsDn < rdegH)) {
        solidFlag |= 0x2;
    }
    if ((angMsLf > rdegL) && (angMsLf < rdegH)) {
        solidFlag |= 0x4;
    }
    if ((angMsRt > rdegL) && (angMsRt < rdegH)) {
        solidFlag |= 0x8;
    }

    if ((angCsUp > pdegL) && (angCsUp < pdegH)) {
        solidFlag |= 0x1 << 4;
    }
    if ((angCsDn > pdegL) && (angCsDn < pdegH)) {
        solidFlag |= 0x2 << 4;
    }
    if ((angMsLf > pdegL) && (angMsLf < pdegH)) {
        solidFlag |= 0x4 << 4;
    }
    if ((angMsRt > pdegL) && (angMsRt < pdegH)) {
        solidFlag |= 0x8 << 4;
    }

    pcp36->crp36Flag = solidFlag;
    
    //solidFlag = 214;
#if LOG_CROP_ROT36
    printf("[crp36] solidFlag (0x%x)\n", solidFlag);
#endif    
    CFLOAT csUp1[2];
    CFLOAT csDn1[2];
    CFLOAT mostLf1[2];
    CFLOAT mostRt1[2];

    memcpy(csUp1, pcp36->crp36CsUp, sizeof(CFLOAT)*2);
    memcpy(csDn1, pcp36->crp36CsDn, sizeof(CFLOAT)*2);
    memcpy(mostLf1, pcp36->crp36MsLf, sizeof(CFLOAT)*2);
    memcpy(mostRt1, pcp36->crp36MsRt, sizeof(CFLOAT)*2);

    #if 1
    memcpy(pcp36->crp36P1, mostLf1, sizeof(CFLOAT)*2);    
    memcpy(pcp36->crp36P2, csUp1, sizeof(CFLOAT)*2);    
    memcpy(pcp36->crp36P3, mostRt1, sizeof(CFLOAT)*2);    
    memcpy(pcp36->crp36P4, csDn1, sizeof(CFLOAT)*2);        
    #else
    memset(pcp36->crp36P1, 0, sizeof(CFLOAT)*2);    
    memset(pcp36->crp36P2, 0, sizeof(CFLOAT)*2);    
    memset(pcp36->crp36P3, 0, sizeof(CFLOAT)*2);    
    memset(pcp36->crp36P4, 0, sizeof(CFLOAT)*2);        
    #endif

#if LOG_CROP_ROT36
    printf("[crp36] org most left = (%lf, %lf)\n", mostLf1[0], mostLf1[1]);
    printf("[crp36] org cross up = (%lf, %lf)\n", csUp1[0], csUp1[1]);
    printf("[crp36] org most right = (%lf, %lf)\n", mostRt1[0], mostRt1[1]);
    printf("[crp36] org cross down = (%lf, %lf)\n", csDn1[0], csDn1[1]);
#endif

    CFLOAT shif=0;
    CFLOAT csLineRU[3];
    CFLOAT csLineLU[3];
    CFLOAT csLineRD[3];
    CFLOAT csLineLD[3];
        
    CFLOAT rtLine[3];
    CFLOAT lfLine[3];
    CFLOAT newCsLineRU[3];
    CFLOAT newCsLineLU[3];
    CFLOAT newCsLineRD[3];
    CFLOAT newCsLineLD[3];
    CFLOAT newCsDn[2];
    CFLOAT newMostLf[2];
    CFLOAT newMostRt[2];

    memcpy(csLineRU, pcp36->crp36CsLineRU, sizeof(CFLOAT)*3);
    memcpy(csLineLU, pcp36->crp36CsLineLU, sizeof(CFLOAT)*3);
    memcpy(csLineRD, pcp36->crp36CsLineRD, sizeof(CFLOAT)*3);
    memcpy(csLineLD, pcp36->crp36CsLineLD, sizeof(CFLOAT)*3);

    memcpy(rtLine, pcp36->crp36LineRight, sizeof(CFLOAT)*3);        
    memcpy(lfLine, pcp36->crp36LineLeft, sizeof(CFLOAT)*3);        
    
    if (csUp1[1] < 0) {
        shif = 0 - csUp1[1];
        csUp1[1] = 0;
    }
    
    getParallelVectorFromV(newCsLineLU, csUp1, csLineLU);
    getParallelVectorFromV(newCsLineRU, csUp1, csLineRU);
    
    int fstLevel = 0;
    int secLevel = 0;
    fstLevel = (solidFlag >> 0) & 0xf;        
    secLevel = (solidFlag >> 4) & 0xf;

    switch(fstLevel) {
    case (0x1 | 0x2 | 0x4 | 0x8):
    case (0x1 | 0x4 | 0x8):
    case (0x2 | 0x4 | 0x8):
        ret = getCross(csLineLD, newCsLineLU, newMostLf);
        if (ret != 0) {
            printf("[crp36] Error!!! get new most left failed!!!, ret: %d\n", ret);
        }            
    
        ret = getCross(csLineRD, newCsLineRU, newMostRt);
        if (ret != 0) {
            printf("[crp36] Error!!! get new most right failed!!!, ret: %d\n", ret);
        }
#if LOG_CROP_ROT36
        printf("[crp36] set most left = (%lf, %lf)\n", mostLf1[0], mostLf1[1]);
        printf("[crp36] set cross up = (%lf, %lf)\n", csUp1[0], csUp1[1]);
        printf("[crp36] set most right = (%lf, %lf)\n", mostRt1[0], mostRt1[1]);
        printf("[crp36] set cross down = (%lf, %lf)\n", csDn1[0], csDn1[1]);
#endif
        memcpy(pcp36->crp36P1, mostLf1, sizeof(CFLOAT)*2);    
        memcpy(pcp36->crp36P2, csUp1, sizeof(CFLOAT)*2);    
        memcpy(pcp36->crp36P3, mostRt1, sizeof(CFLOAT)*2);    
        memcpy(pcp36->crp36P4, csDn1, sizeof(CFLOAT)*2);        
        break;
    case (0x1):
    case (0x2):
        ret = getCross(csLineRD, newCsLineRU, newMostRt);
        if (ret != 0) {
            printf("[crp36] Error!!! get new most right failed!!!, ret: %d\n", ret);
        }

        ret = getCross(csLineLD, newCsLineLU, newMostLf);
        if (ret != 0) {
            printf("[crp36] Error!!! get new most left failed!!!, ret: %d\n", ret);
        }            

#if LOG_CROP_ROT36
        printf("[crp36] set most left = (%lf, %lf) (%d)\n", mostLf1[0], mostLf1[1], 0);
        printf("[crp36] set cross up = (%lf, %lf) (%d)\n", csUp1[0], csUp1[1], 1);
        printf("[crp36] set most right = (%lf, %lf) (%d)\n", mostRt1[0], mostRt1[1], 0);
        printf("[crp36] set cross down = (%lf, %lf) (%d)\n", csDn1[0], csDn1[1], 1);
#endif

        //memcpy(pcp36->crp36P1, mostLf1, sizeof(CFLOAT)*2);    
        memcpy(pcp36->crp36P2, csUp1, sizeof(CFLOAT)*2);    
        //memcpy(pcp36->crp36P3, mostRt1, sizeof(CFLOAT)*2);    
        memcpy(pcp36->crp36P4, csDn1, sizeof(CFLOAT)*2);            

        break;
    case (0x2 | 0x4):
        ret = getCross(csLineRD, newCsLineRU, newMostRt);
        if (ret != 0) {
            printf("[crp36] Error!!! get new most right failed!!!, ret: %d\n",ret);
        }

        ret = getCross(csLineLD, newCsLineLU, newMostLf);
        if (ret != 0) {
            printf("[crp36] Error!!! get new most left failed!!!, ret: %d\n", ret);
        }            
#if LOG_CROP_ROT36
        printf("[crp36] set most left = (%lf, %lf) (%d)\n", mostLf1[0], mostLf1[1], 1);
        printf("[crp36] set cross up = (%lf, %lf) (%d)\n", csUp1[0], csUp1[1], 0);
        printf("[crp36] set most right = (%lf, %lf) (%d)\n", mostRt1[0], mostRt1[1], 0);
        printf("[crp36] set cross down = (%lf, %lf) (%d)\n", csDn1[0], csDn1[1], 1);
#endif
        memcpy(pcp36->crp36P1, mostLf1, sizeof(CFLOAT)*2);    
        //memcpy(pcp36->crp36P2, csUp1, sizeof(CFLOAT)*2);    
        //memcpy(pcp36->crp36P3, mostRt1, sizeof(CFLOAT)*2);    
        memcpy(pcp36->crp36P4, csDn1, sizeof(CFLOAT)*2);         
        break;
    case (0x2 | 0x8):
        ret = getCross(csLineLD, newCsLineLU, newMostLf);
        if (ret != 0) {
            printf("[crp36] Error!!! get new most left failed!!!, ret: %d\n", ret);
        }            
    
        ret = getCross(csLineRD, newCsLineRU, newMostRt);
        if (ret != 0) {
            printf("[crp36] Error!!! get new most right failed!!!, ret: %d\n", ret);
        }
#if LOG_CROP_ROT36
        printf("[crp36] set most left = (%lf, %lf) (%d)\n", mostLf1[0], mostLf1[1], 0);
        printf("[crp36] set cross up = (%lf, %lf) (%d)\n", csUp1[0], csUp1[1], 0);
        printf("[crp36] set most right = (%lf, %lf) (%d)\n", mostRt1[0], mostRt1[1], 1);
        printf("[crp36] set cross down = (%lf, %lf) (%d)\n", csDn1[0], csDn1[1], 1);
#endif
        //memcpy(pcp36->crp36P1, mostLf1, sizeof(CFLOAT)*2);    
        //memcpy(pcp36->crp36P2, csUp1, sizeof(CFLOAT)*2);    
        memcpy(pcp36->crp36P3, mostRt1, sizeof(CFLOAT)*2);    
        memcpy(pcp36->crp36P4, csDn1, sizeof(CFLOAT)*2);         
        break;
    case (0x1 | 0x4):
        ret = getCross(csLineRD, newCsLineRU, newMostRt);
        if (ret != 0) {
            printf("[crp36] Error!!! get new most right failed!!!, ret: %d\n",ret);
        }

        ret = getCross(csLineLD, newCsLineLU, newMostLf);
        if (ret != 0) {
            printf("[crp36] Error!!! get new most left failed!!!, ret: %d\n", ret);
        }            
#if LOG_CROP_ROT36
        printf("[crp36] set most left = (%lf, %lf) (%d)\n", mostLf1[0], mostLf1[1], 1);
        printf("[crp36] set cross up = (%lf, %lf) (%d)\n", csUp1[0], csUp1[1], 1);
        printf("[crp36] set most right = (%lf, %lf) (%d)\n", mostRt1[0], mostRt1[1], 0);
        printf("[crp36] set cross down = (%lf, %lf) (%d)\n", csDn1[0], csDn1[1], 0);
#endif
        memcpy(pcp36->crp36P1, mostLf1, sizeof(CFLOAT)*2);    
        memcpy(pcp36->crp36P2, csUp1, sizeof(CFLOAT)*2);    
        //memcpy(pcp36->crp36P3, mostRt1, sizeof(CFLOAT)*2);    
        //memcpy(pcp36->crp36P4, csDn1, sizeof(CFLOAT)*2);         
        break;
    case (0x1 | 0x8):
        ret = getCross(csLineLD, newCsLineLU, newMostLf);
        if (ret != 0) {
            printf("[crp36] Error!!! get new most left failed!!!, ret: %d\n", ret);
        }            
    
        ret = getCross(csLineRD, newCsLineRU, newMostRt);
        if (ret != 0) {
            printf("[crp36] Error!!! get new most right failed!!!, ret: %d\n", ret);
        }
#if LOG_CROP_ROT36
        printf("[crp36] set most left = (%lf, %lf) (%d)\n", mostLf1[0], mostLf1[1], 0);
        printf("[crp36] set cross up = (%lf, %lf) (%d)\n", csUp1[0], csUp1[1], 1);
        printf("[crp36] set most right = (%lf, %lf) (%d)\n", mostRt1[0], mostRt1[1], 1);
        printf("[crp36] set cross down = (%lf, %lf) (%d)\n", csDn1[0], csDn1[1], 0);
#endif
        //memcpy(pcp36->crp36P1, mostLf1, sizeof(CFLOAT)*2);    
        memcpy(pcp36->crp36P2, csUp1, sizeof(CFLOAT)*2);    
        memcpy(pcp36->crp36P3, mostRt1, sizeof(CFLOAT)*2);    
        //memcpy(pcp36->crp36P4, csDn1, sizeof(CFLOAT)*2);         
        break;
    case (0x4):
        switch (secLevel) {
            case (0x1):
                ret = getCross(csLineLD, newCsLineLU, newMostLf);
                if (ret != 0) {
                    printf("[crp36] Error!!! get new most left failed!!!, ret: %d\n", ret);
                }            

                ret = getCross(csLineRD, newCsLineRU, newMostRt);
                if (ret != 0) {
                    printf("[crp36] Error!!! get new most right failed!!!, ret: %d\n", ret);
                }

                #if LOG_CROP_ROT36        
                printf("[crp36] set most left = (%lf, %lf) (%d)\n", mostLf1[0], mostLf1[1], 1);
                printf("[crp36] set cross up = (%lf, %lf) (%d)\n", csUp1[0], csUp1[1], 0);
                printf("[crp36] set most right = (%lf, %lf) (%d)\n", mostRt1[0], mostRt1[1], 0);
                printf("[crp36] set cross down = (%lf, %lf) (%d)\n", csDn1[0], csDn1[1], 1);
                #endif

                memcpy(pcp36->crp36P1, mostLf1, sizeof(CFLOAT)*2);    
                //memcpy(pcp36->crp36P2, csUp1, sizeof(CFLOAT)*2);    
                //memcpy(pcp36->crp36P3, mostRt1, sizeof(CFLOAT)*2);    
                memcpy(pcp36->crp36P4, csDn1, sizeof(CFLOAT)*2);         
                break;
            case (0x2):
                ret = getCross(csLineLD, newCsLineLU, newMostLf);
                if (ret != 0) {
                    printf("[crp36] Error!!! get new most left failed!!!, ret: %d\n", ret);
                }            

                ret = getCross(csLineRD, newCsLineRU, newMostRt);
                if (ret != 0) {
                    printf("[crp36] Error!!! get new most right failed!!!, ret: %d\n", ret);
                }

                #if LOG_CROP_ROT36        
                printf("[crp36] set most left = (%lf, %lf) (%d)\n", mostLf1[0], mostLf1[1], 1);
                printf("[crp36] set cross up = (%lf, %lf) (%d)\n", csUp1[0], csUp1[1], 1);
                printf("[crp36] set most right = (%lf, %lf) (%d)\n", mostRt1[0], mostRt1[1], 0);
                printf("[crp36] set cross down = (%lf, %lf) (%d)\n", csDn1[0], csDn1[1], 0);
                #endif

                memcpy(pcp36->crp36P1, mostLf1, sizeof(CFLOAT)*2);    
                memcpy(pcp36->crp36P2, csUp1, sizeof(CFLOAT)*2);    
                //memcpy(pcp36->crp36P3, mostRt1, sizeof(CFLOAT)*2);    
                //memcpy(pcp36->crp36P4, csDn1, sizeof(CFLOAT)*2);         
                break;
            default:
                ret = getCross(csLineLD, newCsLineLU, newMostLf);
                if (ret != 0) {
                    printf("[crp36] Error!!! get new most left failed!!!, ret: %d\n", ret);
                }            

                ret = getCross(csLineRD, newCsLineRU, newMostRt);
                if (ret != 0) {
                    printf("[crp36] Error!!! get new most right failed!!!, ret: %d\n", ret);
                }

                #if LOG_CROP_ROT36        
                printf("[crp36] set most left = (%lf, %lf) (%d)\n", mostLf1[0], mostLf1[1], 1);
                printf("[crp36] set cross up = (%lf, %lf) (%d)\n", csUp1[0], csUp1[1], 1);
                printf("[crp36] set most right = (%lf, %lf) (%d)\n", mostRt1[0], mostRt1[1], 0);
                printf("[crp36] set cross down = (%lf, %lf) (%d)\n", csDn1[0], csDn1[1], 1);
                #endif

                memcpy(pcp36->crp36P1, mostLf1, sizeof(CFLOAT)*2);    
                memcpy(pcp36->crp36P2, csUp1, sizeof(CFLOAT)*2);    
                //memcpy(pcp36->crp36P3, mostRt1, sizeof(CFLOAT)*2);    
                memcpy(pcp36->crp36P4, csDn1, sizeof(CFLOAT)*2);         
                break;
        }
        break;
    case (0x8):
        switch (secLevel) {
            case (0x1):
                ret = getCross(csLineLD, newCsLineLU, newMostLf);
                if (ret != 0) {
                    printf("[crp36] Error!!! get new most left failed!!!, ret: %d\n", ret);
                }            

                ret = getCross(csLineRD, newCsLineRU, newMostRt);
                if (ret != 0) {
                    printf("[crp36] Error!!! get new most right failed!!!, ret: %d\n", ret);
                }

                #if LOG_CROP_ROT36        
                printf("[crp36] set most left = (%lf, %lf) (%d)\n", mostLf1[0], mostLf1[1], 0);
                printf("[crp36] set cross up = (%lf, %lf) (%d)\n", csUp1[0], csUp1[1], 1);
                printf("[crp36] set most right = (%lf, %lf) (%d)\n", mostRt1[0], mostRt1[1], 1);
                printf("[crp36] set cross down = (%lf, %lf) (%d)\n", csDn1[0], csDn1[1], 1);
                #endif

                //memcpy(pcp36->crp36P1, mostLf1, sizeof(CFLOAT)*2);    
                memcpy(pcp36->crp36P2, csUp1, sizeof(CFLOAT)*2);    
                memcpy(pcp36->crp36P3, mostRt1, sizeof(CFLOAT)*2);    
                memcpy(pcp36->crp36P4, csDn1, sizeof(CFLOAT)*2);         
                break;
            case (0x2):
                ret = getCross(csLineLD, newCsLineLU, newMostLf);
                if (ret != 0) {
                    printf("[crp36] Error!!! get new most left failed!!!, ret: %d\n", ret);
                }            

                ret = getCross(csLineRD, newCsLineRU, newMostRt);
                if (ret != 0) {
                    printf("[crp36] Error!!! get new most right failed!!!, ret: %d\n", ret);
                }

                #if LOG_CROP_ROT36        
                printf("[crp36] set most left = (%lf, %lf) (%d)\n", mostLf1[0], mostLf1[1], 0);
                printf("[crp36] set cross up = (%lf, %lf) (%d)\n", csUp1[0], csUp1[1], 1);
                printf("[crp36] set most right = (%lf, %lf) (%d)\n", mostRt1[0], mostRt1[1], 1);
                printf("[crp36] set cross down = (%lf, %lf) (%d)\n", csDn1[0], csDn1[1], 1);
                #endif

                //memcpy(pcp36->crp36P1, mostLf1, sizeof(CFLOAT)*2);    
                memcpy(pcp36->crp36P2, csUp1, sizeof(CFLOAT)*2);    
                memcpy(pcp36->crp36P3, mostRt1, sizeof(CFLOAT)*2);    
                memcpy(pcp36->crp36P4, csDn1, sizeof(CFLOAT)*2);         
                break;
            default:
                ret = getCross(csLineLD, newCsLineLU, newMostLf);
                if (ret != 0) {
                    printf("[crp36] Error!!! get new most left failed!!!, ret: %d\n", ret);
                }            

                ret = getCross(csLineRD, newCsLineRU, newMostRt);
                if (ret != 0) {
                    printf("[crp36] Error!!! get new most right failed!!!, ret: %d\n", ret);
                }

                #if LOG_CROP_ROT36        
                printf("[crp36] set most left = (%lf, %lf) (%d)\n", mostLf1[0], mostLf1[1], 0);
                printf("[crp36] set cross up = (%lf, %lf) (%d)\n", csUp1[0], csUp1[1], 1);
                printf("[crp36] set most right = (%lf, %lf) (%d)\n", mostRt1[0], mostRt1[1], 1);
                printf("[crp36] set cross down = (%lf, %lf) (%d)\n", csDn1[0], csDn1[1], 1);
                #endif

                //memcpy(pcp36->crp36P1, mostLf1, sizeof(CFLOAT)*2);    
                memcpy(pcp36->crp36P2, csUp1, sizeof(CFLOAT)*2);    
                memcpy(pcp36->crp36P3, mostRt1, sizeof(CFLOAT)*2);    
                memcpy(pcp36->crp36P4, csDn1, sizeof(CFLOAT)*2);         
                break;
        }
        break;
    default:
        if (fstLevel == 0) {
            #if 0
            ret = getRectPoint(pcp36);
            if (ret != 0) {
                printf("[crp36] Error!!! get new rect four points failed!!!, ret: %d \n", ret);
            }
            #else
#if LOG_CROP_ROT36
            printf("[crp36] set most left = (%lf, %lf) (%d)\n", mostLf1[0], mostLf1[1], 0);
            printf("[crp36] set cross up = (%lf, %lf) (%d)\n", csUp1[0], csUp1[1], 0);
            printf("[crp36] set most right = (%lf, %lf) (%d)\n", mostRt1[0], mostRt1[1], 0);
            printf("[crp36] set cross down = (%lf, %lf) (%d)\n", csDn1[0], csDn1[1], 0);
#endif

            //memcpy(pcp36->crp36P1, mostLf1, sizeof(CFLOAT)*2);    
            memcpy(pcp36->crp36P2, csUp1, sizeof(CFLOAT)*2);    
            //memcpy(pcp36->crp36P3, mostRt1, sizeof(CFLOAT)*2);    
            memcpy(pcp36->crp36P4, csDn1, sizeof(CFLOAT)*2);        
            #endif
        } else {
            getParallelVectorFromV(newCsLineLU, csUp1, csLineLU);
            getParallelVectorFromV(newCsLineRU, csUp1, csLineRU);
    
            ret = getCross(newCsLineRU, csLineRD, newMostRt);
            if (ret != 0) {
                printf("[crp36] Error!!! get new most left failed!!!, ret: %d\n",ret);
            }
    
            ret = getCross(newCsLineLU, csLineLD, newMostLf);
            if (ret != 0) {
                printf("[crp36] Error!!! get new most left failed!!!, ret: %d \n",ret);
            }
#if LOG_CROP_ROT36
            printf("[crp36] set most left = (%lf, %lf) (%d)\n", mostLf1[0], mostLf1[1], 0);
            printf("[crp36] set cross up = (%lf, %lf) (%d)\n", csUp1[0], csUp1[1], 0);
            printf("[crp36] set most right = (%lf, %lf) (%d)\n", mostRt1[0], mostRt1[1], 0);
            printf("[crp36] set cross down = (%lf, %lf) (%d)\n", csDn1[0], csDn1[1], 0);
#endif

            //memcpy(pcp36->crp36P1, mostLf1, sizeof(CFLOAT)*2);    
            memcpy(pcp36->crp36P2, csUp1, sizeof(CFLOAT)*2);    
            //memcpy(pcp36->crp36P3, mostRt1, sizeof(CFLOAT)*2);    
            memcpy(pcp36->crp36P4, csDn1, sizeof(CFLOAT)*2);                     
        }
        break;
    }

    if ((pcp36->crp36P2[0] > (pcp36->crp36P1[0] - honMin)) && (pcp36->crp36P2[0] < (pcp36->crp36P1[0] + honMin))) {
        solidFlag |= 0x1 << 8;        
    }

    if ((pcp36->crp36P4[0] > (pcp36->crp36P1[0] - honMin)) && (pcp36->crp36P4[0] < (pcp36->crp36P1[0] + honMin))) {
        solidFlag |= 0x2 << 8;        
    }

    if ((pcp36->crp36P2[0] > (pcp36->crp36P3[0] - honMin)) && (pcp36->crp36P2[0] < (pcp36->crp36P3[0] + honMin))) {
        solidFlag |= 0x4 << 8;        
    }

    if ((pcp36->crp36P4[0] > (pcp36->crp36P3[0] - honMin)) && (pcp36->crp36P4[0] < (pcp36->crp36P3[0] + honMin))) {
        solidFlag |= 0x8 << 8;        
    }

    pcp36->crp36Flag = solidFlag;
    
    return 0;
}

static int cpyPGrp(int start, int len, CFLOAT *grp, CFLOAT **cpgp, int max) 
{
    int size=0, last=0, end=0;
    int i=0, idx=0;
    CFLOAT *ngrp;

    if (start >= max) {
        return -1;
    }

    if (!grp) {
        return -2;
    }

    if (!cpgp) {
        return -3;
    }

    end = start + len;
    if (end > max) {
        end = max;
    }
    
    len = end - start;

    ngrp = &grp[start*2];

    *cpgp = ngrp;
    
    return len;
}

static int findLine(struct aspCrop36_s *pcp36, struct aspCropExtra_s *pcpex, int midx) 
{

#define MUL_DIST_TOLT   (24.0) //(4.0)
#define CROP_LINE_MIN_L (120.0)
#define CROP_LINE_MIN_F (10.0)//(600.0)
#define CROP_LINE_MIN_W (180.0)//(600.0)
#define CROP_LINE_NUM (2)
#define GROUP_LINE_LIMIT (3.0)
    int i = 0, tot = 0, ret = 0, head = 0, glen = 0, id = 0, aln=0, rid=0, sid=0;
    int cntLf=0, cntRt=0, contL=0, contR=0;
    int allpos[16] = {0};
    int allnum[16] = {0};
    CFLOAT alldist[16] = {0};
    CFLOAT allverTr[16][3] = {0};
    CFLOAT *allgrp[16] = {0};
    CFLOAT *p1, *p2;
    CFLOAT *ptLf, *ptRt;
    CFLOAT vecTr[3] = {0.0, 0.0, 0.0};
    CFLOAT dist = 0, dist2 = 0, diff = 0;
    CFLOAT *cgrp;
    CFLOAT pc0[2], pc1[2], pc2[2];
    CFLOAT distP2P = 0, distP2Bef = 0;
    CFLOAT lineMin=0, wmin=0, linenum=0, w=0, h=0;
    int absLsize = cntLf / 2;
    int absRsize = cntRt / 2;
    int thrd=0, sms=0, minpt=0;

    if (!pcp36) return -1;
    if (!pcpex) return -2;

    h = (CFLOAT)(pcp36->crp36Dn - pcp36->crp36Up);
    linenum = h / CROP_LINE_MIN_L; 
    lineMin = h / CROP_LINE_MIN_F;
    
    w = (CFLOAT)(pcp36->crp36Rt - pcp36->crp36Lf);
    wmin = w / CROP_LINE_MIN_W;

#define CROP_LINE_DIST  (wmin)
#define CROP_POINT_DIST  (wmin / 2.0)

    ptLf = pcpex->crpexLfPots;
    ptRt = pcpex->crpexRtPots;
#if LOG_CROP_FINDBASELINE
    printf("[find] findLine left start \n");    
#endif
    tot = pcpex->crpexSize / 2;
    
    thrd = tot / 12;
    
    cntLf = 0;
    pcpex->crpexLfAbsUsed = 0;
    
    head = 0;                        
#if LOG_CROP_FINDBASELINE
    printf("[find] line start  = [%d] , (%lf, %lf) total: %d\n", head, ptLf[head*2+0], ptLf[head*2+1], tot);    
#endif
    pcpex->crpexLfAbs[cntLf] = 0;
    cntLf ++;

    pc0[0] = -1;
    pc0[1] = -1;
    distP2Bef = -1;
    sms = 0;
    
    for (i=1; i < tot; i++) {
        p1 = &ptLf[head*2];
        p2 = &ptLf[i*2];


        if (sms > thrd) {
            pc0[0] = -1;
            pc0[1] = -1;
            sms = 0;
        } else if (pc0[0] > 0) {
            distP2Bef = calcuDistance(p1, pc0);
            if (distP2Bef < CROP_POINT_DIST) {
#if LOG_CROP_FINDBASELINE
    printf("[find] [skip] [%d] (%.2lf, %.2lf) <-> (%.2lf, %.2lf) dist: %.2lf (%.2lf)\n", head, pc0[0], pc0[1], p1[0], p1[1], distP2Bef, CROP_POINT_DIST);
#endif
                head = i;
                pcpex->crpexLfAbs[cntLf-1] = i;

                pc0[0] = p1[0];
                pc0[1] = p1[1];

                sms ++;

                continue;
            } else {
                pc0[0] = -1;
                pc0[1] = -1;
                sms = 0;
            }
        }

        getVectorFromP(vecTr,  p1,  p2);

        ret = cpyPGrp(head, i-head, ptLf, &cgrp, 2048/2);
        
        if (ret > 0) {
            glen = ret;
        } else {
            glen = 0;
        }

        dist = calcuLineGroupDist(cgrp, vecTr, glen);
        
        if (dist > CROP_LINE_DIST) {
#if LOG_CROP_FINDBASELINE
            printf("line = [%d] -> [%d], (%lf, %lf) -> (%lf, %lf), dist: %lf limit: %.2lf\n", head, i - 1, ptLf[head*2+0], ptLf[head*2+1], ptLf[(i-1)*2+0], ptLf[(i-1)*2+1], dist, CROP_LINE_DIST);
#endif
            head = i;

            pcpex->crpexLfAbs[cntLf] = i - 1;
            
            cntLf ++;
            
            pcpex->crpexLfAbs[cntLf] = i;
            
            cntLf ++;
            
            pc0[0] = p1[0];
            pc0[1] = p1[1];
        }
        else {
            pc0[0] = -1;
            pc0[1] = -1;
        }

        cgrp = 0;
    }
#if LOG_CROP_FINDBASELINE
    printf("line = [%d] -> [%d], (%lf, %lf) -> (%lf, %lf)\n", head, i - 1, ptLf[head*2+0], ptLf[head*2+1], ptLf[(i-1)*2+0], ptLf[(i-1)*2+1]);
#endif
    head = i;

    pcpex->crpexLfAbs[cntLf] = i - 1;
    
    cntLf ++;
    pcpex->crpexLfAbsUsed = cntLf;
#if LOG_CROP_FINDBASELINE
    printf("[find] findLine right start \n");    
#endif
    head = 0;
    cntRt = 0;
    pcpex->crpexRtAbsUsed = 0;
#if LOG_CROP_FINDBASELINE
    printf("line start  = [%d] , (%lf, %lf) \n", head, ptRt[head*2+0], ptRt[head*2+1]);    
#endif
    pcpex->crpexRtAbs[cntRt] = 0;
    cntRt ++;

    pc0[0] = -1;
    pc0[1] = -1;
    distP2Bef = -1;
    sms = 0;	
    
    for (i=1; i < tot; i++) {
        p1 = &ptRt[head*2];
        p2 = &ptRt[i*2];

        if (sms > thrd) {
            pc0[0] = -1;
            pc0[1] = -1;
            sms = 0;
        } else if (pc0[0] > 0) {
            distP2Bef = calcuDistance(p1, pc0);
            if (distP2Bef < CROP_POINT_DIST) {
#if LOG_CROP_FINDBASELINE
    printf("[find] [skip] [%d] (%.2lf, %.2lf) <-> (%.2lf, %.2lf) dist: %.2lf (%.2lf)\n", head, pc0[0], pc0[1], p1[0], p1[1], distP2Bef, CROP_POINT_DIST);
#endif
                head = i;
                pcpex->crpexRtAbs[cntRt-1] = i;

                pc0[0] = p1[0];
                pc0[1] = p1[1];

                sms ++;

                continue;
            } else {
                pc0[0] = -1;
                pc0[1] = -1;
                sms = 0;
            }
        }
        getVectorFromP(vecTr,  p1,  p2);

        ret = cpyPGrp(head, i-head, ptRt, &cgrp, 2048/2);

        if (ret > 0) {
            glen = ret;
        } else {
            glen = 0;
        }

        dist = calcuLineGroupDist(cgrp, vecTr, glen);
        
        if (dist > CROP_LINE_DIST) {
#if LOG_CROP_FINDBASELINE
            printf( "line = [%d] -> [%d], (%lf, %lf) -> (%lf, %lf), dist: %lf limit: %.2lf\n", head, i - 1, ptRt[head*2+0], ptRt[head*2+1], ptRt[(i-1)*2+0], ptRt[(i-1)*2+1], dist, CROP_LINE_DIST);    
#endif
            head = i;

            pcpex->crpexRtAbs[cntRt] = i - 1;
            
            cntRt++;

            pcpex->crpexRtAbs[cntRt] = i;
            
            cntRt++;
            
            pc0[0] = p1[0];
            pc0[1] = p1[1];
        }
        else {
            pc0[0] = -1;
            pc0[1] = -1;
        }

        cgrp = 0;
    }

#if LOG_CROP_FINDBASELINE
    printf( "line = [%d] -> [%d], (%lf, %lf) -> (%lf, %lf) \n", head, i - 1, ptRt[head*2+0], ptRt[head*2+1], ptRt[(i-1)*2+0], ptRt[(i-1)*2+1]);    
#endif
    head = i;

    pcpex->crpexRtAbs[cntRt] = i - 1;
    cntRt++;

    pcpex->crpexRtAbsUsed = cntRt;
    #if LOG_CROP_FINDBASELINE
    for (i=0; i < cntLf; i++) {
        id = pcpex->crpexLfAbs[i];

        printf("%d. left abs = [%d]  =  (%lf, %lf) \n", i, id, ptLf[id*2+0], ptLf[id*2+1]);    
    }
    
    for (i=0; i < cntRt; i++) {
        id = pcpex->crpexRtAbs[i];
        printf("%d. right abs = [%d]  =  (%lf, %lf) \n", i, id, ptRt[id*2+0], ptRt[id*2+1]);    
    }
    #endif
    
    contL = 0;
    contR = 0;
    
    absLsize = cntLf / 2;
    absRsize = cntRt / 2;
    
    pc0[0] = -1;
    pc0[1] = -1;
#if LOG_CROP_FINDBASELINE
    printf("absLsize : %d, absRsize: %d \n", absLsize, absRsize);
#endif

    for (i = 0; i < absLsize; i++) {
        id = pcpex->crpexLfAbs[i * 2 + 0];
        pc1[0] = ptLf[id * 2 + 0];
        pc1[1] = ptLf[id * 2 + 1];

        id = pcpex->crpexLfAbs[i * 2 + 1];
        pc2[0] = ptLf[id * 2 + 0];
        pc2[1] = ptLf[id * 2 + 1];

        distP2P = calcuDistance(pc1, pc2);

#if LOG_CROP_FINDBASELINE
        printf("[find] left scan line (%d) ==== [%.2lf] (%.2lf, %.2lf) (%.2lf, %.2lf) num: %d ==== \n", i, distP2P, pc1[0], pc1[1], pc2[0], pc2[1], (pcpex->crpexLfAbs[i * 2 + 1] - pcpex->crpexLfAbs[i * 2 + 0]));
#endif
        //if ((i == 0) || ( i == (absLsize - 1))) {
        if (i == 0) {
            minpt = CROP_LINE_NUM + 2;
        } else if (i == (absLsize - 1)) {
            minpt = CROP_LINE_NUM + 2;
        }
        else {
            minpt = CROP_LINE_NUM * linenum;
        }

        if ((distP2P > lineMin) &&
            ((pcpex->crpexLfAbs[i * 2 + 1] - pcpex->crpexLfAbs[i * 2 + 0]) > minpt)) {

            ret = cpyPGrp(pcpex->crpexLfAbs[i * 2 + 0], pcpex->crpexLfAbs[i * 2 + 1] - pcpex->crpexLfAbs[i * 2 + 0], ptLf, &cgrp, 2048 / 2);
            if (ret > 0) {
                glen = ret;
            } else {
                glen = 0;
            }

            //ret = calcuGroupLine(cgrp, pcpex->crpexLfAbsVec[i], &dist, glen);
            ret = calcuGroupLineAlign(cgrp, pcpex->crpexLfAbsVec[i], &dist, glen, GROUP_LINE_LIMIT, midx);
            if (ret > (glen / 3)) {
                pcpex->crpexLfAbsVecDist[i] = dist;
#if LOG_CROP_CALCULINE
                printf("[find] (Lf) %d. get group line alignment!! (%.2lf, %.2lf)<->(%.2lf, %.2lf) div: %.2lf ret: %d limit: %.2lf\n"
                , i, pc1[0], pc1[1], pc2[0], pc2[1], dist, ret, CROP_LINE_DIST);
#endif		
            } else {
                dist = -1;
                pcpex->crpexLfAbsVecDist[i] = -1;
#if LOG_CROP_CALCULINE
                printf("[find] (Lf) %d. get group line failed!! (%.2lf, %.2lf)<->(%.2lf, %.2lf)\n", i, pc1[0], pc1[1], pc2[0], pc2[1]);
#endif
            }

            if ((dist < 0) || (dist > (CROP_LINE_DIST))) {
                pcpex->crpexLfAbs[i * 2 + 0] = -1;
                pcpex->crpexLfAbs[i * 2 + 1] = -1;
#if LOG_CROP_CALCULINE
                printf("[find] dist: %.2lf limit: %.2lf - deny\n", dist, CROP_LINE_DIST);
#endif
            }
            else {
                pcpex->crpexLfAbsVecDist[i] = dist;
                contL++;
#if LOG_CROP_CALCULINE
                printf("[find] dist: %.2lf limit: %.2lf - pass %d \n", dist, CROP_LINE_DIST, contL);
#endif
            }

        }
        else {
        
#if LOG_CROP_FINDBASELINE
	    printf("[find] dist: %.2lf num: %d limit: %.2lf, %d - deny\n", distP2P, (pcpex->crpexLfAbs[i * 2 + 1] - pcpex->crpexLfAbs[i * 2 + 0]), lineMin, minpt);
#endif
            pcpex->crpexLfAbs[i * 2 + 0] = -1;
            pcpex->crpexLfAbs[i * 2 + 1] = -1;
        }

    }

    //pcpex->crpexLfAbsCut = contL;

    pc0[0] = -1;
    pc0[1] = -1;
    for (i = 0; i < absRsize; i++) {
        id = pcpex->crpexRtAbs[i * 2 + 0];
        pc1[0] = ptRt[id * 2 + 0];
        pc1[1] = ptRt[id * 2 + 1];

        id = pcpex->crpexRtAbs[i * 2 + 1];
        pc2[0] = ptRt[id * 2 + 0];
        pc2[1] = ptRt[id * 2 + 1];

        distP2P = calcuDistance(pc1, pc2);

#if LOG_CROP_FINDBASELINE
        printf("[find] right scan line (%d) ==== [%.2lf] (%.2lf, %.2lf) (%.2lf, %.2lf) num: %d ==== \n", i, distP2P, pc1[0], pc1[1], pc2[0], pc2[1], (pcpex->crpexRtAbs[i * 2 + 1] - pcpex->crpexRtAbs[i * 2 + 0]));
#endif

        //if ((i == 0) || ( i == (absRsize - 1))) {
        if (i == 0) {
            minpt = CROP_LINE_NUM + 2;
        } else if ( i == (absRsize - 1)) {
            minpt = CROP_LINE_NUM + 2;
        }
        else {
            minpt = CROP_LINE_NUM * linenum - 1;
        }

        if ((distP2P > lineMin) &&
            ((pcpex->crpexRtAbs[i * 2 + 1] - pcpex->crpexRtAbs[i * 2 + 0]) > minpt)) {

            ret = cpyPGrp(pcpex->crpexRtAbs[i * 2 + 0], pcpex->crpexRtAbs[i * 2 + 1] - pcpex->crpexRtAbs[i * 2 + 0], ptRt, &cgrp, 2048 / 2);
            if (ret > 0) {
                glen = ret;
            } else {
                glen = 0;
            }

            //ret = calcuGroupLine(cgrp, pcpex->crpexRtAbsVec[i], &dist, glen);
            ret = calcuGroupLineAlign(cgrp, pcpex->crpexRtAbsVec[i], &dist, glen, GROUP_LINE_LIMIT, midx);
            if (ret > (glen / 3)) {
                pcpex->crpexRtAbsVecDist[i] = dist;
#if LOG_CROP_CALCULINE
                printf("[find] (Rt) %d. get group line alignment!! (%.2lf, %.2lf)<->(%.2lf, %.2lf) div: %.2lf ret: %d limit: %.2lf \n"
#endif		
            } else {
                dist = -1;
                pcpex->crpexRtAbsVecDist[i] = -1;
#if LOG_CROP_CALCULINE
                printf("[find] (Rt) %d. get group line failed!! (%.2lf, %.2lf)<->(%.2lf, %.2lf)\n", i, pc1[0], pc1[1], pc2[0], pc2[1]);
#endif
            }

            if ((dist < 0) || (dist > (CROP_LINE_DIST))) {
                pcpex->crpexRtAbs[i * 2 + 0] = -1;
                pcpex->crpexRtAbs[i * 2 + 1] = -1;
                
#if LOG_CROP_CALCULINE
                printf("[find] dist: %.2lf limit: %.2lf - deny\n", dist, CROP_LINE_DIST);
#endif
            }
            else {
                pcpex->crpexRtAbsVecDist[i] = dist;
                contR++;
#if LOG_CROP_CALCULINE
                printf("[find] dist: %.2lf limit: %.2lf - pass %d\n", dist, CROP_LINE_DIST, contR);
#endif
            }

        }
        else {
#if LOG_CROP_FINDBASELINE
	    printf("[find] dist: %.2lf num: %d limit: %.2lf, %d - deny\n", distP2P, (pcpex->crpexRtAbs[i * 2 + 1] - pcpex->crpexRtAbs[i * 2 + 0]), lineMin, minpt);
#endif
            pcpex->crpexRtAbs[i * 2 + 0] = -1;
            pcpex->crpexRtAbs[i * 2 + 1] = -1;
        }

    }
   //pcpex->crpexRtAbsCut = contR;

#if 0//LOG_CROP_FINDBASELINE
    printf("[find] absLf cut : %d, absRt cut: %d \n", contL,
                        contR);

    for (i = 0; i < cntLf; i++) {
        id = pcpex->crpexLfAbs[i];

	if (id < 0) {
        printf("[find] %d. left abs = [%d] \n", i, id);
	} else {
        printf("[find] %d. left abs = [%d]  =  (%.2lf, %.2lf) \n", i, id, ptLf[id * 2 + 0], ptLf[id * 2 + 1]);
	}

    }

    for (i = 0; i < cntRt; i++) {
        id = pcpex->crpexRtAbs[i];

	if (id < 0) {
        printf("[find] %d. right abs = [%d] \n", i, id);
	} else {
        printf("[find] %d. right abs = [%d]  =  (%.2lf, %.2lf) \n", i, id, ptRt[id * 2 + 0], ptRt[id * 2 + 1]);
	}

    }
#endif

    if (contL > 1) {
        aln = 0;
        for (i = 0; i < absLsize; i++) {
            id = pcpex->crpexLfAbs[i * 2 + 0];
            if (id < 0) {
                continue;
            }

            pc1[0] = ptLf[id * 2 + 0];
            pc1[1] = ptLf[id * 2 + 1];

            id = pcpex->crpexLfAbs[i * 2 + 1];
            pc2[0] = ptLf[id * 2 + 0];
            pc2[1] = ptLf[id * 2 + 1];

            allpos[aln] = i;
            alldist[aln] = calcuDistance(pc1, pc2);

            //getVectorFromP(&allverTr[aln][0], pc1, pc2);
            memcpy(&allverTr[aln][0], &pcpex->crpexLfAbsVec[i][0], sizeof(CFLOAT) * 3);

            allnum[aln] = pcpex->crpexLfAbs[i * 2 + 1] - pcpex->crpexLfAbs[i * 2 + 0];
            ret = cpyPGrp(pcpex->crpexLfAbs[i * 2 + 0], allnum[aln], ptLf, &allgrp[aln], 2048 / 2);
            if (ret == allnum[aln]) {
                dist = calcuLineGroupDist(allgrp[aln], &allverTr[aln][0], allnum[aln]);

                #if LOG_CROP_FINDBASELINE
                 printf("[find] %d. alldist = [%.2lf] (%.2lf, %.2lf) (%.2lf, %.2lf) num: %d (%d) dist: %.2lf (%.2lf) (o)\n", i, alldist[aln], pc1[0], pc1[1], pc2[0], pc2[1], allnum[aln], ret, dist, pcpex->crpexLfAbsVecDist[i]);
                #endif
            } else {
                #if LOG_CROP_FINDBASELINE
                 printf("[find] %d. alldist = [%.2lf] (%.2lf, %.2lf) (%.2lf, %.2lf) num: %d (%d) dist: %.2lf (x) \n", i, alldist[aln], pc1[0], pc1[1], pc2[0], pc2[1], allnum[aln], ret, dist);
                #endif
            }

            aln += 1;
        }	

        for (id = 0; id < aln; id++) {
            if (allpos[id] < 0) continue;
            for (i = 0; i < aln; i++) {
                if (i == id) continue;
                if (allpos[i] < 0) continue;
                
                rid = allpos[i];
                sid = allpos[id];

                dist = calcuLineGroupDist(allgrp[i], &allverTr[id][0], allnum[i]);
				
                #if LOG_CROP_FINDBASELINE
                 printf("[find] Lf %d.%d. grpdist = [%.2lf] num: %d : %d, (%d, %d) (%d, %d) limit: %.2lf\n", id, i, dist, allnum[id], allnum[i],
                            pcpex->crpexLfAbs[sid*2 +0], pcpex->crpexLfAbs[sid*2 +1], pcpex->crpexLfAbs[rid*2 +0], pcpex->crpexLfAbs[rid*2 +1], CROP_LINE_DIST*MUL_DIST_TOLT);
                #endif
				
                if (((dist < CROP_LINE_DIST) || (dist < CROP_LINE_DIST*MUL_DIST_TOLT)) && (allnum[id] >= allnum[i])) {
                
                    if (dist < CROP_LINE_DIST) {
                        dist2 = 0;
                        diff = 0;
                    } else {
                        dist2 = calcuLineGroupDist(allgrp[id], &allverTr[i][0], allnum[id]);
                        diff = fabs(dist - dist2);
                    }

                    #if LOG_CROP_FINDBASELINE
                     printf("[find] dist: %.2lf dist2: %.2lf diff: %.2lf \n", dist, dist2, diff);
                    #endif

                    if (diff < 50.0) {
                        if (pcpex->crpexLfAbs[sid*2 +0] > pcpex->crpexLfAbs[rid*2 +0]) {
                            pcpex->crpexLfAbs[sid*2 +0] = pcpex->crpexLfAbs[rid*2 +0];
                        }

                        if (pcpex->crpexLfAbs[sid*2 +1] < pcpex->crpexLfAbs[rid*2 +1]) {
                            pcpex->crpexLfAbs[sid*2 +1] = pcpex->crpexLfAbs[rid*2 +1];
                        }
		
                        pcpex->crpexLfAbs[rid*2 +0] = -1;
                        pcpex->crpexLfAbs[rid*2 +1] = -1;

                        allnum[id] += allnum[i];

                        allpos[i] = -1;
                    }
                }
            }
        }

        for (id = 0; id < aln; id++) {
            if (allpos[id] < 0) continue;
            for (i = 0; i < aln; i++) {
                if (i == id) continue;
                if (allpos[id] < 0) continue;
                if (allpos[i] < 0) continue;
                
                rid = allpos[i];
                sid = allpos[id];
				
                #if LOG_CROP_FINDBASELINE
                printf("cover Lf %d.%d. num: %d : %d, (%d, %d) (%d, %d) \n", id, i, allnum[id], allnum[i],
                            pcpex->crpexLfAbs[sid*2 +0], pcpex->crpexLfAbs[sid*2 +1], pcpex->crpexLfAbs[rid*2 +0], pcpex->crpexLfAbs[rid*2 +1]);
                #endif

                if (pcpex->crpexLfAbs[sid*2 +0] < pcpex->crpexLfAbs[rid*2 +0]) {
                    if (pcpex->crpexLfAbs[sid*2 +1] > pcpex->crpexLfAbs[rid*2 +1]) {
                        pcpex->crpexLfAbs[rid*2 +0] = -1;
                        pcpex->crpexLfAbs[rid*2 +1] = -1;
                        allpos[i] = -1;
                    }
                }				
                
                if (pcpex->crpexLfAbs[sid*2 +0] < pcpex->crpexLfAbs[rid*2 +0]) {
                    if (pcpex->crpexLfAbs[sid*2 +1] > pcpex->crpexLfAbs[rid*2 +0]) {
                        if (allnum[id] > allnum[i]) {
                            pcpex->crpexLfAbs[rid*2 +0] = -1;
                            pcpex->crpexLfAbs[rid*2 +1] = -1;
                            allpos[i] = -1;
                        } else if (allnum[id] == allnum[i]) {
                            if (alldist[id] > alldist[i]) {
                                pcpex->crpexLfAbs[rid*2 +0] = -1;
                                pcpex->crpexLfAbs[rid*2 +1] = -1;
                                allpos[i] = -1;
                            } else {
                                pcpex->crpexLfAbs[sid*2 +0] = -1;
                                pcpex->crpexLfAbs[sid*2 +1] = -1;
                                allpos[id] = -1;
                            }
                        } else {
                            pcpex->crpexLfAbs[sid*2 +0] = -1;
                            pcpex->crpexLfAbs[sid*2 +1] = -1;
                            allpos[id] = -1;
                        }
                    }
                }		
            }
        }
        
        contL = 0;
        for (i = 0; i < absLsize; i++) {
            id = pcpex->crpexLfAbs[i * 2 + 0];
            if (id < 0) {
                continue;
            }

            pc1[0] = ptLf[id * 2 + 0];
            pc1[1] = ptLf[id * 2 + 1];

            id = pcpex->crpexLfAbs[i * 2 + 1];
            pc2[0] = ptLf[id * 2 + 0];
            pc2[1] = ptLf[id * 2 + 1];

            distP2P = calcuDistance(pc1, pc2);

            #if LOG_CROP_FINDBASELINE
            printf("[find] lf %d. distp2p = [%.2lf] (%.2lf, %.2lf) (%.2lf, %.2lf) num: %d\n", i, distP2P, pc1[0], pc1[1], pc2[0], pc2[1], (pcpex->crpexLfAbs[i * 2 + 1] - pcpex->crpexLfAbs[i * 2 + 0]));
            #endif

            contL += 1;
        }	
        //pcpex->crpexLfAbsCut = contL;
    }

    if (contR > 1) {
        aln = 0;
        for (i = 0; i < absRsize; i++) {
            id = pcpex->crpexRtAbs[i * 2 + 0];
            if (id < 0) {
                continue;
            }

            pc1[0] = ptRt[id * 2 + 0];
            pc1[1] = ptRt[id * 2 + 1];

            id = pcpex->crpexRtAbs[i * 2 + 1];
            pc2[0] = ptRt[id * 2 + 0];
            pc2[1] = ptRt[id * 2 + 1];

            allpos[aln] = i;
            alldist[aln] = calcuDistance(pc1, pc2);
			
            //getVectorFromP(&allverTr[aln][0], pc1, pc2);
            memcpy(&allverTr[aln][0], &pcpex->crpexRtAbsVec[i][0], sizeof(CFLOAT) * 3);

            allnum[aln] = pcpex->crpexRtAbs[i * 2 + 1] - pcpex->crpexRtAbs[i * 2 + 0];
            ret = cpyPGrp(pcpex->crpexRtAbs[i * 2 + 0], allnum[aln], ptRt, &allgrp[aln], 2048 / 2);
            if (ret == allnum[aln]) {
                dist = calcuLineGroupDist(allgrp[aln], &allverTr[aln][0], allnum[aln]);

                #if LOG_CROP_FINDBASELINE
                 printf("[find] %d. alldist = [%.2lf] (%.2lf, %.2lf) (%.2lf, %.2lf) num: %d (%d) dist: %.2lf (%.2lf) (o)\n", i, alldist[aln], pc1[0], pc1[1], pc2[0], pc2[1], allnum[aln], ret, dist, pcpex->crpexRtAbsVecDist[i]);
                #endif
            } else {
                #if LOG_CROP_FINDBASELINE
                 printf("[find] %d. alldist = [%.2lf] (%.2lf, %.2lf) (%.2lf, %.2lf) num: %d (%d) dist: %.2lf (x) \n", i, alldist[aln], pc1[0], pc1[1], pc2[0], pc2[1], allnum[aln], ret, dist);
                #endif
            }

            aln += 1;
        }	

        for (id = 0; id < aln; id++) {
            if (allpos[id] < 0) continue;
            for (i = 0; i < aln; i++) {
                if (i == id) continue;
                if (allpos[i] < 0) continue;
                
                rid = allpos[i];
                sid = allpos[id];
                
                dist = calcuLineGroupDist(allgrp[i], &allverTr[id][0], allnum[i]);
				
                #if LOG_CROP_FINDBASELINE
                printf("[find] Rt %d.%d. grpdist = [%.2lf] num: %d : %d, (%d, %d) (%d, %d) limit: %.2lf\n", id, i, dist, allnum[id], allnum[i],
                            pcpex->crpexRtAbs[sid*2 +0], pcpex->crpexRtAbs[sid*2 +1], pcpex->crpexRtAbs[rid*2 +0], pcpex->crpexRtAbs[rid*2 +1], CROP_LINE_DIST*MUL_DIST_TOLT);
                #endif

                if (((dist < CROP_LINE_DIST) || (dist < CROP_LINE_DIST*MUL_DIST_TOLT)) && (allnum[id] >= allnum[i])) {

                    if (dist < CROP_LINE_DIST) {
                        dist2 = 0;
                        diff = 0;
                    } else {
                        dist2 = calcuLineGroupDist(allgrp[id], &allverTr[i][0], allnum[id]);
                        diff = fabs(dist - dist2);
                    }
                    
                    #if LOG_CROP_FINDBASELINE
                    printf("[find] dist: %.2lf dist2: %.2lf diff: %.2lf \n", dist, dist2, diff);
                    #endif

                    if (diff < 50.0) {
                        if (pcpex->crpexRtAbs[sid*2 +0] > pcpex->crpexRtAbs[rid*2 +0]) {
                            pcpex->crpexRtAbs[sid*2 +0] = pcpex->crpexRtAbs[rid*2 +0];
                        }

                        if (pcpex->crpexRtAbs[sid*2 +1] < pcpex->crpexRtAbs[rid*2 +1]) {
                            pcpex->crpexRtAbs[sid*2 +1] = pcpex->crpexRtAbs[rid*2 +1];
                        }

                        pcpex->crpexRtAbs[rid*2 +0] = -1;
                        pcpex->crpexRtAbs[rid*2 +1] = -1;

                        allnum[id] += allnum[i];
                    
                        allpos[i] = -1;
                    }
                }
            }
        }

        for (id = 0; id < aln; id++) {
            if (allpos[id] < 0) continue;
            for (i = 0; i < aln; i++) {
                if (i == id) continue;
                if (allpos[id] < 0) continue;
                if (allpos[i] < 0) continue;
                
                rid = allpos[i];
                sid = allpos[id];
				
                #if LOG_CROP_FINDBASELINE
                printf("cover Rt %d.%d. num: %d : %d, (%d, %d) (%d, %d) \n", id, i, allnum[id], allnum[i],
                            pcpex->crpexRtAbs[sid*2 +0], pcpex->crpexRtAbs[sid*2 +1], pcpex->crpexRtAbs[rid*2 +0], pcpex->crpexRtAbs[rid*2 +1]);
                #endif

                if (pcpex->crpexRtAbs[sid*2 +0] < pcpex->crpexRtAbs[rid*2 +0]) {
                    if (pcpex->crpexRtAbs[sid*2 +1] > pcpex->crpexRtAbs[rid*2 +1]) {
                        pcpex->crpexRtAbs[rid*2 +0] = -1;
                        pcpex->crpexRtAbs[rid*2 +1] = -1;
                        allpos[i] = -1;
                    }
                }				

                if (pcpex->crpexRtAbs[sid*2 +0] < pcpex->crpexRtAbs[rid*2 +0]) {
                    if (pcpex->crpexRtAbs[sid*2 +1] > pcpex->crpexRtAbs[rid*2 +0]) {
                        if (allnum[id] > allnum[i]) {
                            pcpex->crpexRtAbs[rid*2 +0] = -1;
                            pcpex->crpexRtAbs[rid*2 +1] = -1;
                            allpos[i] = -1;
                        } else if (allnum[id] == allnum[i]) {
                            if (alldist[id] > alldist[i]) {
                                pcpex->crpexRtAbs[rid*2 +0] = -1;
                                pcpex->crpexRtAbs[rid*2 +1] = -1;
                                allpos[i] = -1;
                            } else {
                                pcpex->crpexRtAbs[sid*2 +0] = -1;
                                pcpex->crpexRtAbs[sid*2 +1] = -1;
                                allpos[id] = -1;
                            }
                        } else {
                            pcpex->crpexRtAbs[sid*2 +0] = -1;
                            pcpex->crpexRtAbs[sid*2 +1] = -1;
                            allpos[id] = -1;
                        }
                    }
                }		

                
            }
        }
        
        contR = 0;
        for (i = 0; i < absRsize; i++) {
            id = pcpex->crpexRtAbs[i * 2 + 0];
            if (id < 0) {
                continue;
            }

            pc1[0] = ptRt[id * 2 + 0];
            pc1[1] = ptRt[id * 2 + 1];

            id = pcpex->crpexRtAbs[i * 2 + 1];
            pc2[0] = ptRt[id * 2 + 0];
            pc2[1] = ptRt[id * 2 + 1];

            distP2P = calcuDistance(pc1, pc2);

            #if LOG_CROP_FINDBASELINE
            printf("[find] rt %d. distp2p = [%.2lf] (%.2lf, %.2lf) (%.2lf, %.2lf) num: %d\n", i, distP2P, pc1[0], pc1[1], pc2[0], pc2[1], (pcpex->crpexRtAbs[i * 2 + 1] - pcpex->crpexRtAbs[i * 2 + 0]));
            #endif

            contR += 1;
        }	
        //pcpex->crpexRtAbsCut = contR;
        
    }
    
    #if LOG_CROP_FINDBASELINE
    printf("calculate", "abscut Lf: %d rt: %d used: %d tmpcut lf: %d rt: %d\n"
    , pcpex->crpexLfAbsCut, pcpex->crpexRtAbsCut, pcpex->crpexLfAbsUsed, contL, contR);
    #endif

    pcpex->crpexRtAbsCut = contR;
    pcpex->crpexLfAbsCut = contL;
    
    return 0;
}

static int findUniPoints(struct aspCrop36_s *pcp36, struct aspCropExtra_s *pcpex) 
{
#define BOUNDRY_BIAS (6)
    int ret=0;
    CFLOAT Lfarr[12], Rtarr[12];
    CFLOAT LfarrVec[3][3], RtarrVec[3][3];
    int rtLinSize=0, lfLinSize=0, lfused=0, rtused=0;
    CFLOAT v1[3], v2[3], v3[3], v4[3];
    CFLOAT p1[2], p2[2], p3[2], p4[2], p5[2], p6[2], cs[2], ct[2], cu[2], cv[2];
    CFLOAT sup[2];
    CFLOAT sdn[2];
    CFLOAT slf[2];
    CFLOAT srt[2];
    int id=0, iL=0, iR=0, i=0, isrc=0, idst=0, j=0;
    CFLOAT lval=0, rval=0;
    CFLOAT upal=0, dnal=0;
    CFLOAT csUp[2], msLf[2], msRt[2], csDn[2];
    CFLOAT ttline[3], bbline[3], llline[3], rrline[3];
    CFLOAT bnup=0.0, bndn=0.0, bnlf=0.0, bnrt=0.0;
    CFLOAT distv=0.0;
    uint32_t cropflag = 0;

    bnup = (CFLOAT)((pcp36->crp36Up - BOUNDRY_BIAS) > 0 ? (pcp36->crp36Up - BOUNDRY_BIAS) : 0);
    bndn = (CFLOAT)(pcp36->crp36Dn + BOUNDRY_BIAS);
    bnlf = (CFLOAT)((pcp36->crp36Lf- BOUNDRY_BIAS) > 0 ? (pcp36->crp36Lf - BOUNDRY_BIAS) : 0);
    bnrt = (CFLOAT)(pcp36->crp36Rt + BOUNDRY_BIAS);

    memcpy(ttline, pcp36->crp36LineTop, sizeof(CFLOAT) * 3);
    memcpy(bbline, pcp36->crp36LineBotn, sizeof(CFLOAT) * 3);
    memcpy(llline, pcp36->crp36LineLeft, sizeof(CFLOAT) * 3);
    memcpy(rrline, pcp36->crp36LineRight, sizeof(CFLOAT) * 3);
    
    memcpy(msLf, pcp36->crp36P1, sizeof(CFLOAT)*2);    
    memcpy(csUp, pcp36->crp36P2, sizeof(CFLOAT)*2);    
    memcpy(msRt, pcp36->crp36P3, sizeof(CFLOAT)*2);    
    memcpy(csDn, pcp36->crp36P4, sizeof(CFLOAT)*2);        

    cropflag = pcp36->crp36Flag;
    
    lfused = pcpex->crpexLfAbsUsed / 2;
    rtused = pcpex->crpexRtAbsUsed / 2;

    lfLinSize = pcpex->crpexLfAbsCut;
    rtLinSize = pcpex->crpexRtAbsCut;
#if 0//LOG_CROP_FINDPOINTS
    printf("LfCut: %d, RtCut: %d, lfused: %d, rtused: %d, cropflag: 0x%x \n", lfLinSize, rtLinSize, lfused, rtused, cropflag);
#endif
    memset(Lfarr, 0, sizeof(CFLOAT)*12);
    memset(Rtarr, 0, sizeof(CFLOAT)*12);
    memset(LfarrVec, 0, sizeof(CFLOAT) * 9);
    memset(RtarrVec, 0, sizeof(CFLOAT) * 9);
    memset(sup, 0, sizeof(CFLOAT) * 2);
    memset(sdn, 0, sizeof(CFLOAT) * 2);
    memset(slf, 0, sizeof(CFLOAT) * 2);
    memset(srt, 0, sizeof(CFLOAT) * 2);

    for (i=0; i < 3; i++) {
        for (iL = 0; iL < lfused; iL++) {
            isrc = pcpex->crpexLfAbs[iL*2+0];
            idst = pcpex->crpexLfAbs[iL*2+1];
#if LOG_CROP_FINDPOINTS
            printf("%d-%d. Lfabs1: %d, Lfabs2: %d \n",i, iL, isrc, idst);
#endif
            if (isrc < 0) continue;
            if (idst < 0) continue; 

            Lfarr[i*4+0] = pcpex->crpexLfPots[isrc*2+0];
            Lfarr[i*4+1] = pcpex->crpexLfPots[isrc*2+1];

            Lfarr[i*4+2] = pcpex->crpexLfPots[idst*2+0];
            Lfarr[i*4+3] = pcpex->crpexLfPots[idst*2+1];

            memcpy(&LfarrVec[i][0], &pcpex->crpexLfAbsVec[iL][0], sizeof(CFLOAT) * 3);

            pcpex->crpexLfAbs[iL*2+0] = -1;
            pcpex->crpexLfAbs[iL*2+1] = -1;
            break;
        }
    }
    
    for (i=0; i < 3; i++) {
        for (iR = 0; iR < rtused; iR++) {
            isrc = pcpex->crpexRtAbs[iR*2+0];
            idst = pcpex->crpexRtAbs[iR*2+1];
#if LOG_CROP_FINDPOINTS
            printf("%d-%d. Rtabs1: %d, Rtabs2: %d \n",i , iR, isrc, idst);
#endif
            if (idst < 0) continue;                    
            if (isrc < 0) continue;
            
            Rtarr[i*4+0] = pcpex->crpexRtPots[isrc*2+0];
            Rtarr[i*4+1] = pcpex->crpexRtPots[isrc*2+1];

            Rtarr[i*4+2] = pcpex->crpexRtPots[idst*2+0];
            Rtarr[i*4+3] = pcpex->crpexRtPots[idst*2+1];

            memcpy(&RtarrVec[i][0], &pcpex->crpexRtAbsVec[iR][0], sizeof(CFLOAT) * 3);
            
            pcpex->crpexRtAbs[iR*2+0] = -1;
            pcpex->crpexRtAbs[iR*2+1] = -1;
            break;
        }
    }
    
    for (i=0; i < 3; i++) {
        for (j=0; j < 4; j++) {
#if LOG_CROP_FINDPOINTS
            printf("%d-%d Lfcut: %lf \n", i, j, Lfarr[i*4+j]);
#endif
        }
    }

    for (i=0; i < 3; i++) {
        for (j=0; j < 4; j++) {
#if LOG_CROP_FINDPOINTS
            printf("%d-%d Rtcut: %lf \n", i, j, Rtarr[i*4+j]);
#endif
        }
    }

    if ((cropflag & (0x1 << 8)) && (cropflag & (0x8 << 8))) {
        if ((lfLinSize > 2) || (rtLinSize > 2)) {
            return 3;
        }
     }

    if ((cropflag & (0x2 << 8)) && (cropflag & (0x4 << 8))) {
        if ((lfLinSize > 2) || (rtLinSize > 2)) {
            return 4;
        }
     }

    cs[0] = -1;
    cs[0] = -1;
    ct[0] = -1; 
    ct[1] = -1;
    cu[0] = -1; 
    cu[1] = -1;
    cv[0] = -1;
    cv[1] = -1;
    upal = -1;
    dnal = -1;
    rval = -1;
    lval = -1;
    
    if (lfLinSize == 1) {
        if (rtLinSize == 1) {
            memcpy(v1, LfarrVec[0], sizeof(CFLOAT) * 3);
            memcpy(v2, RtarrVec[0], sizeof(CFLOAT) * 3);

            ret = getCross(v1, ttline, cs);
            ret = getCross(ttline, v2, ct);			
            ret = getCross(bbline, v2, cu);
            ret = getCross(v1, bbline, cv);

#if LOG_CROP_FINDPOINTS
            printf("[find] 0. cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif

            if (cs[0] < cv[0]) {
                slf[0] = cs[0];
                slf[1] = cs[1];

                sup[0] = ct[0];
                sup[1] = ct[1];

                srt[0] = cu[0];
                srt[1] = cu[1];

                sdn[0] = cv[0];
                sdn[1] = cv[1];

            } else {
                slf[0] = cv[0];
                slf[1] = cv[1];

                sup[0] = cs[0];
                sup[1] = cs[1];

                srt[0] = ct[0];
                srt[1] = ct[1];

                sdn[0] = cu[0];
                sdn[1] = cu[1];
            }
        }
         else if (rtLinSize == 2) {    

            memcpy(v1, LfarrVec[0], sizeof(CFLOAT) * 3);
            memcpy(v2, RtarrVec[0], sizeof(CFLOAT) * 3);
            //memcpy(v3, LfarrVec[1], sizeof(CFLOAT) * 3);
            memcpy(v4, RtarrVec[1], sizeof(CFLOAT) * 3);
			
            ret = getCross(v2, v4, ct);
            lval = calcuVectorDistancePoint(ttline, ct);
            rval = calcuVectorDistancePoint(bbline, ct);

#if LOG_CROP_FINDPOINTS
            printf("[find] 1. cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif

            ret = getCross(v1, llline, cs);
            ret = getCross(v1, ttline, p1);
            ret = getCross(v1, bbline, p2);
            if (((cs[1] < bnup) || (cs[1] > bndn)) || ((p1[0] > bnlf) && (p1[0] < bnrt))
			|| ((p2[0] > bnlf) && (p2[0] < bnrt))  || ((cs[0] < bnlf) || (cs[0] > (bnlf+BOUNDRY_BIAS*2)))) {
				
#if LOG_CROP_FINDPOINTS
            printf("[find] 1.1 cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif

                cs[0] = -1;
                cs[1] = -1;
				
                if (lval > rval) {
                    ret = getCross(v1, bbline, cv);
                    if ((cv[0] < bnlf) || (cv[0] > bnrt)) {
						
#if LOG_CROP_FINDPOINTS
            printf("[find] 1.2 cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif

                        cv[0] = -1;
                        cv[1] = -1;
                        ret = getCross(v1, ttline, cu);
                        if ((cu[0] < bnlf) || (cu[0] > bnrt)) {

#if LOG_CROP_FINDPOINTS
            printf("[find] 1.2.1 cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif

                            cu[0] = -1;
                            cu[1] = -1;
                        }
                    }
                } else {
                    ret = getCross(v1, ttline, cu);
                    if ((cu[0] < bnlf) || (cu[0] > bnrt)) {
						
#if LOG_CROP_FINDPOINTS
            printf("[find] 1.3 cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif

                        cu[0] = -1;
                        cu[1] = -1;
                        ret = getCross(v1, bbline, cv);
                        if ((cu[0] < bnlf) || (cu[0] > bnrt)) {

#if LOG_CROP_FINDPOINTS
            printf("[find] 1.3.1 cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif

                            cu[0] = -1;
                            cu[1] = -1;
                        }
                    }

                }
            }

#if LOG_CROP_FINDPOINTS
            printf("[find] 2. cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif

            if ((cs[0] > 0) && (cs[1] > 0)) {

                upal = calcuVectorDistancePoint(ttline, cs);
                dnal = calcuVectorDistancePoint(bbline, cs);

#if LOG_CROP_FINDPOINTS
            printf("[find] 2.1 cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif

                if ((upal >= dnal) && (rval >= lval)) {
                    ret = getCross(v2, ttline, cu);
                    ret = getCross(v4, bbline, cv);

#if LOG_CROP_FINDPOINTS
            printf("[find] 2.1.1 cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif

                }
                else if ((upal <= dnal) && (rval <= lval)) {
                    ret = getCross(v4, bbline, cv);
                    ret = getCross(v2, ttline, cu);

#if LOG_CROP_FINDPOINTS
            printf("[find] 2.1.2 cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif
                }
                else {

#if LOG_CROP_FINDPOINTS
            printf("[find] 2.1.3 cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif

                    if (upal >= dnal) {
                        if (lval >= rval) {
                            if ((upal - dnal) > (lval - rval)) {
                                ret = getCross(v2, ttline, cu);
                                ret = getCross(v4, bbline, cv);

#if LOG_CROP_FINDPOINTS
            printf("[find] 2.1.3.1 cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif

                            } else {
                                ret = getCross(v2, ttline, cu);
                                ret = getCross(v4, bbline, cv);

#if LOG_CROP_FINDPOINTS
            printf("[find] 2.1.3.2 cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif

                            }			
                        } else {
                            if ((upal - dnal) > (rval - lval)) {
                                ret = getCross(v2, ttline, cu);
                                ret = getCross(v4, bbline, cv);

#if LOG_CROP_FINDPOINTS
            printf("[find] 2.1.3.3 cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif
                            } else {
                                ret = getCross(v2, ttline, cu);
                                ret = getCross(v4, bbline, cv);

#if LOG_CROP_FINDPOINTS
            printf("[find] 2.1.3.4 cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif
                            }			
                        }
                    }
                    else {
                        if (lval >= rval) {
                            if ((dnal - upal) > (lval - rval)) {
                                ret = getCross(v4, bbline, cv);
                                ret = getCross(v2, ttline, cu);

#if LOG_CROP_FINDPOINTS
            printf("[find] 2.1.3.1 cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif
                            } else {
                                ret = getCross(v2, ttline, cu);
                                ret = getCross(v4, bbline, cv);

#if LOG_CROP_FINDPOINTS
            printf("[find] 2.1.3.1 cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif

                            }			
                        } else {
                            if ((dnal - upal) > (rval - lval)) {
                                ret = getCross(v4, bbline, cv);
                                ret = getCross(v2, ttline, cu);

#if LOG_CROP_FINDPOINTS
            printf("[find] 2.1.3.1 cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif

                            } else {
                                ret = getCross(v2, ttline, cu);
                                ret = getCross(v4, bbline, cv);

#if LOG_CROP_FINDPOINTS
            printf("[find] 2.1.3.1 cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif

                            }			
                        }
                    }
                }
            }
            else if ((cv[0] > 0) && (cv[1] > 0)) {

#if LOG_CROP_FINDPOINTS
            printf("[find] 2.2 cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif

                if (lval > rval) {
                    ret = getCross(v2, ttline, cu);
                    ret = getCross(v1, ttline, cs);
                    if ((cs[0] < bnlf) || (cs[0] > bnrt)) {
                        cs[1] = rval;
                        cs[0] = bnlf + BOUNDRY_BIAS;		
                    }
                } else {
                    if ((ct[0] > bnrt) || (ct[0] < (bnrt-(BOUNDRY_BIAS*2)))) {
                        ret = getCross(v4, bbline, p1);
                        distv = calcuDistance(cv, p1);
                        if (distv < 100.0) {
                            ret = getCross(v4, rrline, ct);
				ret = getCross(v1, bbline, cu);		

                            lval = calcuVectorDistancePoint(ttline, ct);
                            rval = calcuVectorDistancePoint(bbline, ct);

                            cs[1] = rval;
                            cs[0] = bnlf + BOUNDRY_BIAS;
                        } else {
                            ret = getCross(v2, rrline, ct);
				ret = getCross(v1, bbline, cv);

                            lval = calcuVectorDistancePoint(ttline, ct);
                            rval = calcuVectorDistancePoint(bbline, ct);

                            cs[1] = rval;
                            cs[0] = bnlf + BOUNDRY_BIAS;
                        }
                    }
                    else {
                        ret = getCross(v2, ttline, cu);
                        ret = getCross(v4, bbline, cv);
                        cs[1] = rval;
                        cs[0] = bnlf + BOUNDRY_BIAS;	
                    }
                }
            }
            else if ((cu[0] > 0) && (cu[1] > 0)) {

#if LOG_CROP_FINDPOINTS
            printf("[find] 2.3 cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif

                if (lval > rval) {
                    if ((ct[0] > bnrt) || (ct[0] < (bnrt-(BOUNDRY_BIAS*2)))) {
                        ret = getCross(v2, ttline, p1);
                        distv = calcuDistance(cu, p1);
                        if (distv < 100.0) {
                            ret = getCross(v2, rrline, ct);
				ret = getCross(v1, bbline, cv);		

                            lval = calcuVectorDistancePoint(ttline, ct);
                            rval = calcuVectorDistancePoint(bbline, ct);

                            cs[1] = rval;
                            cs[0] = bnlf + BOUNDRY_BIAS;
                        } else {
                            ret = getCross(v4, rrline, ct);
				ret = getCross(v1, bbline, cv);

                            lval = calcuVectorDistancePoint(ttline, ct);
                            rval = calcuVectorDistancePoint(bbline, ct);

                            cs[1] = rval;
                            cs[0] = bnlf + BOUNDRY_BIAS;
                        }
                    }
                    else {
                        ret = getCross(v4, bbline, cv);
                        cs[1] = rval;
                        cs[0] = bnlf + BOUNDRY_BIAS;	
                    }
                }
                else {
                    ret = getCross(v4, bbline, cv);
                    ret = getCross(v1, bbline, cs);
                    if ((cs[0] < bnlf) || (cs[0] > bnrt)) {
                        cs[1] = rval;
                        cs[0] = bnlf + BOUNDRY_BIAS;	
                    }
                }
            }
            else {

#if LOG_CROP_FINDPOINTS
            printf("[find] 2.4 cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif

                ret = getCross(v2, ttline, cu);
                ret = getCross(v4, bbline, cv);
                cs[1] = rval;
                cs[0] = bnlf + BOUNDRY_BIAS;	
				
            }


            sup[0] = cu[0];
            sup[1] = cu[1];

            slf[0] = cs[0];
            slf[1] = cs[1];

            srt[0] = ct[0];
            srt[1] = ct[1];

            sdn[0] = cv[0];
            sdn[1] = cv[1];

#if 0
            id = 0;
            p1[0] = Rtarr[id * 2 + 0];
            p1[1] = Rtarr[id * 2 + 1];

            id = 1;
            p2[0] = Rtarr[id * 2 + 0];
            p2[1] = Rtarr[id * 2 + 1];

            id = 2;
            p3[0] = Rtarr[id * 2 + 0];
            p3[1] = Rtarr[id * 2 + 1];

            id = 3;
            p4[0] = Rtarr[id * 2 + 0];
            p4[1] = Rtarr[id * 2 + 1];

            ret = getVectorFromP(v1, p1, p2);
            ret = getVectorFromP(v2, p3, p4);
            ret = getCross(v1, v2, cs);

            id = 0;
            upal = Rtarr[id * 2 + 0];

            id = 3;
            dnal = Rtarr[id * 2 + 0];

            if (upal > dnal) {
                id = 0;
                sup[0] = Rtarr[id * 2 + 0];
                sup[1] = Rtarr[id * 2 + 1];

                slf[0] = Lfarr[id * 2 + 0];
                slf[1] = Lfarr[id * 2 + 1];

                srt[0] = cs[0];
                srt[1] = cs[1];

                id = 1;
                sdn[0] = Lfarr[id * 2 + 0];
                sdn[1] = Lfarr[id * 2 + 1];
            } else {
                id = 0;
                sup[0] = Lfarr[id * 2 + 0];
                sup[1] = Lfarr[id * 2 + 1];

                id = 1;
                slf[0] = Lfarr[id * 2 + 0];
                slf[1] = Lfarr[id * 2 + 1];

                srt[0] = cs[0];
                srt[1] = cs[1];

                id = 3;
                sdn[0] = Rtarr[id * 2 + 0];
                sdn[1] = Rtarr[id * 2 + 1];
            }
#endif
        }
         else if ((rtLinSize == 3) && ((cropflag & (0x4 << 4)) || (cropflag & (0x3 << 8)))) {
             id = 0;
             p1[0] = Rtarr[id*2+0];
             p1[1] = Rtarr[id*2+1];
    
             id = 1;
             p2[0] = Rtarr[id*2+0];
             p2[1] = Rtarr[id*2+1];
    
             id = 2;
             p3[0] = Rtarr[id*2+0];
             p3[1] = Rtarr[id*2+1];
    
             id = 3;
             p4[0] = Rtarr[id*2+0];
             p4[1] = Rtarr[id*2+1];

             id = 4;
             p5[0] = Rtarr[id*2+0];
             p5[1] = Rtarr[id*2+1];
    
             id = 5;
             p6[0] = Rtarr[id*2+0];
             p6[1] = Rtarr[id*2+1];
    
             ret = getVectorFromP(v1, p1, p2);
             ret = getVectorFromP(v2, p3, p4);
             ret = getVectorFromP(v3, p5, p6);
             ret = getCross(v1, v2, cs);
             ret = getCross(v2, v3, ct);

             printf("[LF %d-RT %d]  =  cs:(%lf, %lf) ct:(%lf, %lf)\n", lfLinSize, rtLinSize, cs[0], cs[1], ct[0], ct[1]);

             id = 0;
             upal = Rtarr[id*2+0];
    
             id = 5;
             dnal = Rtarr[id*2+0];
    
             if (upal > dnal) {
                 id = 0;
                 sup[0] = Lfarr[id*2+0];
                 sup[1] = Lfarr[id*2+1];
    
                 id = 1;
                 slf[0] = Lfarr[id*2+0];
                 slf[1] = Lfarr[id*2+1];
                  
                 srt[0] = cs[0];
                 srt[1] = cs[1];
                 
                 sdn[0] = ct[0];
                 sdn[1] = ct[1];
             } else {
                 id = 0;
                 sup[0] = cs[0];
                 sup[1] = cs[1];
    
                 slf[0] = Lfarr[id*2+0];
                 slf[1] = Lfarr[id*2+1];
    
                 srt[0] = ct[0];
                 srt[1] = ct[1];
    
                 id = 1;
                 sdn[0] = Lfarr[id*2+0];
                 sdn[1] = Lfarr[id*2+1];

             }
        }
        else {
#if LOG_CROP_FINDPOINTS
            printf("Warnning!!! findline result not match!!!LfSize:%d, RtSize:%d \n", lfLinSize, rtLinSize);
#endif
            if ((csUp[0]) && (msLf[0]) && (msRt[0]) && (csDn[0])) {
                sup[0] = csUp[0];
                sup[1] = csUp[1];
    
                slf[0] = msLf[0];
                slf[1] = msLf[1];
    
                srt[0] = msRt[0];
                srt[1] = msRt[1];
    
                sdn[0] = csDn[0];
                sdn[1] = csDn[1];
            }
        }
    }
    else if (lfLinSize == 2) {
        if (rtLinSize == 1) {

            memcpy(v1, LfarrVec[0], sizeof(CFLOAT) * 3);
            memcpy(v2, RtarrVec[0], sizeof(CFLOAT) * 3);
            memcpy(v3, LfarrVec[1], sizeof(CFLOAT) * 3);
            //memcpy(v4, RtarrVec[1], sizeof(CFLOAT) * 3);
			
            ret = getCross(v1, v3, cs);
            upal = calcuVectorDistancePoint(ttline, cs);
            dnal = calcuVectorDistancePoint(bbline, cs);

            //lval = calcuVectorDistancePoint(ttline, ct);
            //rval = calcuVectorDistancePoint(bbline, ct);

#if LOG_CROP_FINDPOINTS
            printf("[find] L1. cs(%.2lf, %.2lf) ct(%.2lf, %.2lf) cu(%.2lf, %.2lf) cv(%.2lf, %.2lf) d1(%.2lf, %.2lf) d2(%.2lf, %.2lf)\n", cs[0], cs[1], ct[0], ct[1], cu[0], cu[1], cv[0], cv[1], upal, dnal, lval, rval);
#endif
            ret = getCross(v2, rrline, ct);
            ret = getCross(v2, ttline, p1);
            ret = getCross(v2, bbline, p2);
            if (((ct[1] < bnup) || (ct[1] > bndn)) || ((p1[0] > bnlf) && (p1[0] < bnrt))
			|| ((p2[0] > bnlf) && (p2[0] < bnrt)) || ((ct[0] > bnrt) || (ct[0] > (bnrt-BOUNDRY_BIAS*2)))) {

                ct[0] = -1;
                ct[1] = -1;
                if (upal > dnal) {
                    ret = getCross(v2, bbline, cv);
                    if ((cv[0] < bnlf) || (cv[0] > bnrt)) {
                        cv[0] = -1;
                        cv[1] = -1;
                        ret = getCross(v2, ttline, cu);
                        if ((cu[0] < bnlf) || (cu[0] > bnrt)) {
                            cu[0] = -1;
                            cu[1] = -1;
                        }
                    }
                } else {
                    ret = getCross(v2, ttline, cu);
                    if ((cu[0] < bnlf) || (cu[0] > bnrt)) {
                        cu[0] = -1;
                        cu[1] = -1;
                        ret = getCross(v2, bbline, cv);
                        if ((cv[0] < bnlf) || (cv[0] > bnrt)) {
                            cv[0] = -1;
                            cv[1] = -1;
                        }
                    }
                }
            }

            if ((ct[0] > 0) && (ct[1] > 0)) {
                lval = calcuVectorDistancePoint(ttline, ct);
                rval = calcuVectorDistancePoint(bbline, ct);

                if ((upal >= dnal) && (rval >= lval)) {
                    ret = getCross(v1, ttline, cu);
                    ret = getCross(v3, bbline, cv);
                }
                else if ((upal <= dnal) && (rval <= lval)) {
                    ret = getCross(v3, bbline, cv);
                    ret = getCross(v1, ttline, cu);
                }
                else {
                    if (upal >= dnal) {
                        if (lval >= rval) {
                            if ((upal - dnal) > (lval - rval)) {
                                ret = getCross(v1, ttline, cu);
                                ret = getCross(v3, bbline, cv);
                            } else {
                                ret = getCross(v1, ttline, cu);
                                ret = getCross(v3, bbline, cv);
                            }			
                        } else {
                            if ((upal - dnal) > (rval - lval)) {
                                ret = getCross(v1, ttline, cu);
                                ret = getCross(v3, bbline, cv);
                            } else {
                                ret = getCross(v1, ttline, cu);
                                ret = getCross(v3, bbline, cv);
                            }			
                        }
                    } else {
                        if (lval >= rval) {
                            if ((dnal - upal) > (lval - rval)) {
                                ret = getCross(v3, bbline, cv);
                                ret = getCross(v1, ttline, cu);
                            } else {
                                ret = getCross(v1, ttline, cu);
                                ret = getCross(v3, bbline, cv);
                            }			
                        } else {
                            if ((dnal - upal) > (rval - lval)) {
                                ret = getCross(v3, bbline, cv);
                                ret = getCross(v1, ttline, cu);
                            } else {
                                ret = getCross(v1, ttline, cu);
                                ret = getCross(v3, bbline, cv);
                            }			
                        }
                    }
                }
            }
            else if ((cv[0] > 0) && (cv[1] > 0)) {
                if (upal > dnal) {
                    ret = getCross(v1, ttline, cu);
                    ret = getCross(v2, ttline, ct);
                    if ((ct[0] < bnlf) || (ct[0] > bnrt)) {
                        ct[1] = dnal;
                        ct[0] = bnrt + BOUNDRY_BIAS;		
                    }
                } else {
                    if ((cs[0] < bnlf) || (cs[0] > (bnlf+(BOUNDRY_BIAS*2)))) {
                        ret = getCross(v3, bbline, p1);
                        distv = calcuDistance(cv, p1);
                        if (distv < 100.0) {
                            ret = getCross(v3, llline, cs);
				ret = getCross(v2, bbline, cu);		

                            upal = calcuVectorDistancePoint(ttline, cs);
                            dnal = calcuVectorDistancePoint(bbline, cs);

                            ct[1] = dnal;
                            ct[0] = bnrt + BOUNDRY_BIAS;
                        } else {
                            ret = getCross(v1, llline, cs);
				ret = getCross(v2, bbline, cv);

                            upal = calcuVectorDistancePoint(ttline, cs);
                            dnal = calcuVectorDistancePoint(bbline, cs);

                            ct[1] = dnal;
                            ct[0] = bnrt + BOUNDRY_BIAS;                        }
                    }
                    else {
                        ret = getCross(v1, ttline, cu);
                        ret = getCross(v3, bbline, cv);

                        ct[1] = dnal;
                        ct[0] = bnrt + BOUNDRY_BIAS;	
                    }
                }
            }
            else if ((cu[0] > 0) && (cu[1] > 0)) {
                if (upal > dnal) {
                    if ((cs[0] < bnlf) || (cs[0] > (bnlf+(BOUNDRY_BIAS*2)))) {
                        ret = getCross(v1, ttline, p1);
                        distv = calcuDistance(cu, p1);
                        if (distv < 100.0) {
                            ret = getCross(v1, llline, cs);
				ret = getCross(v2, bbline, cv);		

                            upal = calcuVectorDistancePoint(ttline, cs);
                            dnal = calcuVectorDistancePoint(bbline, cs);

                            ct[1] = dnal;
                            ct[0] = bnrt + BOUNDRY_BIAS;
                        } else {
                            ret = getCross(v3, llline, cs);
				ret = getCross(v2, bbline, cv);

                            upal = calcuVectorDistancePoint(ttline, cs);
                            dnal = calcuVectorDistancePoint(bbline, cs);

                            ct[1] = dnal;
                            ct[0] = bnrt + BOUNDRY_BIAS;
                        }
                    }
                    else {
                        ret = getCross(v1, ttline, cu);
                        ret = getCross(v3, bbline, cv);

                        ct[1] = dnal;
                        ct[0] = bnrt + BOUNDRY_BIAS;
                    }
                }
                else {
                    ret = getCross(v3, bbline, cv);
                    ret = getCross(v2, bbline, ct);
                    if ((ct[0] < bnlf) || (ct[0] > bnrt)) {
                        ct[1] = dnal;
                        ct[0] = bnrt + BOUNDRY_BIAS;
                    }
                }
            }
            else {
                ret = getCross(v1, ttline, cu);
                ret = getCross(v3, bbline, cv);

                ct[1] = dnal;
                ct[0] = bnrt + BOUNDRY_BIAS;
            }


            sup[0] = cu[0];
            sup[1] = cu[1];

            slf[0] = cs[0];
            slf[1] = cs[1];

            srt[0] = ct[0];
            srt[1] = ct[1];

            sdn[0] = cv[0];
            sdn[1] = cv[1];

#if 0
            id = 0;
            p1[0] = Lfarr[id * 2 + 0];
            p1[1] = Lfarr[id * 2 + 1];

            id = 1;
            p2[0] = Lfarr[id * 2 + 0];
            p2[1] = Lfarr[id * 2 + 1];

            id = 2;
            p3[0] = Lfarr[id * 2 + 0];
            p3[1] = Lfarr[id * 2 + 1];

            id = 3;
            p4[0] = Lfarr[id * 2 + 0];
            p4[1] = Lfarr[id * 2 + 1];

            ret = getVectorFromP(v1, p1, p2);
            ret = getVectorFromP(v2, p3, p4);
            ret = getCross(v1, v2, cs);

            id = 0;
            upal = Lfarr[id * 2 + 0];

            id = 3;
            dnal = Lfarr[id * 2 + 0];

            if (upal > dnal) {
                id = 0;
                sup[0] = Rtarr[id * 2 + 0];
                sup[1] = Rtarr[id * 2 + 1];

                id = 1;
                srt[0] = Rtarr[id * 2 + 0];
                srt[1] = Rtarr[id * 2 + 1];

                slf[0] = cs[0];
                slf[1] = cs[1];

                id = 3;
                sdn[0] = Lfarr[id * 2 + 0];
                sdn[1] = Lfarr[id * 2 + 1];
            } else {
                id = 0;
                sup[0] = Lfarr[id * 2 + 0];
                sup[1] = Lfarr[id * 2 + 1];

                srt[0] = Rtarr[id * 2 + 0];
                srt[1] = Rtarr[id * 2 + 1];

                slf[0] = cs[0];
                slf[1] = cs[1];

                id = 1;
                sdn[0] = Rtarr[id * 2 + 0];
                sdn[1] = Rtarr[id * 2 + 1];
            }
#endif
    
        }
         else if (rtLinSize == 2) {
            memcpy(v1, LfarrVec[0], sizeof(CFLOAT) * 3);
            memcpy(v2, RtarrVec[0], sizeof(CFLOAT) * 3);
            memcpy(v3, LfarrVec[1], sizeof(CFLOAT) * 3);
            memcpy(v4, RtarrVec[1], sizeof(CFLOAT) * 3);

            ret = getCross(v1, v3, cs);
            ret = getCross(v2, v4, ct);

            upal = calcuVectorDistancePoint(ttline, cs);
            dnal = calcuVectorDistancePoint(bbline, cs);

            lval = calcuVectorDistancePoint(ttline, ct);
            rval = calcuVectorDistancePoint(bbline, ct);

            if ((upal >= dnal) && (rval >= lval)) {
                ret = getCross(v1, ttline, cu);
                ret = getCross(v4, bbline, cv);
            }
            else if ((upal <= dnal) && (rval <= lval)) {
                ret = getCross(v3, bbline, cv);
                ret = getCross(v2, ttline, cu);
            }
            else {
                if (upal >= dnal) {
                    if (lval >= rval) {
                        if ((upal - dnal) > (lval - rval)) {
                            ret = getCross(v1, ttline, cu);
                            ret = getCross(v4, bbline, cv);
                        } else {
                            ret = getCross(v2, ttline, cu);
                            ret = getCross(v3, bbline, cv);
                        }			
                    } else {
                        if ((upal - dnal) > (rval - lval)) {
                            ret = getCross(v1, ttline, cu);
                            ret = getCross(v4, bbline, cv);
                        } else {
                            ret = getCross(v2, ttline, cu);
                            ret = getCross(v3, bbline, cv);
                        }			
                    }
                } else {
                    if (lval >= rval) {
                        if ((dnal - upal) > (lval - rval)) {
                            ret = getCross(v3, bbline, cv);
                            ret = getCross(v2, ttline, cu);
                        } else {
                            ret = getCross(v1, ttline, cu);
                            ret = getCross(v4, bbline, cv);
                        }			
                    } else {
                        if ((dnal - upal) > (rval - lval)) {
                            ret = getCross(v3, bbline, cv);
                            ret = getCross(v2, ttline, cu);
                        } else {
                            ret = getCross(v1, ttline, cu);
                            ret = getCross(v4, bbline, cv);
                        }			
                    }
                }
            }

            sup[0] = cu[0];
            sup[1] = cu[1];

            slf[0] = cs[0];
            slf[1] = cs[1];

            srt[0] = ct[0];
            srt[1] = ct[1];

            sdn[0] = cv[0];
            sdn[1] = cv[1];
#if 0
            id = 0;
            upal = Lfarr[id * 2 + 1];
            dnal = Rtarr[id * 2 + 1];

            if (upal > dnal) {
                id = 0;
                sup[0] = Rtarr[id * 2 + 0];
                sup[1] = Rtarr[id * 2 + 1];
            } else {
                id = 0;
                sup[0] = Lfarr[id * 2 + 0];
                sup[1] = Lfarr[id * 2 + 1];
            }

            id = 0;
            p1[0] = Lfarr[id * 2 + 0];
            p1[1] = Lfarr[id * 2 + 1];

            id = 1;
            p2[0] = Lfarr[id * 2 + 0];
            p2[1] = Lfarr[id * 2 + 1];

            id = 2;
            p3[0] = Lfarr[id * 2 + 0];
            p3[1] = Lfarr[id * 2 + 1];

            id = 3;
            p4[0] = Lfarr[id * 2 + 0];
            p4[1] = Lfarr[id * 2 + 1];

            ret = getVectorFromP(v1, p1, p2);
            ret = getVectorFromP(v2, p3, p4);
            ret = getCross(v1, v2, cs);

            slf[0] = cs[0];
            slf[1] = cs[1];

            id = 0;
            p1[0] = Rtarr[id * 2 + 0];
            p1[1] = Rtarr[id * 2 + 1];

            id = 1;
            p2[0] = Rtarr[id * 2 + 0];
            p2[1] = Rtarr[id * 2 + 1];

            id = 2;
            p3[0] = Rtarr[id * 2 + 0];
            p3[1] = Rtarr[id * 2 + 1];

            id = 3;
            p4[0] = Rtarr[id * 2 + 0];
            p4[1] = Rtarr[id * 2 + 1];

            ret = getVectorFromP(v1, p1, p2);
            ret = getVectorFromP(v2, p3, p4);
            ret = getCross(v1, v2, cs);

            srt[0] = cs[0];
            srt[1] = cs[1];

            if (upal > dnal) {
                id = 3;
                sdn[0] = Lfarr[id * 2 + 0];
                sdn[1] = Lfarr[id * 2 + 1];
            } else {
                id = 3;
                sdn[0] = Rtarr[id * 2 + 0];
                sdn[1] = Rtarr[id * 2 + 1];
            }
#endif
        }
        else {
#if LOG_CROP_FINDPOINTS
            printf("Warnning!!! findline result not match!!!LfSize:%d, RtSize:%d \n", lfLinSize, rtLinSize);
#endif
            if ((csUp[0]) && (msLf[0]) && (msRt[0]) && (csDn[0])){
                sup[0] = csUp[0];
                sup[1] = csUp[1];
    
                slf[0] = msLf[0];
                slf[1] = msLf[1];
    
                srt[0] = msRt[0];
                srt[1] = msRt[1];
    
                sdn[0] = csDn[0];
                sdn[1] = csDn[1];
            }
        }
    }
    else if (lfLinSize == 3) {
        if ((rtLinSize == 1) && ((cropflag & (0x8 << 4)) || (cropflag & (0xc << 8)))) {
             id = 0;
             p1[0] = Lfarr[id*2+0];
             p1[1] = Lfarr[id*2+1];
    
             id = 1;
             p2[0] = Lfarr[id*2+0];
             p2[1] = Lfarr[id*2+1];
    
             id = 2;
             p3[0] = Lfarr[id*2+0];
             p3[1] = Lfarr[id*2+1];
    
             id = 3;
             p4[0] = Lfarr[id*2+0];
             p4[1] = Lfarr[id*2+1];

             id = 4;
             p5[0] = Lfarr[id*2+0];
             p5[1] = Lfarr[id*2+1];
    
             id = 5;
             p6[0] = Lfarr[id*2+0];
             p6[1] = Lfarr[id*2+1];
    
             ret = getVectorFromP(v1, p1, p2);
             ret = getVectorFromP(v2, p3, p4);
             ret = getVectorFromP(v3, p5, p6);
             ret = getCross(v1, v2, cs);
             ret = getCross(v2, v3, ct);

             printf("[LF %d-RT %d]  =  cs:(%lf, %lf) ct:(%lf, %lf)\n", lfLinSize, rtLinSize, cs[0], cs[1], ct[0], ct[1]);
        
             id = 0;
             upal = Lfarr[id*2+0];
    
             id = 5;
             dnal = Lfarr[id*2+0];
    
             if (upal > dnal) {
                 id = 0;
                 sup[0] = cs[0];
                 sup[1] = cs[1];
                 
                 srt[0] = Rtarr[id*2+0];
                 srt[1] = Rtarr[id*2+1];
                 
                 slf[0] = ct[0];
                 slf[1] = ct[1];
    
                 id = 1;
                 sdn[0] = Rtarr[id*2+0];
                 sdn[1] = Rtarr[id*2+1];
             } else {
                 id = 0;
                 sup[0] = Rtarr[id*2+0];
                 sup[1] = Rtarr[id*2+1];
    
                 id = 1;
                 srt[0] = Rtarr[id*2+0];
                 srt[1] = Rtarr[id*2+1];
    
                 slf[0] = cs[0];
                 slf[1] = cs[1];
                 
                 sdn[0] = ct[0];
                 sdn[1] = ct[1];
             }
        }
        else {
#if LOG_CROP_FINDPOINTS
            printf("Warnning!!! findline result not match!!!LfSize:%d, RtSize:%d \n", lfLinSize, rtLinSize);
#endif
            if ((csUp[0]) && (msLf[0]) && (msRt[0]) && (csDn[0])){
                sup[0] = csUp[0];
                sup[1] = csUp[1];
    
                slf[0] = msLf[0];
                slf[1] = msLf[1];
    
                srt[0] = msRt[0];
                srt[1] = msRt[1];
    
                sdn[0] = csDn[0];
                sdn[1] = csDn[1];
            }
        }
    }
    else {
#if LOG_CROP_FINDPOINTS
        printf("Warnning!!! findline result not match!!!LfSize:%d, RtSize:%d \n", lfLinSize, rtLinSize);
#endif
        if ((csUp[0]) && (msLf[0]) && (msRt[0]) && (csDn[0])) {
            sup[0] = csUp[0];
            sup[1] = csUp[1];
    
            slf[0] = msLf[0];
            slf[1] = msLf[1];
    
            srt[0] = msRt[0];
            srt[1] = msRt[1];
    
            sdn[0] = csDn[0];
            sdn[1] = csDn[1];
        }
    }

    if ((sup[0]) && (sdn[0]) && (slf[0]) && (srt[0])) {
#if LOG_CROP_FINDPOINTS
        printf("sup = (%lf, %lf), sdn = (%lf, %lf) \n", sup[0], sup[1], sdn[0], sdn[1]);
        printf("slf = (%lf, %lf), srt = (%lf, %lf) \n", slf[0], slf[1], srt[0], srt[1]);    
#endif
    } else {
        printf("Warnning!!!  sup || sdn || slf || srt == null!!! \n");
    }

    memcpy(pcpex->crpexMostLt, slf, sizeof(CFLOAT)*2);    
    memcpy(pcpex->crpexCrosUp, sup, sizeof(CFLOAT)*2);    
    memcpy(pcpex->crpexMostRt, srt, sizeof(CFLOAT)*2);    
    memcpy(pcpex->crpexCrosDn, sdn, sizeof(CFLOAT)*2);        
    
    return 0;
}

static int calcuLine(struct aspCropExtra_s *pcpex, int midx) 
{
#define CROP_MIN_LINE  3
    int i=0, j=0, ret=0;
    int lfStrUp=-1, lfEndUp=-1, rtStrUp=-1, rtEndUp=-1;
    int lfStrDn=-1, lfEndDn=-1, rtStrDn=-1, rtEndDn=-1;
    int luc=0, ldc=0, ruc=0, rdc=0;
    int szlu=0, szld=0, szru=0, szrd=0;
    int gpCnt=0, tot=0;
    CFLOAT up[2], dn[2], lf[2], rt[2];
    CFLOAT *ptLf, *ptRt;
    CFLOAT *pGrp;
    CFLOAT vecLU[3];
    CFLOAT vecLD[3];
    CFLOAT vecRU[3];
    CFLOAT vecRD[3];
    CFLOAT divLU;
    CFLOAT divLD;
    CFLOAT divRU;
    CFLOAT divRD;

    memcpy(up, pcpex->crpexCrosUp, sizeof(CFLOAT)*2);
    memcpy(dn, pcpex->crpexCrosDn, sizeof(CFLOAT)*2);
    memcpy(lf, pcpex->crpexMostLt, sizeof(CFLOAT)*2);
    memcpy(rt, pcpex->crpexMostRt, sizeof(CFLOAT)*2);
    
    ptLf = pcpex->crpexLfPots;
    ptRt = pcpex->crpexRtPots;
    
    tot = pcpex->crpexSize / 2;
#if LOG_CROP_CALCULINE
    printf("msLf (%lf, %lf) rt (%lf, %lf) \n", lf[0], lf[1], rt[0], rt[1]);
    printf("up (%lf, %lf) dn (%lf, %lf) \n", up[0], up[1], dn[0], dn[1]);
#endif
    for (i = 0; i < tot; i++) {
        //printf("%d. Left (%lf, %lf) Right (%lf, %lf)\n", i, ptLf[i*2+0], ptLf[i*2+1], ptRt[i*2+0], ptRt[i*2+1]);
        #if 0//LOG_CROP_CALCULINE
        printf(" %d. Left (%.2lf, %.2lf) Right (%.2lf, %.2lf)\n", i, ptLf[i*2+0], ptLf[i*2+1], ptRt[i*2+0], ptRt[i*2+1]);
        #endif
        
        if ((ptLf[i*2+0] > (lf[0] - 200.0)) && (ptLf[i*2+0] < (up[0] + 200.0)) && (ptLf[i*2+1] <= lf[1]) && (ptLf[i*2+1] >= up[1])) {
            if (lfStrUp < 0) {
                lfStrUp = i;
            } else {
                lfEndUp = i;
            }
            //printf("LU%d\n", luc);
            luc++;
        }

        if ((ptLf[i*2+0] > (lf[0] - 200.0)) && (ptLf[i*2+0] < (dn[0] + 200.0)) && (ptLf[i*2+1] >= lf[1]) && (ptLf[i*2+1] <= dn[1])) {
            if (lfStrDn< 0) {
                lfStrDn= i;
            } else {
                lfEndDn= i;
            }
            //printf("LD%d\n", ldc);
            ldc++;
        }

        if ((ptRt[i*2+0] < (rt[0] + 200.0)) && (ptRt[i*2+0] > (up[0] - 200.0)) && (ptRt[i*2+1] <= rt[1]) && (ptRt[i*2+1] >= up[1])) {
            if (rtStrUp< 0) {
                rtStrUp = i;
            } else {
                rtEndUp = i;
            }
            //printf("RU%d\n", ruc);
            ruc++;
        }

        if ((ptRt[i*2+0] < (rt[0] + 200.0)) && (ptRt[i*2+0] > (dn[0] - 200.0)) && (ptRt[i*2+1] >= rt[1]) && (ptRt[i*2+1] <= dn[1])) {
            if (rtStrDn< 0) {
                rtStrDn= i;
            } else {
                rtEndDn= i;
            }
            //printf("RD%d\n", rdc);
            rdc++;
        }

    }

    if ((lfStrUp >= 0) && (lfEndUp >= 0)) {
        szlu = lfEndUp - lfStrUp + 1;
    }
    if ((lfEndDn >= 0) && (lfStrDn >= 0)) {        
        szld = lfEndDn - lfStrDn + 1;
    }
    if ((rtEndUp >= 0) && (rtStrUp >= 0)) {
        szru = rtEndUp - rtStrUp + 1;
    }
    if ((rtEndDn >= 0) && (rtStrDn >= 0)) {
        szrd = rtEndDn - rtStrDn + 1;
    }
#if LOG_CROP_CALCULINE
    printf("(size) szlu = %d, szld = %d, szru = %d, szrd = %d\n", szlu, szld, szru, szrd);    
#endif
    memset(pcpex->crpexLinLU, 0, sizeof(CFLOAT)*3);
    memset(pcpex->crpexLinLD, 0, sizeof(CFLOAT)*3);
    memset(pcpex->crpexLinRU, 0, sizeof(CFLOAT)*3);
    memset(pcpex->crpexLinRD, 0, sizeof(CFLOAT)*3);

    pcpex->crpexLinLUDiv = 9999.0;
    pcpex->crpexLinLDDiv = 9999.0;
    pcpex->crpexLinRUDiv = 9999.0;
    pcpex->crpexLinRDDiv = 9999.0;

    pcpex->crpexGrpLUpt = 0;
    pcpex->crpexGrpLDpt = 0;
    pcpex->crpexGrpRUpt = 0;
    pcpex->crpexGrpRDpt = 0;

    pcpex->crpexGrpLUStr = -1;
    pcpex->crpexGrpLDStr = -1;
    pcpex->crpexGrpRUStr = -1;
    pcpex->crpexGrpRDStr = -1;

    pcpex->crpexGrpLULen = -1;
    pcpex->crpexGrpLDLen = -1;
    pcpex->crpexGrpRULen = -1;
    pcpex->crpexGrpRDLen = -1;
    
    if (szlu > CROP_MIN_LINE) {
#if LOG_CROP_CALCULINE
        printf("(LU) copy , start idx = %d, end idx = %d, size = %d\n", lfStrUp, lfEndUp, szlu);
#endif
        pGrp = &pcpex->crpexLfPots[lfStrUp*2];
        ret = calcuGroupLine(pGrp, vecLU, &divLU, szlu, midx);
        if (ret == 0) {
            memcpy(pcpex->crpexLinLU, vecLU, sizeof(CFLOAT)*3);
            pcpex->crpexLinLUDiv = divLU;
            pcpex->crpexGrpLUpt = pGrp;
            pcpex->crpexGrpLUStr = lfStrUp;
            pcpex->crpexGrpLULen = szlu;
            pcpex->crpexGrpLUDist = calcuDistance(pGrp, pGrp+(szlu-1)*2);
#if LOG_CROP_CALCULINE
            printf("(LU) distance from (%.2lf, %.2lf) to (%.2lf, %.2lf) = %.2lf\n", 
            pGrp[0], pGrp[1], *(pGrp+(szlu-1)*2), *(pGrp+(szlu-1)*2+1), pcpex->crpexGrpLUDist);
#endif
        } else {
            pcpex->crpexLinLUDiv = (CFLOAT)abs(ret);
#if LOG_CROP_CALCULINE
            printf("(LU) ret (%d), divLU (%lf)\n", ret, divLU); 
#endif
        }
    }

    if (szld > CROP_MIN_LINE) {
#if LOG_CROP_CALCULINE
        printf("(LD) copy , start idx = %d, end idx = %d, size = %d\n", lfStrDn, lfEndDn, szld);
#endif
        pGrp = &pcpex->crpexLfPots[lfStrDn*2];
        ret = calcuGroupLine(pGrp, vecLD, &divLD, szld, midx);
        if (ret == 0) {
            memcpy(pcpex->crpexLinLD, vecLD, sizeof(CFLOAT)*3);
            pcpex->crpexLinLDDiv = divLD;
            pcpex->crpexGrpLDpt = pGrp;
            pcpex->crpexGrpLDStr = lfStrDn;
            pcpex->crpexGrpLDLen = szld;
            pcpex->crpexGrpLDDist = calcuDistance(pGrp, pGrp+(szld-1)*2);
#if LOG_CROP_CALCULINE
            printf("(LD) distance from (%.2lf, %.2lf) to (%.2lf, %.2lf) = %.2lf\n", 
            pGrp[0], pGrp[1], *(pGrp+(szld-1)*2), *(pGrp+(szld-1)*2+1), pcpex->crpexGrpLDDist);
#endif
        } else {
            pcpex->crpexLinLDDiv = (CFLOAT)abs(ret);
#if LOG_CROP_CALCULINE
            printf("(LD) ret (%d), divLD (%lf)\n", ret, divLD);
#endif
        }
    }

    if (szru > CROP_MIN_LINE) {
#if LOG_CROP_CALCULINE
        printf("(RU) copy , start idx = %d, end idx = %d, size = %d\n", rtStrUp, rtEndUp, szru);    
#endif
        pGrp = &pcpex->crpexRtPots[rtStrUp*2];
        ret = calcuGroupLine(pGrp, vecRU, &divRU, szru, midx);
        if (ret == 0) {
            memcpy(pcpex->crpexLinRU, vecRU, sizeof(CFLOAT)*3);
            pcpex->crpexLinRUDiv = divRU;
            pcpex->crpexGrpRUpt = pGrp;
            pcpex->crpexGrpRUStr = rtStrUp;
            pcpex->crpexGrpRULen = szru;
            pcpex->crpexGrpRUDist = calcuDistance(pGrp, pGrp+(szru-1)*2);
#if LOG_CROP_CALCULINE
            printf("(RU) distance from (%.2lf, %.2lf) to (%.2lf, %.2lf) = %.2lf\n", 
            pGrp[0], pGrp[1], *(pGrp+(szru-1)*2), *(pGrp+(szru-1)*2+1), pcpex->crpexGrpRUDist);
#endif
        } else {
            pcpex->crpexLinRUDiv = (CFLOAT)abs(ret);
#if LOG_CROP_CALCULINE
            printf("(RU) ret (%d), divRU (%lf)\n", ret, divRU);
#endif
        }
    }
    
    if (szrd > CROP_MIN_LINE) {
#if LOG_CROP_CALCULINE
        printf("(RD) copy , start idx = %d, end idx = %d, size = %d\n", rtStrDn, rtEndDn, szrd);    
#endif
        pGrp = &pcpex->crpexRtPots[rtStrDn*2];
        ret = calcuGroupLine(pGrp, vecRD, &divRD, szrd, midx);
        if (ret == 0) {
            memcpy(pcpex->crpexLinRD, vecRD, sizeof(CFLOAT)*3);
            pcpex->crpexLinRDDiv = divRD;
            pcpex->crpexGrpRDpt = pGrp;
            pcpex->crpexGrpRDStr = rtStrDn;
            pcpex->crpexGrpRDLen = szrd;
            pcpex->crpexGrpRDDist = calcuDistance(pGrp, pGrp+(szrd-1)*2);
#if LOG_CROP_CALCULINE
            printf("(RD) distance from (%.2lf, %.2lf) to (%.2lf, %.2lf) = %.2lf\n", 
            pGrp[0], pGrp[1], *(pGrp+(szrd-1)*2), *(pGrp+(szrd-1)*2+1), pcpex->crpexGrpRDDist);
#endif
        } else {
            pcpex->crpexLinRDDiv = (CFLOAT)abs(ret);
#if LOG_CROP_CALCULINE
            printf("(RD) ret (%d), divRD (%lf)\n",  ret, divRD);
#endif
        }
    }

    return 0;
}

static CFLOAT aspMax(CFLOAT d1, CFLOAT d2) 
{
    if (d1 > d2) return d1;
    else return d2;
}

static CFLOAT aspMin(CFLOAT d1, CFLOAT d2) 
{
    if (d1 < d2) return d1;
    else return d2;
}

static int aspMaxInt(int d1, int d2) 
{
    if (d1 > d2) return d1;
    else return d2;
}

static int aspMinInt(int d1, int d2) 
{
    if (d1 < d2) return d1;
    else return d2;
}

static int getRotateP1(struct aspCrop36_s *pcp36, CFLOAT *cp1) 
{
    if (!cp1) return -1;
    if (!pcp36) return -2;

    memcpy(cp1, pcp36->crp36P1, sizeof(CFLOAT)*2);
    
    return 0;
}

static int setRotateP1(struct aspCrop36_s *pcp36, CFLOAT *rotateP1) 
{
    int ngcnt=0;
    int getShpRt=0, getShpLf=0, getShpDn=0, getShpUp=0;
    
    if (!rotateP1) return -1;
    if (!pcp36) return -2;

    getShpRt = pcp36->crp36Rt;
    getShpLf = pcp36->crp36Lf;
    getShpUp = pcp36->crp36Up;
    getShpDn = pcp36->crp36Dn;

    if (rotateP1[0] > getShpRt + 200) {
        rotateP1[0] = getShpRt + 200;
        ngcnt++;
    }
    
    if (rotateP1[0] < getShpLf - 200) {
        rotateP1[0] = getShpLf - 200;
        if (rotateP1[0] < 0) rotateP1[0] = 0;
        ngcnt++;
    }
    if (rotateP1[1] > getShpDn + 200) {
        rotateP1[1] = getShpDn + 200;
        ngcnt++;
    }
    
    if (rotateP1[1] < getShpUp - 200) {
        rotateP1[1] = getShpUp - 200;
        if (rotateP1[1] < 0) rotateP1[1] = 0;
        ngcnt++;
    }
    
    if (ngcnt == 0) {
        memcpy(pcp36->crp36P1, rotateP1, sizeof(CFLOAT)*2);
    } else {
        memcpy(pcp36->crp36P1, rotateP1, sizeof(CFLOAT)*2);
        //memset(pcp36->crp36P1, 0, sizeof(CFLOAT)*2);
    }
    
    return 0;
}

static int getRotateP2(struct aspCrop36_s *pcp36, CFLOAT *cp2) 
{
    if (!cp2) return -1;
    if (!pcp36) return -2;

    memcpy(cp2, pcp36->crp36P2, sizeof(CFLOAT)*2);
    
    return 0;
}

static int setRotateP2(struct aspCrop36_s *pcp36, CFLOAT *rotateP2) 
{
    int ngcnt=0;
    int getShpRt=0, getShpLf=0, getShpDn=0, getShpUp=0;
    
    if (!rotateP2) return -1;
    if (!pcp36) return -2;

    getShpRt = pcp36->crp36Rt;
    getShpLf = pcp36->crp36Lf;
    getShpUp = pcp36->crp36Up;
    getShpDn = pcp36->crp36Dn;

    if (!rotateP2) return -1;
    if (!pcp36) return -2;

    if (rotateP2[0] > getShpRt + 200) {
        rotateP2[0] = getShpRt + 200;
        ngcnt++;
    }
    if (rotateP2[0] < getShpLf - 200) {
        rotateP2[0] = getShpLf - 200;
        if (rotateP2[0] < 0) rotateP2[0] = 0;
        ngcnt++;
    }
    if (rotateP2[1] > getShpDn + 200) {
        rotateP2[1] = getShpDn + 200;
        ngcnt++;
    }
    
    if (rotateP2[1] < getShpUp - 200) {
        rotateP2[1] = getShpUp - 200;
        if (rotateP2[1] < 0) rotateP2[1] = 0;
        ngcnt++;
    }

    if (ngcnt == 0) {
        memcpy(pcp36->crp36P2, rotateP2, sizeof(CFLOAT)*2);
    } else {
        memcpy(pcp36->crp36P2, rotateP2, sizeof(CFLOAT)*2);
        //memset(pcp36->crp36P2, 0, sizeof(CFLOAT)*2);
    }

    return 0;
}

static int getRotateP3(struct aspCrop36_s *pcp36, CFLOAT *cp3) 
{
    if (!cp3) return -1;
    if (!pcp36) return -2;

    memcpy(cp3, pcp36->crp36P3, sizeof(CFLOAT)*2);
    
    return 0;
}

static int setRotateP3(struct aspCrop36_s *pcp36, CFLOAT *rotateP3) 
{
    int ngcnt=0;
    int getShpRt=0, getShpLf=0, getShpDn=0, getShpUp=0;
    
    if (!rotateP3) return -1;
    if (!pcp36) return -2;

    getShpRt = pcp36->crp36Rt;
    getShpLf = pcp36->crp36Lf;
    getShpUp = pcp36->crp36Up;
    getShpDn = pcp36->crp36Dn;

    if (!rotateP3) return -1;
    if (!pcp36) return -2;

    if (rotateP3[0] > getShpRt + 200) {
        rotateP3[0] = getShpRt + 200;
        ngcnt++;
    }
    if (rotateP3[0] < getShpLf - 200) {
        rotateP3[0] = getShpLf - 200;
        if (rotateP3[0] < 0) rotateP3[0] = 0;
        ngcnt++;
    }
    if (rotateP3[1] > getShpDn + 200) {
        rotateP3[1] = getShpDn + 200;
        ngcnt++;
    }
    
    if (rotateP3[1] < getShpUp - 200) {
        rotateP3[1] = getShpUp - 200;
        if (rotateP3[1] < 0) rotateP3[1] = 0;
        ngcnt++;
    }

    if (ngcnt == 0) {
        memcpy(pcp36->crp36P3, rotateP3, sizeof(CFLOAT)*2);
    } else {
        memcpy(pcp36->crp36P3, rotateP3, sizeof(CFLOAT)*2);
        //memset(pcp36->crp36P3, 0, sizeof(CFLOAT)*2);
    }

    return 0;
}

static int getRotateP4(struct aspCrop36_s *pcp36, CFLOAT *cp4) 
{
    if (!cp4) return -1;
    if (!pcp36) return -2;

    memcpy(cp4, pcp36->crp36P4, sizeof(CFLOAT)*2);
    
    return 0;
}

static int setRotateP4(struct aspCrop36_s *pcp36, CFLOAT *rotateP4) 
{
    int ngcnt=0;
    int getShpRt=0, getShpLf=0, getShpDn=0, getShpUp=0;
    
    if (!rotateP4) return -1;
    if (!pcp36) return -2;

    getShpRt = pcp36->crp36Rt;
    getShpLf = pcp36->crp36Lf;
    getShpUp = pcp36->crp36Up;
    getShpDn = pcp36->crp36Dn;

    if (!rotateP4) return -1;
    if (!pcp36) return -2;

    if (rotateP4[0] > getShpRt + 200) {
        rotateP4[0] = getShpRt + 200;
        ngcnt++;
    }
    if (rotateP4[0] < getShpLf - 200) {
        rotateP4[0] = getShpLf - 200;
        if (rotateP4[0] < 0) rotateP4[0] = 0;
        ngcnt++;
    }
    if (rotateP4[1] > getShpDn + 200) {
        rotateP4[1] = getShpDn + 200;
        ngcnt++;
    }
    
    if (rotateP4[1] < getShpUp - 200) {
        rotateP4[1] = getShpUp - 200;
        if (rotateP4[1] < 0) rotateP4[1] = 0;
        ngcnt++;
    }
          
    if (ngcnt == 0) {
        memcpy(pcp36->crp36P4, rotateP4, sizeof(CFLOAT)*2);
    } else {
        memcpy(pcp36->crp36P4, rotateP4, sizeof(CFLOAT)*2);
        //memset(pcp36->crp36P4, 0, sizeof(CFLOAT)*2);
    }

    return 0;
}

static int findBestLine(struct aspCrop36_s *pcp36, struct aspCropExtra_s *pcpex, int midx)
{
#define ACCEPT_OFFSET (1000.0)
#define ACCEPT_FINAL_OFFSET_RADIO (1.0)
#define ACCEPT_COMPU_OFFSET_RADIO (0.8)

    CFLOAT *vLU=0, *vLD=0, *vRU=0, *vRD=0;
    CFLOAT linLU[3], linLD[3], linRU[3], linRD[3];
    CFLOAT vLUDiv, vLDDiv, vRUDiv, vRDDiv;
    CFLOAT pup[2], pdn[2], plf[2], prt[2];
    CFLOAT sup[2], sdn[2], slf[2], srt[2];
    CFLOAT rup[2], rdn[2], rlf[2], rrt[2];
    CFLOAT ptn[40];
    CFLOAT distU2L=-1, distU2R=-1;
    CFLOAT distD2L=-1, distD2R=-1;
    CFLOAT distR2U=-1, distR2D=-1;
    CFLOAT distL2U=-1, distL2D=-1;
    CFLOAT distV=-1, distN=-1;
    int loopcnt=0;
    CFLOAT *pGrpLU, *pGrpLD, *pGrpRU, *pGrpRD;
    CFLOAT gpLUlen, gpLDlen, gpRUlen, gpRDlen;
    int gpLUstr, gpLDstr, gpRUstr, gpRDstr;
    int ret, i=0;
    CFLOAT high=0.0, width=0.0, acptOff_h=0.0, acptOff_v=0.0, acpFn_h=10.0, acpFn_v=10.0;
    CFLOAT ttline[3], bbline[3], llline[3], rrline[3];
    CFLOAT dlu, dru, dld, drd;
    CFLOAT cslf[2], csrt[2], csup[2], csdn[2];
    CFLOAT angleLf=0, angleRt=0, angleUp=0, angleDn=0;
    
    high = pcp36->crp36Dn - pcp36->crp36Up;
    width = pcp36->crp36Rt - pcp36->crp36Lf;

    memcpy(ttline, pcp36->crp36LineTop, sizeof(CFLOAT)*3);
    memcpy(bbline, pcp36->crp36LineBotn, sizeof(CFLOAT)*3);
    memcpy(llline, pcp36->crp36LineLeft, sizeof(CFLOAT)*3);
    memcpy(rrline, pcp36->crp36LineRight, sizeof(CFLOAT)*3);
    
    acptOff_h = ACCEPT_COMPU_OFFSET_RADIO * width;
    acptOff_v = ACCEPT_COMPU_OFFSET_RADIO * high;
    
    acpFn_h = ACCEPT_FINAL_OFFSET_RADIO * width;
    acpFn_v = ACCEPT_FINAL_OFFSET_RADIO * high;

#if LOG_CROP_FINDLINE
    printf("accept offset for compu v:%lf, h:%lf for final: v:%lf, h:%lf \n", acptOff_v, acptOff_h, acpFn_v, acpFn_h);
#endif

    memcpy(ptn, pcp36->crp36Pots, sizeof(CFLOAT)*40);
    memcpy(sup, pcpex->crpexCrosUp, sizeof(CFLOAT)*2);
    memcpy(sdn, pcpex->crpexCrosDn, sizeof(CFLOAT)*2);
    memcpy(slf, pcpex->crpexMostLt, sizeof(CFLOAT)*2);
    memcpy(srt, pcpex->crpexMostRt, sizeof(CFLOAT)*2);   
        
    pGrpLU = pcpex->crpexGrpLUpt;
    pGrpLD = pcpex->crpexGrpLDpt;
    pGrpRU = pcpex->crpexGrpRUpt;
    pGrpRD = pcpex->crpexGrpRDpt;

    gpLUlen = (CFLOAT) pcpex->crpexGrpLULen;    
    gpLDlen = (CFLOAT) pcpex->crpexGrpLDLen;
    gpRUlen = (CFLOAT) pcpex->crpexGrpRULen;
    gpRDlen = (CFLOAT) pcpex->crpexGrpRDLen;

    dlu = pcpex->crpexGrpLUDist;
    dld = pcpex->crpexGrpLDDist;
    dru = pcpex->crpexGrpRUDist;
    drd = pcpex->crpexGrpRDDist;
    
    gpLUstr = pcpex->crpexGrpLUStr;
    gpLDstr = pcpex->crpexGrpLDStr;
    gpRUstr = pcpex->crpexGrpRUStr;
    gpRDstr = pcpex->crpexGrpRDStr;

    vLUDiv = pcpex->crpexLinLUDiv;
    vLDDiv = pcpex->crpexLinLDDiv;
    vRUDiv = pcpex->crpexLinRUDiv;
    vRDDiv = pcpex->crpexLinRDDiv;

    getCross(pcpex->crpexLinLU, pcpex->crpexLinLD, cslf);
    getCross(pcpex->crpexLinRU, pcpex->crpexLinRD, csrt);
    getCross(pcpex->crpexLinLU, pcpex->crpexLinRU, csup);
    getCross(pcpex->crpexLinLD, pcpex->crpexLinRD, csdn);

    angleLf = getAngle(cslf, csup, csdn);
    angleRt = getAngle(csrt, csup, csdn);
    angleUp= getAngle(csup, cslf, csrt);
    angleDn = getAngle(csdn, cslf, csrt);

#if LOG_CROP_FINDLINE
    printf("angle lf: %.2lf rt: %.2lf up: %.2lf dn: %.2lf \n",
                        angleLf, angleRt, angleUp, angleDn);
    printf("cross lf: (%.2lf, %.2lf) rt: (%.2lf, %.2lf) up: (%.2lf, %.2lf) dn: (%.2lf, %.2lf) \n",
                        cslf[0], cslf[1], csrt[0], csrt[1], csup[0], csup[1], csdn[0], csdn[1]);
#endif

#if LOG_CROP_FINDLINE
    printf("line LU str:%d len:%lf div:%lf d:%.2f\n", gpLUstr, gpLUlen, vLUDiv, dlu);
    printf("line LD str:%d len:%lf div:%lf d:%.2f\n", gpLDstr, gpLDlen, vLDDiv, dld);
    printf("line RU str:%d len:%lf div:%lf d:%.2f\n", gpRUstr, gpRUlen, vRUDiv, dru);
    printf("line RD str:%d len:%lf div:%lf d:%.2f\n", gpRDstr, gpRDlen, vRDDiv, drd);
#endif
/*
    if (gpLUlen > 0)
    for (i=0; i < gpLUlen; i++){
        printf("%d.LU %lf, %lf \n", i, pGrpLU[gpLUstr+i*2+0], pGrpLU[gpLUstr+i*2+1]);
    }

    if (gpLDlen > 0)
    for (i=0; i < gpLDlen; i++){
        printf("%d.LD %lf, %lf \n", i, pGrpLD[gpLDstr+i*2+0], pGrpLD[gpLDstr+i*2+1]);
    }

    if (gpRUlen > 0)
    for (i=0; i < gpRUlen; i++){
        printf("%d.RU %lf, %lf \n", i, pGrpRU[gpRUstr+i*2+0], pGrpRU[gpRUstr+i*2+1]);
    }

    if (gpRDlen > 0)
    for (i=0; i < gpRDlen; i++){
        printf("%d.RD %lf, %lf \n", i, pGrpRD[gpRDstr+i*2+0], pGrpRD[gpRDstr+i*2+1]);
    }
*/
    if (gpLUstr >= 0) {
        memcpy(linLU, pcpex->crpexLinLU, sizeof(CFLOAT)*3);   
    } else {
        memset(linLU, 0, sizeof(CFLOAT)*3);   
    }

    if (gpLDstr >= 0) {
        memcpy(linLD, pcpex->crpexLinLD, sizeof(CFLOAT)*3);   
    } else {
        memset(linLD, 0, sizeof(CFLOAT)*3);   
    }

    if (gpRUstr >= 0) {
        memcpy(linRU, pcpex->crpexLinRU, sizeof(CFLOAT)*3);   
    } else {
        memset(linRU, 0, sizeof(CFLOAT)*3);   
    }

    if (gpRDstr >= 0) {
        memcpy(linRD, pcpex->crpexLinRD, sizeof(CFLOAT)*3);   
    } else {
        memset(linRD, 0, sizeof(CFLOAT)*3);   
    }

    if (pGrpLU == 0) {
        pGrpLU = aspMemalloc(sizeof(CFLOAT)*5*2, midx);
    
        pGrpLU[0*2+0] = sup[0];
        pGrpLU[0*2+1] = sup[1];
        
        pGrpLU[1*2+0] = ptn[6*2+0];
        pGrpLU[1*2+1] = ptn[6*2+1];
    
        pGrpLU[2*2+0] = ptn[7*2+0];
        pGrpLU[2*2+1] = ptn[7*2+1];
    
        pGrpLU[3*2+0] = ptn[9*2+0];
        pGrpLU[3*2+1] = ptn[9*2+1];
        
        pGrpLU[4*2+0] = slf[0];
        pGrpLU[4*2+1] = slf[1];

        gpLUlen = 5;
    }
    
    if (pGrpLD == 0) {
        pGrpLD = aspMemalloc(sizeof(CFLOAT)*7*2, midx);
    
        pGrpLD[0*2+0] = sdn[0];
        pGrpLD[0*2+1] = sdn[1];
    
        pGrpLD[1*2+0] = ptn[2*2+0];
        pGrpLD[1*2+1] = ptn[2*2+1];
    
        pGrpLD[2*2+0] = ptn[17*2+0];
        pGrpLD[2*2+1] = ptn[17*2+1];
    
        pGrpLD[3*2+0] = ptn[15*2+0];
        pGrpLD[3*2+1] = ptn[15*2+1];
    
        pGrpLD[4*2+0] = ptn[13*2+0];
        pGrpLD[4*2+1] = ptn[13*2+1];
    
        pGrpLD[5*2+0] = ptn[11*2+0];
        pGrpLD[5*2+1] = ptn[11*2+1];
        
        pGrpLD[6*2+0] = slf[0];
        pGrpLD[6*2+1] = slf[1];
        
        gpLDlen = 7;
    }
    
    if (pGrpRU == 0) {
        pGrpRU = aspMemalloc(sizeof(CFLOAT)*5*2, midx);
        
        pGrpRU[0*2+0] = sup[0];
        pGrpRU[0*2+1] = sup[1];
        
        pGrpRU[1*2+0] = ptn[5*2+0];
        pGrpRU[1*2+1] = ptn[5*2+1];
    
        pGrpRU[2*2+0] = ptn[8*2+0];
        pGrpRU[2*2+1] = ptn[8*2+1];
    
        pGrpRU[3*2+0] = ptn[10*2+0];
        pGrpRU[3*2+1] = ptn[10*2+1];
    
        pGrpRU[4*2+0] = srt[0];
        pGrpRU[4*2+1] = srt[1];

        gpRUlen = 5;
    }
    
    if (pGrpRD == 0) {
        pGrpRD = aspMemalloc(sizeof(CFLOAT)*7*2, midx);
        
        pGrpRD[0*2+0] = sdn[0];
        pGrpRD[0*2+1] = sdn[1];
    
        pGrpRD[1*2+0] = ptn[3*2+0];
        pGrpRD[1*2+1] = ptn[3*2+1];
    
        pGrpRD[2*2+0] = ptn[18*2+0];
        pGrpRD[2*2+1] = ptn[18*2+1];
    
        pGrpRD[3*2+0] = ptn[16*2+0];
        pGrpRD[3*2+1] = ptn[16*2+1];
    
        pGrpRD[4*2+0] = ptn[14*2+0];
        pGrpRD[4*2+1] = ptn[14*2+1];
    
        pGrpRD[5*2+0] = ptn[12*2+0];
        pGrpRD[5*2+1] = ptn[12*2+1];
        
        pGrpRD[6*2+0] = srt[0];
        pGrpRD[6*2+1] = srt[1];
        
        gpRDlen = 7;
    }
        
    CFLOAT maxDiv = 10 / 5.0 ;
    CFLOAT divGpLU=0, divGpLD=0, divGpRU=0, divGpRD=0;

    if (width > (high * 1.2)) {
        divGpLU = ((dlu  * 20.0) + (gpLUlen * 32.0 / vLUDiv) * 18.0) / 38.0;
        divGpLD = ((dld  * 20.0) + (gpLDlen * 32.0 / vLDDiv) * 18.0) / 38.0;
        divGpRU = ((dru * 20.0) + (gpRUlen * 32.0 / vRUDiv) * 18.0) / 38.0;
        divGpRD = ((drd * 20.0) + (gpRDlen * 32.0 / vRDDiv) * 18.0) / 38.0;
    } 
    else {
        divGpLU = (dlu  * gpLUlen) / (vLUDiv);
        divGpLD = (dld  * gpLDlen) / (vLDDiv);
        divGpRU = (dru * gpRUlen) / (vRUDiv);
        divGpRD = (drd * gpRDlen) / (vRDDiv);
    }
    
#if LOG_CROP_FINDLINE
    printf("compare div LU:%.2lf(%.2lf/%.2lf) - %.2f, LD:%.2lf(%.2lf/%.2lf) - %.2f, RU:%.2lf(%.2lf/%.2lf) - %.2f, RD:%.2lf(%.2lf/%.2lf) - %.2f radio: (%.2lf:%.2lf) \n",
                        divGpLU, gpLUlen, vLUDiv, dlu,
                        divGpLD, gpLDlen, vLDDiv, dld,
                        divGpRU, gpRUlen, vRUDiv, dru,
                        divGpRD, gpRDlen, vRDDiv, drd, width, (high * 1.2));
#endif

    maxDiv = aspMax(divGpLU, maxDiv);
    maxDiv = aspMax(divGpLD, maxDiv);
    maxDiv = aspMax(divGpRU, maxDiv);
    maxDiv = aspMax(divGpRD, maxDiv);
    
    if (maxDiv == divGpLU) {
#if LOG_CROP_FINDLINE
        printf("[LU] compare min div = %lf\n", maxDiv);
#endif
        if (gpLUstr >= 0) {
            vLU = linLU;
        }
    } else if (maxDiv == divGpLD) {
#if LOG_CROP_FINDLINE    
        printf("[LD] compare min div = %lf\n", maxDiv);
#endif
        if (gpLDstr >= 0) {
            vLD = linLD;
        }
    } else if (maxDiv == divGpRU) {
#if LOG_CROP_FINDLINE
        printf("[RU] compare min div = %lf\n", maxDiv);
#endif
        if (gpRUstr >= 0) {
            vRU = linRU;
        }
    } else if (maxDiv == divGpRD) {
#if LOG_CROP_FINDLINE
        printf("[RD] compare min div = %lf\n", maxDiv);        
#endif
        if (gpRDstr >= 0) {
            vRD = linRD;
        }
    } else {
        printf("Error!!! compare min div failed!!!\n");

        if (gpLUstr >= 0) {
            vLU = linLU;
        }
        
        if (gpLDstr >= 0) {
            vLD = linLD;
        }
        
        if (gpRUstr >= 0) {
            vRU = linRU;
        }
        
        if (gpRDstr >= 0) {
            vRD = linRD;
        }        
    }
    CFLOAT vLUn[3];
    CFLOAT vLUv[3];
    CFLOAT *vLUs;
    CFLOAT vLDn[3];
    CFLOAT vLDv[3];
    CFLOAT *vLDs;
    CFLOAT vRUn[3];
    CFLOAT vRUv[3];
    CFLOAT *vRUs;
    CFLOAT vRDn[3];
    CFLOAT vRDv[3];
    CFLOAT *vRDs;

    while ((vLU == 0) || (vLD == 0) || (vRU == 0) || (vRD == 0)) {
        
        if (vLU == 0) {
#if LOG_CROP_FINDLINE
            printf("vLU == null\n");
#endif
            if ((vLD != 0) && (vRU != 0)) {
                if (divGpLD > divGpRU) {
                    ret =getRectVectorFromV(vLUn, sup, vLD);
                    ret =getRectVectorFromV(vLUv, slf, vLD);
                } else {
                    ret =getRectVectorFromV(vLUn, sup, vRU);
                    ret =getRectVectorFromV(vLUv, slf, vRU);
                }
            }
            else if (vLD != 0) {
                ret =getRectVectorFromV(vLUn, sup, vLD);
                ret =getRectVectorFromV(vLUv, slf, vLD);
            }
            else if (vRU != 0) {
                ret =getRectVectorFromV(vLUn, sup, vRU);
                ret =getRectVectorFromV(vLUv, slf, vRU);
            }
        
            if ((vLD != 0)  || (vRU != 0)) {
                distN = calcuLineGroupDist(pGrpLU, vLUn, (int)gpLUlen);
                distV = calcuLineGroupDist(pGrpLU, vLUv, (int)gpLUlen);
#if LOG_CROP_FINDLINE
                printf("vLU compare uv distN=%lf, distV=%lf\n", distN, distV);
#endif
                if (distN < distV) {
                    memcpy(linLU, vLUn, sizeof(CFLOAT)*3);   
                } else {
                    memcpy(linLU, vLUv, sizeof(CFLOAT)*3);   
                }
                vLU = linLU;
                vLUs = linLU;
        
                distU2L = calcuVectorDistancePoint(vLUs, sup);
                distL2U = calcuVectorDistancePoint(vLUs, slf);
#if LOG_CROP_FINDLINE
                printf("vLU distU2L=%lf, distL2U=%lf\n", distU2L, distL2U);        
#endif
                if (distU2L > acptOff_v || distL2U > acptOff_h) {
                    gpLUstr = -1;
                    vLU = 0;
#if LOG_CROP_FINDLINE
                    printf("vLU set to NULL\n");
#endif
                }
            }
        
        }
        else {
#if LOG_CROP_FINDLINE
            printf("vLU != null\n");
#endif
            distU2L = calcuVectorDistancePoint(vLU, sup);
            distL2U = calcuVectorDistancePoint(vLU, slf);
#if LOG_CROP_FINDLINE
            printf("vLU distU2L=%lf, distL2U=%lf\n", distU2L, distL2U);
#endif
            if (distU2L > acptOff_v || distL2U > acptOff_h) {
                gpLUstr = -1;
                vLU = 0;
#if LOG_CROP_FINDLINE
                printf("vLU set to NULL\n");
#endif
            }
        }
        
        if (vLD == 0) {
#if LOG_CROP_FINDLINE
            printf("vLD == null\n");
#endif
            if ((vLU != 0) && (vRD != 0)) {
                if (divGpLU > divGpRD) {
                    ret =getRectVectorFromV(vLDn, sdn, vLU);
                    ret =getRectVectorFromV(vLDv, slf, vLU);                
                } else {
                    ret =getRectVectorFromV(vLDn, sdn, vRD);
                    ret =getRectVectorFromV(vLDv, slf, vRD);
                }
            }
            else if (vLU != 0) {
                ret =getRectVectorFromV(vLDn, sdn, vLU);
                ret =getRectVectorFromV(vLDv, slf, vLU);                
            }
            else if (vRD != 0) {
                ret =getRectVectorFromV(vLDn, sdn, vRD);
                ret =getRectVectorFromV(vLDv, slf, vRD);
            }
            
            if ((vLU != 0) || (vRD != 0)) {
                distN = calcuLineGroupDist(pGrpLD, vLDn, (int)gpLDlen);
                distV = calcuLineGroupDist(pGrpLD, vLDv, (int)gpLDlen);
#if LOG_CROP_FINDLINE
                printf("vLD compare uv distN=%lf, distV=%lf\n", distN, distV);
#endif
                if (distN < distV) {
                    memcpy(linLD, vLDn, sizeof(CFLOAT)*3);   
                } else {
                    memcpy(linLD, vLDv, sizeof(CFLOAT)*3);   
                }

                vLD = linLD;
                vLDs = linLD;
            
                distD2L = calcuVectorDistancePoint(vLDs, sdn);
                distL2D = calcuVectorDistancePoint(vLDs, slf);
#if LOG_CROP_FINDLINE
                printf("vLD distD2L=%lf, distL2D=%lf\n", distD2L, distL2D);        
#endif
                if (distD2L > acptOff_v || distL2D > acptOff_h) {
                    gpLDstr = -1;
                    vLD = 0;
#if LOG_CROP_FINDLINE
                    printf("vLD set to NULL\n");
#endif
                }
            }
        }
        else {
#if LOG_CROP_FINDLINE
            printf("vLD != null\n");
#endif
            distD2L = calcuVectorDistancePoint(vLD, sdn);
            distL2D = calcuVectorDistancePoint(vLD, slf);
#if LOG_CROP_FINDLINE
            printf("vLD distD2L=%lf, distL2D=%lf\n", distD2L, distL2D);
#endif
            if (distD2L > acptOff_v || distL2D > acptOff_h) {
                gpLDstr = -1;
                vLD = 0;
#if LOG_CROP_FINDLINE
                printf("vLD set to NULL\n");
#endif
            }
        }
        
        if (vRU == 0) {
#if LOG_CROP_FINDLINE
            printf("vRU == null\n");
#endif
            if ((vRD != 0) && (vLU != 0)) {
                if (divGpRD > divGpLU) {
                    ret =getRectVectorFromV(vRUn, sup, vRD);
                    ret =getRectVectorFromV(vRUv, srt, vRD);                
                } else {
                    ret =getRectVectorFromV(vRUn, sup, vLU);
                    ret =getRectVectorFromV(vRUv, srt, vLU);                
                }
            }
            else if (vRD != 0) {
                ret =getRectVectorFromV(vRUn, sup, vRD);
                ret =getRectVectorFromV(vRUv, srt, vRD);                
            }
            else if (vLU != 0) {
                ret =getRectVectorFromV(vRUn, sup, vLU);
                ret =getRectVectorFromV(vRUv, srt, vLU);                
            }
            if ((vRD != 0) || (vLU != 0)) {        
                distN = calcuLineGroupDist(pGrpRU, vRUn, (int)gpRUlen);
                distV = calcuLineGroupDist(pGrpRU, vRUv, (int)gpRUlen);
#if LOG_CROP_FINDLINE
                printf("vRU compare uv distN=%lf, distV=%lf\n", distN, distV);
#endif
                if (distN < distV) {
                    memcpy(linRU, vRUn, sizeof(CFLOAT)*3);   
                } else {
                    memcpy(linRU, vRUv, sizeof(CFLOAT)*3);   
                }
        
                vRU = linRU;
                vRUs = linRU;
        
                distU2R = calcuVectorDistancePoint(vRUs, sup);
                distR2U = calcuVectorDistancePoint(vRUs, srt);
#if LOG_CROP_FINDLINE
                printf("vRU distU2R=%lf, distR2U=%lf\n", distU2R, distR2U);
#endif
                if (distU2R > acptOff_v || distR2U > acptOff_h) {
                    gpRUstr = -1;
                    vRU = 0;
#if LOG_CROP_FINDLINE
                    printf("vRU set to NULL\n");
#endif
                }
            }
        }
        else {
#if LOG_CROP_FINDLINE
            printf("vRU != null\n");
#endif
            distU2R = calcuVectorDistancePoint(vRU, sup);
            distR2U = calcuVectorDistancePoint(vRU, srt);
#if LOG_CROP_FINDLINE
            printf("vRU distU2R=%lf, distR2U=%lf\n", distU2R, distR2U);
#endif
            if (distU2R > acptOff_v || distR2U > acptOff_h) {
                gpRUstr = -1;
                vRU = 0;
#if LOG_CROP_FINDLINE
                printf("vRU set to NULL\n");
#endif
            }
        }
        
        if (vRD == 0) {
#if LOG_CROP_FINDLINE
            printf("vRD == null\n");
#endif
            if ((vRU != 0) && (vLD != 0)) {
                if (divGpRU > divGpLD) {
                    ret =getRectVectorFromV(vRDn, sdn, vRU);
                    ret =getRectVectorFromV(vRDv, srt, vRU);                
                } else {
                    ret =getRectVectorFromV(vRDn, sdn, vLD);
                    ret =getRectVectorFromV(vRDv, srt, vLD);                
                }
            }
            else if (vRU != 0) {
                ret =getRectVectorFromV(vRDn, sdn, vRU);
                ret =getRectVectorFromV(vRDv, srt, vRU);                
            }
            else if (vLD != 0) {
                ret =getRectVectorFromV(vRDn, sdn, vLD);
                ret =getRectVectorFromV(vRDv, srt, vLD);                
            }
            if ((vRU != 0) || (vLD != 0)) {
                distN = calcuLineGroupDist(pGrpRD, vRDn, (int)gpRDlen);
                distV = calcuLineGroupDist(pGrpRD, vRDv, (int)gpRDlen);
#if LOG_CROP_FINDLINE
                printf("vRD compare uv distN=%lf, distV=%lf\n", distN, distV);
#endif
                if (distN < distV) {
                    memcpy(linRD, vRDn, sizeof(CFLOAT)*3);   
                } else {
                    memcpy(linRD, vRDv, sizeof(CFLOAT)*3);   
                }

                vRD = linRD;
                vRDs = linRD;
        
                distD2R = calcuVectorDistancePoint(vRDs, sdn);
                distR2D = calcuVectorDistancePoint(vRDs, srt);
#if LOG_CROP_FINDLINE
                printf("vRD distD2R=%lf, distR2D=%lf\n", distD2R, distR2D);
#endif
                if (distD2R > acptOff_v || distR2D > acptOff_h) {
                    gpRDstr = -1;
                    vRD = 0;
#if LOG_CROP_FINDLINE
                    printf("vRD set to NULL\n");
#endif
                }
            }
        }
        else {
#if LOG_CROP_FINDLINE
            printf("vRD != null\n");
#endif
            distD2R = calcuVectorDistancePoint(vRD, sdn);
            distR2D = calcuVectorDistancePoint(vRD, srt);
#if LOG_CROP_FINDLINE
            printf("vRD distD2R=%lf, distR2D=%lf\n", distD2R, distR2D);
#endif
            if (distD2R > acptOff_v || distR2D > acptOff_h) {
                gpRDstr = -1;
                vRD = 0;
#if LOG_CROP_FINDLINE
                printf("vRD set to NULL\n");
#endif
            }
        }
    
        loopcnt++;
        if (loopcnt > 10) break;
    }

    if (vLU) {
#if LOG_CROP_FINDLINE
        printf("vLU = %lf, %lf, %lf \n", vLU[0], vLU[1], vLU[2]);
#endif
        memcpy(pcpex->crpexLinLU, vLU, sizeof(CFLOAT)*3);   
        pcpex->crpexGrpLUStr = 1;
    } else {
        pcpex->crpexGrpLUStr = -1;
    }

    if (vLD) {
#if LOG_CROP_FINDLINE
        printf("vLD = %lf, %lf, %lf \n", vLD[0], vLD[1], vLD[2]);
#endif
        memcpy(pcpex->crpexLinLD, vLD, sizeof(CFLOAT)*3);   
        pcpex->crpexGrpLDStr = 1;
    } else {
        pcpex->crpexGrpLDStr = -1;
    }

    if (vRU) {
#if LOG_CROP_FINDLINE
        printf("vRU = %lf, %lf, %lf \n", vRU[0], vRU[1], vRU[2]);
#endif
        memcpy(pcpex->crpexLinRU, vRU, sizeof(CFLOAT)*3);   
        pcpex->crpexGrpRUStr = 1;
    } else {
        pcpex->crpexGrpRUStr = -1;
    }

    if (vRD) {
#if LOG_CROP_FINDLINE
        printf("vRD = %lf, %lf, %lf \n", vRD[0], vRD[1], vRD[2]);
#endif
        memcpy(pcpex->crpexLinRD, vRD, sizeof(CFLOAT)*3);   
        pcpex->crpexGrpRDStr = 1;
    } else {
        pcpex->crpexGrpRDStr = -1;
    }

#if LOG_CROP_FINDLINE
    printf("accept offset for final v: %lf, h:%lf \n", acpFn_v, acpFn_h);
#endif

    if ((vLU != 0) && (vLD != 0) && (vRU != 0) && (vRD != 0)) {
        ret = getCross(vLU, vLD, plf);
        if (ret == 0) {
            CFLOAT dist=0;
            //dist = calcuDistance(slf, plf);
            dist = calcuVectorDistancePoint(llline, plf);
            
            if (dist < acpFn_h) {
                memcpy(pcpex->crpCropLf, plf, sizeof(CFLOAT)*2);
            } else {
                memcpy(pcpex->crpCropLf, slf, sizeof(CFLOAT)*2);
            }

#if LOG_CROP_FINDLINE
            printf("old msLf = (%lf, %lf), new msLf = (%lf, %lf), dist=%lf \n", round(slf[0]), round(slf[1]), round(plf[0]), round(plf[1]), dist);
#endif
        }
        
        ret = getCross(vLU, vRU, pup);
        if (ret == 0) {
            CFLOAT dist=0;
            //dist = calcuDistance(sup, pup);
            dist = calcuVectorDistancePoint(ttline, pup);
            
            if (dist < acpFn_v) {
                memcpy(pcpex->crpCropUp, pup, sizeof(CFLOAT)*2);
            } else {
                memcpy(pcpex->crpCropUp, sup, sizeof(CFLOAT)*2);
            }
#if LOG_CROP_FINDLINE
            printf("old csUp = (%lf, %lf), new csUp = (%lf, %lf), dist=%lf\n", round(sup[0]), round(sup[1]), round(pup[0]), round(pup[1]), dist);
#endif
        }
        
        ret = getCross(vRU, vRD, prt);
        if (ret == 0) {
            CFLOAT dist = 0;
            //dist = calcuDistance(srt, prt);
            dist = calcuVectorDistancePoint(rrline, prt);
            
            if (dist < acpFn_h) {
                memcpy(pcpex->crpCropRt, prt, sizeof(CFLOAT)*2);
            } else {
                memcpy(pcpex->crpCropRt, srt, sizeof(CFLOAT)*2);
            }
#if LOG_CROP_FINDLINE
            printf("old msRt = (%lf, %lf), new msRt = (%lf, %lf), dist=%lf\n", round(srt[0]), round(srt[1]), round(prt[0]), round(prt[1]), dist);
#endif
        }
        
        ret = getCross(vLD, vRD, pdn);
        if (ret == 0) {
            CFLOAT dist = 0;
            //dist = calcuDistance(sdn, pdn);
            dist = calcuVectorDistancePoint(bbline, pdn);
            
            if (dist < acpFn_v) {
                memcpy(pcpex->crpCropDn, pdn, sizeof(CFLOAT)*2);
            } else {
                memcpy(pcpex->crpCropDn, sdn, sizeof(CFLOAT)*2);
            }
#if LOG_CROP_FINDLINE
            printf("old csDn = (%lf, %lf), new csDn = (%lf, %lf), dist=%lf\n", round(sdn[0]), round(sdn[1]), round(pdn[0]), round(pdn[1]), dist);
#endif
        }            

        getVectorFromP(vLUv, pcpex->crpCropUp, pcpex->crpCropLf);
        getVectorFromP(vLDv, pcpex->crpCropDn, pcpex->crpCropLf);
        getVectorFromP(vRUv, pcpex->crpCropUp, pcpex->crpCropRt);
        getVectorFromP(vRDv, pcpex->crpCropDn, pcpex->crpCropRt);

        memcpy(pcpex->crpexLinLU, vLUv, sizeof(CFLOAT)*3);
        memcpy(pcpex->crpexLinLD, vLDv, sizeof(CFLOAT)*3);
        memcpy(pcpex->crpexLinRU, vRUv, sizeof(CFLOAT)*3);
        memcpy(pcpex->crpexLinRD, vRDv, sizeof(CFLOAT)*3);
        
        //Log.e(TAG, "group get cross, up= ("+Math.round(pup[0])+", "+Math.round(pup[1])+"), down = ("+Math.round(pdn[0])+", "+Math.round(pdn[1])+"), left = ("+Math.round(plf[0])+", "+Math.round(plf[1])+"), right = "+Math.round(prt[0])+", "+Math.round(prt[1])+")");    

        ret = topPositive(pcpex);

        msync(pcpex, sizeof(struct aspCropExtra_s), MS_SYNC);
        
        setRotateP1(pcp36, pcpex->crpCropLf);
        setRotateP2(pcp36, pcpex->crpCropUp);
        setRotateP3(pcp36, pcpex->crpCropRt);
        setRotateP4(pcp36, pcpex->crpCropDn);
    
        ret = getRotateP1(pcp36, rlf);
        if (!ret) {
#if LOG_CROP_FINDLINE
            printf("rotateP1 = (%lf, %lf) \n", rlf[0], rlf[1]);
#endif
        }
        ret = getRotateP2(pcp36, rup);
        if (!ret) {
#if LOG_CROP_FINDLINE
            printf("rotateP2 = (%lf, %lf) \n", rup[0], rup[1]);
#endif
        }
        ret = getRotateP3(pcp36, rrt);
        if (!ret) {
#if LOG_CROP_FINDLINE
            printf("rotateP3 = (%lf, %lf) \n", rrt[0], rrt[1]);
#endif
        }
        ret = getRotateP4(pcp36, rdn);
        if (!ret) {
#if LOG_CROP_FINDLINE
            printf("rotateP4 = (%lf, %lf) \n", rdn[0], rdn[1]);
#endif
        }
    
    }
    return 0;
}

static int topPositive(struct aspCropExtra_s *pcpex) 
{
    CFLOAT vecRU[3], vecLU[3], vecRD[3], vecLD[3];
    CFLOAT vecRUsf[3], vecRDsf[3], vecLUsf[3], vecLDsf[3];
    CFLOAT lfsf[2], rtsf[2], topsf[2], dnsf[2];
    CFLOAT leftsf[2], rightsf[2];
    CFLOAT top[2], left[2], down[2], right[2];
    int minw, maxw, minh, maxh;

    memcpy(top, pcpex->crpCropUp, sizeof(CFLOAT)*2);
    memcpy(left, pcpex->crpCropLf, sizeof(CFLOAT)*2);
    memcpy(down, pcpex->crpCropDn, sizeof(CFLOAT)*2);
    memcpy(right, pcpex->crpCropRt, sizeof(CFLOAT)*2);

    memcpy(vecRU, pcpex->crpexLinRU, sizeof(CFLOAT)*3);
    memcpy(vecLU, pcpex->crpexLinLU, sizeof(CFLOAT)*3);
    memcpy(vecRD, pcpex->crpexLinRD, sizeof(CFLOAT)*3);
    memcpy(vecLD, pcpex->crpexLinLD, sizeof(CFLOAT)*3);

    memset(topsf, 0, sizeof(CFLOAT)*2);
    memset(dnsf, 0, sizeof(CFLOAT)*2);
    memset(lfsf, 0, sizeof(CFLOAT)*2);
    memset(rtsf, 0, sizeof(CFLOAT)*2);

    topsf[0] = top[0];
    if (top[1] < 0) {
        topsf[1] = 0;
    } else {
        topsf[1] = top[1];
    }
    
    getParallelVectorFromV(vecRUsf, topsf, vecRU);
    getParallelVectorFromV(vecLUsf, topsf, vecLU);

    getCross(vecRUsf, vecRD, rtsf);
    getCross(vecLUsf, vecLD, lfsf);

#if LOG_CROP_TOPOFFSET
        printf("get shift cross left (%lf, %lf) right (%lf, %lf) \n", round(lfsf[0]), round(lfsf[1]), round(rtsf[0]), round(rtsf[1]));
#endif

    while (rtsf[1] < 0.0) {
        rightsf[0] = rtsf[0];
        rightsf[1] = 10;

        getParallelVectorFromV(vecRUsf, rightsf, vecRU);
        getCross(vecRUsf, vecRD, rtsf);            
#if LOG_CROP_TOPOFFSET
        printf("right shift from (%lf, %lf) to (%lf, %lf) \n", round(right[0]), round(right[1]), round(rtsf[0]), round(rtsf[1]));
#endif
    }   
/*
    while (rtsf[0] < 0.0) {
        rightsf[0] = 10;
        rightsf[1] = rtsf[1];

        getParallelVectorFromV(vecRDsf, rightsf, vecRD);
        getCross(vecRDsf, vecRUsf, rtsf);            

        printf("right shift again from (%lf, %lf) to (%lf, %lf)\n", round(right[0]), round(right[1]), round(rtsf[0]), round(rtsf[1]));
    }
*/
    while (lfsf[1] < 0.0) {
        leftsf[0] = lfsf[0];
        leftsf[1] = 10;

        getParallelVectorFromV(vecLUsf, leftsf, vecLU);
        getCross(vecLUsf, vecLD, lfsf);            
#if LOG_CROP_TOPOFFSET
        printf("left shift from (%lf, %lf) to (%lf, %lf)\n", round(left[0]), round(left[1]), round(lfsf[0]), round(lfsf[1]));
#endif
    }
/*
    while (lfsf[0] < 0.0) {
        leftsf[0] = 10;
        leftsf[1] = lfsf[1];
        
        getParallelVectorFromV(vecLDsf, leftsf, vecLD);
        getCross(vecLUsf, vecLDsf, lfsf);            

        printf("left shift again from (%lf, %lf) to (%lf, %lf)\n", round(left[0]), round(left[1]), round(lfsf[0]), round(lfsf[1]));
    }
*/
    getParallelVectorFromV(vecLDsf, lfsf, vecLD);
    getParallelVectorFromV(vecRDsf, rtsf, vecRD);
        
    getCross(vecRUsf, vecLUsf, topsf);
    getCross(vecRDsf, vecLDsf, dnsf);

#if LOG_CROP_TOPOFFSET
    printf("END top shift from (%lf, %lf) to (%lf, %lf)\n", round(top[0]), round(top[1]), round(topsf[0]), round(topsf[1]));
    printf("END left shift from (%lf, %lf) to (%lf, %lf)\n", round(left[0]), round(left[1]), round(lfsf[0]), round(lfsf[1]));
    printf("END right shift from (%lf, %lf) to (%lf, %lf)\n", round(right[0]), round(right[1]), round(rtsf[0]), round(rtsf[1]));
    printf("END down shift from (%lf, %lf) to (%lf, %lf)\n", round(down[0]), round(down[1]), round(dnsf[0]), round(dnsf[1]));
#endif
    memcpy(pcpex->crpCropUp, topsf, sizeof(CFLOAT)*2);
    memcpy(pcpex->crpCropLf, lfsf, sizeof(CFLOAT)*2);
    memcpy(pcpex->crpCropDn, dnsf, sizeof(CFLOAT)*2);
    memcpy(pcpex->crpCropRt, rtsf, sizeof(CFLOAT)*2);

    return 0;
}

static int doCropCalcuPt(struct aspDoCropCalcu *crpdo, struct aspMetaDataviaUSB_s *pscanInfo, char *indat, int maxs, struct procRes_s *rs, int midx) 
{
    struct intMbs32_s *pt=0;
    struct aspCropExtra_s *pextra=0;
    struct aspCrop36_s *ppt36 = 0;
    char *ptext=0, *pch=0;
    unsigned short *shtbuf=0;

    int adpi=0, len=0, val=0;
    int gap=0, cy=0, lnrec=0, lnlength=0, masUsed=0, masRecd=0;
    int ix=0, cxm=0, cxn=0, ipx=0;

    if ((!crpdo) || (!pscanInfo) || (!indat)) {
        return -2;
    }

    pextra = crpdo->acrpex;
    ppt36 = crpdo->acrp36;

    if ((!ppt36) || (!pextra)) {
        return -3;
    }
    
    adpi = crpdo->acrpDPI;
        
    if ((indat) && (pscanInfo)) {
        val = (int)pscanInfo->MPIONT_LEN;
    
        if (val > maxs) {
            sprintf_f(rs->logs, "Error!!! MPIONT_LEN: %d not match max len: %d \n", val, maxs); 
            print_f(rs->plogs, "DoC", rs->logs);
            
            return -4;
        }

        ptext = indat;
    }
    
    if (pscanInfo) {       
        
        gap = pscanInfo->YLine_Gap;
        cy = pscanInfo->Start_YLine_No;
        len = (int)pscanInfo->MPIONT_LEN;
        
        pch = (char *)&(pscanInfo->YLines_Recorded);
        val = pch[0] << 8 | pch[1];
        lnrec = val;
        
        pch = &pscanInfo->EXTRA_POINT[2];
        val = pch[0] << 8 | pch[1];
        lnlength = val;

        sprintf_f(rs->logs, "mass len: %d expect len: %d \n", val, len-4); 
        print_f(rs->plogs, "DoC", rs->logs);

        if (val != (len - 4)) {
            sprintf_f(rs->logs, "Error!!! mass len: %d not match expect len: %d \n", val, len); 
            print_f(rs->plogs, "DoC", rs->logs);
            return -5;
        }

        if (len <= 4) {
            sprintf_f(rs->logs, "skip extra point calculation len: %d \n", len); 
            print_f(rs->plogs, "DoC", rs->logs);
            return -6;
        }
        
        masUsed = lnlength;
        masRecd = lnrec;
        
        sprintf_f(rs->logs, "meta masspt info (used:%d, start:%d lineRec:%d gap:%d)\n", masUsed, cy, masRecd, gap); 
        print_f(rs->plogs, "DoC", rs->logs);
        
        msync(ptext, masUsed, MS_SYNC);
        shtbuf = (unsigned short *)ptext;

    }

    if (masRecd) {
        ipx=0;
        
        for (ix = 0; ix < masRecd; ix++) {
        
            cxm = (int)*shtbuf;
            shtbuf++;
            cxn = (int)*shtbuf;
            shtbuf++;              
        
            if (adpi < 300) {
                cxm = (cxm * adpi) / 300;
                cxn = (cxn * adpi) / 300;
            }
            
            pextra->crpexLfPots[ipx*2+0] = (CFLOAT)cxm;
            pextra->crpexLfPots[ipx*2+1] = (CFLOAT)cy;
        
            pextra->crpexRtPots[ipx*2+0] = (CFLOAT)cxn;
            pextra->crpexRtPots[ipx*2+1] = (CFLOAT)cy;
        
            ipx ++;
            cy += gap;
        }
        
        pextra->crpexSize = ipx*2;
        
        msync(pextra, sizeof(struct aspCropExtra_s), MS_SYNC);
        
        sprintf_f(rs->logs, "total extra points size: %d \n", ipx);
        print_f(rs->plogs, "DoC", rs->logs);
        
        #if LOG_P6_CROP_EN
        for (ix = 0; ix < ipx; ix++) {
            sprintf_f(rs->logs, "unsort pt %d. L (%.1f, %.1f) R (%.1f, %.1f) \n", ix
                                  , pextra->crpexLfPots[ix*2+0], pextra->crpexLfPots[ix*2+1], pextra->crpexRtPots[ix*2+0], pextra->crpexRtPots[ix*2+1]);
            print_f(rs->plogs, "DoC", rs->logs);
        }
        #endif

        return 0;
    }

    return -1;
}

static int doCropCalcu36(struct aspDoCropCalcu *crpdo, char *indat, int maxs, struct procRes_s *rs, int midx) 
{
    int aidxL[] = {6, 7, 9, 11, 13, 15, 17, 2};
    int aidxR[] = {5, 8, 10, 12, 14, 16, 18, 3};    

    uint32_t cord=0;
    int len=0, val=0, hval=0, ret=0, ix=0, xpn=0, adpi=0;
    struct aspMetaDataviaUSB_s *pscanInfo=0;
    struct intMbs32_s *pt=0;
    struct aspCropExtra_s *pextra=0;
    struct aspCrop36_s *ppt36 = 0;
    CFLOAT rotlf[2], rotup[2], rotrt[2], rotdn[2];

    pextra = crpdo->acrpex;
    ppt36 = crpdo->acrp36;

    if (!ppt36) {
        return -1;
    }
    
    if (!pextra) {
        return -2;
    }

    if (indat) {
        pscanInfo = (struct aspMetaDataviaUSB_s *)indat;
        len = sizeof(struct aspMetaDataviaUSB_s);

        val = (int)pscanInfo->MPIONT_LEN;
        val += len;
    
        if (val > maxs) {
            return -1;
        }
    }

    if (pscanInfo) {
        adpi = crpdo->acrpDPI;
        pt = &(pscanInfo->CROP_POS_1);
        for (ix = 1; ix < (CROP_MAX_NUM_META+1); ix++) {
    
            cord = msb2lsb32(pt);
            val = cord >> 16;
            if (adpi < 300) {
                val = (val * adpi) / 300;
            }
        
            hval = cord & 0xffff;

            ppt36->crp36Pots[ix*2+0] = val;
            ppt36->crp36Pots[ix*2+1] = hval;

            #if LOG_P6_CROP_EN
            sprintf_f(rs->logs, "%d. (%d, %d) \n", ix, val, hval);
            print_f(rs->plogs, "DoC", rs->logs);
            #endif
                            
            pt++;
        }

        xpn = 0;
        ppt36->crp36Pots[xpn*2+0] = 100;
        ppt36->crp36Pots[xpn*2+1] = 0;

        xpn = CROP_MAX_NUM_META+1;
        ppt36->crp36Pots[xpn*2+0] = 1100;
        ppt36->crp36Pots[xpn*2+1] = 0;
    }

    /* first stage of cropping algorithm */            
    ret = aspCrp36GetBoundry(ppt36, CROP_MAX_NUM_META+2, pextra->crpexLfPots, pextra->crpexRtPots, pextra->crpexSize/2);
    #if LOG_P6_CROP_EN
    sprintf_f(rs->logs, "crop36 get boundry, ret = %d\n", ret);
    print_f(rs->plogs, "DoC", rs->logs);

    for (ix = 1; ix < (CROP_MAX_NUM_META+1); ix++) {
    
        val = ppt36->crp36Pots[ix*2+0];
        hval = ppt36->crp36Pots[ix*2+1];

        #if LOG_P6_CROP_EN
        sprintf_f(rs->logs, "new %d. (%d, %d) \n", ix, val, hval);
        print_f(rs->plogs, "DoC", rs->logs);
        #endif
                        
        pt++;
    }
    #endif
    
    ret = 0;
    ret |= calcuCrossUpAph(ppt36, midx);
    #if LOG_P6_CROP_EN
    sprintf_f(rs->logs, "crop36 cross up ret = %d\n", ret);
    print_f(rs->plogs, "DoC", rs->logs);
    #endif

    ret |= calcuCrossDnAph(ppt36, midx);
    #if LOG_P6_CROP_EN
    sprintf_f(rs->logs, "crop36 cross down ret = %d\n", ret);
    print_f(rs->plogs, "DoC", rs->logs);
    #endif

    if (ret) {
        getRectPoint(ppt36);
    } else {
        ret = calcuMostRtLf(ppt36);
        if (ret == 0) {
            ret = calcuCrossUpLine(ppt36);
            #if LOG_P6_CROP_EN
            sprintf_f(rs->logs, "crop36 cross up line ret = %d\n", ret);
            print_f(rs->plogs, "DoC", rs->logs);
            #endif

            ret = calcuCrossDnLine(ppt36);
            #if LOG_P6_CROP_EN
            sprintf_f(rs->logs, "crop36 cross down line ret = %d\n", ret);
            print_f(rs->plogs, "DoC", rs->logs);
            #endif

            ret = getCrop36RotatePoints(ppt36);
            #if LOG_P6_CROP_EN
            sprintf_f(rs->logs, "crop36 get rotate points, ret = %d\n", ret);
            print_f(rs->plogs, "DoC", rs->logs);
            #endif
        } else {
            getRectPoint(ppt36);
        }
    }

    #if LOG_P6_CROP_EN
    ret = getRotateP1(ppt36, rotlf);
    if (!ret) {
        sprintf_f(rs->logs, "first stage get rotateP1 (%.2lf, %.2lf) \n", rotlf[0], rotlf[1]);
        print_f(rs->plogs, "DoC", rs->logs);
    }
    
    ret = getRotateP2(ppt36, rotup);
    if (!ret) {
        sprintf_f(rs->logs, "first stage get rotateP2 (%.2lf, %.2lf) \n", rotup[0], rotup[1]);
        print_f(rs->plogs, "DoC", rs->logs);
    }
    
    ret = getRotateP3(ppt36, rotrt);
    if (!ret) {
        sprintf_f(rs->logs, "first stage get rotateP3 (%.2lf, %.2lf) \n", rotrt[0], rotrt[1]);
        print_f(rs->plogs, "DoC", rs->logs);
    }
    
    ret = getRotateP4(ppt36, rotdn);
    if (!ret) {
        sprintf_f(rs->logs, "first stage get rotateP4 (%.2lf, %.2lf) \n", rotdn[0], rotdn[1]);
        print_f(rs->plogs, "DoC", rs->logs);
    }
    #endif
                            
    return 0;
}

static int doCropCalcu(struct aspDoCropCalcu *crpdo, char *indat, int maxs, struct procRes_s *rs, int midx) 
{
    int len=0, val=0, ret=0, cnt=0;
    int ix=0, xpn=0, ipx=0, ipn=0, cls=0, cof=0, idx=0;
    int lngap=0, lnstart=0, lnrec=0, lnlength=0;
    int masUsed=0, masRecd=0, masStart=0, cy=0, linecnt=0;
    CFLOAT cxm=0.0, cxn=0.0, gap=0.0, hval=0.0;
    int adpi=0;
    struct aspMetaDataviaUSB_s *pscanInfo=0;
    struct intMbs32_s *pt=0;
    struct aspCropExtra_s *pextra=0;
    struct aspCrop36_s *ppt36 = 0;
    char *ptext=0, *pch=0;
    CFLOAT mostlft[2]={0}, mostrgt[2]={0}, lftgrp[10][2]={0}, rgtgrp[10][2]={0}, fhi=0.0, fwh=0.0, fwe=0.0;
    CFLOAT rotlf[2]={0}, rotup[2]={0}, rotrt[2]={0}, rotdn[2]={0};
    unsigned short *shtbuf=0;
    CFLOAT *org;
    int messpair_pos=0, new_mass_len=0, ext_cnt_lf=0, ext_cnt_rt=0, i=0;
        
    pextra = crpdo->acrpex;
    ppt36 = crpdo->acrp36;

    if (!ppt36) {
        return -1;
    }
    
    if (!pextra) {
        return -2;
    }

    adpi = crpdo->acrpDPI;
    org = &ppt36->crp36Pots[2];
        
    if (indat) {
        pscanInfo = (struct aspMetaDataviaUSB_s *)indat;
        len = sizeof(struct aspMetaDataviaUSB_s);

        val = (int)pscanInfo->MPIONT_LEN;
        val += len;
    
        if (val > maxs) {
            return -1;
        }

        ptext = indat + len;
    }

    if (pscanInfo) {
        messpair_pos = pextra->crpexSize;
        gap = (CFLOAT)pscanInfo->YLine_Gap;
        
        #if LOG_P6_CROP_EN
        sprintf_f(rs->logs, "messpair_pos = %d\n", messpair_pos);
        print_f(rs->plogs, "DoC", rs->logs);
        #endif
        {
    
            if ((org[2] > ppt36->crp36Lf) && (org[4] < ppt36->crp36Rt)) {
                #if LOG_P6_CROP_EN
                sprintf_f(rs->logs, "org pos %d (%.2f, %.2f) to extra lf-%d \n", 2, org[2], org[3], ext_cnt_lf);
                print_f(rs->plogs, "DoC", rs->logs);
                #endif
                pextra->crpexLfPots[messpair_pos + ext_cnt_lf++] = org[2];
                pextra->crpexLfPots[messpair_pos + ext_cnt_lf++] = org[3];

                #if LOG_P6_CROP_EN
                sprintf_f(rs->logs, "org pos %d (%.2f, %.2f) to extra rt-%d \n", 4, org[4], org[5], ext_cnt_rt);
                print_f(rs->plogs, "DoC", rs->logs);
                #endif
                pextra->crpexRtPots[messpair_pos + ext_cnt_rt++] = org[4];
                pextra->crpexRtPots[messpair_pos + ext_cnt_rt++] = org[5];
            }
            if ((org[10] > ppt36->crp36Lf) && (org[8] < ppt36->crp36Rt)) {		
                #if LOG_P6_CROP_EN
                sprintf_f(rs->logs, "org pos %d (%.2f, %.2f) to extra lf-%d \n", 10, org[10], org[11], ext_cnt_lf);
                print_f(rs->plogs, "DoC", rs->logs);
                #endif
                pextra->crpexLfPots[messpair_pos + ext_cnt_lf++] = org[10];
                pextra->crpexLfPots[messpair_pos + ext_cnt_lf++] = org[11];
            
                #if LOG_P6_CROP_EN
                sprintf_f(rs->logs, "org pos %d (%.2f, %.2f) to extra rf-%d \n", 8, org[8], org[9], ext_cnt_rt);
                print_f(rs->plogs, "DoC", rs->logs);
                #endif
                pextra->crpexRtPots[messpair_pos + ext_cnt_rt++] = org[8];
                pextra->crpexRtPots[messpair_pos + ext_cnt_rt++] = org[9];
            }
    
            for (i = 3; i < CROP_MAX_NUM_META / 2; i++) {
                if ((org[i * 4] > ppt36->crp36Lf) && (org[i * 4 + 2] < ppt36->crp36Rt)) {	
                    #if LOG_P6_CROP_EN
                    sprintf_f(rs->logs, "org pos %d (%.2f, %.2f) to extra lf-%d \n", i*4, org[i*4], org[i*4+1], ext_cnt_lf);
                    print_f(rs->plogs, "DoC", rs->logs);
                    #endif
                    pextra->crpexLfPots[messpair_pos + ext_cnt_lf++] = org[i * 4];
                    pextra->crpexLfPots[messpair_pos + ext_cnt_lf++] = org[i * 4 + 1];
                
                    #if LOG_P6_CROP_EN
                    sprintf_f(rs->logs, "org pos %d (%.2f, %.2f) to extra rt-%d \n", i*4+2, org[i*4+2], org[i*4+3], ext_cnt_rt);
                    print_f(rs->plogs, "DoC", rs->logs);
                    #endif
                    pextra->crpexRtPots[messpair_pos + ext_cnt_rt++] = org[i * 4 + 2];
                    pextra->crpexRtPots[messpair_pos + ext_cnt_rt++] = org[i * 4 + 3];
                }
            }
        }
        
        new_mass_len = (messpair_pos + ext_cnt_lf) * 2;

        #if LOG_P6_CROP_EN
        sprintf_f(rs->logs, "after add new_mass_len = %d gap: %.2lf\n", new_mass_len, gap);
        print_f(rs->plogs, "DoC", rs->logs);
        #endif
        
        qsort((void *) pextra->crpexLfPots, (new_mass_len / 4), sizeof(CFLOAT) * 2, qsort_comp);
        qsort((void *) pextra->crpexRtPots, (new_mass_len / 4), sizeof(CFLOAT) * 2, qsort_comp);
        
        pextra->crpexSize = messpair_pos + ext_cnt_lf;
        
        ipx = pextra->crpexSize/2;

        #if LOG_P6_CROP_EN
        for (i=0; i < (pextra->crpexSize/2); i++) {
            sprintf_f(rs->logs, "%d. qsort lf(%.2f, %.2f) rt(%.2f, %.2f) p%d\n", i, pextra->crpexLfPots[i*2], pextra->crpexLfPots[i*2+1], 
            pextra->crpexRtPots[i*2], pextra->crpexRtPots[i*2+1], midx);
            print_f(rs->plogs, "DoC", rs->logs);    
        }
        #endif

        #if 1
        ret = getRotateP1(ppt36, mostlft);
        if (!ret) {
            #if LOG_P6_CROP_EN
            sprintf_f(rs->logs, "get most left (%lf, %lf) \n", mostlft[0], mostlft[1]);
            print_f(rs->plogs, "DoC", rs->logs);
            #endif
        }
        
        fwh = mostlft[1] - (gap * 2);
        if (fwh < 0.0) {
            fwh = 0.0;
        }
        
        ret = getRotateP3(ppt36, mostrgt);
        if (!ret) {
            #if LOG_P6_CROP_EN
            sprintf_f(rs->logs, "get most right (%lf, %lf) \n", mostrgt[0], mostrgt[1]);
            print_f(rs->plogs, "DoC", rs->logs);
            #endif
        }
        
        fwe = mostrgt[1] - (gap * 2);
        if (fwe < 0.0) {
            fwe = 0.0;
        }
        
        cnt = 0; 
        idx = 0;
        for (ix = 0; ix < ipx; ix++) {
        
            #if LOG_P6_CROP_EN
            sprintf_f(rs->logs, "pt %d. L%.1lf, %.1lf R%.1lf, %.1lf \n", ix
                                  , pextra->crpexLfPots[ix*2+0], pextra->crpexLfPots[ix*2+1], pextra->crpexRtPots[ix*2+0], pextra->crpexRtPots[ix*2+1]);
            print_f(rs->plogs, "DoC", rs->logs);
            #endif
        
            hval = pextra->crpexLfPots[ix*2+1];
            cxm = pextra->crpexLfPots[ix*2+0];
            cxn = pextra->crpexRtPots[ix*2+0];
        
            fhi = hval;
        
            if (cnt < 4) {
                if (fhi > fwh) {
                    lftgrp[cnt][0] = cxm;
                    lftgrp[cnt][1] = fhi;
                    cnt ++;
                }
            }
        
            if (idx < 4) {
                if (fhi > fwe) {
                    rgtgrp[idx][0] = cxn;
                    rgtgrp[idx][1] = fhi;
                    idx ++;
                }
            }
        }
        
        /* fix most left and most right shift */  
        fhi = 0.0; fwh = 0.0; fwe = 0.0;
        for (ix=0; ix < 4; ix++) {
        
            #if LOG_P6_CROP_EN
            sprintf_f(rs->logs, "left apporach group (%lf, %lf) \n", lftgrp[ix][0], lftgrp[ix][1]);
            print_f(rs->plogs, "DoC", rs->logs);
            #endif
        
            fhi += lftgrp[ix][0] - mostlft[0];
            fwh += lftgrp[ix][0];
        }
        
        fwe = fhi / 4.0;
        if (fwe > 15.0) {
            mostlft[0] = fwh / 4.0;
            setRotateP1(ppt36, mostlft);
        
            #if 1//LOG_P6_CROP_EN
            sprintf_f(rs->logs, "correct most left (%lf, %lf) \n", mostlft[0], mostlft[1]);
            print_f(rs->plogs, "DoC", rs->logs);
            #endif
        }
        
        fhi = 0.0; fwh = 0.0; fwe = 0.0;
        for (ix=0; ix < 4; ix++) {
        
            #if LOG_P6_CROP_EN
            sprintf_f(rs->logs, "right apporach group (%lf, %lf) \n", rgtgrp[ix][0], rgtgrp[ix][1]);
            print_f(rs->plogs, "DoC", rs->logs);
            #endif
        
            fhi += mostrgt[0] - rgtgrp[ix][0];
            fwh += rgtgrp[ix][0];
        }
        
        fwe = fhi / 4.0;
        if (fwe > 15.0) {
            mostrgt[0] = fwh / 4.0;
            setRotateP3(ppt36, mostrgt);
        
            #if 1//LOG_P6_CROP_EN
            sprintf_f(rs->logs, "correct most right (%lf, %lf) \n", mostrgt[0], mostrgt[1]);
            print_f(rs->plogs, "DoC", rs->logs);
            #endif
        }
        #endif
        
    }

    #if LOG_P6_CROP_EN
    msync(ppt36, sizeof(struct aspCrop36_s), MS_SYNC);
    ret = getRotateP1(ppt36, rotlf);
    if (!ret) {
        sprintf_f(rs->logs, "fixed P1 (%lf, %lf) \n", rotlf[0], rotlf[1]);
        print_f(rs->plogs, "DoC", rs->logs);
    }

    ret = getRotateP2(ppt36, rotup);
    if (!ret) {
        sprintf_f(rs->logs, "fixed P2 (%lf, %lf) \n", rotup[0], rotup[1]);
        print_f(rs->plogs, "DoC", rs->logs);
    }

    ret = getRotateP3(ppt36, rotrt);
    if (!ret) {
        sprintf_f(rs->logs, "fixed P3 (%lf, %lf) \n", rotrt[0], rotrt[1]);
        print_f(rs->plogs, "DoC", rs->logs);
    }

    ret = getRotateP4(ppt36, rotdn);
    if (!ret) {
        sprintf_f(rs->logs, "fixed P4 (%lf, %lf) \n", rotdn[0], rotdn[1]);
        print_f(rs->plogs, "DoC", rs->logs);
    }
    #endif
    
    /* second stage of cropping algorithm */
    msync(pextra, sizeof(struct aspCropExtra_s), MS_SYNC);
    findLine(ppt36, pextra, midx);

    msync(pextra, sizeof(struct aspCropExtra_s), MS_SYNC);
    ret = findUniPoints(ppt36, pextra);
    if (!ret) {
        msync(pextra, sizeof(struct aspCropExtra_s), MS_SYNC);
        calcuLine(pextra, midx);

        msync(pextra, sizeof(struct aspCropExtra_s), MS_SYNC);
        findBestLine(ppt36, pextra, midx);
    } else {
        getRectPoint(ppt36);
    }

    #if 0 /* test code */
    getRectPoint(ppt36);
    #endif

    #if LOG_P6_CROP_EN
    msync(ppt36, sizeof(struct aspCrop36_s), MS_SYNC);
    ret = getRotateP1(ppt36, rotlf);
    if (!ret) {
        sprintf_f(rs->logs, "get rotateP1 (%lf, %lf) \n", rotlf[0], rotlf[1]);
        print_f(rs->plogs, "DoC", rs->logs);
    }

    ret = getRotateP2(ppt36, rotup);
    if (!ret) {
        sprintf_f(rs->logs, "get rotateP2 (%lf, %lf) \n", rotup[0], rotup[1]);
        print_f(rs->plogs, "DoC", rs->logs);
    }

    ret = getRotateP3(ppt36, rotrt);
    if (!ret) {
        sprintf_f(rs->logs, "get rotateP3 (%lf, %lf) \n", rotrt[0], rotrt[1]);
        print_f(rs->plogs, "DoC", rs->logs);
    }

    ret = getRotateP4(ppt36, rotdn);
    if (!ret) {
        sprintf_f(rs->logs, "get rotateP4 (%lf, %lf) \n", rotdn[0], rotdn[1]);
        print_f(rs->plogs, "DoC", rs->logs);
    }
    #endif

    return 0;
}

void doCalculate(int *result, int *org, int org_len, int *mass, int mass_len, struct procRes_s *rs, int midx) 
{
    char dfile[128] = { 0 };
    int i=0;

    #if CROP_CALCU_PROCESS
    sprintf_f(rs->logs, "doCalculate org_len = %d, mass_len = %d \n", org_len, mass_len);
    print_f(rs->plogs, "DoC", rs->logs);
    #endif
        
    struct aspCrop36_s *pcp36 = (struct aspCrop36_s *) aspMemalloc(sizeof(struct aspCrop36_s), midx);
    struct aspCropExtra_s *pcpex = (struct aspCropExtra_s *) aspMemalloc(sizeof(struct aspCropExtra_s), midx);
    
    memset(pcp36, 0, sizeof(struct aspCrop36_s));
    memset(pcpex, 0, sizeof(struct aspCropExtra_s));

    int new_mass_len = mass_len;

    pcp36->crp36Pots[0] = 100;
    pcp36->crp36Pots[1] = 0;
    pcp36->crp36Pots[(CROP_MAX_NUM_META + 1) * 2] = 1100;
    pcp36->crp36Pots[(CROP_MAX_NUM_META + 1) * 2 + 1] = 0;

    for (i = 0; i < CROP_MAX_NUM_META * 2; i++) {
        pcp36->crp36Pots[i + 2] = (CFLOAT) org[i];
    }

    int messpair = new_mass_len / 4;

    #if CROP_CALCU_PROCESS
    sprintf_f(rs->logs, "messpair = %d, new_mass_len = %d \n", messpair, new_mass_len);
    print_f(rs->plogs, "DoC", rs->logs);
    #endif

    for (i = 0; i < messpair; i++) {
        pcpex->crpexLfPots[i * 2] = mass[4 * i];
        pcpex->crpexLfPots[i * 2 + 1] = mass[4 * i + 1];
        
        pcpex->crpexRtPots[i * 2] = mass[4 * i + 2];
        pcpex->crpexRtPots[i * 2 + 1] = mass[4 * i + 3];
    }

    int ret=0;
    ret = aspCrp36GetBoundry(pcp36, CROP_MAX_NUM_META + 2, pcpex->crpexLfPots, pcpex->crpexRtPots, messpair);

    #if CROP_CALCU_PROCESS
    for (i = 0; i < CROP_MAX_NUM_META; i++) {
        sprintf_f(rs->logs, "new 36 pts %d = (%.1lf, %.1lf) vs old (%d, %d) \n", (i+1), pcp36->crp36Pots[(i+1)*2], pcp36->crp36Pots[(i+1)*2+1], org[i*2], org[i*2+1]);
        print_f(rs->plogs, "DoC", rs->logs);
    }
    #endif
    
    int messpair_pos = messpair * 2;
    int ext_cnt_lf = 0;
    int ext_cnt_rt = 0;

    #if CROP_CALCU_PROCESS
    sprintf_f(rs->logs, "messpair_pos = %d \n", messpair_pos);
    print_f(rs->plogs, "DoC", rs->logs);
    #endif
    {
    
        if ((org[2] > pcp36->crp36Lf) && (org[4] < pcp36->crp36Rt)) {

            #if CROP_CALCU_PROCESS
            sprintf_f(rs->logs, "org pos %d (%d, %d) to extra lf%d \n", 2, org[2], org[3], ext_cnt_lf);
            print_f(rs->plogs, "DoC", rs->logs);
            #endif
         
            pcpex->crpexLfPots[messpair_pos + ext_cnt_lf++] = org[2];
            pcpex->crpexLfPots[messpair_pos + ext_cnt_lf++] = org[3];

            #if CROP_CALCU_PROCESS
            sprintf_f(rs->logs, "org pos %d (%d, %d) to extra rt%d \n", 4, org[4], org[5], ext_cnt_rt);
            print_f(rs->plogs, "DoC", rs->logs);
            #endif

            pcpex->crpexRtPots[messpair_pos + ext_cnt_rt++] = org[4];
            pcpex->crpexRtPots[messpair_pos + ext_cnt_rt++] = org[5];
        }
        
        if ((org[10] > pcp36->crp36Lf) && (org[8] < pcp36->crp36Rt)) {

            #if CROP_CALCU_PROCESS
            sprintf_f(rs->logs, "org pos %d (%d, %d) to extra lf%d\n", 10, org[10], org[11], ext_cnt_lf);
            print_f(rs->plogs, "DoC", rs->logs);
            #endif

            pcpex->crpexLfPots[messpair_pos + ext_cnt_lf++] = org[10];
            pcpex->crpexLfPots[messpair_pos + ext_cnt_lf++] = org[11];

            #if CROP_CALCU_PROCESS
            sprintf_f(rs->logs, "org pos %d (%d, %d) to extra rf%d\n", 8, org[8], org[9], ext_cnt_rt);
            print_f(rs->plogs, "DoC", rs->logs);
            #endif

            pcpex->crpexRtPots[messpair_pos + ext_cnt_rt++] = org[8];
            pcpex->crpexRtPots[messpair_pos + ext_cnt_rt++] = org[9];
        }

        for (i = 3; i < CROP_MAX_NUM_META / 2; i++) {
            if ((org[i * 4] > pcp36->crp36Lf) && (org[i * 4 + 2] < pcp36->crp36Rt)) {   
                #if CROP_CALCU_PROCESS
                sprintf_f(rs->logs, "org pos %d (%d, %d) to extra lf%d\n", i*4, org[i*4], org[i*4+1], ext_cnt_lf);
                print_f(rs->plogs, "DoC", rs->logs);
                #endif
         
                pcpex->crpexLfPots[messpair_pos + ext_cnt_lf++] = org[i * 4];
                pcpex->crpexLfPots[messpair_pos + ext_cnt_lf++] = org[i * 4 + 1];

                #if CROP_CALCU_PROCESS
                sprintf_f(rs->logs, "org pos %d (%d, %d) to extra rt%d\n", i*4+2, org[i*4+2], org[i*4+3], ext_cnt_rt);
                print_f(rs->plogs, "DoC", rs->logs);
                #endif

                pcpex->crpexRtPots[messpair_pos + ext_cnt_rt++] = org[i * 4 + 2];
                pcpex->crpexRtPots[messpair_pos + ext_cnt_rt++] = org[i * 4 + 3];
            }
        }
    }
    
    new_mass_len += ext_cnt_lf * 2;

    #if CROP_CALCU_PROCESS
    sprintf_f(rs->logs, "after add new_mass_len = %d \n", new_mass_len);
    print_f(rs->plogs, "DoC", rs->logs);
    #endif
    
    qsort((void *) pcpex->crpexLfPots, (new_mass_len / 4), sizeof(CFLOAT) * 2, qsort_comp);
    qsort((void *) pcpex->crpexRtPots, (new_mass_len / 4), sizeof(CFLOAT) * 2, qsort_comp);
    pcpex->crpexSize = new_mass_len / 2;

    #if CROP_CALCU_PROCESS
    for (i = 0; i < new_mass_len / 4; i++) {
        sprintf_f(rs->logs, "res pcpex->crpexLfPots[%d] = %.2lf, %.2lf \n", i, pcpex->crpexLfPots[2 * i], pcpex->crpexLfPots[2 * i + 1]);
        print_f(rs->plogs, "DoC", rs->logs);
    }
    
    for (i = 0; i < new_mass_len / 4; i++) {
        sprintf_f(rs->logs, "res pcpex->crpexRtPots[%d] = %.2lf, %.2lf \n", i, pcpex->crpexRtPots[2 * i], pcpex->crpexRtPots[2 * i + 1]);
        print_f(rs->plogs, "DoC", rs->logs);
    }
    #endif

    ret = 0;
    ret |= calcuCrossUpAph(pcp36, midx);

    ret |= calcuCrossDnAph(pcp36, midx);

    if (ret) {
        getRectPoint(pcp36);
    } else {
        ret = calcuMostRtLf(pcp36);
        if (ret == 0) {
            ret = calcuCrossUpLine(pcp36);
            ret = calcuCrossDnLine(pcp36);
            ret = getCrop36RotatePoints(pcp36);
        } else {
            getRectPoint(pcp36);
        }
    }

    result[0] = pcp36->crp36P1[0];
    result[1] = pcp36->crp36P1[1];
    result[2] = pcp36->crp36P2[0];
    result[3] = pcp36->crp36P2[1];
    result[4] = pcp36->crp36P3[0];
    result[5] = pcp36->crp36P3[1];
    result[6] = pcp36->crp36P4[0];
    result[7] = pcp36->crp36P4[1];

    /*
    sprintf_f(rs->logs, "first stage result p1 (%d, %d) \n", result[0], result[1]);
    print_f(rs->plogs, "DoC", rs->logs);
    
    sprintf_f(rs->logs, "first stage result p2 (%d, %d)\n", result[2], result[3]);
    print_f(rs->plogs, "DoC", rs->logs);

    sprintf_f(rs->logs, "first stage result p3 (%d, %d)\n", result[4], result[5]);
    print_f(rs->plogs, "DoC", rs->logs);

    sprintf_f(rs->logs, "first stage result p4 (%d, %d)\n", result[6], result[7]);
    print_f(rs->plogs, "DoC", rs->logs);
    */
    
    if (mass_len >= 8) {
        int gap = 0;
        for (i = 0; i < mass_len / 4 - 1; i++) {
            int y1 = mass[i * 4 + 1];
            int y2 = mass[(i + 1) * 4 + 1];
            int tempgap = y2 - y1;

            #if CROP_CALCU_PROCESS
            sprintf_f(rs->logs, "gap : index %d %d, yvalues %d %d, tempgap %d \n", i * 4 + 1, (i + 1) * 4 + 1, y1, y2, tempgap);
            print_f(rs->plogs, "DoC", rs->logs);
            #endif

            gap = tempgap;  
        }
        
        CFLOAT mostlft[2] = {0.0, 0.0};
        CFLOAT mostrgt[2] = {0.0, 0.0};
        CFLOAT lftgrp[10][2], rgtgrp[10][2], fhi = 0.0, fwh = 0.0, fwe = 0.0;
        memset(lftgrp, 0, sizeof(CFLOAT) * 10 * 2);
        memset(rgtgrp, 0, sizeof(CFLOAT) * 10 * 2);
        ret = getRotateP1(pcp36, mostlft);

        fwh = mostlft[1] - (gap * 2);
        if (fwh < 0.0) {
            fwh = 0.0;
        }

        ret = getRotateP3(pcp36, mostrgt);

        fwe = mostrgt[1] - (gap * 2);
        if (fwe < 0.0) {
            fwe = 0.0;
        }

        int cnt = 0;
        int ix = 0;
        int vhi, cxm, cxn;
        int cpx = pcpex->crpexSize / 2;

        #if CROP_CALCU_PROCESS
        sprintf_f(rs->logs, "cpx is %d \n", cpx);
        print_f(rs->plogs, "DoC", rs->logs);
        #endif

        for (i = 0; i < cpx; i++) {

            vhi = (int) pcpex->crpexLfPots[i * 2 + 1];
            cxm = (int) pcpex->crpexLfPots[i * 2 + 0];
            cxn = (int) pcpex->crpexRtPots[i * 2 + 0];

            fhi = (CFLOAT) vhi;
            if (cnt < 4) {
                if (fhi > fwh) {
                    lftgrp[cnt][0] = cxm;
                    lftgrp[cnt][1] = fhi;

                    cnt++;
                }
            }

            if (ix < 4) {
                if (fhi > fwe) {
                    rgtgrp[ix][0] = cxn;
                    rgtgrp[ix][1] = fhi;

                    ix++;
                }
            }
        }

        /* fix most left and most right shift */
        fhi = 0.0;
        fwh = 0.0;
        fwe = 0.0;
        for (ix = 0; ix < 4; ix++) {
            fhi += lftgrp[ix][0] - mostlft[0];
            fwh += lftgrp[ix][0];
        }

        fwe = fhi / 4.0;
        if (fwe > 15.0) {
            mostlft[0] = fwh / 4.0;
            setRotateP1(pcp36, mostlft);
        }

        fhi = 0.0;
        fwh = 0.0;
        fwe = 0.0;
        for (ix = 0; ix < 4; ix++) {
            fhi += mostrgt[0] - rgtgrp[ix][0];
            fwh += rgtgrp[ix][0];
        }

        fwe = fhi / 4.0;
        if (fwe > 15.0) {
            mostrgt[0] = fwh / 4.0;
            setRotateP3(pcp36, mostrgt);
        }
        //PAPA new version end

        pcp36->crp36Flag &= ~(CROP_SINGLE_LAST_SET);
        
        /* second stage of cropping algorithm */
        ret = findLine(pcp36, pcpex, midx);
        
        #if CROP_CALCU_PROCESS
        sprintf_f(rs->logs, "findLine ret = %d lfcut: %d, rtcut: %d \n", ret, pcpex->crpexLfAbsCut, pcpex->crpexRtAbsCut);
        print_f(rs->plogs, "DoC", rs->logs);
        #endif
        
        ret = findUniPoints(pcp36, pcpex);

        #if CROP_CALCU_PROCESS
        sprintf_f(rs->logs, "findUniPoints ret = %d \n", ret);
        print_f(rs->plogs, "DoC", rs->logs);
        #endif

        if (!ret) {
            calcuLine(pcpex, midx);
            findBestLine(pcp36, pcpex, midx);
        } else {
            getRectPoint(pcp36);
        }

        CFLOAT rotlf[2], rotup[2], rotrt[2], rotdn[2];

        ret = getRotateP1(pcp36, rotlf);
        if (!ret && CROP_CALCU_PROCESS) {
            sprintf_f(rs->logs, "getRotateP1 ret = %d, rotlf[0] = %.2lf, rotlf[1] = %.2lf \n", ret, rotlf[0], rotlf[1]);
            print_f(rs->plogs, "DoC", rs->logs);
        }

        ret = getRotateP2(pcp36, rotup);
        if (!ret && CROP_CALCU_PROCESS) {
            sprintf_f(rs->logs, "getRotateP2 ret = %d, rotup[0] = %.2lf, rotup[1] = %.2lf", ret, rotup[0], rotup[1]);
            print_f(rs->plogs, "DoC", rs->logs);

        }

        ret = getRotateP3(pcp36, rotrt);
        if (!ret && CROP_CALCU_PROCESS) {
            sprintf_f(rs->logs, "getRotateP3 ret = %d, rotrt[0] = %.2lf, rotrt[1] = %.2lf", ret, rotrt[0], rotrt[1]);
            print_f(rs->plogs, "DoC", rs->logs);

        }

        ret = getRotateP4(pcp36, rotdn);
        if (!ret && CROP_CALCU_PROCESS) {
            sprintf_f(rs->logs, "getRotateP4 ret = %d, rotdn[0] = %.2lf, rotdn[1] = %.2lf \n", ret, rotdn[0], rotdn[1]);
            print_f(rs->plogs, "DoC", rs->logs);
        }
        
        result[0] = rotlf[0];
        result[1] = rotlf[1];
        result[2] = rotup[0];
        result[3] = rotup[1];
        result[4] = rotrt[0];
        result[5] = rotrt[1];
        result[6] = rotdn[0];
        result[7] = rotdn[1];
    }

    #if CROP_CALCU_PROCESS
    sprintf_f(rs->logs, "most left right csup csdn:  lf(%.2lf, %.2lf) rt(%.2lf, %.2lf) up(%.2lf, %.2lf) dn(%.2lf, %.2lf) \n", 
        pcp36->crp36MsLf[0], pcp36->crp36MsLf[1], pcp36->crp36MsRt[0], pcp36->crp36MsRt[1],
        pcp36->crp36CsUp[0], pcp36->crp36CsUp[1], pcp36->crp36CsDn[0], pcp36->crp36CsDn[1]);
    print_f(rs->plogs, "DoC", rs->logs);
    sprintf_f(rs->logs, "most left right csup csdn angle:  lf(%.2lf) rt(%.2lf) up(%.2lf) dn(%.2lf) \n", pcp36->crp36AngleLf, pcp36->crp36AngleRt, pcp36->crp36AngleUp, pcp36->crp36AngleDn);
    print_f(rs->plogs, "DoC", rs->logs);
    #endif
    
    #if CROP_CALCU_PROCESS
    for (i = 0; i < 8; i++) {
        sprintf_f(rs->logs, "result[%d] = %d\n", i, result[i]);
        print_f(rs->plogs, "DoC", rs->logs);
    }
    #endif

}

static int getOrg(int *org, char *indat, int maxs, struct procRes_s *rs, int lyertot) 
{
    uint32_t cord=0, tmp=0;
    int len=0, val=0, hval=0, ret=0, ix=0, mlt=0, div=300, dpi=0, vdiv=1, inc=0;
    struct aspConfig_s *pct=0;
    struct aspMetaDataviaUSB_s *pscanInfo=0;
    struct intMbs32_s *pt=0;

    if (!indat) {
        return -1;
    }

    if (!org) {
        return -2;
    }

    pct = rs->pcfgTable;
    pscanInfo = (struct aspMetaDataviaUSB_s *)indat;
    val = sizeof(struct aspMetaDataviaUSB_s);

    len = (int)pscanInfo->MPIONT_LEN;
    val += len;

    #if CROP_CALCU_PROCESS
    sprintf_f(rs->logs, "mlen: %4d, (%4d vs %4d) \n", len, val, maxs);
    print_f(rs->plogs, "GetORG", rs->logs);
    #endif
    
    if (val > maxs) {
        return -3;
    }

    if (lyertot > 1) {
        vdiv = lyertot;
    }

    tmp = 0;
    ret = cfgTableGetChkDPI(pct, ASPOP_RESOLUTION, &tmp, ASPOP_STA_CON);    
    dpi = tmp;
    //sprintf_f(rs->logs, "get dpi: %d flag: %d ret: %d \n", dpi, tmp, ret);
    //print_f(rs->plogs, "GetORG", rs->logs);

    pt = &(pscanInfo->CROP_POS_1);
    for (ix = 0; ix < CROP_MAX_NUM_META; ix++) {
    
        cord = msb2lsb32(pt);
        val = cord >> 16;
        
        hval = cord & 0xffff;

        if (dpi < 300) {
            mlt = dpi * val;
            val = mlt / div;
        }

        inc = hval % vdiv;
            
        hval = hval / vdiv;
        if (inc > (vdiv/2)) {
            hval += 1;
        }

        org[ix*2+0] = val;
        org[ix*2+1] = hval;

        #if CROP_CALCU_PROCESS
        sprintf_f(rs->logs, "%4d. (%4d, %4d) \n", ix, val, hval);
        print_f(rs->plogs, "GetORG", rs->logs);
        #endif
                            
        pt++;
    }

    return 0;
}

static int getExtra(int *mass, char *indat, int maxs, struct procRes_s *rs, int lyertot) 
{
    uint32_t tmp=0;
    struct aspConfig_s *pct=0;
    struct aspMetaDataviaUSB_s *pscanInfo=0;
    struct aspCrop36_s *ppt36 = 0;
    char *ptext=0, *pch=0;
    unsigned short *shtbuf=0;
    int adpi=0, len=0, val=0, mlt=0, div=300, ret=0, dpi=0, vdiv=1, inc=0, vrlt=0;
    int gap=0, cy=0, lnrec=0, lnlength=0, masUsed=0, masRecd=0;
    int ix=0, cxm=0, cxn=0, ipx=0;

    if (!indat) {
        return -1;
    }

    if (!mass) {
        return -2;
    }

    if (lyertot > 1) {
        vdiv = lyertot;
    }
    
    msync(indat, maxs, MS_SYNC);
    pct = rs->pcfgTable;
    pscanInfo = (struct aspMetaDataviaUSB_s *)indat;
    val = sizeof(struct aspMetaDataviaUSB_s);

    len = (int)pscanInfo->MPIONT_LEN;
    val += len;

    #if CROP_CALCU_PROCESS
    sprintf_f(rs->logs, "totsz: %d, mlen: %d, max: %d \n", val, len, maxs); 
    print_f(rs->plogs, "GetEXT", rs->logs);
    #endif
    
    if (val > maxs) {
        return -3;
    }

    gap = pscanInfo->YLine_Gap;
    cy = pscanInfo->Start_YLine_No;
    len = (int)pscanInfo->MPIONT_LEN;
    
    pch = (char *)&(pscanInfo->YLines_Recorded);
    val = pch[0] << 8 | pch[1];
    lnrec = val;
    
    pch = &pscanInfo->EXTRA_POINT[2];
    val = pch[0] << 8 | pch[1];
    lnlength = val;
    
    #if CROP_CALCU_PROCESS
    sprintf_f(rs->logs, "gap: %d, yLine start: %d, yLine record: %d, exLen: %d\n", gap, cy, lnrec, lnlength); 
    print_f(rs->plogs, "GetEXT", rs->logs);
    #endif
    
    masUsed = lnlength;
    masRecd = lnrec;

    #if CROP_CALCU_PROCESS
    sprintf_f(rs->logs, "meta masspt info (used:%d, start:%d lineRec:%d gap:%d)\n", masUsed, cy, masRecd, gap); 
    print_f(rs->plogs, "GetEXT", rs->logs);
    #endif

    tmp = 0;
    ret = cfgTableGetChkDPI(pct, ASPOP_RESOLUTION, &tmp, ASPOP_STA_CON);    
    dpi = tmp;
    //sprintf_f(rs->logs, "get dpi: %d flag: %d ret: %d \n", dpi, tmp, ret);
    //print_f(rs->plogs, "GetEXT", rs->logs);

    shtbuf = (unsigned short *)&pscanInfo->EXTRA_POINT[4];

    ipx=0;
    for (ix = 0; ix < masRecd; ix++) {
    
        cxm = (int)*shtbuf;
        shtbuf++;
        cxn = (int)*shtbuf;
        shtbuf++;              

        if (dpi < 300) {
            mlt = dpi * cxm;
            cxm = mlt / div;
            mlt = dpi * cxn;
            cxn = mlt / div;
        }

        inc = cy % vdiv;
        vrlt = cy / vdiv;
            
        if (inc > (vdiv/2)) {
            vrlt += 1;
        }
        
        mass[ipx*4+0] = cxm;
        mass[ipx*4+1] = vrlt;
    
        mass[ipx*4+2] = cxn;
        mass[ipx*4+3] = vrlt;
    
        ipx ++;
        cy += gap;
    }

    #if CROP_CALCU_PROCESS
    sprintf_f(rs->logs, "total extra points size: %d \n", ipx);
    print_f(rs->plogs, "GetEXT", rs->logs);

    
    for (ix = 0; ix < masRecd; ix++) {
        sprintf_f(rs->logs, "unsort pt %d. L (%4d, %4d) R (%4d, %4d) \n", ix, mass[ix*4+0], mass[ix*4+1], mass[ix*4+2], mass[ix*4+3]);
        print_f(rs->plogs, "GetEXT", rs->logs);
    }
    #endif

    return 0;
}

#define LOG_ROTORI_DBG  (0)
static int findRectOrient(struct aspRectObj *pRout, struct aspRectObj *pRin)
{
    CFLOAT minH=0, minV=0, offsetH=0, offsetV=0;
    CFLOAT LUn[2], RUn[2], LDn[2], RDn[2];
    CFLOAT pLU[2], pRU[2], pLD[2], pRD[2];
    
    int LUt[2], RUt[2], LDt[2], RDt[2];
    int maxhint=0, maxvint=0, minhint=0, minvint=0, rowsize=0, rawszNew=0;
    
    if (!pRin) {
        return -1;
    }

    if (!pRout) {
        return -2;
    }

    memcpy(LUn, pRin->aspRectLU, sizeof(CFLOAT) * 2);
    memcpy(RUn, pRin->aspRectRU, sizeof(CFLOAT) * 2);
    memcpy(LDn, pRin->aspRectLD, sizeof(CFLOAT) * 2);
    memcpy(RDn, pRin->aspRectRD, sizeof(CFLOAT) * 2);
    
    minH = aspMin(LUn[0], RUn[0]);
    minH = aspMin(minH, LDn[0]);
    minH = aspMin(minH, RDn[0]);

    minV = aspMin(LUn[1], RUn[1]);
    minV = aspMin(minV, LDn[1]);
    minV = aspMin(minV, RDn[1]);

    offsetH = 0 - minH;
    offsetV = 0 - minV;

    #if 0
    LUn[0] += offsetH;
    LUn[1] += offsetV;

    RUn[0] += offsetH;
    RUn[1] += offsetV;

    LDn[0] += offsetH;
    LDn[1] += offsetV;

    RDn[0] += offsetH;
    RDn[1] += offsetV;
    #endif

    LUt[0] = (int)round(LUn[0]);
    LUt[1] = (int)round(LUn[1]);

    RUt[0] = (int)round(RUn[0]);
    RUt[1] = (int)round(RUn[1]);

    LDt[0] = (int)round(LDn[0]);
    LDt[1] = (int)round(LDn[1]);

    RDt[0] = (int)round(RDn[0]);
    RDt[1] = (int)round(RDn[1]);
    
    #if LOG_ROTORI_DBG
    printf("[ORT] bound: LUn: %lf, %lf -> %d, %d\n", LUn[0], LUn[1], LUt[0], LUt[1]);
    printf("[ORT] bound: RUn: %lf, %lf -> %d, %d \n", RUn[0], RUn[1], RUt[0], RUt[1]);
    printf("[ORT] bound: LDn: %lf, %lf -> %d, %d \n", LDn[0], LDn[1], LDt[0], LDt[1]);
    printf("[ORT] bound: RDn: %lf, %lf -> %d, %d \n", RDn[0], RDn[1], RDt[0], RDt[1]);
    #endif
    
    maxhint= aspMaxInt(LUt[0], RUt[0]);
    maxhint = aspMaxInt(maxhint, LDt[0]);
    maxhint = aspMaxInt(maxhint, RDt[0]);

    maxvint = aspMaxInt(LUt[1], RUt[1]);
    maxvint = aspMaxInt(maxvint, LDt[1]);
    maxvint = aspMaxInt(maxvint, RDt[1]);

    minhint= aspMinInt(LUt[0], RUt[0]);
    minhint = aspMinInt(minhint, LDt[0]);
    minhint = aspMinInt(minhint, RDt[0]);

    minvint = aspMinInt(LUt[1], RUt[1]);
    minvint = aspMinInt(minvint, LDt[1]);
    minvint = aspMinInt(minvint, RDt[1]);

    #if LOG_ROTORI_DBG    
    printf("[ORT] maxh: %d, minh: %d, maxv: %d, minv: %d \n", maxhint, minhint, maxvint, minvint);
    #endif

    pLU[0] = -1;
    pLU[1] = -1;
    pRU[0] = -1;
    pRU[1] = -1;
    pLD[0] = -1;
    pLD[1] = -1;
    pRD[0] = -1;
    pRD[1] = -1;

    if (minhint == LUt[0]) {
    
        #if LOG_ROTORI_DBG    
        printf("[ORT] LU =  %d, %d match minhint: %d !!!left - 0\n", LUt[0], LUt[1], minhint);
        #endif

        if (minvint == LUt[1]) {

            #if LOG_ROTORI_DBG    
            printf("[ORT] LU =  %d, %d match minvint: %d !!!left - 0\n", LUt[0], LUt[1], minvint);
            #endif
        
            pLD[0] = LUn[0];
            pLD[1] = LUn[1];

            #if LOG_ROTORI_DBG    
            printf("[ORT] set PLD = %lf, %lf\n", pLD[0], pLD[1]);
            #endif

        } else {
            if (maxvint == LUt[1]) {

                #if LOG_ROTORI_DBG    
                printf("[ORT] LU =  %d, %d match maxvint: %d !!!left - 0\n", LUt[0], LUt[1], maxvint);
                #endif

                pLU[0] = LUn[0];
                pLU[1] = LUn[1];

                #if LOG_ROTORI_DBG    
                printf("[ORT] set PLU = %lf, %lf\n", pLU[0], pLU[1]);
                #endif

            }
        }

        if ((maxvint == RUt[1]) || (maxvint == LUt[1]) || (minvint == LDt[1]) || (minvint == RDt[1])) {
            //if ((minvint == LDt[1]) || (minvint == RDt[1])) {
                if (RUt[0] >= LDt[0]) {
                    pLU[0] = LUn[0];
                    pLU[1] = LUn[1];

                    pLD[0] = LDn[0];
                    pLD[1] = LDn[1];
                } else if (RUt[0] < LDt[0]) {
                    pLU[0] = RUn[0];
                    pLU[1] = RUn[1];

                    pLD[0] = LUn[0];
                    pLD[1] = LUn[1];
                } else {
                    printf("[ORT] WARNING!! LU =  %d, %d not match!!!left - 1\n", LUt[0], LUt[1]);
                }
            //} else {
                //printf("[ORT] WARNING!! LU =  %d, %d not match!!! left - 2\n", LUt[0], LUt[1]);
            //}
        }

        
    }
    
    if (minhint == RUt[0]) {

        #if LOG_ROTORI_DBG    
        printf("[ORT] RU =  %d, %d match minhint: %d !!!left - 0\n", RUt[0], RUt[1], minhint);
        #endif

        if (minvint == RUt[1]) {

            #if LOG_ROTORI_DBG    
            printf("[ORT] RU =  %d, %d match minvint: %d !!!left - 0\n", RUt[0], RUt[1], minvint);
            #endif
            
            pLD[0] = RUn[0];
            pLD[1] = RUn[1];

            #if LOG_ROTORI_DBG    
            printf("[ORT] set PLD = %lf, %lf\n", pLD[0], pLD[1]);
            #endif
        } else {
            if (maxvint == RUt[1]) {

                #if LOG_ROTORI_DBG    
                printf("[ORT] RU =  %d, %d match maxvint: %d !!!left - 0\n", RUt[0], RUt[1], maxvint);
                #endif
                
                pLU[0] = RUn[0];
                pLU[1] = RUn[1];

                #if LOG_ROTORI_DBG    
                printf("[ORT] set PLU = %lf, %lf\n", pLU[0], pLU[1]);
                #endif
            }
        }

        if ((maxvint == RDt[1]) || (maxvint == RUt[1]) || (minvint == LUt[1]) || (minvint == LDt[1])) {
            //if ((minvint == LUt[1]) || (minvint == LDt[1])) {
                if (RDt[0] >= LUt[0]) {
                    pLU[0] = RUn[0];
                    pLU[1] = RUn[1];
        
                    pLD[0] = LUn[0];
                    pLD[1] = LUn[1];
                } else if (RDt[0] < LUt[0]) {
                    pLU[0] = RDn[0];
                    pLU[1] = RDn[1];
        
                    pLD[0] = RUn[0];
                    pLD[1] = RUn[1];
                } else {
                    printf("[ORT] WARNING!! RU =  %d, %d not match!!!left - 1\n", RUt[0], RUt[1]);
                }
            //} else {
                //printf("[ORT] WARNING!! RU =  %d, %d not match!!!left - 2\n", RUt[0], RUt[1]);
            //}
        }
    }
        
    if (minhint == LDt[0]) {

        #if LOG_ROTORI_DBG    
        printf("[ORT] LD =  %d, %d match minhint: %d !!!left - 0\n", LDt[0], LDt[1], minhint);
        #endif
        
        if (minvint == LDt[1]) {

            #if LOG_ROTORI_DBG    
            printf("[ORT] LD =  %d, %d match minvint: %d !!!left - 0\n", LDt[0], LDt[1], minvint);
            #endif

            pLD[0] = LDn[0];
            pLD[1] = LDn[1];

            #if LOG_ROTORI_DBG    
            printf("[ORT] set PLD = %lf, %lf\n", pLD[0], pLD[1]);
            #endif
        } else {
            if (maxvint == LDt[1]) {
                #if LOG_ROTORI_DBG    
                printf("[ORT] LD =  %d, %d match maxvint: %d !!!left - 0\n", LDt[0], LDt[1], maxvint);
                #endif

                pLU[0] = LDn[0];
                pLU[1] = LDn[1];

                #if LOG_ROTORI_DBG    
                printf("[ORT] set PLU = %lf, %lf\n", pLU[0], pLU[1]);
                #endif

            }
        }

        if ((maxvint == LUt[1]) || (maxvint == LDt[1]) || (minvint == RDt[1]) || (minvint == RUt[1])) {
            //if ((minvint == RDt[1]) || (minvint == RUt[1])) {
                if (LUt[0] >= RDt[0]) {
                    pLU[0] = LDn[0];
                    pLU[1] = LDn[1];
        
                    pLD[0] = RDn[0];
                    pLD[1] = RDn[1];
                } else if (LUt[0] < RDt[0]) {
                    pLU[0] = LUn[0];
                    pLU[1] = LUn[1];
        
                    pLD[0] = LDn[0];
                    pLD[1] = LDn[1];
                } else {
                    printf("[ORT] WARNING!! LD =  %d, %d not match!!!left - 1\n", LDt[0], LDt[1]);
                }
            //} else {
                //printf("[ORT] WARNING!! LD =  %d, %d not match!!!left - 2\n", LDt[0], LDt[1]);
            //}
        }
    }
        
    if (minhint == RDt[0]) {

        #if LOG_ROTORI_DBG    
        printf("[ORT] RD =  %d, %d match minhint: %d !!!left - 0\n", RDt[0], RDt[1], minhint);
        #endif

        if (minvint == RDt[1]) {

            #if LOG_ROTORI_DBG    
            printf("[ORT] RD =  %d, %d match minvint: %d !!!left - 0\n", RDt[0], RDt[1], minvint);
            #endif

            pLD[0] = RDn[0];
            pLD[1] = RDn[1];                    

            #if LOG_ROTORI_DBG    
            printf("[ORT] set PLD = %lf, %lf\n", pLD[0], pLD[1]);
            #endif
        } else {
            if (maxvint == RDt[1]) {

                #if LOG_ROTORI_DBG    
                printf("[ORT] RD =  %d, %d match maxvint: %d !!!left - 0\n", RDt[0], RDt[1], maxvint);
                #endif

                pLU[0] = RDn[0];
                pLU[1] = RDn[1];

                #if LOG_ROTORI_DBG    
                printf("[ORT] set PLU = %lf, %lf\n", pLU[0], pLU[1]);
                #endif
            }
        }

        if ((maxvint == LDt[1]) || (maxvint == RDt[1]) || (minvint == RUt[1]) || (minvint == LUt[1])) {
            //if ((minvint == RUt[1]) || (minvint == LUt[1])) {
                if (LDt[0] >= RUt[0]) {
                    pLU[0] = RDn[0];
                    pLU[1] = RDn[1];
        
                    pLD[0] = RUn[0];
                    pLD[1] = RUn[1];
                } else if (LDt[0] < RUt[0]) {
                    pLU[0] = LDn[0];
                    pLU[1] = LDn[1];
        
                    pLD[0] = RDn[0];
                    pLD[1] = RDn[1];
                } else {
                    printf("[ORT] WARNING!! RD =  %d, %d not match!!!left - 1\n", RDt[0], RDt[1]);
                }
            //} else {
                //printf("[ORT] WARNING!! RD =  %d, %d not match!!!left - 2\n", RDt[0], RDt[1]);
            //}
        }
    }

    if (maxhint == LUt[0]) {

        #if LOG_ROTORI_DBG    
        printf("[ORT] LU =  %d, %d match maxhint: %d !!!right - 0\n", LUt[0], LUt[1], maxhint);
        #endif

        if (minvint == LUt[1]) {
        
            #if LOG_ROTORI_DBG    
            printf("[ORT] LU =  %d, %d match minvint: %d !!!right - 0\n", LUt[0], LUt[1], minvint);
            #endif

            pRD[0] = LUn[0];
            pRD[1] = LUn[1];

            #if LOG_ROTORI_DBG    
            printf("[ORT] set PLD = %lf, %lf\n", pRD[0], pRD[1]);
            #endif

        } else {
            if (maxvint == LUt[1]) {

                #if LOG_ROTORI_DBG    
                printf("[ORT] LU =  %d, %d match maxvint: %d !!!right - 0\n", LUt[0], LUt[1], maxvint);
                #endif

                pRU[0] = LUn[0];
                pRU[1] = LUn[1];

                #if LOG_ROTORI_DBG    
                printf("[ORT] set PRU = %lf, %lf\n", pRU[0], pRU[1]);
                #endif

            }
        }
        
        if ((maxvint == LDt[1]) || (maxvint == LUt[1]) || (minvint == RUt[1]) || (minvint == RDt[1])) {
            //if ((minvint == RUt[1]) || (minvint == RDt[1])) {
                if (RUt[0] <= LDt[0]) {
                    pRU[0] = LDn[0];
                    pRU[1] = LDn[1];

                    pRD[0] = LUn[0];
                    pRD[1] = LUn[1];
                } else if (RUt[0] > LDt[0]) {
                    pRU[0] = LUn[0];
                    pRU[1] = LUn[1];

                    pRD[0] = RUn[0];
                    pRD[1] = RUn[1];
                } else {
                    printf("[ORT] WARNING!! LU =  %d, %d not match!!!right - 1\n", LUt[0], LUt[1]);
                }
            //} else {
                //printf("[ORT] WARNING!! LU =  %d, %d not match!!!right - 2\n", LUt[0], LUt[1]);
            //}
        }
    }
    
    if (maxhint == RUt[0]) {
    
        #if LOG_ROTORI_DBG    
        printf("[ORT] RU =  %d, %d match maxhint: %d !!!right - 0\n", RUt[0], RUt[1], maxhint);
        #endif

        if (minvint == RUt[1]) {

            #if LOG_ROTORI_DBG    
            printf("[ORT] RU =  %d, %d match minvint: %d !!!right - 0\n", RUt[0], RUt[1], minvint);
            #endif

            pRD[0] = RUn[0];
            pRD[1] = RUn[1];

            #if LOG_ROTORI_DBG    
            printf("[ORT] set PLD = %lf, %lf\n", pRD[0], pRD[1]);
            #endif

        } else {
            if (maxvint == RUt[1]) {

                #if LOG_ROTORI_DBG    
                printf("[ORT] RU =  %d, %d match maxvint: %d !!!right - 0\n", RUt[0], RUt[1], maxvint);
                #endif

                pRU[0] = RUn[0];
                pRU[1] = RUn[1];

                #if LOG_ROTORI_DBG    
                printf("[ORT] set PRU = %lf, %lf\n", pRU[0], pRU[1]);
                #endif

            }
        }

        if ((maxvint == LUt[1]) || (maxvint == RUt[1]) || (minvint == RDt[1]) || (minvint == LDt[1])) {
            //if ((minvint == RDt[1]) || (minvint == LDt[1])) {
                if (RDt[0] <= LUt[0]) {
                    pRU[0] = LUn[0];
                    pRU[1] = LUn[1];
        
                    pRD[0] = RUn[0];
                    pRD[1] = RUn[1];
                } else if (RDt[0] > LUt[0]) {
                    pRU[0] = RUn[0];
                    pRU[1] = RUn[1];
        
                    pRD[0] = RDn[0];
                    pRD[1] = RDn[1];
                } else {
                    printf("[ORT] WARNING!! RU =  %d, %d not match!!!right - 1\n", RUt[0], RUt[1]);
                }
            //} else {
                //printf("[ORT] WARNING!! RU =  %d, %d not match!!!right - 2\n", RUt[0], RUt[1]);
            //}
        }
    }
        
    if (maxhint == LDt[0]) {

        #if LOG_ROTORI_DBG    
        printf("[ORT] LD =  %d, %d match maxhint: %d !!!right - 0\n", LDt[0], LDt[1], maxhint);
        #endif

        if (minvint == LDt[1]) {

            #if LOG_ROTORI_DBG    
            printf("[ORT] LD =  %d, %d match minvint: %d !!!right - 0\n", LDt[0], LDt[1], minvint);
            #endif

            pRD[0] = LDn[0];
            pRD[1] = LDn[1];                  

            #if LOG_ROTORI_DBG    
            printf("[ORT] set PLD = %lf, %lf\n", pRD[0], pRD[1]);
            #endif

        } else {
            if (maxvint == LDt[1]) {

                #if LOG_ROTORI_DBG    
                printf("[ORT] LD =  %d, %d match maxvint: %d !!!right - 0\n", LDt[0], LDt[1], maxvint);
                #endif

                pRU[0] = LDn[0];
                pRU[1] = LDn[1];

                #if LOG_ROTORI_DBG    
                printf("[ORT] set PRU = %lf, %lf\n", pRU[0], pRU[1]);
                #endif

            }
        }
        
        if ((maxvint == RDt[1]) || (maxvint == LDt[1]) || (minvint == LUt[1]) || (minvint == RUt[1])) {
            //if ((minvint == LUt[1]) || (minvint == RUt[1])) {
                if (LUt[0] <= RDt[0]) {
                    pRU[0] = RDn[0];
                    pRU[1] = RDn[1];
        
                    pRD[0] = LDn[0];
                    pRD[1] = LDn[1];
                } else if (LUt[0] > RDt[0]) {
                    pRU[0] = LDn[0];
                    pRU[1] = LDn[1];
        
                    pRD[0] = LUn[0];
                    pRD[1] = LUn[1];
                } else {
                    printf("[ORT] WARNING!! LD =  %d, %d not match!!!right - 1\n", LDt[0], LDt[1]);
                }
            //} else {
                //printf("[ORT] WARNING!! LD =  %d, %d not match!!!right - 2\n", LDt[0], LDt[1]);
            //}
        }
    }
            
    if (maxhint == RDt[0]) {

        #if LOG_ROTORI_DBG    
        printf("[ORT] RD =  %d, %d match maxhint: %d !!!right - 0\n", RDt[0], RDt[1], maxhint);
        #endif

        if (minvint == RDt[1]) {

            #if LOG_ROTORI_DBG    
            printf("[ORT] RD =  %d, %d match minvint: %d !!!right - 0\n", RDt[0], RDt[1], minvint);
            #endif

            pRD[0] = RDn[0];
            pRD[1] = RDn[1];                    

            #if LOG_ROTORI_DBG    
            printf("[ORT] set PLD = %lf, %lf\n", pRD[0], pRD[1]);
            #endif

        } else {
            if (maxvint == RDt[1]) {

                #if LOG_ROTORI_DBG    
                printf("[ORT] RD =  %d, %d match maxvint: %d !!!right - 0\n", RDt[0], RDt[1], maxvint);
                #endif

                pRU[0] = RDn[0];
                pRU[1] = RDn[1];

                #if LOG_ROTORI_DBG    
                printf("[ORT] set PRU = %lf, %lf\n", pRU[0], pRU[1]);
                #endif

            }
        }
        
        if ((maxvint == RUt[1]) || (maxvint == RDt[1]) || (minvint == LDt[1]) || (minvint == LUt[1])) {
            //if ((minvint == LDt[1]) || (minvint == LUt[1])) {
                if (LDt[0] <= RUt[0]) {
                    pRU[0] = RUn[0];
                    pRU[1] = RUn[1];
        
                    pRD[0] = RDn[0];
                    pRD[1] = RDn[1];
                } else if (LDt[0] > RUt[0]) {
                    pRU[0] = RDn[0];
                    pRU[1] = RDn[1];
        
                    pRD[0] = LDn[0];
                    pRD[1] = LDn[1];
                } else {
                    printf("[ORT] WARNING!! RD =  %d, %d not match!!!right - 1\n", RDt[0], RDt[1]);
                }
            //} else {
                //printf("[ORT] WARNING!! RD =  %d, %d not match!!!right - 2\n", RDt[0], RDt[1]);
            //}
        }
    }

    memcpy(pRout->aspRectLU, pLU, sizeof(CFLOAT) * 2);
    memcpy(pRout->aspRectRU, pRU, sizeof(CFLOAT) * 2);
    memcpy(pRout->aspRectLD, pLD, sizeof(CFLOAT) * 2);
    memcpy(pRout->aspRectRD, pRD, sizeof(CFLOAT) * 2);
    
    return 0;
}

static inline char* getPixelN(char *rawCpy, int dx, int dy, int rowsz, int bitset, int n) 
{
    return (rawCpy + dx * bitset + dy * rowsz * n);
}

static inline char* getPixel(char *rawCpy, int dx, int dy, int rowsz, int bitset) 
{
    return (rawCpy + dx * bitset + dy * rowsz);
}
            

#define LOG_ROTMF_DBG  (0)
/**
 * rotateBMPMf - get a small rectangle from a big rectangle located in a bmp 
 * @@input parameter:
 * @cropinfo: info of target rectangle
 *    cropinfo[0]: x 
 *    cropinfo[1]: y
 *    cropinfo[2]: width
 *    cropinfo[3]: height
 *    cropinfo[4]: width of banknote area, could be estimating value, the value will be overwrited by 
 *                      algorithm's estimating value if the input value is zero
 *    cropinfo[5]: height of banknote area, could be estimating value, the value will be overwrited by 
 *                      algorithm's estimating value if the input value is zero
 *    cropinfo[6]: layer id ex: 0 to 3
 *    cropinfo[7]: total layer number ex: 4
 *
 * @bmpsrc: memory address of raw image for BMP
 * @pmreal: four coordinates of scaned image comes from croping algorithm 
 *    pmreal[0]: x of point 1
 *    pmreal[1]: y of point 1
 *    pmreal[2]: x of point 2
 *    pmreal[3]: y of point 2
 *    pmreal[4]: x of point 3
 *    pmreal[5]: y of point 3
 *    pmreal[6]: x of point 4
 *    pmreal[7]: y of point 4
 *    <example>
 *        int mreal[8], utmp, crod;
 *        utmp = msb2lsb32(&pusbmeta->CROP_POS_F1);
 *        crod = utmp & 0xffff;
 *        utmp = utmp >> 16;
 *        mreal[0] = utmp;
 *        mreal[1] = crod;
 *        
 *        utmp = msb2lsb32(&pusbmeta->CROP_POS_F2);
 *        crod = utmp & 0xffff;
 *        utmp = utmp >> 16;
 *        mreal[2] = utmp;
 *        mreal[3] = crod;
 *        
 *        utmp = msb2lsb32(&pusbmeta->CROP_POS_F3);
 *        crod = utmp & 0xffff;
 *        utmp = utmp >> 16;
 *        mreal[4] = utmp;
 *        mreal[5] = crod;
 *        
 *        utmp = msb2lsb32(&pusbmeta->CROP_POS_F4);
 *        crod = utmp & 0xffff;
 *        utmp = utmp >> 16;
 *        mreal[6] = utmp;
 *        mreal[7] = crod;
 * @pattern: the byte value you want to place in image if the transforming coordinates out of boundary
 * @midx: no matter if outside mothership
 *
 * @@output parameter:
 * @rotbuff: memory address to save raw image which is the result of rotate and crop rectangle
 * @headbuff: memory address of BMP header for bmpsrc, will be overwrite with new header for rotbuff, 
 *   the last four bytes save the rotating degree with integer
 * @cropinfo: WH info of target banknote rectangle
 *    cropinfo[4]: approx width base on pmreal, the original value will be overwrited if it is zero otherwise will be keep
 *    cropinfo[5]: approx heigh base on pmreal, the original value will be overwrited if it is zero otherwise will be keep 
 */
int rotateBMPMf(char *rotbuff, char *headbuff, int *cropinfo, char *bmpsrc, int *pmreal, int pattern, int midx)
{
#define UNIT_DEG (100.0)
#define MIN_P  (100.0)
#define BMP_8_BIT_HEAD_SIZE (1078)
#define V_FLIP_EN (0)
#define VIB_FILTER_EN (0)

    char *addr=0, *srcbuf=0, *ph, *rawCpy, *rawSrc, *rawTmp, *rawdest=0;
    int ret, bitset, len=0, totsz=0, lstsz=0, cnt=0, acusz=0, err=0, rvs=0;
    int rawsz=0, oldWidth=0, oldHeight=0, oldRowsz=0, oldTot=0;
    char ch;
    struct bitmapHeader_s *bheader;
    CFLOAT LU[2], RU[2], LD[2], RD[2];
    CFLOAT LUn[2], RUn[2], LDn[2], RDn[2];
    int LUt[2], RUt[2], LDt[2], RDt[2], drawCord[4], bmpScale[4], oldScale[4];
    int sdot[2], ddot[2];
    CFLOAT rangle[2], thacos=0, thasin=0, theta, piAngle = 180.0;
    CFLOAT minH=0, minV=0, offsetH=0, offsetV=0;
    int maxhint=0, maxvint=0, minhint=0, minvint=0, rowsize=0, rawszNew=0;
    int bpp=0, ix=0, iy=0, dx=0, dy=0, outi[2], id=0, ixd=0, iyn=0, ixn=0, offsetCal=0;
    CFLOAT ind[4], outd[2], fx=0, fy=0, tx=0, ty=0;
    CFLOAT *tars, *tarc;
    char gdat[3];
    char *dst=0, *src=0;
    char *paintcolr=0;

    int *crsAry, crsASize, expCAsize;
    CFLOAT linLU[3], linRU[3], linLD[3], linRD[3], linPal[3], linCrs[3];
    CFLOAT pLU[2], pRU[2], pLD[2], pRD[2], pal[2], par[2], pt[2];
    CFLOAT plm[2], prm[2], plc[2], prc[2], pn[2], ptop[2];
    CFLOAT maxhf=0, maxvf=0, minhf=0, minvf=0;
    CFLOAT imgw=0.0, imgh=0.0, imgdeg=0.0;
    int ublen=0, ubret=0, ubrst=0;
    uint32_t val=0;
    int cxm, cxn;
    int deg=0, layerId=-1, layerN=0;
    struct aspRectObj *pRectin=0, *pRectROI=0, *pRectinR=0;
    CFLOAT distH, distW;
    
    #if VIB_FILTER_EN
    int pixcnt=0, pixval=0, pixacu=0, pixvar=0, pixmin=0, pixdiv=0, pixvmin=0;
    #endif

    paintcolr = aspMemalloc(sizeof(char) * 4, midx); 
    pRectin = aspMemalloc(sizeof(struct aspRectObj), midx);
    pRectROI = aspMemalloc(sizeof(struct aspRectObj), midx);
    pRectinR = aspMemalloc(sizeof(struct aspRectObj), midx);

    memset(paintcolr, pattern&0xff, sizeof(char) * 4);
    
    srcbuf = bmpsrc;

    /* check header */
    //shmem_dump(srcbuf, 512);

    /* rotate */
    bheader = aspMemalloc(sizeof(struct bitmapHeader_s), midx);
    memset(bheader, 0, sizeof(struct bitmapHeader_s));

    ph = &bheader->aspbmpMagic[2];
    memcpy(ph, headbuff, sizeof(struct bitmapHeader_s) - 2);
    
    #if LOG_ROTMF_DBG    
    dbgBitmapHeader(bheader, len);
    #endif
    rawsz = bheader->aspbiRawSize;
    oldWidth = bheader->aspbiWidth;
    if (bheader->aspbiHeight < 0) {
        bheader->aspbiHeight = 0 - bheader->aspbiHeight;
        rvs = 1;
    }
    oldHeight = bheader->aspbiHeight;
    bpp = bheader->aspbiCPP >> 16;
    oldRowsz = ((bpp * oldWidth + 31) / 32) * 4;

    rawCpy = srcbuf;

    #if LOG_ROTMF_DBG    
    printf("rotate raw offset: %d \n", bheader->aspbhRawoffset); 
    #endif
    
    imgw = (CFLOAT)bheader->aspbiWidth;
    imgh = (CFLOAT)bheader->aspbiHeight;

    cxm = pmreal[0];
    cxn = pmreal[1];

    #if LOG_ROTMF_DBG    
    printf("rot meta get F1: (%d, %d) \n", cxm, cxn); 
    #endif

    LD[0] = (CFLOAT)cxm;
    LD[1] = (CFLOAT)cxn;

    cxm = pmreal[2];
    cxn = pmreal[3];

    #if LOG_ROTMF_DBG    
    printf("rot meta get F2: (%d, %d) \n", cxm, cxn); 
    #endif          

    RD[0] = (CFLOAT)cxm;
    RD[1] = (CFLOAT)cxn;

    cxm = pmreal[4];
    cxn = pmreal[5];

    #if LOG_ROTMF_DBG    
    printf("rot meta get F3: (%d, %d) \n", cxm, cxn); 
    #endif

    RU[0] = (CFLOAT)cxm;
    RU[1] = (CFLOAT)cxn;

    cxm = pmreal[6];
    cxn = pmreal[7];

    #if LOG_ROTMF_DBG    
    printf("rot meta get F4: (%d, %d) \n", cxm, cxn); 
    #endif          

    LU[0] = (CFLOAT)cxm;
    LU[1] = (CFLOAT)cxn;    
    
    memcpy(pRectin->aspRectLU, LU, sizeof(CFLOAT)*2);
    memcpy(pRectin->aspRectLD, LD, sizeof(CFLOAT)*2);
    memcpy(pRectin->aspRectRD, RD, sizeof(CFLOAT)*2);
    memcpy(pRectin->aspRectRU, RU, sizeof(CFLOAT)*2);

    findRectOrient(pRectinR, pRectin);

    #if LOG_ROTMF_DBG    
    dbgprintRect(pRectinR);
    #endif

    layerId = cropinfo[6];
    layerN = cropinfo[7];

    if ((cropinfo[4] == 0) && (cropinfo[5] == 0)) {
        distH = calcuDistance(pRectinR->aspRectLU, pRectinR->aspRectLD);
        distW = calcuDistance(pRectinR->aspRectLU, pRectinR->aspRectRU);

        cropinfo[4] = (int)round(distW);
        cropinfo[5] = (int)round(distH);
    }
    
    #if LOG_ROTMF_DBG    
    printf("WH: (%d, %d) \n", cropinfo[4], cropinfo[5]); 
    #endif          
    
    ret = getRotRectPointMf(cropinfo, pRectROI, &imgdeg, oldRowsz, bpp, pRectinR, midx);
    if (ret == 0) {
        memcpy(LU, pRectROI->aspRectLU, sizeof(CFLOAT)*2);
        memcpy(LD, pRectROI->aspRectLD, sizeof(CFLOAT)*2);
        memcpy(RD, pRectROI->aspRectRD, sizeof(CFLOAT)*2);
        memcpy(RU, pRectROI->aspRectRU, sizeof(CFLOAT)*2);
    } else {
        LU[0] = 0;
        LU[1] = bheader->aspbiHeight-1;

        RU[0] = bheader->aspbiWidth-1;
        RU[1] = bheader->aspbiHeight-1;        

        LD[0] = 0;
        LD[1] = 0;

        RD[0] = bheader->aspbiWidth-1;
        RD[1] = 0;

        err = ret;
    }

    #if LOG_ROTMF_DBG    
    printf("getRotRectPointMf: LUn: %lf, %lf\n", LU[0], LU[1]);
    printf("getRotRectPointMf: LDn: %lf, %lf \n", LD[0], LD[1]);
    printf("getRotRectPointMf: RDn: %lf, %lf \n", RD[0], RD[1]);
    printf("getRotRectPointMf: RUn: %lf, %lf \n", RU[0], RU[1]);
    printf("getRotRectPointMf: degree: %.2lf \n", imgdeg);
    #endif
    
    deg = (int)(imgdeg * UNIT_DEG);
    deg = 0 - deg;

    theta = (CFLOAT)deg;
    theta = theta / UNIT_DEG;

    theta = theta * M_PI / piAngle;

    thacos = cos(theta);
    thasin = sin(theta);
    
    rangle[0] = thacos;
    rangle[1] = thasin;
    
    calcuRotateCoordinates(LUt, LUn, LU, rangle);
    calcuRotateCoordinates(RUt, RUn, RU, rangle);
    calcuRotateCoordinates(LDt, LDn, LD, rangle);
    calcuRotateCoordinates(RDt, RDn, RD, rangle);
    
    #if LOG_ROTMF_DBG
    printf("rotate: LU: %.2lf, %.2lf -> %3d, %3d\n", LU[0], LU[1], LUt[0], LUt[1]);
    printf("rotate: LD: %.2lf, %.2lf -> %3d, %3d \n", LD[0], LD[1], LDt[0], LDt[1]);
    printf("rotate: RD: %.2lf, %.2lf -> %3d, %3d \n", RD[0], RD[1], RDt[0], RDt[1]);
    printf("rotate: RU: %.2lf, %.2lf -> %3d, %3d \n", RU[0], RU[1], RUt[0], RUt[1]);
    #endif
    
    minH = aspMin(LUn[0], RUn[0]);
    minH = aspMin(minH, LDn[0]);
    minH = aspMin(minH, RDn[0]);

    minV = aspMin(LUn[1], RUn[1]);
    minV = aspMin(minV, LDn[1]);
    minV = aspMin(minV, RDn[1]);
    
    offsetH = 0 - minH;
    offsetV = 0 - minV;

    LUn[0] += offsetH;
    LUn[1] += offsetV;

    RUn[0] += offsetH;
    RUn[1] += offsetV;

    LDn[0] += offsetH;
    LDn[1] += offsetV;

    RDn[0] += offsetH;
    RDn[1] += offsetV;

    LUt[0] = (int)round(LUn[0]);
    LUt[1] = (int)round(LUn[1]);

    RUt[0] = (int)round(RUn[0]);
    RUt[1] = (int)round(RUn[1]);

    LDt[0] = (int)round(LDn[0]);
    LDt[1] = (int)round(LDn[1]);

    RDt[0] = (int)round(RDn[0]);
    RDt[1] = (int)round(RDn[1]);
    
    #if LOG_ROTMF_DBG    
    printf("bound: LUn: %lf, %lf -> %d, %d\n", LUn[0], LUn[1], LUt[0], LUt[1]);
    printf("bound: RUn: %lf, %lf -> %d, %d \n", RUn[0], RUn[1], RUt[0], RUt[1]);
    printf("bound: LDn: %lf, %lf -> %d, %d \n", LDn[0], LDn[1], LDt[0], LDt[1]);
    printf("bound: RDn: %lf, %lf -> %d, %d \n", RDn[0], RDn[1], RDt[0], RDt[1]);
    #endif
    
    maxhint= aspMaxInt(LUt[0], RUt[0]);
    maxhint = aspMaxInt(maxhint, LDt[0]);
    maxhint = aspMaxInt(maxhint, RDt[0]);

    maxvint = aspMaxInt(LUt[1], RUt[1]);
    maxvint = aspMaxInt(maxvint, LDt[1]);
    maxvint = aspMaxInt(maxvint, RDt[1]);

    minhint= aspMinInt(LUt[0], RUt[0]);
    minhint = aspMinInt(minhint, LDt[0]);
    minhint = aspMinInt(minhint, RDt[0]);

    minvint = aspMinInt(LUt[1], RUt[1]);
    minvint = aspMinInt(minvint, LDt[1]);
    minvint = aspMinInt(minvint, RDt[1]);
    
    rowsize = ((bpp * (maxhint + 1) + 31) / 32) * 4;
    rawszNew = rowsize * (maxvint+1);

    bheader->aspbhSize = bheader->aspbhRawoffset + rawszNew;
    bheader->aspbiWidth = maxhint+1;
    bheader->aspbiHeight = maxvint+1;
    bheader->aspbiRawSize = rawszNew;

    ubrst = 512 - (bheader->aspbhSize % 512);
    
    #if LOG_ROTMF_DBG    
    printf("raw dest size: %d!!!\n", rawszNew);
    #endif
    
    rawdest = rotbuff;
    if (rawdest) {
        #if LOG_ROTMF_DBG    
        printf("get raw dest size: %d succeed!!!\n", rawszNew);
        #endif
    } else {
        printf("allocate raw dest size: %d failed!!!\n", rawszNew);
        return -1;
    }
    
    rawSrc = rawdest;

    #if LOG_ROTMF_DBG    
    printf("maxh: %d, minh: %d, maxv: %d, minv: %d \n", maxhint, minhint, maxvint, minvint);
    #endif

    pLU[0] = -1;
    pLU[1] = -1;
    pRU[0] = -1;
    pRU[1] = -1;
    pLD[0] = -1;
    pLD[1] = -1;
    pRD[0] = -1;
    pRD[1] = -1;

    if (minhint == LUt[0]) {
    
        #if LOG_ROTMF_DBG    
        printf("LU =  %d, %d match minhint: %d !!!left - 0\n", LUt[0], LUt[1], minhint);
        #endif

        if (minvint == LUt[1]) {

            #if LOG_ROTMF_DBG    
            printf("LU =  %d, %d match minvint: %d !!!left - 0\n", LUt[0], LUt[1], minvint);
            #endif
        
            pLD[0] = LUn[0];
            pLD[1] = LUn[1];

            #if LOG_ROTMF_DBG    
            printf("set PLD = %lf, %lf\n", pLD[0], pLD[1]);
            #endif

        } else {
            if (maxvint == LUt[1]) {

                #if LOG_ROTMF_DBG    
                printf("LU =  %d, %d match maxvint: %d !!!left - 0\n", LUt[0], LUt[1], maxvint);
                #endif

                pLU[0] = LUn[0];
                pLU[1] = LUn[1];

                #if LOG_ROTMF_DBG    
                printf("set PLU = %lf, %lf\n", pLU[0], pLU[1]);
                #endif
            }
        }
        
        if ((maxvint == RUt[1]) && (pLU[1] == -1)) {
            if ((minvint == LDt[1]) && (pLD[1] == -1)) {
                if (RUt[0] >= LDt[0]) {
                    pLU[0] = LUn[0];
                    pLU[1] = LUn[1];

                    pLD[0] = LDn[0];
                    pLD[1] = LDn[1];
                    
                    #if LOG_ROTMF_DBG    
                    printf("set PLU = %lf, %lf - 3\n", pLU[0], pLU[1]);
                    #endif

                    #if LOG_ROTMF_DBG    
                    printf("set PLD = %lf, %lf - 3 \n", pLD[0], pLD[1]);
                    #endif

                } else if (RUt[0] < LDt[0]) {
                    pLU[0] = RUn[0];
                    pLU[1] = RUn[1];

                    pLD[0] = LUn[0];
                    pLD[1] = LUn[1];

                    #if LOG_ROTMF_DBG    
                    printf("set PLU = %lf, %lf - 3\n", pLU[0], pLU[1]);
                    #endif

                    #if LOG_ROTMF_DBG    
                    printf("set PLD = %lf, %lf - 3 \n", pLD[0], pLD[1]);
                    #endif

                } else {
                    printf("WARNING!! LU =  %d, %d not match!!!left - 1\n", LUt[0], LUt[1]);
                }
            } else {
                printf("WARNING!! LU =  %d, %d not match!!! left - 2\n", LUt[0], LUt[1]);
            }
        }
    }
    
    if (minhint == RUt[0]) {

        #if LOG_ROTMF_DBG    
        printf("RU =  %d, %d match minhint: %d !!!left - 0\n", RUt[0], RUt[1], minhint);
        #endif

        if (minvint == RUt[1]) {

            #if LOG_ROTMF_DBG    
            printf("RU =  %d, %d match minvint: %d !!!left - 0\n", RUt[0], RUt[1], minvint);
            #endif
            
            pLD[0] = RUn[0];
            pLD[1] = RUn[1];

            #if LOG_ROTMF_DBG    
            printf("set PLD = %lf, %lf\n", pLD[0], pLD[1]);
            #endif
        } else {
            if (maxvint == RUt[1]) {

                #if LOG_ROTMF_DBG    
                printf("RU =  %d, %d match maxvint: %d !!!left - 0\n", RUt[0], RUt[1], maxvint);
                #endif
                
                pLU[0] = RUn[0];
                pLU[1] = RUn[1];

                #if LOG_ROTMF_DBG    
                printf("set PLU = %lf, %lf\n", pLU[0], pLU[1]);
                #endif               
            }
        }

        if ((maxvint == RDt[1]) && (pLU[1] == -1)) {
            if ((minvint == LUt[1]) && (pLD[1] == -1)) {
                if (RDt[0] >= LUt[0]) {
                    pLU[0] = RUn[0];
                    pLU[1] = RUn[1];
        
                    pLD[0] = LUn[0];
                    pLD[1] = LUn[1];

                    #if LOG_ROTMF_DBG    
                    printf("set PLU = %lf, %lf - 3\n", pLU[0], pLU[1]);
                    #endif

                    #if LOG_ROTMF_DBG    
                    printf("set PLD = %lf, %lf - 3 \n", pLD[0], pLD[1]);
                    #endif
                    
                } else if (RDt[0] < LUt[0]) {
                    pLU[0] = RDn[0];
                    pLU[1] = RDn[1];
        
                    pLD[0] = RUn[0];
                    pLD[1] = RUn[1];

                    #if LOG_ROTMF_DBG    
                    printf("set PLU = %lf, %lf - 3\n", pLU[0], pLU[1]);
                    #endif

                    #if LOG_ROTMF_DBG    
                    printf("set PLD = %lf, %lf - 3 \n", pLD[0], pLD[1]);
                    #endif
                    
                } else {
                    printf("WARNING!! RU =  %d, %d not match!!!left - 1\n", RUt[0], RUt[1]);
                }
            } else {
                printf("WARNING!! RU =  %d, %d not match!!!left - 2\n", RUt[0], RUt[1]);
            }
        }
    }
        
    if (minhint == LDt[0]) {

        #if LOG_ROTMF_DBG    
        printf("LD =  %d, %d match minhint: %d !!!left - 0\n", LDt[0], LDt[1], minhint);
        #endif
        
        if (minvint == LDt[1]) {

            #if LOG_ROTMF_DBG    
            printf("LD =  %d, %d match minvint: %d !!!left - 0\n", LDt[0], LDt[1], minvint);
            #endif

            pLD[0] = LDn[0];
            pLD[1] = LDn[1];

            #if LOG_ROTMF_DBG    
            printf("set PLD = %lf, %lf\n", pLD[0], pLD[1]);
            #endif
        } else {
            if (maxvint == LDt[1]) {
                #if LOG_ROTMF_DBG    
                printf("LD =  %d, %d match maxvint: %d !!!left - 0\n", LDt[0], LDt[1], maxvint);
                #endif

                pLU[0] = LDn[0];
                pLU[1] = LDn[1];

                #if LOG_ROTMF_DBG    
                printf("set PLU = %lf, %lf\n", pLU[0], pLU[1]);
                #endif                                
            }
        }

        if ((maxvint == LUt[1]) && (pLU[1] == -1)) {
            if ((minvint == RDt[1]) && (pLD[1] == -1)) {
                if (LUt[0] >= RDt[0]) {
                    pLU[0] = LDn[0];
                    pLU[1] = LDn[1];
        
                    pLD[0] = RDn[0];
                    pLD[1] = RDn[1];

                    #if LOG_ROTMF_DBG    
                    printf("set PLU = %lf, %lf - 3\n", pLU[0], pLU[1]);
                    #endif

                    #if LOG_ROTMF_DBG    
                    printf("set PLD = %lf, %lf - 3 \n", pLD[0], pLD[1]);
                    #endif
                } else if (LUt[0] < RDt[0]) {
                    pLU[0] = LUn[0];
                    pLU[1] = LUn[1];
        
                    pLD[0] = LDn[0];
                    pLD[1] = LDn[1];

                    #if LOG_ROTMF_DBG    
                    printf("set PLU = %lf, %lf - 3\n", pLU[0], pLU[1]);
                    #endif

                    #if LOG_ROTMF_DBG    
                    printf("set PLD = %lf, %lf - 3 \n", pLD[0], pLD[1]);
                    #endif
                } else {
                    printf("WARNING!! LD =  %d, %d not match!!!left - 1\n", LDt[0], LDt[1]);
                }
            } else {
                printf("WARNING!! LD =  %d, %d not match!!!left - 2\n", LDt[0], LDt[1]);
            }
        }
    }
        
    if (minhint == RDt[0]) {

        #if LOG_ROTMF_DBG    
        printf("RD =  %d, %d match minhint: %d !!!left - 0\n", RDt[0], RDt[1], minhint);
        #endif

        if (minvint == RDt[1]) {

            #if LOG_ROTMF_DBG    
            printf("RD =  %d, %d match minvint: %d !!!left - 0\n", RDt[0], RDt[1], minvint);
            #endif

            pLD[0] = RDn[0];
            pLD[1] = RDn[1];                    

            #if LOG_ROTMF_DBG    
            printf("set PLD = %lf, %lf\n", pLD[0], pLD[1]);
            #endif
        } else {
            if (maxvint == RDt[1]) {

                #if LOG_ROTMF_DBG    
                printf("RD =  %d, %d match maxvint: %d !!!left - 0\n", RDt[0], RDt[1], maxvint);
                #endif

                pLU[0] = RDn[0];
                pLU[1] = RDn[1];

                #if LOG_ROTMF_DBG    
                printf("set PLU = %lf, %lf\n", pLU[0], pLU[1]);
                #endif
            }
        }

        if ((maxvint == LDt[1]) && (pLU[1] == -1)) {
            if ((minvint == RUt[1]) && (pLD[1] == -1)) {
                if (LDt[0] >= RUt[0]) {
                    pLU[0] = RDn[0];
                    pLU[1] = RDn[1];
        
                    pLD[0] = RUn[0];
                    pLD[1] = RUn[1];

                    #if LOG_ROTMF_DBG    
                    printf("set PLU = %lf, %lf - 3\n", pLU[0], pLU[1]);
                    #endif

                    #if LOG_ROTMF_DBG    
                    printf("set PLD = %lf, %lf - 3 \n", pLD[0], pLD[1]);
                    #endif
                } else if (LDt[0] < RUt[0]) {
                    pLU[0] = LDn[0];
                    pLU[1] = LDn[1];
        
                    pLD[0] = RDn[0];
                    pLD[1] = RDn[1];

                    #if LOG_ROTMF_DBG    
                    printf("set PLU = %lf, %lf - 3\n", pLU[0], pLU[1]);
                    #endif

                    #if LOG_ROTMF_DBG    
                    printf("set PLD = %lf, %lf - 3 \n", pLD[0], pLD[1]);
                    #endif
                } else {
                    printf("WARNING!! RD =  %d, %d not match!!!left - 1\n", RDt[0], RDt[1]);
                }
            } else {
                printf("WARNING!! RD =  %d, %d not match!!!left - 2\n", RDt[0], RDt[1]);
            }
        }
    }

    if (maxhint == LUt[0]) {

        #if LOG_ROTMF_DBG    
        printf("LU =  %d, %d match maxhint: %d !!!right - 0\n", LUt[0], LUt[1], maxhint);
        #endif

        if (minvint == LUt[1]) {
        
            #if LOG_ROTMF_DBG    
            printf("LU =  %d, %d match minvint: %d !!!right - 0\n", LUt[0], LUt[1], minvint);
            #endif

            pRD[0] = LUn[0];
            pRD[1] = LUn[1];

            #if LOG_ROTMF_DBG    
            printf("set PRD = %lf, %lf\n", pRD[0], pRD[1]);
            #endif

        } else {
            if (maxvint == LUt[1]) {

                #if LOG_ROTMF_DBG    
                printf("LU =  %d, %d match maxvint: %d !!!right - 0\n", LUt[0], LUt[1], maxvint);
                #endif

                pRU[0] = LUn[0];
                pRU[1] = LUn[1];

                #if LOG_ROTMF_DBG    
                printf("set PRU = %lf, %lf\n", pRU[0], pRU[1]);
                #endif
            }
        }
        
        if ((maxvint == LDt[1]) && (pRU[1] == -1)) {
            if ((minvint == RUt[1]) && (pRD[1] == -1)) {
                if (RUt[0] <= LDt[0]) {
                    pRU[0] = LDn[0];
                    pRU[1] = LDn[1];

                    pRD[0] = LUn[0];
                    pRD[1] = LUn[1];

                    #if LOG_ROTMF_DBG    
                    printf("set PRU = %lf, %lf - 3\n", pRU[0], pRU[1]);
                    #endif

                    #if LOG_ROTMF_DBG    
                    printf("set PRD = %lf, %lf - 3\n", pRD[0], pRD[1]);
                    #endif
                
                } else if (RUt[0] > LDt[0]) {
                    pRU[0] = LUn[0];
                    pRU[1] = LUn[1];

                    pRD[0] = RUn[0];
                    pRD[1] = RUn[1];

                    #if LOG_ROTMF_DBG    
                    printf("set PRU = %lf, %lf - 3\n", pRU[0], pRU[1]);
                    #endif

                    #if LOG_ROTMF_DBG    
                    printf("set PRD = %lf, %lf - 3\n", pRD[0], pRD[1]);
                    #endif
                    
                } else {
                    printf("WARNING!! LU =  %d, %d not match!!!right - 1\n", LUt[0], LUt[1]);
                }
            } else {
                printf("WARNING!! LU =  %d, %d not match!!!right - 2\n", LUt[0], LUt[1]);
            }
        }
    }
    
    if (maxhint == RUt[0]) {
    
        #if LOG_ROTMF_DBG    
        printf("RU =  %d, %d match maxhint: %d !!!right - 0\n", RUt[0], RUt[1], maxhint);
        #endif

        if (minvint == RUt[1]) {

            #if LOG_ROTMF_DBG    
            printf("RU =  %d, %d match minvint: %d !!!right - 0\n", RUt[0], RUt[1], minvint);
            #endif

            pRD[0] = RUn[0];
            pRD[1] = RUn[1];

            #if LOG_ROTMF_DBG    
            printf("set PRD = %lf, %lf\n", pRD[0], pRD[1]);
            #endif

        } else {
            if (maxvint == RUt[1]) {

                #if LOG_ROTMF_DBG    
                printf("RU =  %d, %d match maxvint: %d !!!right - 0\n", RUt[0], RUt[1], maxvint);
                #endif

                pRU[0] = RUn[0];
                pRU[1] = RUn[1];

                #if LOG_ROTMF_DBG    
                printf("set PRU = %lf, %lf\n", pRU[0], pRU[1]);
                #endif
            }
        }
        
        if ((maxvint == LUt[1]) && (pRU[1] == -1)) {
            if ((minvint == RDt[1]) && (pRD[1] == -1)) {
                if (RDt[0] <= LUt[0]) {
                    pRU[0] = LUn[0];
                    pRU[1] = LUn[1];
        
                    pRD[0] = RUn[0];
                    pRD[1] = RUn[1];

                    #if LOG_ROTMF_DBG    
                    printf("set PRU = %lf, %lf - 3\n", pRU[0], pRU[1]);
                    #endif

                    #if LOG_ROTMF_DBG    
                    printf("set PRD = %lf, %lf - 3\n", pRD[0], pRD[1]);
                    #endif
                } else if (RDt[0] > LUt[0]) {
                    pRU[0] = RUn[0];
                    pRU[1] = RUn[1];
        
                    pRD[0] = RDn[0];
                    pRD[1] = RDn[1];

                    #if LOG_ROTMF_DBG    
                    printf("set PRU = %lf, %lf - 3\n", pRU[0], pRU[1]);
                    #endif

                    #if LOG_ROTMF_DBG    
                    printf("set PRD = %lf, %lf - 3\n", pRD[0], pRD[1]);
                    #endif
                } else {
                    printf("WARNING!! RU =  %d, %d not match!!!right - 1\n", RUt[0], RUt[1]);
                }
            } else {
                printf("WARNING!! RU =  %d, %d not match!!!right - 2\n", RUt[0], RUt[1]);
            }
        }
    }
        
    if (maxhint == LDt[0]) {

        #if LOG_ROTMF_DBG    
        printf("LD =  %d, %d match maxhint: %d !!!right - 0\n", LDt[0], LDt[1], maxhint);
        #endif

        if (minvint == LDt[1]) {

            #if LOG_ROTMF_DBG    
            printf("LD =  %d, %d match minvint: %d !!!right - 0\n", LDt[0], LDt[1], minvint);
            #endif

            pRD[0] = LDn[0];
            pRD[1] = LDn[1];                  

            #if LOG_ROTMF_DBG    
            printf("set PRD = %lf, %lf\n", pRD[0], pRD[1]);
            #endif

        } else {
            if (maxvint == LDt[1]) {

                #if LOG_ROTMF_DBG    
                printf("LD =  %d, %d match maxvint: %d !!!right - 0\n", LDt[0], LDt[1], maxvint);
                #endif

                pRU[0] = LDn[0];
                pRU[1] = LDn[1];

                #if LOG_ROTMF_DBG    
                printf("set PRU = %lf, %lf\n", pRU[0], pRU[1]);
                #endif
            }
        }

        if ((maxvint == RDt[1]) && (pRU[1] == -1)) {
            if ((minvint == LUt[1]) && (pRD[1] == -1)) {
                if (LUt[0] <= RDt[0]) {
                    pRU[0] = RDn[0];
                    pRU[1] = RDn[1];
        
                    pRD[0] = LDn[0];
                    pRD[1] = LDn[1];

                    #if LOG_ROTMF_DBG    
                    printf("set PRU = %lf, %lf - 3\n", pRU[0], pRU[1]);
                    #endif

                    #if LOG_ROTMF_DBG    
                    printf("set PRD = %lf, %lf - 3\n", pRD[0], pRD[1]);
                    #endif
                } else if (LUt[0] > RDt[0]) {
                    pRU[0] = LDn[0];
                    pRU[1] = LDn[1];
        
                    pRD[0] = LUn[0];
                    pRD[1] = LUn[1];

                    #if LOG_ROTMF_DBG    
                    printf("set PRU = %lf, %lf - 3\n", pRU[0], pRU[1]);
                    #endif

                    #if LOG_ROTMF_DBG    
                    printf("set PRD = %lf, %lf - 3\n", pRD[0], pRD[1]);
                    #endif
                } else {
                    printf("WARNING!! LD =  %d, %d not match!!!right - 1\n", LDt[0], LDt[1]);
                }
            } else {
                printf("WARNING!! LD =  %d, %d not match!!!right - 2\n", LDt[0], LDt[1]);
            }
        }
    }
            
    if (maxhint == RDt[0]) {

        #if LOG_ROTMF_DBG    
        printf("RD =  %d, %d match maxhint: %d !!!right - 0\n", RDt[0], RDt[1], maxhint);
        #endif

        if (minvint == RDt[1]) {

            #if LOG_ROTMF_DBG    
            printf("RD =  %d, %d match minvint: %d !!!right - 0\n", RDt[0], RDt[1], minvint);
            #endif

            pRD[0] = RDn[0];
            pRD[1] = RDn[1];                    

            #if LOG_ROTMF_DBG    
            printf("set PRD = %lf, %lf\n", pRD[0], pRD[1]);
            #endif

        } else {
            if (maxvint == RDt[1]) {

                #if LOG_ROTMF_DBG    
                printf("RD =  %d, %d match maxvint: %d !!!right - 0\n", RDt[0], RDt[1], maxvint);
                #endif

                pRU[0] = RDn[0];
                pRU[1] = RDn[1];

                #if LOG_ROTMF_DBG    
                printf("set PRU = %lf, %lf\n", pRU[0], pRU[1]);
                #endif
            }
        }
        
        if ((maxvint == RUt[1]) && (pRU[1] == -1)) {
            if ((minvint == LDt[1]) && (pRD[1] == -1)) {
                if (LDt[0] <= RUt[0]) {
                    pRU[0] = RUn[0];
                    pRU[1] = RUn[1];
        
                    pRD[0] = RDn[0];
                    pRD[1] = RDn[1];
                    
                    #if LOG_ROTMF_DBG    
                    printf("set PRU = %lf, %lf - 3\n", pRU[0], pRU[1]);
                    #endif

                    #if LOG_ROTMF_DBG    
                    printf("set PRD = %lf, %lf - 3\n", pRD[0], pRD[1]);
                    #endif
                } else if (LDt[0] > RUt[0]) {
                    pRU[0] = RDn[0];
                    pRU[1] = RDn[1];
        
                    pRD[0] = LDn[0];
                    pRD[1] = LDn[1];
                    
                    #if LOG_ROTMF_DBG    
                    printf("set PRU = %lf, %lf - 3\n", pRU[0], pRU[1]);
                    #endif

                    #if LOG_ROTMF_DBG    
                    printf("set PRD = %lf, %lf - 3\n", pRD[0], pRD[1]);
                    #endif
                } else {
                    printf("WARNING!! RD =  %d, %d not match!!!right - 1\n", RDt[0], RDt[1]);
                }
            }
            else {
                printf("WARNING!! RD =  %d, %d not match!!!right - 2\n", RDt[0], RDt[1]);
            }
        }
    }

    LUt[0] = (int)round(pLU[0]*MIN_P);
    LUt[1] = (int)round(pLU[1]*MIN_P);

    RUt[0] = (int)round(pRU[0]*MIN_P);
    RUt[1] = (int)round(pRU[1]*MIN_P);

    LDt[0] = (int)round(pLD[0]*MIN_P);
    LDt[1] = (int)round(pLD[1]*MIN_P);

    RDt[0] = (int)round(pRD[0]*MIN_P);
    RDt[1] = (int)round(pRD[1]*MIN_P);

    pLU[0] = (CFLOAT)LUt[0];
    pLU[1] = (CFLOAT)LUt[1];
    pRU[0] = (CFLOAT)RUt[0];
    pRU[1] = (CFLOAT)RUt[1];
    pLD[0] = (CFLOAT)LDt[0];
    pLD[1] = (CFLOAT)LDt[1];
    pRD[0] = (CFLOAT)RDt[0];
    pRD[1] = (CFLOAT)RDt[1];

    pLU[0] = pLU[0]/MIN_P;
    pLU[1] = pLU[1]/MIN_P;
    pRU[0] = pRU[0]/MIN_P;
    pRU[1] = pRU[1]/MIN_P;
    pLD[0] = pLD[0]/MIN_P;
    pLD[1] = pLD[1]/MIN_P;
    pRD[0] = pRD[0]/MIN_P;
    pRD[1] = pRD[1]/MIN_P; 
    
    #if LOG_ROTMF_DBG
    printf("align: PLU: %lf, %lf \n", pLU[0], pLU[1]);
    printf("align: PRU: %lf, %lf \n", pRU[0], pRU[1]);
    printf("align: PLD: %lf, %lf \n", pLD[0], pLD[1]);
    printf("align: PRD: %lf, %lf \n", pRD[0], pRD[1]);
    #endif

    if (pLU[1] > pRU[1]) {
        #if LOG_ROTMF_DBG
        printf("PLU[1]: %lf  > PRU[1]: %lf \n", pLU[1], pRU[1]);
        #endif

        getVectorFromP(linLU, pLD, pLU);
        getVectorFromP(linLD, pLD, pRD);
        getVectorFromP(linRD, pRD, pRU);
        getVectorFromP(linRU, pRU, pLU);

        #if LOG_ROTMF_DBG
        printf("lineLU:(%lf, %lf, %lf) = pLU:(%lf, %lf) <-> pLD:(%lf, %lf)  \n", linLU[0], linLU[1], linLU[2], pLU[0], pLU[1], pLD[0], pLD[1]);
        printf("linLD:(%lf, %lf, %lf) = pLD:(%lf, %lf) <-> pRD:(%lf, %lf)  \n", linLD[0], linLD[1], linLD[2], pLD[0], pLD[1], pRD[0], pRD[1]);
        printf("linRD:(%lf, %lf, %lf) = pRD:(%lf, %lf) <-> pRU:(%lf, %lf)  \n", linRD[0], linRD[1], linRD[2], pRD[0], pRD[1], pRU[0], pRU[1]);
        printf("linRU:(%lf, %lf, %lf) = pRU:(%lf, %lf) <-> pLU:(%lf, %lf)  \n", linRU[0], linRU[1], linRU[2], pRU[0], pRU[1], pLU[0], pLU[1]);
        #endif

        plm[0] = pLD[0];
        plm[1] = pLD[1];
        
        prm[0] = pRU[0];
        prm[1] = pRU[1];
    }
    else {
        #if LOG_ROTMF_DBG
        printf("PLU[1]: %lf  <= PRU[1]: %lf \n", pLU[1], pRU[1]);
        #endif

        getVectorFromP(linLU, pRU, pLU);
        getVectorFromP(linLD, pLU, pLD);
        getVectorFromP(linRD, pLD, pRD);
        getVectorFromP(linRU, pRD, pRU);

        #if LOG_ROTMF_DBG
        printf("lineLU:(%lf, %lf, %lf) = pRU:(%lf, %lf) <-> pLU:(%lf, %lf)  \n", linLU[0], linLU[1], linLU[2], pRU[0], pRU[1], pLU[0], pLU[1]);
        printf("linLD:(%lf, %lf, %lf) = pLU:(%lf, %lf) <-> pLD:(%lf, %lf)  \n", linLD[0], linLD[1], linLD[2], pLU[0], pLU[1], pLD[0], pLD[1]);
        printf("linRD:(%lf, %lf, %lf) = pLD:(%lf, %lf) <-> pRD:(%lf, %lf)  \n", linRD[0], linRD[1], linRD[2], pLD[0], pLD[1], pRD[0], pRD[1]);
        printf("linRU:(%lf, %lf, %lf) = pRU:(%lf, %lf) <-> pLU:(%lf, %lf)  \n", linRU[0], linRU[1], linRU[2], pRD[0], pRD[1], pRU[0], pRU[1]);
        #endif
        
        plm[0] = pLU[0];
        plm[1] = pLU[1];
        
        prm[0] = pRD[0];
        prm[1] = pRD[1];
    }

    ret = getCross(linLD, linLU, plc);

    ret = getCross(linRD, linRU, prc);

    ret = getCross(linRU, linLU, ptop);

    ret= getCross(linRD, linLD, pn);

    
    #if LOG_ROTMF_DBG
    printf("test linLD cross linLU.  left %lf, %lf ret: %d \n", plc[0], plc[1], ret);
    printf("test linRD cross linRU.  right %lf, %lf ret: %d \n", prc[0], prc[1], ret);
    printf("test linRU cross linLU.  top %lf, %lf ret: %d \n", ptop[0], ptop[1], ret);
    printf("test linRD cross linLD.  down %lf, %lf ret: %d \n", pn[0], pn[1], ret);
    #endif

    pal[0] = 100;
    pal[1] = 100;

    par[0] = 100;
    par[1] = 1000;
    getVectorFromP(linPal, par, pal);        

    #if LOG_ROTMF_DBG
    printf("linPal:(%lf, %lf, %lf) = par:(%lf, %lf) <-> pal:(%lf, %lf)  \n", linPal[0], linPal[1], linPal[2], par[0], par[1], pal[0], pal[1]);
    #endif

    expCAsize = maxvint-minvint+1;
    len = 3*sizeof(int);
    crsAry = aspMemalloc(expCAsize*len, midx);

    #if LOG_ROTMF_DBG
    printf("bf trim r: %lf, l: %lf, top: %lf down: %lf \n", prm[1], plm[1], ptop[1], pn[1]);
    #endif
    
    pt[0] = 200.0;
    fy = ptop[1] - plm[1];
    if (fy < 1.0) {
        plm[1] = ptop[1];
    }

    fy = ptop[1] - prm[1];
    if (fy < 1.0) {
        prm[1] = ptop[1];
    }

    fy = plm[1] - pn[1];
    if (fy < 1.0) {
        plm[1] = pn[1];
    }

    fy = prm[1] - pn[1];
    if (fy < 1.0) {
        prm[1] = pn[1];
    }

    #if LOG_ROTMF_DBG
    printf("after trim r: %lf, l: %lf, top: %lf down: %lf \n", prm[1], plm[1], ptop[1], pn[1]);
    #endif

    for (iy=minvint, ix=0; ix < expCAsize; iy++, ix++) {
        pt[1] = (CFLOAT)iy;
        getRectVectorFromV(linCrs, pt, linPal);
        #if LOG_ROTMF_DBG
        printf("linCrs:(%lf, %lf, %lf) = pt:(%lf, %lf)  \n", linCrs[0], linCrs[1], linCrs[2], pt[0], pt[1]);
        #endif
        if (pt[1] > plm[1]) {
            getCross(linCrs, linLU, plc);
        } else {
            getCross(linCrs, linLD, plc);
        }
        if (pt[1] > prm[1]) {
            getCross(linCrs, linRU, prc);
        } else {
            getCross(linCrs, linRD, prc);
        }
        crsAry[ix*3+0] = iy;
        crsAry[ix*3+1] = (int)round(plc[0]);
        crsAry[ix*3+2] = (int)round(prc[0]);
    }



    /*
    for (ix=0; ix < (maxvint-minvint+1); ix++) {
        printf("list %d. %d, %d, %d (%d)\n", ix, crsAry[ix*3+0], crsAry[ix*3+1], crsAry[ix*3+2], crsAry[ix*3+2] - crsAry[ix*3+1]);
    }
    */
    
    #if LOG_ROTMF_DBG    
    printf("new bitmap H/V = %d /%d, rowsize: %d, rawsize: %d, buffused: %d, sizeof crsArry: %d\n", maxhint, maxvint, rowsize, rawszNew, totsz, expCAsize);
    #endif
    
    /* retate raw data */
    oldScale[0] = oldRowsz;
    oldScale[1] = oldHeight;
    oldScale[2] = rawsz;
    oldScale[3] = bpp;        

    bmpScale[0] = rowsize;
    bmpScale[1] = maxvint;        
    bmpScale[2] = rawszNew;
    bmpScale[3] = bpp;

    rawTmp = rawSrc;
    //memset(rawTmp, 0, rawszNew);
    
    /* reverse to fill the rotate image */
    theta = (CFLOAT) (360*UNIT_DEG - deg);
    theta = theta / UNIT_DEG;
    
    #if LOG_ROTMF_DBG    
    printf("reverse rotate angle = %lf, deg: %d\n", theta, deg);
    #endif

    theta = theta * M_PI / piAngle;

    thacos = cos(theta);
    thasin = sin(theta);

    lstsz = 0;
    totsz = bheader->aspbhSize;
    bpp = bpp / 8;

    msync(crsAry, expCAsize*3*4, MS_SYNC);
    
    rawCpy += oldRowsz * layerId;
    
    cnt = 0;
    
    for (id=0; id < expCAsize; id++) {
        iy = crsAry[id*3+0];
        ix = crsAry[id*3+1];
        ixd = crsAry[id*3+2]; 

        fy = (CFLOAT)iy;
        fy -= offsetV;

        #if VIB_FILTER_EN
        pixcnt = 0;
        pixacu = 0;
        pixvar = 0;
        #endif
        
        for (;ix <= ixd; ix++) {       
            
            fx = (CFLOAT)ix;

            fx -= offsetH;

            dx = (int) round(fx*thacos - fy*thasin);
            dy = (int) round(fx*thasin + fy*thacos);

            cnt++;
            bitset = bpp;
            
            if ((dx < 0) || (dy < 0) || (dx >= oldWidth) || (dy >= oldHeight)) {
                src = paintcolr;
                //printf("ob dx: %d, dy: %d, ix: %d, iy: %d colr: 0x%.2x\n", dx, dy, ix, iy, src[0]);
                //continue;
            } else {
                src = getPixelN(rawCpy, dx, dy, oldRowsz, bitset, layerN);
            }

            #if VIB_FILTER_EN
            ch = *src;
            pixval = ch;

            if (pixmin) {
                pixdiv = abs(pixval - pixmin);
                
                pixvar += pixdiv;
            }
            pixacu += pixval;
            pixcnt ++;
                        
            //printf("(%d, %d) %d:%d:%d\n", ix, iy, pixmin, (pixmin - pixvmin*2), pixval);

            if (bitset == 1) {
                ch = *src;

                pixval = ch;
                if (pixval > (pixmin - (pixvmin*8)/10)) {
                    ch = 0xff;
                }

                *src = ch;
            }
            #endif
            
            #if V_FLIP_EN
            if (rvs) {
                //printf("(%d, %d) \n", ix, expCAsize - iy);
                dst = getPixel(rawTmp, ix, expCAsize - iy - 1, rowsize, bitset);
            } else {
                dst = getPixel(rawTmp, ix, iy, rowsize, bitset);
            }
            #else
            //printf("(%d, %d) %d\n", ix, iy, expCAsize - 1 - iy);
            dst = getPixel(rawTmp, ix, iy, rowsize, bitset);
            #endif
            
            cnt = 0;
            while (bitset > 0) {
                *dst = *src;

                bitset --;
                cnt++;
                src++;
                dst++;

                if (cnt > 2) break;
            }
        }

        #if VIB_FILTER_EN
        //printf("(%d, %d) c:%d a:%d m:%d v:%d vm:%d \n", ix, iy, pixcnt, pixacu, pixmin, pixvar, pixvmin);
        if (pixvar) {
            pixvmin = pixvar / pixcnt;
            pixmin = pixacu / pixcnt;
        } else {
            pixmin = pixacu / pixcnt;
        }
        #endif

        
    }

    msync(rawTmp, totsz, MS_SYNC); 

    deg = 0 - deg;
    if (deg > 180*UNIT_DEG) {
        deg = deg - 360*UNIT_DEG;
    }
    if (deg < -180*UNIT_DEG) {
        deg = deg + 360*UNIT_DEG;
    }
    
    bheader->aspbiNumImpColor = deg;

    #if !V_FLIP_EN
    if (rvs) {
        bheader->aspbiHeight = 0 - bheader->aspbiHeight;;
    }
    #endif

    #if LOG_ROTMF_DBG
    dbgBitmapHeader(bheader, sizeof(struct bitmapHeader_s) - 2);
    #endif
    
    memcpy(headbuff, ph, sizeof(struct bitmapHeader_s) - 2);
    
    aspFree(pRectin, midx);
    aspFree(pRectROI, midx);
    aspFree(pRectinR, midx);
    aspFree(bheader, midx);
    aspFree(crsAry, midx);
    
    return err; 
}

#define LOG_ROT_DBG  (0)
static int rotateBMP(struct procRes_s *rs, int *page, struct aspMetaData_s *meta, char *bmpsrc, char *bmphd, int hdlen, char *rotbuff, int *pside, int *pmreal, int *layers, int midx)
{
#define UNIT_DEG_BMP (1000.0)

    struct sdParseBuff_s *pabuf=0;
    char *addr=0, *srcbuf=0, *ph, *rawCpy, *rawSrc, *rawTmp, *rawdest=0;
    int ret, bitset, len=0, totsz=0, lstsz=0, cnt=0, acusz=0, err=0;
    int rawsz=0, oldWidth=0, oldHeight=0, oldRowsz=0, oldTot=0;
    char ch;
    struct bitmapHeader_s *bheader;
    CFLOAT LU[2], RU[2], LD[2], RD[2];
    CFLOAT LUn[2], RUn[2], LDn[2], RDn[2];
    int LUt[2], RUt[2], LDt[2], RDt[2], drawCord[4], bmpScale[4], oldScale[4];
    int sdot[2], ddot[2];
    CFLOAT rangle[2], thacos=0, thasin=0, theta, piAngle = 180.0;
    CFLOAT minH=0, minV=0, offsetH=0, offsetV=0;
    int maxhint=0, maxvint=0, minhint=0, minvint=0, rowsize=0, rawszNew=0;
    int bpp=0, ix=0, iy=0, dx=0, dy=0, outi[2], id=0, ixd=0, iyn=0, ixn=0, offsetCal=0;
    CFLOAT ind[4], outd[2], fx=0, fy=0, tx=0, ty=0;
    CFLOAT *tars, *tarc;
    char gdat[3];
    char *dst=0, *src=0;

    int *crsAry, crsASize, expCAsize;
    CFLOAT linLU[3], linRU[3], linLD[3], linRD[3], linPal[3], linCrs[3];
    CFLOAT pLU[2], pRU[2], pLD[2], pRD[2], pal[2], par[2], pt[2];
    CFLOAT plm[2], prm[2], plc[2], prc[2], pn[2];
    CFLOAT maxhf=0, maxvf=0, minhf=0, minvf=0;
    CFLOAT imgw=0.0, imgh=0.0, imgdeg=0.0;
    int ublen=0, ubret=0, ubrst=0;
    struct aspConfig_s *pct=0;
    uint32_t val=0;
    int cxm, cxn;
    int deg=0;
    struct aspRectObj *pRectin=0, *pRectROI=0, *pRectinR=0, *pRectroc=0;

    pRectin = aspMemalloc(sizeof(struct aspRectObj), midx);
    pRectROI = aspMemalloc(sizeof(struct aspRectObj), midx);
    pRectroc = aspMemalloc(sizeof(struct aspRectObj), midx);
    pRectinR = aspMemalloc(sizeof(struct aspRectObj), midx);
    
    pct = rs->pcfgTable;

    pabuf = &rs->psFat->parBuf;
    srcbuf = bmpsrc;

    /* check header */
    //shmem_dump(srcbuf, 512);

    /* rotate */
    bheader = rs->pbheader;
    ph = &bheader->aspbmpMagic[2];
    
    #if LOG_ROT_DBG    
    dbgBitmapHeader(bheader, len);
    #endif
    rawsz = bheader->aspbiRawSize;
    oldWidth = bheader->aspbiWidth;
    oldHeight = bheader->aspbiHeight;
    bpp = bheader->aspbiCPP >> 16;
    oldRowsz = ((bpp * oldWidth + 31) / 32) * 4;

    rawCpy = srcbuf;
        
    imgw = (CFLOAT)bheader->aspbiWidth;
    imgh = (CFLOAT)bheader->aspbiHeight;

    ret = cfgTableGet(pct, ASPOP_USBCROP_FP01, &val);
    cxm = (val>>16)&0xffff;
    cxn = val & 0xffff;

    sprintf_f(rs->logs, "rot meta get F1: (%d, %d) ret: %d\n", cxm, cxn, ret); 
    print_f(rs->plogs, "ROT", rs->logs);                     

    LD[0] = (CFLOAT)cxm;
    LD[1] = (CFLOAT)cxn;

    ret = cfgTableGet(pct, ASPOP_USBCROP_FP02, &val);
    cxm = (val>>16)&0xffff;
    cxn = val & 0xffff;

    sprintf_f(rs->logs, "rot meta get F2: (%d, %d) ret: %d\n", cxm, cxn, ret); 
    print_f(rs->plogs, "ROT", rs->logs);                     

    RD[0] = (CFLOAT)cxm;
    RD[1] = (CFLOAT)cxn;

    ret = cfgTableGet(pct, ASPOP_USBCROP_FP03, &val);
    cxm = (val>>16)&0xffff;
    cxn = val & 0xffff;

    sprintf_f(rs->logs, "rot meta get F3: (%d, %d) ret: %d\n", cxm, cxn, ret); 
    print_f(rs->plogs, "ROT", rs->logs);                     

    RU[0] = (CFLOAT)cxm;
    RU[1] = (CFLOAT)cxn;

    ret = cfgTableGet(pct, ASPOP_USBCROP_FP04, &val);
    cxm = (val>>16)&0xffff;
    cxn = val & 0xffff;

    sprintf_f(rs->logs, "rot meta get F4: (%d, %d) ret: %d\n", cxm, cxn, ret); 
    print_f(rs->plogs, "ROT", rs->logs);                     

    LU[0] = (CFLOAT)cxm;
    LU[1] = (CFLOAT)cxn;    
    
    memcpy(pRectin->aspRectLU, LU, sizeof(CFLOAT)*2);
    memcpy(pRectin->aspRectLD, LD, sizeof(CFLOAT)*2);
    memcpy(pRectin->aspRectRD, RD, sizeof(CFLOAT)*2);
    memcpy(pRectin->aspRectRU, RU, sizeof(CFLOAT)*2);

    findRectOrient(pRectinR, pRectin);
    
    dbgprintRect(pRectin);
    //dbgprintRect(pRectinR);
            
    ret = getRotRectPoint(rs, pRectinR, page, meta, midx, pRectROI, &imgdeg, pRectroc, rawCpy, oldRowsz, bpp, pside, pmreal);
    if (ret == 0) {
        memcpy(LU, pRectROI->aspRectLU, sizeof(CFLOAT)*2);
        memcpy(LD, pRectROI->aspRectLD, sizeof(CFLOAT)*2);
        memcpy(RD, pRectROI->aspRectRD, sizeof(CFLOAT)*2);
        memcpy(RU, pRectROI->aspRectRU, sizeof(CFLOAT)*2);
    } else {
        LU[0] = 0;
        LU[1] = bheader->aspbiHeight-1;

        RU[0] = bheader->aspbiWidth-1;
        RU[1] = bheader->aspbiHeight-1;        

        LD[0] = 0;
        LD[1] = 0;

        RD[0] = bheader->aspbiWidth-1;
        RD[1] = 0;

        err = ret;
    }

    #if LOG_ROT_DBG    
    sprintf_f(rs->logs, "getRotRectPoint: LUn: %lf, %lf\n", LU[0], LU[1]);
    print_f(rs->plogs, "ROT", rs->logs);
    sprintf_f(rs->logs, "getRotRectPoint: LDn: %lf, %lf \n", LD[0], LD[1]);
    print_f(rs->plogs, "ROT", rs->logs);
    sprintf_f(rs->logs, "getRotRectPoint: RDn: %lf, %lf \n", RD[0], RD[1]);
    print_f(rs->plogs, "ROT", rs->logs);
    sprintf_f(rs->logs, "getRotRectPoint: RUn: %lf, %lf \n", RU[0], RU[1]);
    print_f(rs->plogs, "ROT", rs->logs);
    sprintf_f(rs->logs, "getRotRectPoint: degree: %.2lf \n", imgdeg);
    print_f(rs->plogs, "ROT", rs->logs);
    #endif
    
    deg = (int)(imgdeg * UNIT_DEG_BMP);
    deg = 0 - deg;

    theta = (CFLOAT)deg;
    theta = theta / UNIT_DEG_BMP;
    
    sprintf_f(rs->logs, "rotate angle = %lf \n", theta);
    print_f(rs->plogs, "ROT", rs->logs);

    theta = theta * M_PI / piAngle;

    thacos = cos(theta);
    thasin = sin(theta);
    
    rangle[0] = thacos;
    rangle[1] = thasin;
    
    calcuRotateCoordinates(LUt, LUn, LU, rangle);
    calcuRotateCoordinates(RUt, RUn, RU, rangle);
    calcuRotateCoordinates(LDt, LDn, LD, rangle);
    calcuRotateCoordinates(RDt, RDn, RD, rangle);
    
    #if LOG_ROT_DBG
    sprintf_f(rs->logs, "rotate: LU: %.2lf, %.2lf -> %3d, %3d\n", LU[0], LU[1], LUt[0], LUt[1]);
    print_f(rs->plogs, "ROT", rs->logs);
    sprintf_f(rs->logs, "rotate: LD: %.2lf, %.2lf -> %3d, %3d \n", LD[0], LD[1], LDt[0], LDt[1]);
    print_f(rs->plogs, "ROT", rs->logs);
    sprintf_f(rs->logs, "rotate: RD: %.2lf, %.2lf -> %3d, %3d \n", RD[0], RD[1], RDt[0], RDt[1]);
    print_f(rs->plogs, "ROT", rs->logs);
    sprintf_f(rs->logs, "rotate: RU: %.2lf, %.2lf -> %3d, %3d \n", RU[0], RU[1], RUt[0], RUt[1]);
    print_f(rs->plogs, "ROT", rs->logs);
    #endif
    
    minH = aspMin(LUn[0], RUn[0]);
    minH = aspMin(minH, LDn[0]);
    minH = aspMin(minH, RDn[0]);

    minV = aspMin(LUn[1], RUn[1]);
    minV = aspMin(minV, LDn[1]);
    minV = aspMin(minV, RDn[1]);

    //sprintf_f(rs->logs, "minH: %lf, minV: %lf \n", minH, minV);
    //print_f(rs->plogs, "ROT", rs->logs);

    //minH = (minH > 0) ? (minH + 1):(minH-1);
    //minV = (minV > 0) ? (minV + 1):(minV-1);
    
    offsetH = 0 - minH;
    offsetV = 0 - minV;

    LUn[0] += offsetH;
    LUn[1] += offsetV;

    RUn[0] += offsetH;
    RUn[1] += offsetV;

    LDn[0] += offsetH;
    LDn[1] += offsetV;

    RDn[0] += offsetH;
    RDn[1] += offsetV;

    LUt[0] = (int)round(LUn[0]);
    LUt[1] = (int)round(LUn[1]);

    RUt[0] = (int)round(RUn[0]);
    RUt[1] = (int)round(RUn[1]);

    LDt[0] = (int)round(LDn[0]);
    LDt[1] = (int)round(LDn[1]);

    RDt[0] = (int)round(RDn[0]);
    RDt[1] = (int)round(RDn[1]);
    
    #if 0
    sprintf_f(rs->logs, "bound: LUn: %lf, %lf -> %d, %d\n", LUn[0], LUn[1], LUt[0], LUt[1]);
    print_f(rs->plogs, "ROT", rs->logs);
    sprintf_f(rs->logs, "bound: RUn: %lf, %lf -> %d, %d \n", RUn[0], RUn[1], RUt[0], RUt[1]);
    print_f(rs->plogs, "ROT", rs->logs);
    sprintf_f(rs->logs, "bound: LDn: %lf, %lf -> %d, %d \n", LDn[0], LDn[1], LDt[0], LDt[1]);
    print_f(rs->plogs, "ROT", rs->logs);
    sprintf_f(rs->logs, "bound: RDn: %lf, %lf -> %d, %d \n", RDn[0], RDn[1], RDt[0], RDt[1]);
    print_f(rs->plogs, "ROT", rs->logs);
    #endif
    
    maxhint= aspMaxInt(LUt[0], RUt[0]);
    maxhint = aspMaxInt(maxhint, LDt[0]);
    maxhint = aspMaxInt(maxhint, RDt[0]);

    maxvint = aspMaxInt(LUt[1], RUt[1]);
    maxvint = aspMaxInt(maxvint, LDt[1]);
    maxvint = aspMaxInt(maxvint, RDt[1]);

    minhint= aspMinInt(LUt[0], RUt[0]);
    minhint = aspMinInt(minhint, LDt[0]);
    minhint = aspMinInt(minhint, RDt[0]);

    minvint = aspMinInt(LUt[1], RUt[1]);
    minvint = aspMinInt(minvint, LDt[1]);
    minvint = aspMinInt(minvint, RDt[1]);
    
    rowsize = ((bpp * (maxhint + 1) + 31) / 32) * 4;
    rawszNew = rowsize * (maxvint + 1);

    bheader->aspbhSize = bheader->aspbhRawoffset + rawszNew;
    bheader->aspbiWidth = maxhint + 1;
    bheader->aspbiHeight = maxvint + 1;
    bheader->aspbiRawSize = rawszNew;

    ubrst = 512 - (bheader->aspbhSize % 512);
    
    #if LOG_ROT_DBG    
    sprintf_f(rs->logs, "allocate raw dest size: %d!!!\n", rawszNew);
    print_f(rs->plogs, "ROT", rs->logs);
    #endif
    
    rawdest = rotbuff;//aspMemalloc(bheader->aspbhSize + 512 + ubrst, midx);
    if (rawdest) {
    
        #if LOG_ROT_DBG    
        sprintf_f(rs->logs, "allocate raw dest size: %d succeed!!!\n", rawszNew);
        print_f(rs->plogs, "ROT", rs->logs);
        #endif

    } else {
        sprintf_f(rs->logs, "allocate raw dest size: %d failed!!!\n", rawszNew);
        print_f(rs->plogs, "ROT", rs->logs);
        return -1;
    }
    
    memcpy(rawdest, bmphd, hdlen);
    memcpy(rawdest, ph, 54);
    rawSrc = rawdest + bheader->aspbhRawoffset;

    if (hdlen != bheader->aspbhRawoffset) {
        sprintf_f(rs->logs, "Error!!! Rawoffset: %d not match head len: %d !!!\n", bheader->aspbhRawoffset, hdlen);
        print_f(rs->plogs, "ROT", rs->logs);
    }

    pabuf->dirBuffUsed = bheader->aspbhSize + ubrst;
    pabuf->dirParseBuff = rawdest;

    #if LOG_ROT_DBG    
    sprintf_f(rs->logs, "maxh: %d, minh: %d, maxv: %d, minv: %d \n", maxhint, minhint, maxvint, minvint);
    print_f(rs->plogs, "ROT", rs->logs);
    #endif

    pLU[0] = -1;
    pLU[1] = -1;
    pRU[0] = -1;
    pRU[1] = -1;
    pLD[0] = -1;
    pLD[1] = -1;
    pRD[0] = -1;
    pRD[1] = -1;

    if (minhint == LUt[0]) {
    
        #if LOG_ROT_DBG    
        sprintf_f(rs->logs, "LU =  %d, %d match minhint: %d !!!left - 0\n", LUt[0], LUt[1], minhint);
        print_f(rs->plogs, "ROT", rs->logs);
        #endif

        if (minvint == LUt[1]) {

            #if LOG_ROT_DBG    
            sprintf_f(rs->logs, "LU =  %d, %d match minvint: %d !!!left - 0\n", LUt[0], LUt[1], minvint);
            print_f(rs->plogs, "ROT", rs->logs);
            #endif
        
            pLD[0] = LUn[0];
            pLD[1] = LUn[1];

            #if LOG_ROT_DBG    
            sprintf_f(rs->logs, "set PLD = %lf, %lf\n", pLD[0], pLD[1]);
            print_f(rs->plogs, "ROT", rs->logs);
            #endif

        } else {
            if (maxvint == LUt[1]) {

                #if LOG_ROT_DBG    
                sprintf_f(rs->logs, "LU =  %d, %d match maxvint: %d !!!left - 0\n", LUt[0], LUt[1], maxvint);
                print_f(rs->plogs, "ROT", rs->logs);
                #endif

                pLU[0] = LUn[0];
                pLU[1] = LUn[1];

                #if LOG_ROT_DBG    
                sprintf_f(rs->logs, "set PLU = %lf, %lf\n", pLU[0], pLU[1]);
                print_f(rs->plogs, "ROT", rs->logs);
                #endif
            }
        }
        
        if ((maxvint == RUt[1]) && (pLU[1] == -1)) {
            if ((minvint == LDt[1]) && (pLD[1] == -1)) {
                if (RUt[0] >= LDt[0]) {
                    pLU[0] = LUn[0];
                    pLU[1] = LUn[1];

                    pLD[0] = LDn[0];
                    pLD[1] = LDn[1];
                    
                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PLU = %lf, %lf - 3\n", pLU[0], pLU[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PLD = %lf, %lf - 3 \n", pLD[0], pLD[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif

                } else if (RUt[0] < LDt[0]) {
                    pLU[0] = RUn[0];
                    pLU[1] = RUn[1];

                    pLD[0] = LUn[0];
                    pLD[1] = LUn[1];

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PLU = %lf, %lf - 3\n", pLU[0], pLU[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PLD = %lf, %lf - 3 \n", pLD[0], pLD[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif

                } else {
                    sprintf_f(rs->logs, "WARNING!! LU =  %d, %d not match!!!left - 1\n", LUt[0], LUt[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                }
            } else {
                sprintf_f(rs->logs, "WARNING!! LU =  %d, %d not match!!! left - 2\n", LUt[0], LUt[1]);
                print_f(rs->plogs, "ROT", rs->logs);
            }
        }
    }
    
    if (minhint == RUt[0]) {

        #if LOG_ROT_DBG    
        sprintf_f(rs->logs, "RU =  %d, %d match minhint: %d !!!left - 0\n", RUt[0], RUt[1], minhint);
        print_f(rs->plogs, "ROT", rs->logs);
        #endif

        if (minvint == RUt[1]) {

            #if LOG_ROT_DBG    
            sprintf_f(rs->logs, "RU =  %d, %d match minvint: %d !!!left - 0\n", RUt[0], RUt[1], minvint);
            print_f(rs->plogs, "ROT", rs->logs);
            #endif
            
            pLD[0] = RUn[0];
            pLD[1] = RUn[1];

            #if LOG_ROT_DBG    
            sprintf_f(rs->logs, "set PLD = %lf, %lf\n", pLD[0], pLD[1]);
            print_f(rs->plogs, "ROT", rs->logs);
            #endif
        } else {
            if (maxvint == RUt[1]) {

                #if LOG_ROT_DBG    
                sprintf_f(rs->logs, "RU =  %d, %d match maxvint: %d !!!left - 0\n", RUt[0], RUt[1], maxvint);
                print_f(rs->plogs, "ROT", rs->logs);
                #endif
                
                pLU[0] = RUn[0];
                pLU[1] = RUn[1];

                #if LOG_ROT_DBG    
                sprintf_f(rs->logs, "set PLU = %lf, %lf\n", pLU[0], pLU[1]);
                print_f(rs->plogs, "ROT", rs->logs);
                #endif               
            }
        }

        if ((maxvint == RDt[1]) && (pLU[1] == -1)) {
            if ((minvint == LUt[1]) && (pLD[1] == -1)) {
                if (RDt[0] >= LUt[0]) {
                    pLU[0] = RUn[0];
                    pLU[1] = RUn[1];
        
                    pLD[0] = LUn[0];
                    pLD[1] = LUn[1];

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PLU = %lf, %lf - 3\n", pLU[0], pLU[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PLD = %lf, %lf - 3 \n", pLD[0], pLD[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif
                    
                } else if (RDt[0] < LUt[0]) {
                    pLU[0] = RDn[0];
                    pLU[1] = RDn[1];
        
                    pLD[0] = RUn[0];
                    pLD[1] = RUn[1];

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PLU = %lf, %lf - 3\n", pLU[0], pLU[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PLD = %lf, %lf - 3 \n", pLD[0], pLD[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif
                    
                } else {
                    sprintf_f(rs->logs, "WARNING!! RU =  %d, %d not match!!!left - 1\n", RUt[0], RUt[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                }
            } else {
                sprintf_f(rs->logs, "WARNING!! RU =  %d, %d not match!!!left - 2\n", RUt[0], RUt[1]);
                print_f(rs->plogs, "ROT", rs->logs);
            }
        }
    }
        
    if (minhint == LDt[0]) {

        #if LOG_ROT_DBG    
        sprintf_f(rs->logs, "LD =  %d, %d match minhint: %d !!!left - 0\n", LDt[0], LDt[1], minhint);
        print_f(rs->plogs, "ROT", rs->logs);
        #endif
        
        if (minvint == LDt[1]) {

            #if LOG_ROT_DBG    
            sprintf_f(rs->logs, "LD =  %d, %d match minvint: %d !!!left - 0\n", LDt[0], LDt[1], minvint);
            print_f(rs->plogs, "ROT", rs->logs);
            #endif

            pLD[0] = LDn[0];
            pLD[1] = LDn[1];

            #if LOG_ROT_DBG    
            sprintf_f(rs->logs, "set PLD = %lf, %lf\n", pLD[0], pLD[1]);
            print_f(rs->plogs, "ROT", rs->logs);
            #endif
        } else {
            if (maxvint == LDt[1]) {
                #if LOG_ROT_DBG    
                sprintf_f(rs->logs, "LD =  %d, %d match maxvint: %d !!!left - 0\n", LDt[0], LDt[1], maxvint);
                print_f(rs->plogs, "ROT", rs->logs);
                #endif

                pLU[0] = LDn[0];
                pLU[1] = LDn[1];

                #if LOG_ROT_DBG    
                sprintf_f(rs->logs, "set PLU = %lf, %lf\n", pLU[0], pLU[1]);
                print_f(rs->plogs, "ROT", rs->logs);
                #endif                                
            }
        }

        if ((maxvint == LUt[1]) && (pLU[1] == -1)) {
            if ((minvint == RDt[1]) && (pLD[1] == -1)) {
                if (LUt[0] >= RDt[0]) {
                    pLU[0] = LDn[0];
                    pLU[1] = LDn[1];
        
                    pLD[0] = RDn[0];
                    pLD[1] = RDn[1];

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PLU = %lf, %lf - 3\n", pLU[0], pLU[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PLD = %lf, %lf - 3 \n", pLD[0], pLD[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif
                } else if (LUt[0] < RDt[0]) {
                    pLU[0] = LUn[0];
                    pLU[1] = LUn[1];
        
                    pLD[0] = LDn[0];
                    pLD[1] = LDn[1];

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PLU = %lf, %lf - 3\n", pLU[0], pLU[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PLD = %lf, %lf - 3 \n", pLD[0], pLD[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif
                } else {
                    sprintf_f(rs->logs, "WARNING!! LD =  %d, %d not match!!!left - 1\n", LDt[0], LDt[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                }
            } else {
                sprintf_f(rs->logs, "WARNING!! LD =  %d, %d not match!!!left - 2\n", LDt[0], LDt[1]);
                print_f(rs->plogs, "ROT", rs->logs);
            }
        }
    }
        
    if (minhint == RDt[0]) {

        #if LOG_ROT_DBG    
        sprintf_f(rs->logs, "RD =  %d, %d match minhint: %d !!!left - 0\n", RDt[0], RDt[1], minhint);
        print_f(rs->plogs, "ROT", rs->logs);
        #endif

        if (minvint == RDt[1]) {

            #if LOG_ROT_DBG    
            sprintf_f(rs->logs, "RD =  %d, %d match minvint: %d !!!left - 0\n", RDt[0], RDt[1], minvint);
            print_f(rs->plogs, "ROT", rs->logs);
            #endif

            pLD[0] = RDn[0];
            pLD[1] = RDn[1];                    

            #if LOG_ROT_DBG    
            sprintf_f(rs->logs, "set PLD = %lf, %lf\n", pLD[0], pLD[1]);
            print_f(rs->plogs, "ROT", rs->logs);
            #endif
        } else {
            if (maxvint == RDt[1]) {

                #if LOG_ROT_DBG    
                sprintf_f(rs->logs, "RD =  %d, %d match maxvint: %d !!!left - 0\n", RDt[0], RDt[1], maxvint);
                print_f(rs->plogs, "ROT", rs->logs);
                #endif

                pLU[0] = RDn[0];
                pLU[1] = RDn[1];

                #if LOG_ROT_DBG    
                sprintf_f(rs->logs, "set PLU = %lf, %lf\n", pLU[0], pLU[1]);
                print_f(rs->plogs, "ROT", rs->logs);
                #endif
            }
        }

        if ((maxvint == LDt[1]) && (pLU[1] == -1)) {
            if ((minvint == RUt[1]) && (pLD[1] == -1)) {
                if (LDt[0] >= RUt[0]) {
                    pLU[0] = RDn[0];
                    pLU[1] = RDn[1];
        
                    pLD[0] = RUn[0];
                    pLD[1] = RUn[1];

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PLU = %lf, %lf - 3\n", pLU[0], pLU[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PLD = %lf, %lf - 3 \n", pLD[0], pLD[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif
                } else if (LDt[0] < RUt[0]) {
                    pLU[0] = LDn[0];
                    pLU[1] = LDn[1];
        
                    pLD[0] = RDn[0];
                    pLD[1] = RDn[1];

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PLU = %lf, %lf - 3\n", pLU[0], pLU[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PLD = %lf, %lf - 3 \n", pLD[0], pLD[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif
                } else {
                    sprintf_f(rs->logs, "WARNING!! RD =  %d, %d not match!!!left - 1\n", RDt[0], RDt[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                }
            } else {
                sprintf_f(rs->logs, "WARNING!! RD =  %d, %d not match!!!left - 2\n", RDt[0], RDt[1]);
                print_f(rs->plogs, "ROT", rs->logs);
            }
        }
    }

    if (maxhint == LUt[0]) {

        #if LOG_ROT_DBG    
        sprintf_f(rs->logs, "LU =  %d, %d match maxhint: %d !!!right - 0\n", LUt[0], LUt[1], maxhint);
        print_f(rs->plogs, "ROT", rs->logs);
        #endif

        if (minvint == LUt[1]) {
        
            #if LOG_ROT_DBG    
            sprintf_f(rs->logs, "LU =  %d, %d match minvint: %d !!!right - 0\n", LUt[0], LUt[1], minvint);
            print_f(rs->plogs, "ROT", rs->logs);
            #endif

            pRD[0] = LUn[0];
            pRD[1] = LUn[1];

            #if LOG_ROT_DBG    
            sprintf_f(rs->logs, "set PRD = %lf, %lf\n", pRD[0], pRD[1]);
            print_f(rs->plogs, "ROT", rs->logs);
            #endif

        } else {
            if (maxvint == LUt[1]) {

                #if LOG_ROT_DBG    
                sprintf_f(rs->logs, "LU =  %d, %d match maxvint: %d !!!right - 0\n", LUt[0], LUt[1], maxvint);
                print_f(rs->plogs, "ROT", rs->logs);
                #endif

                pRU[0] = LUn[0];
                pRU[1] = LUn[1];

                #if LOG_ROT_DBG    
                sprintf_f(rs->logs, "set PRU = %lf, %lf\n", pRU[0], pRU[1]);
                print_f(rs->plogs, "ROT", rs->logs);
                #endif
            }
        }
        
        if ((maxvint == LDt[1]) && (pRU[1] == -1)) {
            if ((minvint == RUt[1]) && (pRD[1] == -1)) {
                if (RUt[0] <= LDt[0]) {
                    pRU[0] = LDn[0];
                    pRU[1] = LDn[1];

                    pRD[0] = LUn[0];
                    pRD[1] = LUn[1];

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PRU = %lf, %lf - 3\n", pRU[0], pRU[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PRD = %lf, %lf - 3\n", pRD[0], pRD[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif
                
                } else if (RUt[0] > LDt[0]) {
                    pRU[0] = LUn[0];
                    pRU[1] = LUn[1];

                    pRD[0] = RUn[0];
                    pRD[1] = RUn[1];

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PRU = %lf, %lf - 3\n", pRU[0], pRU[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PRD = %lf, %lf - 3\n", pRD[0], pRD[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif
                    
                } else {
                    sprintf_f(rs->logs, "WARNING!! LU =  %d, %d not match!!!right - 1\n", LUt[0], LUt[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                }
            } else {
                sprintf_f(rs->logs, "WARNING!! LU =  %d, %d not match!!!right - 2\n", LUt[0], LUt[1]);
                print_f(rs->plogs, "ROT", rs->logs);
            }
        }
    }
    
    if (maxhint == RUt[0]) {
    
        #if LOG_ROT_DBG    
        sprintf_f(rs->logs, "RU =  %d, %d match maxhint: %d !!!right - 0\n", RUt[0], RUt[1], maxhint);
        print_f(rs->plogs, "ROT", rs->logs);
        #endif

        if (minvint == RUt[1]) {

            #if LOG_ROT_DBG    
            sprintf_f(rs->logs, "RU =  %d, %d match minvint: %d !!!right - 0\n", RUt[0], RUt[1], minvint);
            print_f(rs->plogs, "ROT", rs->logs);
            #endif

            pRD[0] = RUn[0];
            pRD[1] = RUn[1];

            #if LOG_ROT_DBG    
            sprintf_f(rs->logs, "set PRD = %lf, %lf\n", pRD[0], pRD[1]);
            print_f(rs->plogs, "ROT", rs->logs);
            #endif

        } else {
            if (maxvint == RUt[1]) {

                #if LOG_ROT_DBG    
                sprintf_f(rs->logs, "RU =  %d, %d match maxvint: %d !!!right - 0\n", RUt[0], RUt[1], maxvint);
                print_f(rs->plogs, "ROT", rs->logs);
                #endif

                pRU[0] = RUn[0];
                pRU[1] = RUn[1];

                #if LOG_ROT_DBG    
                sprintf_f(rs->logs, "set PRU = %lf, %lf\n", pRU[0], pRU[1]);
                print_f(rs->plogs, "ROT", rs->logs);
                #endif
            }
        }
        
        if ((maxvint == LUt[1]) && (pRU[1] == -1)) {
            if ((minvint == RDt[1]) && (pRD[1] == -1)) {
                if (RDt[0] <= LUt[0]) {
                    pRU[0] = LUn[0];
                    pRU[1] = LUn[1];
        
                    pRD[0] = RUn[0];
                    pRD[1] = RUn[1];

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PRU = %lf, %lf - 3\n", pRU[0], pRU[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PRD = %lf, %lf - 3\n", pRD[0], pRD[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif
                } else if (RDt[0] > LUt[0]) {
                    pRU[0] = RUn[0];
                    pRU[1] = RUn[1];
        
                    pRD[0] = RDn[0];
                    pRD[1] = RDn[1];

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PRU = %lf, %lf - 3\n", pRU[0], pRU[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PRD = %lf, %lf - 3\n", pRD[0], pRD[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif
                } else {
                    sprintf_f(rs->logs, "WARNING!! RU =  %d, %d not match!!!right - 1\n", RUt[0], RUt[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                }
            } else {
                sprintf_f(rs->logs, "WARNING!! RU =  %d, %d not match!!!right - 2\n", RUt[0], RUt[1]);
                print_f(rs->plogs, "ROT", rs->logs);
            }
        }
    }
        
    if (maxhint == LDt[0]) {

        #if LOG_ROT_DBG    
        sprintf_f(rs->logs, "LD =  %d, %d match maxhint: %d !!!right - 0\n", LDt[0], LDt[1], maxhint);
        print_f(rs->plogs, "ROT", rs->logs);
        #endif

        if (minvint == LDt[1]) {

            #if LOG_ROT_DBG    
            sprintf_f(rs->logs, "LD =  %d, %d match minvint: %d !!!right - 0\n", LDt[0], LDt[1], minvint);
            print_f(rs->plogs, "ROT", rs->logs);
            #endif

            pRD[0] = LDn[0];
            pRD[1] = LDn[1];                  

            #if LOG_ROT_DBG    
            sprintf_f(rs->logs, "set PRD = %lf, %lf\n", pRD[0], pRD[1]);
            print_f(rs->plogs, "ROT", rs->logs);
            #endif

        } else {
            if (maxvint == LDt[1]) {

                #if LOG_ROT_DBG    
                sprintf_f(rs->logs, "LD =  %d, %d match maxvint: %d !!!right - 0\n", LDt[0], LDt[1], maxvint);
                print_f(rs->plogs, "ROT", rs->logs);
                #endif

                pRU[0] = LDn[0];
                pRU[1] = LDn[1];

                #if LOG_ROT_DBG    
                sprintf_f(rs->logs, "set PRU = %lf, %lf\n", pRU[0], pRU[1]);
                print_f(rs->plogs, "ROT", rs->logs);
                #endif
            }
        }

        if ((maxvint == RDt[1]) && (pRU[1] == -1)) {
            if ((minvint == LUt[1]) && (pRD[1] == -1)) {
                if (LUt[0] <= RDt[0]) {
                    pRU[0] = RDn[0];
                    pRU[1] = RDn[1];
        
                    pRD[0] = LDn[0];
                    pRD[1] = LDn[1];

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PRU = %lf, %lf - 3\n", pRU[0], pRU[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PRD = %lf, %lf - 3\n", pRD[0], pRD[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif
                } else if (LUt[0] > RDt[0]) {
                    pRU[0] = LDn[0];
                    pRU[1] = LDn[1];
        
                    pRD[0] = LUn[0];
                    pRD[1] = LUn[1];

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PRU = %lf, %lf - 3\n", pRU[0], pRU[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PRD = %lf, %lf - 3\n", pRD[0], pRD[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif
                } else {
                    sprintf_f(rs->logs, "WARNING!! LD =  %d, %d not match!!!right - 1\n", LDt[0], LDt[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                }
            } else {
                sprintf_f(rs->logs, "WARNING!! LD =  %d, %d not match!!!right - 2\n", LDt[0], LDt[1]);
                print_f(rs->plogs, "ROT", rs->logs);
            }
        }
    }
            
    if (maxhint == RDt[0]) {

        #if LOG_ROT_DBG    
        sprintf_f(rs->logs, "RD =  %d, %d match maxhint: %d !!!right - 0\n", RDt[0], RDt[1], maxhint);
        print_f(rs->plogs, "ROT", rs->logs);
        #endif

        if (minvint == RDt[1]) {

            #if LOG_ROT_DBG    
            sprintf_f(rs->logs, "RD =  %d, %d match minvint: %d !!!right - 0\n", RDt[0], RDt[1], minvint);
            print_f(rs->plogs, "ROT", rs->logs);
            #endif

            pRD[0] = RDn[0];
            pRD[1] = RDn[1];                    

            #if LOG_ROT_DBG    
            sprintf_f(rs->logs, "set PRD = %lf, %lf\n", pRD[0], pRD[1]);
            print_f(rs->plogs, "ROT", rs->logs);
            #endif

        } else {
            if (maxvint == RDt[1]) {

                #if LOG_ROT_DBG    
                sprintf_f(rs->logs, "RD =  %d, %d match maxvint: %d !!!right - 0\n", RDt[0], RDt[1], maxvint);
                print_f(rs->plogs, "ROT", rs->logs);
                #endif

                pRU[0] = RDn[0];
                pRU[1] = RDn[1];

                #if LOG_ROT_DBG    
                sprintf_f(rs->logs, "set PRU = %lf, %lf\n", pRU[0], pRU[1]);
                print_f(rs->plogs, "ROT", rs->logs);
                #endif
            }
        }
        
        if ((maxvint == RUt[1]) && (pRU[1] == -1)) {
            if ((minvint == LDt[1]) && (pRD[1] == -1)) {
                if (LDt[0] <= RUt[0]) {
                    pRU[0] = RUn[0];
                    pRU[1] = RUn[1];
        
                    pRD[0] = RDn[0];
                    pRD[1] = RDn[1];
                    
                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PRU = %lf, %lf - 3\n", pRU[0], pRU[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PRD = %lf, %lf - 3\n", pRD[0], pRD[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif
                } else if (LDt[0] > RUt[0]) {
                    pRU[0] = RDn[0];
                    pRU[1] = RDn[1];
        
                    pRD[0] = LDn[0];
                    pRD[1] = LDn[1];
                    
                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PRU = %lf, %lf - 3\n", pRU[0], pRU[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif

                    #if LOG_ROT_DBG    
                    sprintf_f(rs->logs, "set PRD = %lf, %lf - 3\n", pRD[0], pRD[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                    #endif
                } else {
                    sprintf_f(rs->logs, "WARNING!! RD =  %d, %d not match!!!right - 1\n", RDt[0], RDt[1]);
                    print_f(rs->plogs, "ROT", rs->logs);
                }
            }
            else {
                sprintf_f(rs->logs, "WARNING!! RD =  %d, %d not match!!!right - 2\n", RDt[0], RDt[1]);
                print_f(rs->plogs, "ROT", rs->logs);
            }
        }
    }

    LUt[0] = (int)round(pLU[0]*100000);
    LUt[1] = (int)round(pLU[1]*100000);

    RUt[0] = (int)round(pRU[0]*100000);
    RUt[1] = (int)round(pRU[1]*100000);

    LDt[0] = (int)round(pLD[0]*100000);
    LDt[1] = (int)round(pLD[1]*100000);

    RDt[0] = (int)round(pRD[0]*100000);
    RDt[1] = (int)round(pRD[1]*100000);

    pLU[0] = (CFLOAT)LUt[0];
    pLU[1] = (CFLOAT)LUt[1];
    pRU[0] = (CFLOAT)RUt[0];
    pRU[1] = (CFLOAT)RUt[1];
    pLD[0] = (CFLOAT)LDt[0];
    pLD[1] = (CFLOAT)LDt[1];
    pRD[0] = (CFLOAT)RDt[0];
    pRD[1] = (CFLOAT)RDt[1];

    pLU[0] = pLU[0]/100000.0;
    pLU[1] = pLU[1]/100000.0;
    pRU[0] = pRU[0]/100000.0;
    pRU[1] = pRU[1]/100000.0;
    pLD[0] = pLD[0]/100000.0;
    pLD[1] = pLD[1]/100000.0;
    pRD[0] = pRD[0]/100000.0;
    pRD[1] = pRD[1]/100000.0; 
    
    #if LOG_ROT_DBG
    sprintf_f(rs->logs, "align: PLU: %lf, %lf \n", pLU[0], pLU[1]);
    print_f(rs->plogs, "ROT", rs->logs);
    sprintf_f(rs->logs, "align: PRU: %lf, %lf \n", pRU[0], pRU[1]);
    print_f(rs->plogs, "ROT", rs->logs);
    sprintf_f(rs->logs, "align: PLD: %lf, %lf \n", pLD[0], pLD[1]);
    print_f(rs->plogs, "ROT", rs->logs);
    sprintf_f(rs->logs, "align: PRD: %lf, %lf \n", pRD[0], pRD[1]);
    print_f(rs->plogs, "ROT", rs->logs);
    #endif

    if (pLU[1] > pRU[1]) {
        #if LOG_ROT_DBG
        sprintf_f(rs->logs, "PLU[1]: %lf  > PRU[1]: %lf \n", pLU[1], pRU[1]);
        print_f(rs->plogs, "ROT", rs->logs);
        #endif

        getVectorFromP(linLU, pLD, pLU);
        getVectorFromP(linLD, pLD, pRD);
        getVectorFromP(linRD, pRD, pRU);
        getVectorFromP(linRU, pRU, pLU);

        #if LOG_ROT_DBG
        sprintf_f(rs->logs, "lineLU:(%lf, %lf, %lf) = pLU:(%lf, %lf) <-> pLD:(%lf, %lf)  \n", linLU[0], linLU[1], linLU[2], pLU[0], pLU[1], pLD[0], pLD[1]);
        print_f(rs->plogs, "ROT", rs->logs);
        
        sprintf_f(rs->logs, "linLD:(%lf, %lf, %lf) = pLD:(%lf, %lf) <-> pRD:(%lf, %lf)  \n", linLD[0], linLD[1], linLD[2], pLD[0], pLD[1], pRD[0], pRD[1]);
        print_f(rs->plogs, "ROT", rs->logs);

        sprintf_f(rs->logs, "linRD:(%lf, %lf, %lf) = pRD:(%lf, %lf) <-> pRU:(%lf, %lf)  \n", linRD[0], linRD[1], linRD[2], pRD[0], pRD[1], pRU[0], pRU[1]);
        print_f(rs->plogs, "ROT", rs->logs);
        
        sprintf_f(rs->logs, "linRU:(%lf, %lf, %lf) = pRU:(%lf, %lf) <-> pLU:(%lf, %lf)  \n", linRU[0], linRU[1], linRU[2], pRU[0], pRU[1], pLU[0], pLU[1]);
        print_f(rs->plogs, "ROT", rs->logs);
        #endif

        plm[0] = pLD[0];
        plm[1] = pLD[1];
        
        prm[0] = pRU[0];
        prm[1] = pRU[1];
    }
    else {
        #if LOG_ROT_DBG
        sprintf_f(rs->logs, "PLU[1]: %lf  <= PRU[1]: %lf \n", pLU[1], pRU[1]);
        print_f(rs->plogs, "ROT", rs->logs);
        #endif

        getVectorFromP(linLU, pRU, pLU);
        getVectorFromP(linLD, pLU, pLD);
        getVectorFromP(linRD, pLD, pRD);
        getVectorFromP(linRU, pRD, pRU);

        #if LOG_ROT_DBG
        sprintf_f(rs->logs, "lineLU:(%lf, %lf, %lf) = pRU:(%lf, %lf) <-> pLU:(%lf, %lf)  \n", linLU[0], linLU[1], linLU[2], pRU[0], pRU[1], pLU[0], pLU[1]);
        print_f(rs->plogs, "ROT", rs->logs);
        
        sprintf_f(rs->logs, "linLD:(%lf, %lf, %lf) = pLU:(%lf, %lf) <-> pLD:(%lf, %lf)  \n", linLD[0], linLD[1], linLD[2], pLU[0], pLU[1], pLD[0], pLD[1]);
        print_f(rs->plogs, "ROT", rs->logs);

        sprintf_f(rs->logs, "linRD:(%lf, %lf, %lf) = pLD:(%lf, %lf) <-> pRD:(%lf, %lf)  \n", linRD[0], linRD[1], linRD[2], pLD[0], pLD[1], pRD[0], pRD[1]);
        print_f(rs->plogs, "ROT", rs->logs);
        
        sprintf_f(rs->logs, "linRU:(%lf, %lf, %lf) = pRU:(%lf, %lf) <-> pLU:(%lf, %lf)  \n", linRU[0], linRU[1], linRU[2], pRD[0], pRD[1], pRU[0], pRU[1]);
        print_f(rs->plogs, "ROT", rs->logs);
        #endif
        
        plm[0] = pLU[0];
        plm[1] = pLU[1];
        
        prm[0] = pRD[0];
        prm[1] = pRD[1];
    }
    
    #if LOG_ROT_DBG
    ret = getCross(linLD, linLU, plc);
    sprintf_f(rs->logs, "test linLD cross linLU.  left %lf, %lf ret: %d \n", plc[0], plc[1], ret);
    print_f(rs->plogs, "ROT", rs->logs);
            
    ret = getCross(linRD, linRU, prc);
    sprintf_f(rs->logs, "test linRD cross linRU.  right %lf, %lf ret: %d \n", prc[0], prc[1], ret);
    print_f(rs->plogs, "ROT", rs->logs);

    ret = getCross(linRU, linLU, pt);
    sprintf_f(rs->logs, "test linRU cross linLU.  top %lf, %lf ret: %d \n", pt[0], pt[1], ret);
    print_f(rs->plogs, "ROT", rs->logs);

    ret= getCross(linRD, linLD, pn);
    sprintf_f(rs->logs, "test linRD cross linLD.  down %lf, %lf ret: %d \n", pn[0], pn[1], ret);
    print_f(rs->plogs, "ROT", rs->logs);
    #endif

    pal[0] = 100;
    pal[1] = 100;

    par[0] = 100;
    par[1] = 1000;
    getVectorFromP(linPal, par, pal);        

    #if LOG_ROT_DBG
    sprintf_f(rs->logs, "linPal:(%lf, %lf, %lf) = par:(%lf, %lf) <-> pal:(%lf, %lf)  \n", linPal[0], linPal[1], linPal[2], par[0], par[1], pal[0], pal[1]);
    print_f(rs->plogs, "ROT", rs->logs);
    #endif

    expCAsize = maxvint-minvint+1;
    len = 3*sizeof(int);
    //crsAry = aspMemalloc(expCAsize*len);
    crsAry = aspMemalloc(expCAsize*len, midx);
    #if 0
    crsAry = (int *)rs->pbrotate->aspRotCrossAry;
    crsASize = rs->pbrotate->aspRotCASize /len;
    if (expCAsize > crsASize) {
        expCAsize = crsASize;
    }
    #endif

    pt[0] = 200.0;
    for (iy=minvint, ix=0; ix < expCAsize; iy++, ix++) {
        pt[1] = (CFLOAT)iy;
        getRectVectorFromV(linCrs, pt, linPal);

        #if 0//LOG_ROT_DBG
        sprintf_f(rs->logs, "linCrs:(%lf, %lf, %lf) = pt:(%lf, %lf)  \n", linCrs[0], linCrs[1], linCrs[2], pt[0], pt[1]);
        print_f(rs->plogs, "ROT", rs->logs);
        #endif

        //getCross(linCrs, linPal, pn);
        //sprintf_f(rs->logs, "pn: %.4lf, %.4lf \n", pn[0], pn[1]);
        //print_f(rs->plogs, "ROT", rs->logs);

        if (pt[1] > plm[1]) {
            getCross(linCrs, linLU, plc);
        } else {
            getCross(linCrs, linLD, plc);
        }

        //sprintf_f(rs->logs, "%.4lf %.4lf, left cross (%.4lf, %.4lf) \n", pt[1], plm[1], plc[0], plc[1]);
        //print_f(rs->plogs, "ROT", rs->logs);

        if (pt[1] > prm[1]) {
            getCross(linCrs, linRU, prc);
        } else {
            getCross(linCrs, linRD, prc);
        }

        //sprintf_f(rs->logs, "%.4lf %.4lf, right cross (%.4lf, %.4lf) \n", pt[1], prm[1], prc[0], prc[1]);
        //print_f(rs->plogs, "ROT", rs->logs);
        
        crsAry[ix*3+0] = iy;
        crsAry[ix*3+1] = (int)round(plc[0]);
        crsAry[ix*3+2] = (int)round(prc[0]);
    }

    /*
    for (ix=0; ix < (maxvint-minvint+1); ix++) {
        sprintf_f(rs->logs, "%d. %d, %d, %d (%d)\n", ix, crsAry[ix*3+0], crsAry[ix*3+1], crsAry[ix*3+2], crsAry[ix*3+2] - crsAry[ix*3+1]);
        print_f(rs->plogs, "ROT", rs->logs);
    }
    */
    
    #if LOG_ROT_DBG    
    sprintf_f(rs->logs, "new bitmap H/V = %d /%d, rowsize: %d, rawsize: %d, buffused: %d, sizeof crsArry: %d\n", maxhint, maxvint, rowsize, rawszNew, totsz, expCAsize);
    print_f(rs->plogs, "ROT", rs->logs);
    #endif

    //memset(rawSrc, 0, rawszNew);
    
    /* retate raw data */
    //memset(rawSrc, 0xff, rawszNew);
    oldScale[0] = oldRowsz;
    oldScale[1] = oldHeight;
    oldScale[2] = rawsz;
    oldScale[3] = bpp;        

    bmpScale[0] = rowsize;
    bmpScale[1] = maxvint;        
    bmpScale[2] = rawszNew;
    bmpScale[3] = bpp;

    rawTmp = rawSrc;
    memset(rawTmp, 0xff, rawszNew);
    
    /* reverse to fill the rotate image */
    
    theta = (CFLOAT) (360*UNIT_DEG_BMP - deg);
    theta = theta / UNIT_DEG_BMP;
    
    #if LOG_ROT_DBG    
    sprintf_f(rs->logs, "reverse rotate angle = %lf \n", theta);
    print_f(rs->plogs, "ROT", rs->logs);
    #endif

    theta = theta * M_PI / piAngle;

    thacos = cos(theta);
    thasin = sin(theta);

    ix = (int)round(0 - offsetH);
    iy = (int)round(0 - offsetV);
    
    if (maxhint > maxvint) {
        oldTot = (int)round(maxhint - offsetH + 1);
    } else {
        oldTot = (int)round(maxvint - offsetV + 1);
    }

    if (ix < iy) {
        id = ix - 1;
    } else {
        id = iy - 1;
    }

    offsetCal = 0 - id;
    len = oldTot - id;

    #if 0 
    tars = aspMemalloc(sizeof(CFLOAT) * len);
    tarc = aspMemalloc(sizeof(CFLOAT) * len);

    sprintf_f(rs->logs, "pre-calculating buffer size: %d, max: %d, min: %d, offset: %d, tars: 0x%.8x, tarc: 0x%.8x\n", len, oldTot, id, offsetCal, tars, tarc);
    print_f(rs->plogs, "ROT", rs->logs);
    
    
    for (ix = id, iy = 0; iy < len; ix++, iy++) {

        fx = (CFLOAT)ix;
        tars[iy] = fx * thasin;
        tarc[iy] = fx * thacos;

        sprintf_f(rs->logs, "pre-calculate fx: %lf, sin: %lf, cos: %lf \n", fx, tars[iy], tarc[iy]);
        print_f(rs->plogs, "ROT", rs->logs);

    }
    #endif

    #if 0
    fx = LUn[0] - offsetH;
    fy = LUn[1] - offsetV;
    dx = (int) round(fx*thacos - fy*thasin);
    dy = (int) round(fx*thasin + fy*thacos);
    sprintf_f(rs->logs, "LU back %d(%f), %d(%f) => %d, %d offset(%f, %f)\n", LUt[0], fx, LUt[1], fy,  dx, dy, offsetH, offsetV);
    print_f(rs->plogs, "ROT", rs->logs);
    
    fx = RUn[0] - offsetH;
    fy = RUn[1] - offsetV;
    dx = (int) round(fx*thacos - fy*thasin);
    dy = (int) round(fx*thasin + fy*thacos);
    sprintf_f(rs->logs, "RU back %d(%f), %d(%f) => %d, %d offset(%f, %f)\n", RUt[0], fx, RUt[1], fy,  dx, dy, offsetH, offsetV);
    print_f(rs->plogs, "ROT", rs->logs);

    fx = RDn[0] - offsetH;
    fy = RDn[1] - offsetV;
    dx = (int) round(fx*thacos - fy*thasin);
    dy = (int) round(fx*thasin + fy*thacos);
    sprintf_f(rs->logs, "RD back %d(%f), %d(%f) => %d, %d offset(%f, %f)\n", RDt[0], fx, RDt[1], fy,  dx, dy, offsetH, offsetV);
    print_f(rs->plogs, "ROT", rs->logs);

    fx = LDn[0] - offsetH;
    fy = LDn[1] - offsetV;
    dx = (int) round(fx*thacos - fy*thasin);
    dy = (int) round(fx*thasin + fy*thacos);
    sprintf_f(rs->logs, "LD back %d(%f), %d(%f) => %d, %d offset(%f, %f)\n", LDt[0], fx, LDt[1], fy,  dx, dy, offsetH, offsetV);
    print_f(rs->plogs, "ROT", rs->logs);
    #endif

    lstsz = 0;
    totsz = bheader->aspbhSize;
    //ring_buf_init(&mrs->cmdRx);

    msync(crsAry, expCAsize*3*4, MS_SYNC);
    
    cnt = 0;
    for (id=0; id < expCAsize; id++) {
        iy = crsAry[id*3+0];
        ix = crsAry[id*3+1];
        ixd = crsAry[id*3+2]; 

        //fx = (CFLOAT)ix;
        fy = (CFLOAT)iy;
        
        //fx -= offsetH;
        fy -= offsetV;

        //dx = (int) round(fx*thacos - fy*thasin);
        //dy = (int) round(fx*thasin + fy*thacos);

        //sprintf_f(rs->logs, "back %d(%f), %d(%f) => %d, %d offset(%f, %f)\n", ix, fx, iy, fy,  dx, dy, offsetH, offsetV);
        //print_f(rs->plogs, "ROT", rs->logs);

        //iyn = (int)round(fy);
        //iyn += offsetCal;
        
        for (;ix <= ixd; ix++) {       

            fx = (CFLOAT)ix;

            fx -= offsetH;

            //ixn = (int)round(fx);
            //ixn += offsetCal;

            //dx = (int) round(tarc[ixn] - tars[iyn]);
            //dy = (int) round(tars[ixn] + tarc[iyn]);

            dx = (int) round(fx*thacos - fy*thasin);
            dy = (int) round(fx*thasin + fy*thacos);

            cnt++;

            if ((dx < 0) || (dy < 0) || (dx >= oldWidth) || (dy >= oldHeight)) {
                //sprintf(rs->logs, "%d. %d, %d => %d, %d (%d, %d)\n",id, ix, iy,  dx, dy, oldWidth, oldHeight);
                //print_f(rs->plogs, "ROT", rs->logs);
                continue;
            }

            bitset = bpp / 8;
            //src = rawCpy + (dx*bitset + dy*oldRowsz);
            src = getPixel(rawCpy, dx, dy, oldRowsz, bitset);
            //dst = rawTmp + (ix*bitset + iy*rowsize);
            dst = getPixel(rawTmp, ix, iy, rowsize, bitset);

            //sprintf(rs->logs, "%d. %d, %d => %d, %d (0x%.2x)\n",id, ix, iy,  dx, dy, (unsigned int)(*src));
            //print_f(rs->plogs, "ROT", rs->logs);
            
            cnt = 0;
            while (bitset > 0) {
                *dst = *src;
                //gdat[cnt] = *src;

                bitset --;
                cnt++;
                src++;
                dst++;

                if (cnt > 2) break;
            }
        }
    }

    msync(rawdest, totsz, MS_SYNC);

    #if LOG_ROT_DBG
    dbgBitmapHeader(bheader, len);
    #endif
    return err; 
}

static int doSystemCmd(char *sCommand)
{
#define BUFLEN 128

    int ret=0, wct=0, n=0, totlog=0;
    FILE *fpRead = 0;
    char retBuff[BUFLEN], *pch=0, *p0=0;

    memset(retBuff, 0, BUFLEN);

    //printf("doSystemCmd() [%s]\n", sCommand);
    fpRead = popen(sCommand, "r");
    //sleep(1);
    
    if (!fpRead) return -1;

    pch = fgets(retBuff, BUFLEN , fpRead);
    while (pch) {
    
        if (pch) {
            printf("[cmd]: %s ", retBuff);
        } else {
            wct++;
            printf("sCommand: wait count %d...\n", wct);
            if (wct > 999) {
                break;
            }
            usleep(10000);
        }
        
        memset(retBuff, 0, BUFLEN);

        pch = fgets(retBuff, BUFLEN , fpRead);
    }
            
    pclose(fpRead);

    return 0;
}

static int findEOF(char *p, int max)
{
    int index[2] = {0, 0};
    char mark[2] = {0xff, 0xd9};
    char target = 0;
    int i, cnt=0;

    if (!p) return -1;
    if (max == 0) return -2;

    target = mark[0];
    for (i = 0; i < max; i++) {
        if (cnt > 0) {
            if (p[i] == target) {
                index[1] = i; 
                break;
            } else {
                cnt = 0;
                target = mark[0];
            }
        } else {
            if (p[i] == target) {
                index[0] = i; 
                cnt = 1;
                target = mark[1];
            }
        }    
    }

    if (i < max) {
        return index[0];
    } 

    return -3;
}

static int tiffHead(char *ptiff, int max)
{
    int ret=0;
    if (!ptiff) return -1;
    if (!max) return -2;
    char sample[8] = {0x49, 0x49, 0x2a, 0x00, 0x08, 0xa0, 0x39, 0x00};

    memcpy(ptiff, sample, 8);
    ret = 8;

    return ret;
}

static int tiffTail(char *ptiff, int max)
{
    char patern[170] = {0x0C, 0x00, 0x00, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0xE0, 0x10, 
         0x00, 0x00, 0x01, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x50, 0x1B, 0x00, 0x00, 0x02, 
         0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x01, 0x03, 0x00, 
         0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 
         0x00, 0x01, 0x00, 0x00, 0x00, 0x11, 0x01, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 
         0x00, 0x00, 0x15, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x16, 
         0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x50, 0x1B, 0x00, 0x00, 0x17, 0x01, 0x04, 0x00, 
         0x01, 0x00, 0x00, 0x00, 0xC0, 0x9C, 0x39, 0x00, 0x1A, 0x01, 0x05, 0x00, 0x01, 0x00, 0x00,
         0x00, 0x62, 0x9D, 0x39, 0x00, 0x1B, 0x01, 0x05, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6A, 0x9D, 
         0x39, 0x00, 0x1C, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
         0x00, 0x00, 0x00, 0xE0, 0x10, 0x00, 0x00, 0x00, 0x00, 0x80, 0x25, 0x00, 0x00, 0x20, 0x00, 
         0x00, 0x00, 0x80, 0x25, 0x00, 0x00, 0x20, 0x00};
    int ret=0;
    if (!ptiff) return -1;
    if (!max) return -2;
    if (max < 170) return -3;
    
    memcpy(ptiff, patern, 170);
    ret = 170;

    return ret;
}

static int pdfParamCalcu(int hi, int wh, int *mh, int *mw)
{
    CFLOAT jscale=0.0, tscale=0.0, dscale=0.0;;
    CFLOAT tw=0.0, th=0.0, sw=0.0, sh=0.0;;
    
    if (!mh) return -1;
    if (!mw) return -2;
    if (!hi) return -3;
    if (!wh) return -4;

    sh = hi;
    sw = wh;

    tscale = MAX_PDF_W / MAX_PDF_H;
    jscale = sw / sh;

    if (jscale > tscale) {
        tw = MAX_PDF_W;
        dscale = tw / sw;
        th = sh * dscale;
    } else {
        th = MAX_PDF_H;
        dscale = th / sh;
        tw = sw * dscale;
    }

    *mh = (int) th;
    *mw = (int) tw;

    return 0;
}

static int pdfAppend(char *d, char *s, int tot, int max)
{
    int idx = 0, slen = 0, end = 0;

    if (d == 0) return -1;
    if (s == 0) return -2;
    if (tot > max) return -3;

    slen = strlen(s);
    idx = tot;
    end = tot + slen;
    if (end > max) return -4;
    
    while (idx < end) {
        d[idx] = *s;
        idx ++;
        s++;
    }
    
    return slen;
}

static int pdfHead(char *ppdf, int max, int inSize, int *inData)
{
    CFLOAT wscale=0.0, hscale=0.0;
    CFLOAT d1=0, d2=0;
    char tch[128], *dst = 0;
    int tlen = 0, tot = 0, n=0;
    int hi=0, wh=0, mh=0, mw=0, cm=0;
    

    if (ppdf == 0) return -1;
    if (max == 0) return -2;
    if (hi == 0) return -7;
    if (wh == 0) return -4;
    if (mh == 0) return -5;
    if (mw == 0) return -6;
    if (!inData) return -7;

    dst = ppdf;

    hi = inData[0];
    wh = inData[1];
    mh = inData[2];
    mw = inData[3];
    cm = inData[4]; /*color mode*/
    
    d1 = mh;
    d2 = hi;
    hscale = d1 / d2;

    d1 = mw;
    d2 = wh;
    wscale = d1 / d2;
    
    sprintf(tch, "%cPDF-1.4\n", '%');
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;
    
    sprintf(tch, "1 0 obj\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "<< /Type /Catalog\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "/Pages 2 0 R\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, ">>\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "endobj\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "3 0 obj\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "<< /Type /Page\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "/Parent 2 0 R\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "/Resources 4 0 R\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "/MediaBox [0 0 %d %d]\n", mw, mh);
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "/Contents 5 0 R\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, ">>\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "endobj\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    inData[4] = tot;
    sprintf(tch, "4 0 obj\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "<< /ProcSet [/PDF /ImageB]\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "/XObject << /Im1 6 0 R >>\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, ">>\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "endobj\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    inData[5] = tot;
    sprintf(tch, "5 0 obj\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "<< /Length 107 >>\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "stream\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "   q\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "      %.6f 0 0 %.6f 0 0 cm\n", wscale, hscale);
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "      1 0 0 1 0 0 cm\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "      %d 0 0 %d 0 0 cm\n", wh, hi);
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "      /Im1 Do\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "   Q\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "\nendstream\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "endobj\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    inData[6] = tot;
    sprintf(tch, "6 0 obj\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "<< /Type /XObject\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "/Subtype /Image\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "/Width %d\n", wh);
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "/Height %d\n", hi);
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    switch (cm) {
        case COLOR_MODE_GRAY:
        case COLOR_MODE_GRAY_DETAIL:
        case COLOR_MODE_BLACKWHITE:
            sprintf(tch, "/ColorSpace /DeviceGray\n");
            break;
        case COLOR_MODE_COLOR:
            sprintf(tch, "/ColorSpace /DeviceRGB\n");
            break;
        default:
            sprintf(tch, "/ColorSpace /DeviceRGB\n");
            printf("WARNNING!!! color mode config out of range (0x%x) \n", cm);
            break;
    }
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "/BitsPerComponent 8\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "/Filter/DCTDecode /Length 7 0 R>>\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "stream\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;


    return tot;
}

static int pdfTail(char *ppdf, int max, int inSize, int *inData)
{
    char tch[128], *dst = 0;
    char end[6] = {0x25, 0x25, 0x45, 0x4f, 0x46, 0x00};
    int tlen = 0, tot = 0, n=0;
    int offset_2=0, offset_7=0, offset_x=0;
    int offset_4=0, offset_5=0, offset_6=0;
    int offset, imgSize;

    if (ppdf == 0) return -1;
    if (max == 0) return -2;
    if (!inData) return -4;

    offset_4 = inData[4];
    offset_5 = inData[5];
    offset_6 = inData[6];
    offset = inData[7];
    imgSize = inData[8];

    dst = ppdf;

    sprintf(tch, "\nendstream\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "endobj\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    offset_7 = offset + tot;
    sprintf(tch, "7 0 obj\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "%d\n", imgSize);
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "endobj\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    offset_2 = offset + tot;
    
    sprintf(tch, "2 0 obj\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "<< /Type /Pages\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "/Kids [3 0 R ]\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "/Count 1\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, ">>\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "endobj\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    offset_x = offset + tot;
    sprintf(tch, "xref\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "0 8\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "0000000000 65535 f\r\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "0000000009 00000 n\r\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "%.10d 00000 n\r\n", offset_2);
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "0000000058 00000 n\r\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "%.10d 00000 n\r\n", offset_4);
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "%.10d 00000 n\r\n", offset_5);
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "%.10d 00000 n\r\n", offset_6);
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "%.10d 00000 n\r\n", offset_7);
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "trailer\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "<< /Size 8\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "/Root 1 0 R\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, ">>\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "startxref\n");
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    sprintf(tch, "%d\n",offset_x);
    n = pdfAppend(dst, tch, tot, max);
    if (n < 0) return -3;
    tot += n;

    n = pdfAppend(dst, end, tot, max);
    if (n < 0) return -3;
    tot += n;

    return tot;
}

static void aspFree(void *p, int pidx)
{
    //printf("<<<<<<<<  free 0x%.8x \n", (uint32_t)p);
    //free(p);
}

static void aspFreeSup(void *p, int pidx)
{
    printf("XXXXXXXXX  free Sup 0x%.8x \n", (uint32_t)p);
    //free(p);
}

static void* aspMalloc(int mlen, int pidx)
{
    int tot=0;
    int num=0, rst=0;
    void *p=0;

    rst = mlen % MIN_MEM_ALLOC_SIZE;

    if (rst != 0) {
        num = mlen >> 12;
        mlen = (num + 1) * MIN_MEM_ALLOC_SIZE;
    }

    if (pidx >= MSP_P_NUM) return 0;
    
    tot = asptotMalloc[pidx];
    tot += mlen;
    //printf("!!!!!!!!!!!!!!!!!!!  malloc size: %d / %d on [p%d] \n", mlen, tot, pidx);
    asptotMalloc[pidx] = tot;
    
    p = malloc(mlen);
    return p;
}

static void* aspSalloc(uint32_t slen)
{
    char logbuf[256];
    uint32_t tot=0;
    char *p=0;
    
    tot = *totSalloc;
    tot += slen;
    
    //printf("*******************  salloc size: %d / %d\n", slen, tot);
    //sprintf_f(logbuf, "*******************  salloc size: %d / %d\n", slen, tot);
    //print_f(mlogPool, "SHM", logbuf);    
    
    *totSalloc = tot;
    
    p = mmap(NULL, slen, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);
    return p;
}

static void debugPrintInfoSec(struct sdFSinfo_s *pinfo)
{
#if LOG_FS_EN
            /* lead ingnature, shall be 0x52 0x52 0x61 0x41 */
    printf("[0x%.8x]: /* lead ingnature, shall be 0x52 0x52 0x61 0x41 */ \n", pinfo->finLdsn);
            /* structure signature, shall be 0x72 0x72 0x41 0x61 */
    printf("[0x%.8x]: /* structure signature, shall be 0x72 0x72 0x41 0x61 */\n", pinfo->finStsn);
            /* free cluster count */
    printf("[%d]: /* free cluster count */\n", pinfo->finFreClst);
            /* next free cluster */
    printf("[%d]: /* next free cluster */\n", pinfo->finNxtFreClst); 
            /* shall be 0x00 0x00 0x55 0xaa */
    printf("[0x%.8x]: /* shall be 0x00 0x00 0x55 0xaa */\n", pinfo->finTrsn); 
#endif
}

static void debugPrintBootSec(struct sdbootsec_s *psec)
{
#if 1//LOG_FS_EN
            /* 0  Jump command */
    printf("[0x%x]: /* 0  Jump command */ \n", psec->secJpcmd);
            /* 3  system id */
    printf("[%s]: /* 3  system id */\n", psec->secSysid);
            /* 11 sector size */ 
    printf("[%d]: /* 11 sector size */ \n", psec->secSize);
            /* 13 sector per cluster */
    printf("[%d]: /* 13 sector per cluster */\n", psec->secPrClst);
            /* 14 reserved sector count*/
    printf("[%d]: /* 14 reserved sector count*/\n", psec->secResv);            
            /* 16 number of FATs */
    printf("[%d]: /* 16 number of FATs */\n", psec->secNfat);
            /* 17 skip, number of root dir entries */
            /* 19 skip, total sectors */
            /* 21 medium id */
    printf("[0x%x]: /* 21 medium id */\n", psec->secIDm);
            /* 22 skip, sector per FAT */
            /* 24 sector per track */
    printf("[%d]: /* 24 sector per track */\n", psec->secPrtrk);
            /* 26 number of sides */
    printf("[%d]: /* 26 number of sides */\n", psec->secNsid);
            /* 28 number of hidded sectors */
    printf("[%d]: /* 28 number of hidded sectors */\n", psec->secNhid);
            /* 32 total sectors */
    printf("[%d]: /* 32 total sectors */\n", psec->secTotal);
            /* 36 sectors per FAT */
    printf("[%d]: /* 36 sectors per FAT */\n", psec->secPrfat);
            /* 40 extension flag */
    printf("[0x%x]: /* 40 extension flag */\n", psec->secExtf);
            /* 42 FS version */
    printf("[0x%x]: /* 42 FS version */\n", psec->secVers); 
            /* 44 root cluster */
    printf("[%d]: /* 44 root cluster */\n", psec->secRtclst); 
            /* 48 FS info */
    printf("[0x%x]: /* 48 FS info */\n", psec->secFSif); 
            /* 50 backup boot sector */
    printf("[%d]: /* 50 backup boot sector */\n", psec->secBkbt); 
            /* 64 physical disk number */
    printf("[%d]: /* 64 physical disk number */\n", psec->secPhdk);
            /* 66 extended boot record signature */
    printf("[0x%x]: /* 66 extended boot record signature */\n", psec->secExtbt);
            /* 67 volume ID number */
    printf("[0x%x]: /* 67 volume ID number */\n", psec->secVoid); 
            /* 71 to 81 volume label */
    printf("[%s]: /* 71 to 81 volume label */\n", psec->secVola);
            /* 82 to 89 file system type */
    printf("[%s]: /* 82 to 89 file system type */\n", psec->secFtyp);
            /* 510 signature word */
    printf("[0x%x]: /* 510 signature word */\n", psec->secSign);
            /* set the boot sector status to 1 */
    printf("[0x%x]: /* boot sector status */\n", psec->secSt);
            /* the start sector of fat table */
    printf("[%d]: /* the start sector of fat table */\n", psec->secWhfat);
            /* the start sector of root dir */
    printf("[%d]: /* the start sector of root dir */\n", psec->secWhroot);
#endif
}

static void debugPrintDir(struct directnFile_s *pf)
{
#if 0
struct directnFile_s{
    uint32_t   dftype;
    uint32_t   dfstats;
    char        dfLFN[256];
    char        dfSFN[12];
    int           dflen;
    uint32_t   dfattrib;
    uint32_t   dfcretime;
    uint32_t   dfcredate;
    uint32_t   dflstacdate;
    uint32_t   dfrecotime;
    uint32_t   dfrecodate;
    uint32_t   dfclstnum;
    uint32_t   dflength;
    struct directnFile_s *pa;
    struct directnFile_s *br;
    struct directnFile_s *ch;   
};
#endif

#if 1 //LOG_FS_EN
    printf("==========================================\n");
    printf("  [%x] type \n", pf->dftype);
    printf("  [%x] status \n", pf->dfstats);
    printf("  [%s] long file name, len:%d\n", pf->dfLFN, pf->dflen);
    printf("  [%s] short file name \n", pf->dfSFN);
    printf("  [%x] attribute \n", pf->dfattrib);
    printf("  [%.2d:%.2d:%.2d] H:M:S created time \n", (pf->dfcretime >> 16) & 0xff, (pf->dfcretime >> 8) & 0xff, (pf->dfcretime >> 0) & 0xff);
    printf("  [%.2d:%.2d:%.2d] Y:M:D created date \n", ((pf->dfcredate >> 16) & 0xff) + 1980, (pf->dfcredate >> 8) & 0xff, (pf->dfcredate >> 0) & 0xff);
    printf("  [%.2d:%.2d:%.2d] Y:M:D access date \n", ((pf->dflstacdate >> 16) & 0xff) + 1980, (pf->dflstacdate >> 8) & 0xff, (pf->dflstacdate >> 0) & 0xff);
    printf("  [%.2d:%.2d:%.2d] H:M:S recorded time \n", (pf->dfrecotime >> 16) & 0xff, (pf->dfrecotime >> 8) & 0xff, (pf->dfrecotime >> 0) & 0xff);
    printf("  [%.2d:%.2d:%.2d] Y:M:D recorded date \n", ((pf->dfrecodate >> 16) & 0xff) + 1980, (pf->dfrecodate >> 8) & 0xff, (pf->dfrecodate >> 0) & 0xff);
    printf("  [%d] cluster number \n", pf->dfclstnum);
    printf("  [%d] file length \n", pf->dflength);
    printf("  [0x%.8x][0x%x] self id \n",(uint32_t)pf , pf->dfindex);
    printf("  [0x%.8x][0x%x] parent id \n", (uint32_t)pf->pa, pf->dfpaid);
    printf("  [0x%.8x][0x%x] bother id \n", (uint32_t)pf->br, pf->dfbrid);
    printf("  [0x%.8x][0x%x] child id \n", (uint32_t)pf->ch, pf->dfchid);
    printf("==========================================\n");
#endif
}

static int aspCalcSupLen(struct supdataBack_s *sup)
{
    int len=0, cnt=0;
    struct supdataBack_s *scr;
    if (!sup) return -1;
    
    scr = sup;
    while(scr) {
        len += scr->supdataTot - scr->supdataUse;

        //printf("%d. calcu sup, tot / used / len = %d / %d / %d\n", cnt, scr->supdataTot, scr->supdataUse, len);
        scr = scr->n;

        cnt++;
    }
    return len;
}

static int aspPopSupOut(char *dst, struct supdataBack_s *str, int size, struct supdataBack_s **nxt)
{
    int ret = 0, acusz = 0;
    char *src1 = 0, *src2 = 0;
    int tot=0, usd=0, rst=0;
    struct supdataBack_s *scr=0, *snx=0;
    
    if (!str) return -1;
    if (!nxt) return -2;
    if (!dst) return -3;

    scr = str;
    snx = str->n;

    src1 = scr->supdataBuff;
    tot = scr->supdataTot;
    usd = scr->supdataUse;
    rst = tot - usd;

    if (rst < 0) return -4;
    if (rst == 0) return 0;

    if (size == rst) {
        memcpy(dst, src1+usd, size);
        acusz += size;
        *nxt = snx;
        scr->supdataUse += size;
    } else if (size > rst) {
        memcpy(dst, src1+usd, rst);
        acusz += rst;
        ret = aspPopSupOut(dst+rst, snx, size - rst, nxt);
        if (ret > 0) {
            acusz += ret;
        } else {
            *nxt = snx;
        }
        scr->supdataUse += rst;
    } else {
        memcpy(dst, src1+usd, size);    
        acusz += size;
        *nxt = scr;
        scr->supdataUse += size;
    }

    return acusz;
}

static uint32_t aspRawCompose(char * raw, int size)
{
    int sh[4] = {0, 8, 16, 24};
    int i = 0;
    uint32_t val = 0, tmp = 0;

    while(i < size) {
        tmp = raw[i];
        val |= tmp << sh[i];
        i++;
    }
    return val;
}

static uint32_t aspRawReverse(char * raw, int size, uint32_t val)
{
    int sh[4] = {0, 8, 16, 24};
    int i = 0;
    uint8_t tmp = 0;

    while(i < size) {
        tmp = (val >> sh[i]) & 0xff;
        raw[i] = tmp;
        i++;
        //printf("0x%.2x \n", tmp);
    }
    return 0;
}

static uint32_t cfgValueOffset(uint32_t val, int offset)
{
    return (val >> offset) & 0xff;
}

static int cfgTableUpd(struct aspConfig_s *table, int idx, uint32_t val)
{
    struct aspConfig_s *p=0;
    int ret=0;

    if (!table) return -1;
    if (idx >= ASPOP_CODE_MAX) return -1;

    p = &table[idx];
    if (!p) return -2;

    ret = cmdfunc_opchk_single(val, p->opMask, p->opBitlen, p->opType);
    if (ret < 0) {
        ret = (ret * 10) -3;
        return ret;
    } else {            
        p->opValue = val;
        p->opStatus = ASPOP_STA_UPD;
    }

    return 0;
}

static int cfgTableClr(struct aspConfig_s *table, int idx)
{
    struct aspConfig_s *p=0;
    int ret=0;

    if (!table) return -1;
    if (idx >= ASPOP_CODE_MAX) return -1;

    p = &table[idx];
    if (!p) return -2;

    p->opStatus = ASPOP_STA_NONE;

    return 0;
}

static int cfgTableSet(struct aspConfig_s *table, int idx, uint32_t val)
{
    struct aspConfig_s *p=0;
    int ret=0;

    if (!table) return -1;
    if (idx >= ASPOP_CODE_MAX) return -1;

    p = &table[idx];
    if (!p) return -2;

    ret = cmdfunc_opchk_single(val, p->opMask, p->opBitlen, p->opType);
    if (ret < 0) {
        ret = (ret * 10) -3;
        return ret;
    } else {            
        p->opValue = val;
        p->opStatus = ASPOP_STA_WR;
    }

    return 0;
}

static int cfgTableGet(struct aspConfig_s *table, int idx, uint32_t *rval)
{
    struct aspConfig_s *p=0;
    int ret=0;

    if (!rval) return -1;
    if (!table) return -1;
    if (idx >= ASPOP_CODE_MAX) return -1;

    p = &table[idx];
    if (!p) return -2;

    if (p->opStatus == ASPOP_STA_NONE) return -3;

    *rval = p->opValue;

    return 0;
}

static int cfgTableGetChk(struct aspConfig_s *table, int idx, uint32_t *rval, uint32_t stat)
{
    struct aspConfig_s *p=0;
    int ret=0;

    if (!rval) return -1;
    if (!table) return -1;
    if (idx >= ASPOP_CODE_MAX) return -1;

    p = &table[idx];
    if (!p) return -2;

    *rval = p->opValue;
    
    if (p->opStatus != stat) return -3;

    return 0;
}

static int cfgTableGetChkDPI(struct aspConfig_s *table, int idx, uint32_t *rval, uint32_t stat)
{
    struct aspConfig_s *p=0;
    int err=0;
    uint32_t dpi=0, tmp=0;

    if (!rval) return -1;
    if (!table) return -1;
    if (idx >= ASPOP_CODE_MAX) return -1;

    p = &table[idx];
    if (!p) return -2;

    tmp = p->opValue;
    switch (tmp) {
    case RESOLUTION_1200:
        dpi = 1200;
        break;
    case RESOLUTION_600:
        dpi = 600;
        break;
    case RESOLUTION_300:
        dpi = 300;
        break;
    case RESOLUTION_200:
        dpi = 200;
        break;
    case RESOLUTION_150:
        dpi = 150;
        break;
    case RESOLUTION_100:
        dpi = 100;
        break;
    case RESOLUTION_75:
        dpi = 75;
        break;
    default:
        dpi = 300;
        err = -3;
        break;
    }
                
    *rval = dpi;
    
    if (p->opStatus != stat) return -4;

    return err;
}

static int asp_idxofch(char *str, char ch, int start, int max) 
{
    int i=0, ret=-1;
    char *p=0;

    if (start >= max) return -2;

    p = str + start;
    
    while (start < max) {

        if (*p == ch) {
            //printf("%c ", *p);
            return start;
        } else {
            //printf("x%c", *p);
        }

        p++;
        start++;
    }
    
    return ret;
}

static int asp_strsplit(struct aspInfoSplit_s **info, char *str, int max)
{
    char log[256];
    int len, cnt;
    int cur, nex, ret;
    struct aspInfoSplit_s *h=0, *p=0, *c=0;

    cur = 0;
    cnt = 0;
    
    while (cur < max) {
        ret = asp_idxofch(str, ',', cur, max);
        if (ret >= 0) {
            nex = ret;
            p = aspMemalloc(sizeof(struct aspInfoSplit_s), 6);
            memset(p, 0, sizeof(struct aspInfoSplit_s));            
            cnt++;
        } else {
            p = aspMemalloc(sizeof(struct aspInfoSplit_s), 6);
            memset(p, 0, sizeof(struct aspInfoSplit_s));            
            cnt++;
            nex = max;
        }
    
        len = nex - cur;

        if (len == 0) {
            cur = nex+1;            
            aspMemFree(p, 6);
            continue;
        }
        
        p->infoStr = aspMemalloc(len+1, 6);
        p->infoLen = len;
        memcpy(p->infoStr, str+cur,  len);

        p->infoStr[len] = '\0';

        //sprintf_f(log, "%d, %s\n", p->infoLen, p->infoStr);
        //print_f(mlogPool, "SPLT", log);

        cur = nex+1;

        if (c) {
            c->n = p;
        }
        
        c = p;
        
        if (!h) {
            h = c;
        }

    }

    *info = h;
    return cnt;
}

static struct aspInfoSplit_s *asp_getInfo(struct aspInfoSplit_s *info, int idx) 
{
    int i=0;
    
    while (i < idx) {
        i++;
        if (!info) break;
        info = info->n;
    }

    return info;
}
static struct aspInfoSplit_s *asp_freeInfo(struct aspInfoSplit_s *info) 
{
    struct aspInfoSplit_s *nex=0;
    if (!info) return 0;
    nex = info->n;

    //printf("free[%s]\n", info->infoStr);

    aspMemFree(info->infoStr, 9);
    aspMemFree(info, 9);
    return nex;
}

static int aspFSms2rs(struct directnFile_s **rsd, struct directnFile_s *msd, struct sdFatDir_s *pfatdir)
{
    char logbuf[256];
    struct sdDirPool_s *pdirpool=0;
    int pid, fid;
    
    pid = msd->dfindex >> 16;
    fid = msd->dfindex & 0xffff;
    msync(pfatdir, sizeof(struct sdFatDir_s), MS_SYNC);

    sprintf_f(logbuf, "ms2rs pid:%d %d \n", pid, fid);
    print_f(mlogPool, "M2R", logbuf);    

    if (!pid) {
        printf("[FSV] ERROR!!! pid: %d \n", pid);
        return -1;
    }

    if (pid > pfatdir->dirFATMax) {
        printf("[FSV] ERROR!!! pid: %d > max: %d \n", pid, pfatdir->dirFATMax);
        return -2;
    }

    if (pid > pfatdir->dirFATUsed) {
        printf("[FSV] ERROR!!! pid: %d > used: %d \n", pid, pfatdir->dirFATUsed);
        return -3;
    } else {
        sprintf_f(logbuf, "pid: %d <= used: %d \n", pid, pfatdir->dirFATUsed);
        print_f(mlogPool, "M2R", logbuf);  
    }

    pdirpool = pfatdir->fatDirPool[pid - 1];
    if (!pdirpool) {
        printf("[FSV] ERROR!!! pdirpool == null \n");
        return -4;
    } else {
        sprintf_f(logbuf, "pdirpool max = %d\n", pdirpool->dirMax);
        print_f(mlogPool, "M2R", logbuf);  
    }
/*
    if (fid > pdirpool->dirUsed) {
        printf("[FSV] ERROR!!! fid: %d > used: %d \n", fid, pdirpool->dirUsed);
        return -5;
    } else {
        printf("[FSV] fid: %d <= used: %d \n", fid, pdirpool->dirUsed);
    }
*/
    if (fid >= pdirpool->dirMax) {
        printf("[FSV] ERROR!!! fid: %d > max: %d \n", fid, pdirpool->dirMax);
        return -6;
    }
    
    *rsd = &pdirpool->dirPool[fid];

    sprintf_f(logbuf, "file name: [%s]\n", pdirpool->dirPool[fid].dfSFN);
    print_f(mlogPool, "M2R", logbuf);  
    
    return 0;
}

static int aspFScpDir(struct directnFile_s *dstd, struct directnFile_s *srcd)
{
    memcpy(dstd, srcd, sizeof(struct directnFile_s));

    return 0;
}

static int aspFScpDirTr(struct directnFile_s *dstd, struct directnFile_s *srcd, struct sdFatDir_s *dsttr)
{  
    char logbuf[256];
    struct sdDirPool_s *slecdir=0;
    struct directnFile_s *dir=0, *dpa=0, *dch=0, *dbr=0, *msroot=0, *curDir=0;
    int ipa=0, ibr=0, ich=0, icur=0, iroot=0, ipol=0, idir=0;
    
    memcpy(dstd, srcd, (sizeof(struct directnFile_s) - 4));
    
    dpa=0; 
    dbr=0; 
    dch=0;

    dir = dstd;

    sprintf_f(logbuf, "filename: [%s] info: \n", dir->dfSFN);
    print_f(mlogPool, "CPDIR", logbuf);    

    debugPrintDir(dir);
    if (dir->pa) {
        ipa = dir->dfpaid;
        ipol = ipa >> 16;
        idir = ipa & 0xffff;

        if (ipol > dsttr->dirFATUsed) {
            sprintf_f(logbuf, "ERROR!!! the dir pool id is overflow, id: %d, used: %d\n", ipol, dsttr->dirFATUsed);
            print_f(mlogPool, "CPDIR", logbuf);    
            return -1;
        }

        slecdir = dsttr->fatDirPool[ipol - 1];

        if (idir > slecdir->dirUsed) {
            sprintf_f(logbuf, "ERROR!!! the dir id is overflow, id: %d, used: %d\n", idir, slecdir->dirUsed);
            print_f(mlogPool, "CPDIR", logbuf);    
            return -2;
        }

        dpa = &slecdir->dirPool[idir];
        if (dpa->dfindex != ipa) {
            sprintf_f(logbuf, "WARNING!!! the pa id is different!!! (%d / %d)\n", ipa, dpa->dfindex);
            print_f(mlogPool, "CPDIR", logbuf);    
        }
    }

    if (dir->br) {
        ibr = dir->dfbrid;
        ipol = ibr >> 16;
        idir = ibr & 0xffff;

        if (ipol > dsttr->dirFATUsed) {
            sprintf_f(logbuf, "ERROR!!! the dir pool id is overflow, id: %d, used: %d\n", ipol, dsttr->dirFATUsed);
            print_f(mlogPool, "CPDIR", logbuf);    
            return -7;
        }

        slecdir = dsttr->fatDirPool[ipol - 1];

        if (idir > slecdir->dirUsed) {
            sprintf_f(logbuf, "ERROR!!! the dir id is overflow, id: %d, used: %d\n", idir, slecdir->dirUsed);
            print_f(mlogPool, "CPDIR", logbuf);    
            return -8;
        }

        dbr = &slecdir->dirPool[idir];
        if (dbr->dfindex != ibr) {
            sprintf_f(logbuf, "WARNING!!! the br id is different!!! (%d / %d)\n", ibr, dbr->dfindex);
            print_f(mlogPool, "CPDIR", logbuf);    
        }
    }

    if (dir->ch) {
        ich = dir->dfchid;
        ipol = ich >> 16;
        idir = ich & 0xffff;

        if (ipol > dsttr->dirFATUsed) {
            sprintf_f(logbuf, "ERROR!!! the dir pool id is overflow, id: %d, used: %d\n", ipol, dsttr->dirFATUsed);
            print_f(mlogPool, "CPDIR", logbuf);    
            return -9;
        }

        slecdir = dsttr->fatDirPool[ipol - 1];

        if (idir > slecdir->dirUsed) {
            sprintf_f(logbuf, "ERROR!!! the dir id is overflow, id: %d, used: %d\n", idir, slecdir->dirUsed);
            print_f(mlogPool, "CPDIR", logbuf);    
            return -10;
        }                    

        dch = &slecdir->dirPool[idir];
        if (dch->dfindex != ich) {
            sprintf_f(logbuf, "WARNING!!! the br id is different!!! (%d / %d)\n", ich, dch->dfindex);
            print_f(mlogPool, "CPDIR", logbuf);    
        }
    }

    if (dpa) {
        sprintf_f(logbuf, "pa:[%s] \n", dpa->dfSFN);
        print_f(mlogPool, "CPDIR", logbuf);    
    }

    if (dbr) {
        sprintf_f(logbuf, "br:[%s] \n", dbr->dfSFN);
        print_f(mlogPool, "CPDIR", logbuf);    
    }

    if (dch) {
        sprintf_f(logbuf, "ch:[%s] \n", dch->dfSFN);
        print_f(mlogPool, "CPDIR", logbuf);    
    }

    dir->pa = dpa;
    dir->br = dbr;
    dir->ch = dch;

    if (dir->dftype == ASPFS_TYPE_ROOT) {
        sprintf_f(logbuf, "rootdir:[%s] \n", dir->dfSFN);
        print_f(mlogPool, "CPDIR", logbuf);    

        dsttr->dirRoot = dir;
        if (!dsttr->dirCur) {
            dsttr->dirCur = dir;
            sprintf_f(logbuf, "curdir: [%s] \n", dir->dfSFN);
            print_f(mlogPool, "CPDIR", logbuf);    
        }
    }
                                
    return 0;
}

static int mspFS_preSetPool(struct sdDirPool_s *pool, uint32_t lv)
{
    int id=0;
    pool->dirMax = FAT_DIRPOOL_IDX_MAX;
    for (id = 0; id < FAT_DIRPOOL_IDX_MAX; id++) {
        pool->dirPool[id].dfindex = id | (lv << 16);
    }
    return 0;
}

static int mspFS_allocDirRs(struct sdFatDir_s *dsttr, int usedindx)
{
    int cid=0;
    struct sdFatDir_s  *pfatDir=0;
    struct sdDirPool_s *pool=0;

    if (!dsttr) return -1;
    if (!usedindx) return -2;

    pfatDir = dsttr;

    if (usedindx > pfatDir->dirFATMax) {
        return -3;
    }
    
    if (pfatDir->dirFATUsed < usedindx) {
        pfatDir->dirFATUsed = usedindx;
    }

    cid = usedindx - 1;

    if (!pfatDir->fatDirPool[cid]) {
        //pool = aspMalloc(sizeof(struct sdDirPool_s), 8);
        pool = aspMemalloc(sizeof(struct sdDirPool_s), 8);
        if (!pool) {
            return -3;
        }
        pfatDir->fatDirPool[cid] = pool;
    } else {
        pool = pfatDir->fatDirPool[cid];        
    }
    
    memset(pool, 0, sizeof(struct sdDirPool_s));

    mspFS_preSetPool(pool, usedindx);

    //pfatDir->dirFATDirty = 1;

    return 0;
}

static int aspFScpFatDir(struct sdFatDir_s *dsttr, struct sdFatDir_s *srctr, struct procRes_s *rs)
{
    int ret=0, bufn=0, loop=0, len=0, vdcnt=0;
    int used=0, idt=0, maxsz=0, totsz=0;
    int drsz=0, idr=0, ipol=0, idir=0;
    int ipa=0, ibr=0, ich=0, icur=0, iroot=0;
    struct sdDirPool_s *rsdir=0, **msdir=0;
    struct sdDirPool_s *slecdir=0;
    struct directnFile_s *dir=0, *dpa=0, *dch=0, *dbr=0;
    char *pr=0, *pt=0, *addrs=0, ch=0;
    int cntout=0;
    if (!dsttr) return -1;
    if (!srctr) return -2;

    msync(srctr, sizeof(struct sdFatDir_s), MS_SYNC);

    maxsz = srctr->dirFATMax;
    used = srctr->dirFATUsed;
    icur = rs->psFat->fatCurDir.dfindex;
    iroot = rs->psFat->fatRootdir.dfindex;

    sprintf_f(rs->logs, "used index: %d, dirt src: %d dst: %d\n", used, srctr->dirFATDirty, dsttr->dirFATDirty);
    print_f(rs->plogs, "CPFAT", rs->logs);    

    if (used > maxsz) {
        used = maxsz;
    }

    if (!srctr->dirFATDirty) {
        return 1;
    }

    while (!(srctr->dirFATDirty & 0x2)) {
        msync(srctr, sizeof(struct sdFatDir_s), MS_SYNC);    
        usleep(100000);
        cntout++;
        if (cntout > 5) {
            sprintf_f(rs->logs, "time out break !!!cnt: %d \n", cntout);
            print_f(rs->plogs, "CPFAT", rs->logs);    
            return 1;
        }
    }

    //msdir = aspMalloc(sizeof(struct sdDirPool_s*)*used, 6);
    msdir = aspMemalloc(sizeof(struct sdDirPool_s*)*used, 6);
    if (!msdir) {
        sprintf_f(rs->logs, "ERROR!!!failed to allocate memory for msdir !!!\n");
        print_f(rs->plogs, "CPFAT", rs->logs);    
        return -6;
    }

    for (idt = 0; idt < used; idt++) {
        //msdir[idt] = (struct sdDirPool_s *)aspMalloc(sizeof(struct sdDirPool_s), 6);
        msdir[idt] = (struct sdDirPool_s *)aspMemalloc(sizeof(struct sdDirPool_s), 6);
        if (!msdir[idt]) {
            sprintf_f(rs->logs, "ERROR!!!failed to allocate memory for msdir !!!\n");
            print_f(rs->plogs, "CPFAT", rs->logs);    
            return -7;
        }
    }

    sprintf_f(rs->logs, "pool used: %d \n", used);
    print_f(rs->plogs, "CPFAT", rs->logs);    
    
    for (idt = 0; idt < used; idt++) {
        ret = rs_ipc_get(rs, &ch, 1);
        if (ret > 0) {
            if (ch == 'd') {
                bufn = ring_buf_info_len(rs->pdataRx);
                sprintf_f(rs->logs, "succeed to get ch = %c, bufn = %d\n", ch, bufn);
                print_f(rs->plogs, "CPFAT", rs->logs);    

                pt = (char *)msdir[idt]->dirPool;
                loop = bufn;
                totsz = 0;
                while (loop > 0) {
                    len = ring_buf_cons(rs->pdataRx, &addrs);
                    if (len < 0) {
                        sprintf_f(rs->logs, "ERROR!!! get ring buff failed ret: %d\n", len);
                        print_f(rs->plogs, "CPFAT", rs->logs);    
                    }
            
                    msync(addrs, len, MS_SYNC);

                    totsz += len;

                    if (totsz > sizeof(struct sdDirPool_s)) {
                        sprintf_f(rs->logs, "ERROR!!! get ring buff out of buff range totsz: %d, range: %d\n", totsz, sizeof(struct sdDirPool_s));
                        print_f(rs->plogs, "CPFAT", rs->logs);    
                    } else {
                        memcpy(pt, addrs, len);
                    }
                    
                    pt += len;
                    loop --;

                    sprintf_f(rs->logs, "%d. len: %d, totsz:%d\n", loop, len, totsz);
                    print_f(rs->plogs, "CPFAT", rs->logs);    
                }

                msdir[idt]->dirMax = FAT_DIRPOOL_IDX_MAX;
                len = sizeof(struct directnFile_s);

                msdir[idt]->dirUsed = totsz / len;

                sprintf_f(rs->logs, "%d. dir info: max = %d, used = %d = %d / %d\n", idt, msdir[idt]->dirMax, msdir[idt]->dirUsed, totsz, len);
                print_f(rs->plogs, "CPFAT", rs->logs);    

                rs_ipc_put(rs, "D", 1);
            }
            else {
                sprintf_f(rs->logs, "warnning!! ch == %c \n", ch);
                print_f(rs->plogs, "CPFAT", rs->logs);                
            }
        } else {
            sprintf_f(rs->logs, "failed to get ch ret: %d\n", ret);
            print_f(rs->plogs, "CPFAT", rs->logs);    
        }
    }

    for (idt = 0; idt < used; idt++) {
        ret = mspFS_allocDirRs(dsttr, idt+1);
        if (ret < 0) {
            sprintf_f(rs->logs, "failed to allocate dir for rs ret: %d, idx: %d\n", ret, idt);
            print_f(rs->plogs, "CPFAT", rs->logs);    
            return -5;
        }
    }

    for (idt = 0; idt < used; idt++) {
        //msdir = srctr->fatDirPool[idt];

        rsdir = dsttr->fatDirPool[idt];

        if (!msdir[idt]) {
            return -3;
        }

        if (!rsdir) {
            return -4;
        }

        drsz = msdir[idt]->dirUsed;

        pt = (char *)rsdir->dirPool;
        pr = (char *)msdir[idt]->dirPool;

        rsdir->dirUsed = drsz;
        rsdir->dirMax = FAT_DIRPOOL_IDX_MAX;  
        
        memcpy(pt, pr, sizeof(struct directnFile_s) * drsz);
        
#if 0 //LOG_FS_EN
        sprintf_f(rs->logs, "dir size: %d print start \n", drsz);
        print_f(rs->plogs, "CPFAT", rs->logs);    
#endif
        for (idr=0; idr < drsz; idr++) {
            dpa=0; 
            dbr=0; 
            dch=0;
            dir = &rsdir->dirPool[idr];
            
#if 0 //LOG_FS_EN
            if (dir->dflen > 0) {
                sprintf_f(rs->logs, "dir %d. addr:0x%.8x, status: 0x%x <0x%.8x,0x%.8x,0x%.8x,0x%.8x> SFN[%s]\n", idr, dir, dir->dfstats, 
                    dir->dfindex, dir->dfpaid, dir->dfbrid, dir->dfchid,dir->dfSFN, dir->dfLFN, dir->dflen);
                print_f(rs->plogs, "CPFAT", rs->logs);    
            } else {
                sprintf_f(rs->logs, "dir %d. addr:0x%.8x, status: 0x%x <0x%.8x,0x%.8x,0x%.8x,0x%.8x> SFN[%s]\n", idr, dir, dir->dfstats, 
                    dir->dfindex, dir->dfpaid, dir->dfbrid, dir->dfchid,dir->dfSFN);
                print_f(rs->plogs, "CPFAT", rs->logs);    
            }
#endif

#if 0 //LOG_FS_EN
            /* pa info */
            sprintf_f(rs->logs, "    pa addr: 0x%.8x \n", dir->pa);
            print_f(rs->plogs, "CPFAT", rs->logs);    
            /* br info */
            sprintf_f(rs->logs, "    br addr: 0x%.8x \n", dir->br);
            print_f(rs->plogs, "CPFAT", rs->logs);    
            /* ch info */
            sprintf_f(rs->logs, "    ch addr: 0x%.8x \n", dir->ch);
            print_f(rs->plogs, "CPFAT", rs->logs);    
#endif

            if (dir->dfstats == ASPFS_STATUS_EN) {
                //debugPrintDir(dir);
#if 0 //LOG_FS_EN
                sprintf_f(rs->logs, "****** filename: [%s] ******\n", dir->dfSFN);
                print_f(rs->plogs, "CPFAT", rs->logs);    
#endif
                if (dir->pa) {
                    ipa = dir->dfpaid;
                    ipol = ipa >> 16;
                    idir = ipa & 0xffff;
#if 0 //LOG_FS_EN
                    sprintf_f(rs->logs, "    pa 0x%.8x = %d, %d\n", ipa, ipol, idir);
                    print_f(rs->plogs, "CPFAT", rs->logs);    
#endif
                    if (ipol > dsttr->dirFATUsed) {
                        sprintf_f(rs->logs, "ERROR!!! the dir pool id is overflow, id: %d, used: %d\n", ipol, dsttr->dirFATUsed);
                        print_f(rs->plogs, "CPFAT", rs->logs);    
                        return -5;
                    }

                    slecdir = dsttr->fatDirPool[ipol - 1];
                    if (!slecdir) {
                        return -5;
                    }
#if 0 //LOG_FS_EN
                    sprintf_f(rs->logs, "    pa pool max: %d, used: %d\n", slecdir->dirMax, slecdir->dirUsed);
                    print_f(rs->plogs, "CPFAT", rs->logs);    
#endif

                    if (idir > slecdir->dirUsed) {
                        sprintf_f(rs->logs, "ERROR!!! the dir id is overflow, id: %d, used: %d\n", idir, slecdir->dirUsed);
                        print_f(rs->plogs, "CPFAT", rs->logs);    
                        return -6;
                    }
                    
                    dpa = &slecdir->dirPool[idir];
                    if (!dpa) {
                        return -6;
                    }
#if 0 //LOG_FS_EN
                    sprintf_f(rs->logs, "    pa status: 0x%.8x \n", dpa->dfstats);
                    print_f(rs->plogs, "CPFAT", rs->logs);    
#endif
                    if (dpa->dfindex != ipa) {
                        sprintf_f(rs->logs, "WARNING!!! the pa id is different!!! (%d / %d)\n", ipa, dpa->dfindex);
                        print_f(rs->plogs, "CPFAT", rs->logs);    
                    }
                    
                }
                if (dir->br) {
                    ibr = dir->dfbrid;

                    ipol = ibr >> 16;
                    idir = ibr & 0xffff;
#if 0 //LOG_FS_EN
                    sprintf_f(rs->logs, "    br 0x%.8x = %d, %d\n", ibr, ipol, idir);
                    print_f(rs->plogs, "CPFAT", rs->logs);    
#endif
                    if (ipol > dsttr->dirFATUsed) {
                        sprintf_f(rs->logs, "ERROR!!! the dir pool id is overflow, id: %d, used: %d\n", ipol, dsttr->dirFATUsed);
                        print_f(rs->plogs, "CPFAT", rs->logs);    
                        return -7;
                    }

                    slecdir = dsttr->fatDirPool[ipol - 1];
                    if (!slecdir) {
                        return -7;
                    }
#if 0 //LOG_FS_EN
                    sprintf_f(rs->logs, "    br pool max: %d, used: %d\n", slecdir->dirMax, slecdir->dirUsed);
                    print_f(rs->plogs, "CPFAT", rs->logs);    
#endif
                    if (idir > slecdir->dirUsed) {
                        sprintf_f(rs->logs, "ERROR!!! the dir id is overflow, id: %d, used: %d\n", idir, slecdir->dirUsed);
                        print_f(rs->plogs, "CPFAT", rs->logs);    
                        return -8;
                    }
                    
                    dbr = &slecdir->dirPool[idir];
                    if (!dbr) {
                        return -6;
                    }
#if 0 //LOG_FS_EN
                    sprintf_f(rs->logs, "    br status: 0x%.8x \n", dbr->dfstats);
                    print_f(rs->plogs, "CPFAT", rs->logs);    
#endif
                    if (dbr->dfindex != ibr) {
                        sprintf_f(rs->logs, "WARNING!!! the br id is different!!! (%d / %d)\n", ibr, dbr->dfindex);
                        print_f(rs->plogs, "CPFAT", rs->logs);    
                    }
                }
                
                if (dir->ch) {
                    ich = dir->dfchid;

                    ipol = ich >> 16;
                    idir = ich & 0xffff;
#if 0 //LOG_FS_EN
                    sprintf_f(rs->logs, "    ch 0x%.8x = %d, %d\n", ich, ipol, idir);
                    print_f(rs->plogs, "CPFAT", rs->logs);    
#endif
                    if (ipol > dsttr->dirFATUsed) {
                        sprintf_f(rs->logs, "ERROR!!! the dir pool id is overflow, id: %d, used: %d\n", ipol, dsttr->dirFATUsed);
                        print_f(rs->plogs, "CPFAT", rs->logs);    
                        return -9;
                    }

                    slecdir = dsttr->fatDirPool[ipol - 1];
                    if (!slecdir) {
                        return -9;
                    }
#if 0 //LOG_FS_EN
                    sprintf_f(rs->logs, "    ch pool max: %d, used: %d\n", slecdir->dirMax, slecdir->dirUsed);
                    print_f(rs->plogs, "CPFAT", rs->logs);    
#endif
                    if (idir > slecdir->dirUsed) {
                        sprintf_f(rs->logs, "ERROR!!! the dir id is overflow, id: %d, used: %d\n", idir, slecdir->dirUsed);
                        print_f(rs->plogs, "CPFAT", rs->logs);    
                        return -10;
                    }
                    
                    dch = &slecdir->dirPool[idir];
                    if (!dch) {
                        return -6;
                    }
#if 0 //LOG_FS_EN
                    sprintf_f(rs->logs, "    ch status: 0x%.8x \n", dch->dfstats);
                    print_f(rs->plogs, "CPFAT", rs->logs);    
#endif
                    if (dch->dfindex != ich) {
                        sprintf_f(rs->logs, "WARNING!!! the br id is different!!! (%d / %d)\n", ich, dch->dfindex);
                        print_f(rs->plogs, "CPFAT", rs->logs);    
                    }
                }

#if 0//LOG_FS_EN
                sprintf_f(rs->logs, "    dpa: 0x%.8x, dbr: 0x%.8x, dch: 0x%.8x \n", dpa, dbr, dch);
                print_f(rs->plogs, "CPFAT", rs->logs);    
                
                if (dpa) {
                    sprintf_f(rs->logs, "    pa:[%s] status: 0x%.8x \n", dpa->dfSFN, dpa->dfstats);
                    print_f(rs->plogs, "CPFAT", rs->logs);    
                } else {
                    sprintf_f(rs->logs, "    pa addr:[0x%.8x]\n", dpa);
                    print_f(rs->plogs, "CPFAT", rs->logs);    
                }
                if (dbr) {
                    sprintf_f(rs->logs, "    br:[%s] status: 0x%.8x \n", dbr->dfSFN, dbr->dfstats);
                    print_f(rs->plogs, "CPFAT", rs->logs);    
                } else {
                    sprintf_f(rs->logs, "    br addr:[0x%.8x]\n", dbr);
                    print_f(rs->plogs, "CPFAT", rs->logs);    
                }

                if (dch) {
                    sprintf_f(rs->logs, "    ch:[%s] status: 0x%.8x \n", dch->dfSFN, dch->dfstats);
                    print_f(rs->plogs, "CPFAT", rs->logs);    
                } else {
                    sprintf_f(rs->logs, "    ch addr:[0x%.8x]\n", dch);
                    print_f(rs->plogs, "CPFAT", rs->logs);    
                }
#endif

                dir->pa = dpa;
                dir->br = dbr;
                dir->ch = dch;
                
                if (dir->dftype == ASPFS_TYPE_ROOT) {
                    sprintf_f(rs->logs, "rootdir:[%s] \n", dir->dfSFN);
                    print_f(rs->plogs, "CPFAT", rs->logs);    

                    dsttr->dirRoot = dir;
                    if (!dsttr->dirCur) {
                        dsttr->dirCur = dir;
                        sprintf_f(rs->logs, "curdir: [%s] \n", dir->dfSFN);
                        print_f(rs->plogs, "CPFAT", rs->logs);    
                    }
                }
                                
            }
            else {
                sprintf_f(rs->logs, "dir status [0x%x] go next \n", dir->dfstats);
                print_f(rs->plogs, "CPFAT", rs->logs);    
            }

        }
#if LOG_FS_EN
        sprintf_f(rs->logs, "dir size: %d print end \n", drsz);
        print_f(rs->plogs, "CPFAT", rs->logs);    
#endif
    }


    if (dsttr->dirCur) {
        aspFScpDir(&rs->psFat->fatCurDir, dsttr->dirCur);
        mspFS_folderList(&rs->psFat->fatCurDir, 4);            
        sprintf_f(rs->logs, "current folder: [%s] \n", rs->psFat->fatCurDir.dfSFN);
        print_f(rs->plogs, "CPFAT", rs->logs);    
    } else {
        sprintf_f(rs->logs, "ERROR!!! didn't get cur dir \n");
        print_f(rs->plogs, "CPFAT", rs->logs);    
    }

    if (dsttr->dirRoot) {
        if (dsttr->dirRoot->dfindex != iroot) {
            sprintf_f(rs->logs, "ERROR!!! didn't get root dir, iroot: %d index: %d\n", iroot, dsttr->dirRoot->dfindex);
            print_f(rs->plogs, "CPFAT", rs->logs);    
        }
    } else {
        sprintf_f(rs->logs, "ERROR!!! didn't get root dir point = null \n");
        print_f(rs->plogs, "CPFAT", rs->logs);    
    }

    srctr->dirFATDirty = 0;
    
    return 0;
}

static int aspNameCpyfromName(char *name, char *dst, int offset, int len, int jump)
{
    char ch=0;
    int i=0, cnt=0, idx=0;

    if (!len) return 0;

    cnt = 0;
    for (i = 0; i < len; i++) {
        idx = offset + i*jump;
        
        if (jump == 2) { /* Long file name */
            ch = aspLnameFilter(name[i]);
        } else { /* short file name */
            ch = aspSnameFilterIn(name[i]);
        }

        if (ch == 0xff) return cnt;
        dst[idx] = ch;
        cnt++;
        if (ch == 0) return cnt;
    }

    //printf("cpy cnt:%d \n", cnt);
    return cnt;
}

static int aspCompirseSFN(uint8_t *pc, struct directnFile_s *pf, uint8_t *sfn)
{
    uint32_t tmp32=0;
    struct directnFile_s *fs=0;
    uint8_t *raw=0;

    if (!pc) return -1;
    if (!pf) return -2;

    fs = pf;
    raw = pc;

    memset(raw, 0, 32);
#if LOG_FS_EN
    printf("  Compirse SFN: \n");
    printf("  [%x] type \n", pf->dftype);
    printf("  [%x] status \n", pf->dfstats);
    printf("  [%s] long file name, len:%d\n", pf->dfLFN, pf->dflen);
    printf("  [%s] short file name \n", pf->dfSFN);
    printf("  [%s] short file name - 2\n", sfn);
    printf("  [%x] attribute \n", pf->dfattrib);
    printf("  [%.2d:%.2d:%.2d] H:M:S created time \n", (pf->dfcretime >> 16) & 0xff, (pf->dfcretime >> 8) & 0xff, (pf->dfcretime >> 0) & 0xff);
    printf("  [%.2d:%.2d:%.2d] Y:M:D created date \n", ((pf->dfcredate >> 16) & 0xff) + 1980, (pf->dfcredate >> 8) & 0xff, (pf->dfcredate >> 0) & 0xff);
    printf("  [%.2d:%.2d:%.2d] Y:M:D access date \n", ((pf->dflstacdate >> 16) & 0xff) + 1980, (pf->dflstacdate >> 8) & 0xff, (pf->dflstacdate >> 0) & 0xff);
    printf("  [%.2d:%.2d:%.2d] H:M:S recorded time \n", (pf->dfrecotime >> 16) & 0xff, (pf->dfrecotime >> 8) & 0xff, (pf->dfrecotime >> 0) & 0xff);
    printf("  [%.2d:%.2d:%.2d] Y:M:D recorded date \n", ((pf->dfrecodate >> 16) & 0xff) + 1980, (pf->dfrecodate >> 8) & 0xff, (pf->dfrecodate >> 0) & 0xff);
    printf("  [%d] cluster number \n", pf->dfclstnum);
    printf("  [%d] file length \n", pf->dflength);
#endif
    if (fs->dfattrib & ASPFS_ATTR_DIRECTORY) {
        raw[11] = ASPFS_ATTR_DIRECTORY;
    } else {
        raw[11] = ASPFS_ATTR_ARCHIVE;
    }

    tmp32 = aspFStimeCps(fs->dfcretime);
    raw[15] = (tmp32 >> 8) & 0xff;
    raw[14] = tmp32 & 0xff;

    tmp32 = aspFSdateCps(fs->dfcredate);
    raw[17] = (tmp32 >> 8) & 0xff;
    raw[16] = tmp32 & 0xff;

    tmp32 = aspFSdateCps(fs->dflstacdate);
    raw[19] = (tmp32 >> 8) & 0xff;
    raw[18] = tmp32 & 0xff;

    tmp32 = aspFStimeCps(fs->dfrecotime);
    raw[23] = (tmp32 >> 8) & 0xff;
    raw[22] = tmp32 & 0xff;

    tmp32 = aspFSdateCps(fs->dfrecodate);
    raw[25] = (tmp32 >> 8) & 0xff;
    raw[24] = tmp32 & 0xff;

    tmp32 = fs->dfclstnum;
    raw[26] = tmp32 & 0xff;
    raw[27] = (tmp32 >> 8) & 0xff;
    raw[20] = (tmp32 >> 16) & 0xff;
    raw[21] = (tmp32 >> 24) & 0xff;

    tmp32 = fs->dflength;
    raw[28] = tmp32 & 0xff;
    raw[29] = (tmp32 >> 8) & 0xff;
    raw[30] = (tmp32 >> 16) & 0xff;
    raw[31] = (tmp32 >> 24) & 0xff;

    /* debug time and date */
    //shmem_dump(raw, 32);
    //printf("  dump end \n ");
    
    aspNameCpyfromName(sfn, raw, 0, 11, 1);
    
    return 32;
}

static int aspCompirseLFN(uint8_t *pc, char *name, uint8_t chksum, int size)
{
    char *c=0;
    uint8_t *p=0;
    int num=0, rst=0, i = 0, cnt=0;
    if (!pc) return -1;
    if (!name) return -2;

    if (size > 255) size = 255;
    
    rst = size % 13;
    num = (rst == 0) ? (size/13) : (size/13+1);

    printf("  LFN[%s] num: %d, rst: %d\n", name, num, rst);

    p = pc;
    c = name;
    for (i = num; i > 0; i--) {
        memset(p, 0, 32);
        p[0] = i & 0x0f;
        p[11] = 0x0f;
        p[12] = 0x00;
        p[13] = chksum;
        p[26] = 0x00;
        p[27] = 0x00;

        c = name + ((i - 1) * 13);
        if (i == num) {
            p[0] |= 0x40;
            if (rst) {
                if (rst > 5) {
                    aspNameCpyfromName(c, p, 1, 5, 2);
                    rst -= 5;
                } else {
                    aspNameCpyfromName(c, p, 1, rst, 2);
                    memset(p+1+rst*2, 0xff, (5-rst)*2);
                    rst = 0;
                }
                c += 5;
                
                if (rst > 6) {
                    aspNameCpyfromName(c, p, 14, 6, 2);
                    rst -= 6;
                } else {
                    aspNameCpyfromName(c, p, 14, rst, 2);
                    memset(p+14+rst*2, 0xff, (6-rst)*2);
                    rst = 0;
                }
                c += 6;
                
                if (rst > 2) {
                    printf("ERROR!! rst should not (> 2) rst: %d \n", rst);
                    aspNameCpyfromName(c, p, 28, 2, 2);
                    rst = 0;
                } else {
                    aspNameCpyfromName(c, p, 28, rst, 2);
                    memset(p+28+rst*2, 0xff, (2-rst)*2);
                    rst = 0;
                }                
            } else {
                aspNameCpyfromName(c, p, 1, 5, 2);
                c += 5;
                aspNameCpyfromName(c, p, 14, 6, 2);
                c += 6;
                aspNameCpyfromName(c, p, 28, 2, 2);
            }
        } else {
            aspNameCpyfromName(c, p, 1, 5, 2);
            c += 5;
            aspNameCpyfromName(c, p, 14, 6, 2);
            c += 6;
            aspNameCpyfromName(c, p, 28, 2, 2);
        }
        p += 32;
    }

    return (p - pc);
}

static int aspFindDot(char *name, int size)
{
    int i=0;
    char *p=0;

    if (!name) return -1;

    p = name;

    i = 0;
    while (i < size) {
        if (*p == '.') {
            return i;
        }
        i++;
        p++;
    }

    return -2;
}

static int aspCompirseDEF(uint8_t *pc, struct directnFile_s *fs)
{
    uint8_t chksum = 0;
    uint8_t *p=0, tmSFN[16];
    int ret=0, len=0;
    if (!pc) return -1;
    if (!fs) return -2;

    memset(tmSFN, 0x20, 16);
    ret = aspFindDot(fs->dfSFN, strlen(fs->dfSFN));
    if (ret < 0) {
#if LOG_FS_EN
        printf("  SFN do not have dot, ret: %d\n", ret);
#endif
        aspNameCpyfromName(fs->dfSFN, tmSFN, 0, strlen(fs->dfSFN), 1);
    } else {
        if (ret == 0) {
            if (strcmp(fs->dfSFN, ".") == 0) {
                tmSFN[0] = 0x2e;
            } else if (strcmp(fs->dfSFN, "..") == 0) {
                tmSFN[0] = 0x2e;
                tmSFN[1] = 0x2e;
            } else {
                fs->dflen = strlen(fs->dfSFN);
                strcpy(fs->dfLFN, fs->dfSFN);
                
                aspNameCpyfromName(fs->dfSFN, tmSFN, 1, fs->dflen-1, 1);
            }
        } else {
#if LOG_FS_EN
            printf("  SFN have dot, at [%d]\n", ret);
#endif
            aspNameCpyfromName(fs->dfSFN, tmSFN, 0, ret, 1);
            aspNameCpyfromName(fs->dfSFN+ret+1, tmSFN, 8, 3, 1);
        }
    }

    chksum = aspFSchecksum(tmSFN);
#if LOG_FS_EN
    printf("  tmSFN: [%s], chksum: 0x%.2x\n", tmSFN, chksum);
#endif
    p = pc;
    if (fs->dflen) {
        len = aspCompirseLFN(p, fs->dfLFN, chksum, fs->dflen+1);
        if (len > 0) {
#if LOG_FS_EN
            printf("  LFN get, len: %d\n", len);
#endif
            shmem_dump(p, len);
            p = p + len;
        } else {
            printf("  ERROR!!! LFN get failed, len: %d\n", len);        
        }
    }

    len = aspCompirseSFN(p, fs, tmSFN);
    if (len > 0) {
#if LOG_FS_EN
        printf("  SFN get, len: %d\n", len);
#endif
        shmem_dump(p, len);
        //*(p+12) = 0x18; // for windows conpatiable
        p = p + len;
    } else {
        printf("  ERROR!!! SFN get failed, len: %d\n", len);        
    }
    
    return (p - pc);
}

static int aspFindFreeDEF(uint8_t **ppc, uint8_t *pc, int max, int itvl)
{
    int i=0, j=0;
    uint8_t *p=0;

    p = pc;
    while (i < max) {
        if (*p == 0) {
            j = 0;
            while (j < itvl) { 
                if (p[j] != 0) break;
                j++;
            }

            if (j == itvl) {
                *ppc = p;
                return (max - i);
            }
        }
        p += itvl;
        i += itvl;
    }

    *ppc = pc + max;
    
    return -1;
}

static uint8_t aspFSchecksum(uint8_t *pch)
{
    int i=0;
    uint8_t sum=0, ch=0;

    sum = 0;
    for (i=0; i < 11; i++) {
        sum = ((sum & 0x01) ? 0x80:0) | (sum >> 1);
        ch = *pch;
        sum += ch;
        pch++;
    }

    return sum;
}

static char aspLnameFilter(char ch)
{
    char def = '_', *p=0;
    char notAllow[10] = {0x22, 0x2a, 0x2f, 0x3a, 0x3c, 
                                     0x3e, 0x3f, 0x5c, 0x7c, 0x7f};

    if (ch == 0x0)  return ch;
    if (ch < 0x20)  return def;
    if (ch > 0x7f)  return def;

    p = notAllow + 9;
    while (p >= notAllow) {
        if (*p == ch) return def;
        p --;
    }

    return ch;
}

static char aspSnameFilterOut(char ch)
{
    char def = '_', *p=0;
    char notAllow[16] = {0x22, 0x2a, 0x2b, 0x2c, 0x2f, 0x3a, 0x3b, 0x3c, 
                                     0x3d, 0x3e, 0x3f, 0x5b, 0x5c, 0x5d, 0x7c, 0x7f};

    if (ch == 0x0)  return ch;
    if (ch < 0x20)  return def;
    if (ch > 0x7f)  return def;
    if ((ch > 0x40) && ch < (0x5b)) {
        ch += 0x20;
    }

    p = notAllow + 15;
    while (p >= notAllow) {
        if (*p == ch) return def;
        p --;
    }

    return ch;
}

static char aspSnameFilterIn(char ch)
{
    char def = '_', *p=0;
    char notAllow[16] = {0x22, 0x2a, 0x2b, 0x2c, 0x2f, 0x3a, 0x3b, 0x3c, 
                                     0x3d, 0x3e, 0x3f, 0x5b, 0x5c, 0x5d, 0x7c, 0x7f};

    if (ch == 0x0)  return 0x20;
    if (ch < 0x20)  return def;
    if (ch > 0x7f)  return def;
    if ((ch > 0x60) && ch < (0x7b)) {
        ch -= 0x20;
    }

    p = notAllow + 15;
    while (p >= notAllow) {
        if (*p == ch) return def;
        p --;
    }

    return ch;
}

static int aspNameCpyfromRaw(char *raw, char *dst, int offset, int len, int jump)
{
    char ch=0;
    int i=0, cnt=0, idx=0;

    cnt = 0;
    for (i = 0; i < len; i++) {
        idx = offset+i*jump;
        if (idx > 32) return (-1);
        
        if (jump == 2) { /* Long file name */
            ch = aspLnameFilter(raw[idx]);
        } else { /* short file name */
            ch = aspSnameFilterOut(raw[idx]);
        }

        if (ch == 0xff) return cnt;
        *dst = ch;
        dst ++;
        cnt++;
        if (ch == 0) return cnt;
    }

    //printf("cpy cnt:%d \n", cnt);
    return cnt;
}

static int aspFSspaceCount(char *str, int len)
{
    int space=0;
    int sc=0;
    char *end=0;
    if (!str) return -1;
    if (!len) return -2;
    end = str + len - 1;
    while (end >= str) {
        if (*end == 0x20) {
            space++;
            //*end = 0;
        } else {
            break;
        }
        //if (*end != 0) break;
        end --;
    }
    return space;
}

static int aspFSrmspace(char *str, int len)
{
    int space=0;
    int sc=0;
    char *end=0;
    if (!str) return -1;
    if (!len) return -2;
    end = str + len - 1;
    while (end >= str) {
        if (*end == 0x20) {
            space++;
            *end = 0;
        }
        
        if (*end != 0) break;
        
        end --;
    }
    return space;
}

static void aspFSadddot(char *str, int len)
{
    int sc=0;
    char *end=0;
    if (!str) return;
    if (!len) return;
    end = str + len;
    while (end > str) {
        if (*end == 0x20) {
            *end = '.';
            break;
        }
        end --;
    }
}

static uint32_t aspFSdateAsb(uint32_t fst)
{
    uint32_t val=0, y=0, m=0, d=0;
    d = fst & 0x1f; // 0 -4, 5bits
    m = (fst >> 5) & 0xf; // 5 - 8, 4bits
    y = (fst >> 9) & 0x7f; // 9 - 15, 7bits
    val |= (y << 16) | (m << 8) | d;
    return val;
}

static uint32_t aspFSdateCps(uint32_t val)
{
    uint32_t fst=0, y=0, m=0, d=0;

    d = val & 0x1f; // 0 -4, 5bits
    m = (val >> 8) & 0xf; // 5 - 8, 4bits
    y = (val >> 16) & 0x7f; // 9 - 15, 7bits

    fst = (y << 9) | (m << 5) | d;
    
    return fst;
}

static uint32_t aspFStimeAsb(uint32_t fst)
{
    uint32_t val=0, s=0, m=0, h=0;
    s = (fst & 0x1f) << 1; // 0 -4, 5bits
    m = (fst >> 5) & 0x3f; // 5 - 10, 6bits
    h = (fst >> 11) & 0x1f; // 11 - 15, 5bits
    val |= (h << 16) | (m << 8) | s;
    return val;
}

static uint32_t aspFStimeCps(uint32_t val)
{
    uint32_t fst=0, s=0, m=0, h=0;
    s = (val >> 1) & 0x1f; // 0 -4, 5bits
    m = (val >> 8) & 0x3f; // 5 - 10, 6bits
    h = (val >> 16) & 0x1f; // 11 - 15, 5bits

    fst = (h << 11) | (m << 5) | s;
    
    return fst;
}

static int aspLnameAbs(char *raw, char *dst) 
{
    int cnt=0, ret=0;
    char ch=0;
    if (!raw) return (-1);
    if (!dst) return (-2);

    ret = aspNameCpyfromRaw(raw, dst, 1, 5, 2);
    cnt += ret;
    if (ret != 5) return cnt;

    dst += ret;
    ret = aspNameCpyfromRaw(raw, dst, 14, 6, 2);
    cnt += ret;
    if (ret != 6) return cnt;
    
    dst += ret;
    ret = aspNameCpyfromRaw(raw, dst, 28, 2, 2);
    cnt += ret;

    //printf("name abs cnt:%d\n", cnt);
    return cnt;
}

static int aspRawParseDir(char *raw, struct directnFile_s *fs, int last)
{
    //printf("[PAR][%d] - [%.6x] - S\n", last, fs->dfstats);
    uint32_t tmp32=0;
    uint8_t sum=0;
    int leN=0, cnt=0, idx=0, ret = 0, n = 0;
    char *plnN=0, *pstN=0, *nxraw=0;
    char ld=0, nd=0;
    uint32_t lf=0;

    if (!raw) return (-1);
    if (!fs) return (-2);
    if (last < 32) return last; 

    if (fs->dfstats == ASPFS_STATUS_EN) return 0;

    ld = *raw;
    
#if LOG_FS_EN
    shmem_dump(raw, 32);
#endif

    if ((ld == 0xe5) || (ld == 0x05)) {
        ret = -4;
        //memset(fs, 0x00, sizeof(struct directnFile_s));
        goto fsparseEnd;
    } else if (ld == 0x00) {
        for (n=1; n < 32; n++) {
            if (raw[n] != 0) {
                break;
            }
        }

        if (n == 32) {
            memset(fs, 0x00, sizeof(struct directnFile_s));
            //return (-5);
            return last;
        } else {
            goto fsparseEnd;
        }
    } else if ((fs->dfstats & 0xff) == ASPFS_STATUS_DIS) {
        pstN = fs->dfSFN;
        ret = aspNameCpyfromRaw(raw, pstN, 0, 11, 1);
        if (ret != 11) {
            //memset(fs, 0x00, sizeof(struct directnFile_s));
#if LOG_FS_EN
            printf("\n  ERROR!!short name [%s] copy error ret:%d \n", pstN, ret);
#endif
            goto fsparseEnd;
        }

        idx = (fs->dfstats >> 8) & 0xf;
        if (idx) {
            sum = aspFSchecksum((uint8_t*)raw);
#if LOG_FS_EN
            printf("LONG file name parsing... last parsing [len:%d]\n", fs->dflen);
#endif
            if (sum != ((fs->dfstats >> 16) & 0xff)) {
                ret = -11;
                //memset(fs, 0x00, sizeof(struct directnFile_s));
#if LOG_FS_EN
                printf("WARNING!!! checksum error: 0x%x / 0x%x [%s]\n", sum, (fs->dfstats >> 16) & 0xff, pstN);
#endif
                goto fsparseEnd;
            } else {
#if LOG_FS_EN
                printf("CONGING!!! checksum match: 0x%x / 0x%x [%s]\n\n", sum, (fs->dfstats >> 16) & 0xff, pstN);
#endif
            }
        } else {
#if LOG_FS_EN
            printf("\nSHORT file name parsing... [len:%d][%s]\n", fs->dflen, pstN);
#endif
        }

        cnt = aspFSspaceCount(pstN+8, 3);
        if (cnt < 3) {
            memset(pstN, 0, 12);
            ret = aspNameCpyfromRaw(raw, pstN, 0, 8, 1);
            if (ret != 8) {
                //memset(fs, 0x00, sizeof(struct directnFile_s));
                //printf("short name copy error ret:%d \n", ret);
                goto fsparseEnd;
            }
            ret = aspFSspaceCount(pstN, 8);
#if LOG_FS_EN
            printf("[%s]short name space count:%d \n", pstN, ret);
#endif
            n = strlen(pstN) - ret;
            pstN += n;
            *pstN = '.';
            pstN += 1;
#if LOG_FS_EN
            printf("[%s]short name space n:%d \n", pstN, n);
#endif
            ret = aspNameCpyfromRaw(raw, pstN, 8, 3, 1);
            if (ret != 3) {
                //memset(fs, 0x00, sizeof(struct directnFile_s));
                //printf("short name copy error ret:%d \n", ret);
                goto fsparseEnd;
            }
#if LOG_FS_EN
            printf("[%s]short name space tail \n", pstN);
#endif
            pstN = fs->dfSFN;
            ret = aspFSrmspace(pstN, 12);
#if LOG_FS_EN
            printf("[%s]short name space result, cnt: %d\n", fs->dfSFN, ret);
#endif
        }
        else {
            cnt = aspFSrmspace(pstN, 8);
#if LOG_FS_EN
            printf("rm space count : %d [%s] - 2\n", cnt, pstN);
#endif
        }

        fs->dfattrib = raw[11];
        tmp32 = raw[14] | (raw[15] << 8);
        fs->dfcretime = aspFStimeAsb(tmp32);
        tmp32 = raw[16] | (raw[17] << 8);
        fs->dfcredate = aspFSdateAsb(tmp32);
        tmp32 = raw[18] | (raw[19] << 8);
        fs->dflstacdate =aspFSdateAsb(tmp32);
        tmp32 = raw[22] | (raw[23] << 8);
        fs->dfrecotime= aspFStimeAsb(tmp32);
        tmp32 = raw[24] | (raw[25] << 8);
        fs->dfrecodate = aspFSdateAsb(tmp32);
        tmp32 = raw[26] | (raw[27] << 8) | (raw[20] << 16) | (raw[21] << 24);
        fs->dfclstnum = tmp32;
        tmp32 = raw[28] | (raw[29] << 8) | (raw[30] << 16) | (raw[31] << 24);
        fs->dflength = tmp32;

        if (fs->dfattrib & ASPFS_ATTR_DIRECTORY) {
            fs->dftype = ASPFS_TYPE_DIR;
        } else {
            fs->dftype = ASPFS_TYPE_FILE;
        }

        fs->dfstats = ASPFS_STATUS_EN;
        ret = 0;

        if (fs->dfattrib > ASPFS_ATTR_ARCHIVE) {
            ret = -12;
        }
        /*
        if (fs->dfattrib & ASPFS_ATTR_DIRECTORY) {
            if (fs->dflength > 0) {
                ret = -13;
            }
        } 
        */
        if (!fs->dfclstnum) {
            ret = -14;
        }

        if (ret) {
            //memset(fs, 0x00, sizeof(struct directnFile_s));
        }
        
        goto fsparseEnd;
    }
    else if ((ld & 0xf0) == 0x40) {
        nd = raw[32]; 
        lf = raw[11] | (raw[12] << 8) | (raw[27] << 16) | (raw[26] << 24);
#if LOG_FS_EN        
        printf("\n before LONG file name parsing...[0x%.2x] [0x%.2x] [0x%.8x] \n", ld, nd, lf);
#endif

        if (ld == 0x41) {
            if (lf != 0xf) {
                fs->dfstats = ASPFS_STATUS_DIS;
                return aspRawParseDir(raw, fs, last);
            }
        }
        else if ((nd != ((ld & 0xf) - 1)) || (nd == 0)) {
            //memset(fs, 0x00, sizeof(struct directnFile_s));
            fs->dfstats = ASPFS_STATUS_DIS;
            return aspRawParseDir(raw, fs, last);
        }
        
#if LOG_FS_EN
        printf("\n LONG file name parsing...[0x%.2x] \n", ld);
#endif

        ret = 0;
        if (raw[11] != 0x0f) {
            ret = -5;
        }
        if (raw[12] != 0x00) {
            ret = -6;
        }
        if (ret) {
            //memset(fs, 0x00, sizeof(struct directnFile_s));
            goto fsparseEnd;
        }

        //memset(fs, 0x00, sizeof(struct directnFile_s));

        idx = ld & 0xf;

        if (idx == 0x01) {
            fs->dfstats = ASPFS_STATUS_DIS;
            fs->dfstats |= (ld & 0xf) << 8;
            fs->dfstats |= (raw[13] & 0xff) << 16;
            //printf("WARNING!!! get checksum: 0x%x - 1.0\n", (fs->dfstats >> 16) & 0xff);
        } else {
            fs->dfstats = ASPFS_STATUS_ING;
            fs->dfstats |= (ld & 0xf) << 8;
            fs->dfstats |= (raw[13] & 0xff) << 16;
            //printf("WARNING!!! get checksum: 0x%x - 1.1\n", (fs->dfstats >> 16) & 0xff);
        }

        nxraw = raw+32;
        ret = 32 + aspRawParseDir(nxraw, fs, last-32);

        plnN = fs->dfLFN;
        plnN += fs->dflen;
        cnt = aspLnameAbs(raw, plnN);
        fs->dflen += cnt;
        
#if LOG_FS_EN
        printf("LONG file name parsing... go to next ret:%d len:%d cnt:%d\n", ret, fs->dflen, cnt);
#endif
        return ret;
    }
    else if ((fs->dfstats & 0xff) == ASPFS_STATUS_ING) {
    
#if LOG_FS_EN
        printf("LONG file name parsing... the next \n");
#endif
        ret = 0;
        idx = (fs->dfstats >> 8) & 0xf;
        if (ld != (idx - 1)) {
            ret = -7;
        }
        if (raw[11] != 0x0f) {
            ret = -8;
        }
        if (raw[12] != 0x00) {
            ret = -9;
        }
        if (raw[13] != ((fs->dfstats >> 16) & 0xff)) {
            ret = -10;
        }       
        if (ret) {
            printf("\nERROR!!LONG file name parsing... broken here ret:%d\n", ret);
            //memset(fs, 0x00, sizeof(struct directnFile_s));
            goto fsparseEnd;
        }
        
        if ((ld & 0xf) == 0x01) {
            fs->dfstats = ASPFS_STATUS_DIS;
            fs->dfstats |= (ld & 0xf) << 8;
            fs->dfstats |= (raw[13] & 0xff) << 16;
            //printf("WARNING!!! get checksum: 0x%x - 2.0\n", (fs->dfstats >> 16) & 0xff);
        } else {
            fs->dfstats = ASPFS_STATUS_ING;
            fs->dfstats |= (ld & 0xf) << 8;
            fs->dfstats |= (raw[13] & 0xff) << 16;
            //printf("WARNING!!! get checksum: 0x%x - 2.1\n", (fs->dfstats >> 16) & 0xff);
        }

        nxraw = raw+32;
        ret = 32 + aspRawParseDir(nxraw, fs, last-32);

        plnN = fs->dfLFN;
        plnN += fs->dflen;
        cnt = aspLnameAbs(raw, plnN);
        fs->dflen += cnt;
#if LOG_FS_EN
        printf("LONG file name parsing... go to the next's next ret:%d len:%d cnt:%d\n", ret, fs->dflen, cnt);
#endif
        return ret;
    }
    else {
            //memset(fs, 0x00, sizeof(struct directnFile_s));
            fs->dfstats = ASPFS_STATUS_DIS;
            return aspRawParseDir(raw, fs, last);
    }

fsparseEnd:

    //printf("[PAR][%d] - [%.6x] - E \n", last, fs->dfstats);
    
    if (last == 32) {
        return 32;
    } else if (last > 32) {
        raw += 32;
        last = last - 32;
        return 32 + aspRawParseDir(raw, fs, last);
    } else {
        return ret;
    }

}

static int aspFS_createFATRoot(struct sdFAT_s *pfat)
{
    char dir[32] = "ROOT";
    struct directnFile_s *r = 0, *c = 0;

    mspFS_allocDir(&pfat->fatDirTr, &r, 9);
    if (!r) {
        return (-1);
    }
    //memset(r, 0, sizeof(struct directnFile_s));

    r->pa = 0;
    r->br = 0;
    r->ch = 0;
    r->dftype = ASPFS_TYPE_ROOT;
    r->dfattrib = 0;
    r->dfstats = ASPFS_STATUS_EN;
    r->dfclstnum = 2;

    strcpy(r->dfSFN, dir);

    /*
    r->dflen = strlen(dir);
    if (r->dflen > 255) r->dflen = 255;
    strncpy(r->dfLFN, dir, r->dflen);
    */
    
    //pfat->fatRootdir = r;
    pfat->fatDirTr.dirRoot = r;
    //aspFScpDir(&pfat->fatRootdir, r);

    return 0;
}

static int aspFS_insertFATChilds(struct sdFAT_s *pfat, struct directnFile_s *root, char *dir, int max)
{
#define TAB_DEPTH   4
    int ret = 0, cnt = 0;
    DIR *dp;
    struct dirent *entry;
    struct stat statbuf;
    struct directnFile_s *dfs = 0;

    char *dkbuf=0;

    if (!root) {
        printf("[R]root error 0x%x\n", (uint32_t)root);
        ret = -1;
        goto insertEnd;
    }

    if (root->dflen) {
#if LOG_FS_EN
        printf("[R]open directory [%s] - %d\n", root->dfLFN, root->dfclstnum);
#endif
    } else {
#if LOG_FS_EN
        printf("[R]open directory [%s] - %d\n", root->dfSFN, root->dfclstnum);
#endif
    }

    if ((!dir) || (max <=0)) {
        printf("[R]Can`t open directory \n");
        ret = -2;
        goto insertEnd;
    }

    dkbuf = dir;
    mspFS_allocDir(&pfat->fatDirTr, &dfs, 9);
    if (!dfs) {
        ret = -3;
        goto insertEnd;
    }
    //memset(dfs, 0, sizeof(struct directnFile_s));
    cnt = 0;
    ret = aspRawParseDir(dkbuf, dfs, max);
#if LOG_FS_EN
    printf("[R]raw parsing cnt: %d / %d \n", ret, max);
#endif
    while (max > 0) {
        if (dfs->dfstats) {
#if LOG_FS_EN
            printf("[R]short name: %s \n", dfs->dfSFN);
#endif
            //dfs->dfstats = 0;
            if (dfs->dflen > 0) {
                //printf("[R]long name: %s, len:%d \n", dfs->dfLFN, dfs->dflen);
            }

            if (strcmp(dfs->dfSFN, ".") == 0) {
                dfs->dfstats = 0;
                //memset(dfs, 0, sizeof(struct directnFile_s));
            } else if (strcmp(dfs->dfSFN, "..") == 0 ) {
                dfs->dfstats = 0;
                //memset(dfs, 0, sizeof(struct directnFile_s));
            } else {
            
                //debugPrintDir(dfs);
                aspFS_insertFATChild(root, dfs);

                mspFS_allocDir(&pfat->fatDirTr, &dfs, 9);
                if (!dfs) {
                    ret = -3;
                    goto insertEnd;
                }
                //memset(dfs, 0, sizeof(struct directnFile_s));
            }
        }

        dkbuf += ret;
        max -= ret;
        cnt++;
        
        ret = aspRawParseDir(dkbuf, dfs, max);
        if (ret <= 0) break;
#if LOG_FS_EN
        printf("[R] cnt:%d ret: %d, last:%d \n", cnt, ret, max);
#endif
    }

#if LOG_FS_EN
    printf("[R]raw parsing end: %d \n", ret);
#endif

insertEnd:

    return ret;
}

static int aspFS_insertFATChild(struct directnFile_s *parent, struct directnFile_s *r)
{
    int ret=0;
    struct directnFile_s *brt = 0;

    r->pa = parent;
    r->dfpaid = parent->dfindex;
    r->br = 0;
    r->ch = 0;

    if (parent->ch == 0) {
        parent->ch = r;
        parent->dfchid = r->dfindex;
    } else {
        brt = parent->ch;
        if (brt->br == 0) {
            brt->br = r;
            brt->dfbrid = r->dfindex;
        } else {
            r->br = brt->br;
            r->dfbrid = brt->br->dfindex;
            brt->br = r;
            brt->dfbrid = r->dfindex;
        }
    }

//    ret = aspFS_insertFATChilds(r);
 
    return ret;
}


static int mspFS_insertFATChildDir(struct sdFAT_s *pfat, struct directnFile_s *parent, char * dir, int max)
{
    int ret;
    char mlog[256];

    struct directnFile_s *c = 0;
    struct directnFile_s *brt = 0;

    mspFS_allocDir(&pfat->fatDirTr, &c, 9);
    if (!c) {
        return (-1);
    }
    //memset(c, 0, sizeof(struct directnFile_s));

    c->pa = parent;
    c->dfpaid = parent->dfindex;
    c->br = 0;
    c->ch = 0;
    c->dftype = ASPFS_TYPE_DIR;
    c->dfattrib = 0;
    c->dfstats = ASPFS_STATUS_EN;
    c->dflen = 0;
    strcpy(c->dfSFN, "..");
    
    if (parent->ch == 0) {
        parent->ch = c;
        parent->dfchid = c->dfindex;
    } else {
        brt = parent->ch;
        if (brt->br == 0) {
            brt->br = c;
            brt->dfbrid = c->dfindex;
        } else {
            c->br = brt->br;
            c->dfbrid = brt->br->dfindex;
            brt->br = c;
            brt->dfbrid = c->dfindex;
        }
    }

    ret = aspFS_insertFATChilds(pfat, parent, dir, max);
    
    return ret;
}
static int aspFS_list(struct directnFile_s *root, int depth)
{

    struct directnFile_s *fs = 0;
    if (!root) return (-1);

    fs = root->ch;
    while (fs) {
        printf("%*s%s[%d]\n", depth, "", fs->dfLFN, fs->dftype);
        if (fs->dftype == ASPFS_TYPE_DIR) {
            aspFS_list(fs, depth + 4);
        }
        fs = fs->br;
    }

    return 0;
}

static int mspSD_WriteFAT(int idx, int val, uint8_t *fat, uint32_t max) 
{
    uint8_t *uch;
    uint32_t offset=0, i=0;

    if (idx > max) {
        printf(" ERROR!! Get next Free FAT idx: %d > max: %d\n", idx, max);
        return 0xffffffff;
    }

    offset = idx * 4;

    uch = fat + offset;

    i = 0;
    while (i < 4) {
        uch[i] = val >> (i * 8);
        i++;
    }

    //printf("FAT val: %.2x - %.2x - %.2x - %.2x\n", uch[0], uch[1], uch[2], uch[3]);

    return 0;    
}

static int mspSD_writeList2FAT(int start, int length, uint8_t *fat, uint32_t max) 
{
    int i=0, ret=0;
    int cur=0;

    if (!length) return -1;

    cur = start;
    for (i = 0; i < length; i++) {
        if (cur > max) return -2;
        ret = mspSD_WriteFAT(cur, cur+1, fat, max);
        if (ret) return -3;
        cur++;
    }

    return 0;
}

static int mspSD_updLocalFAT(struct adFATLinkList_s *list, uint8_t *fat, uint32_t max) 
{
    int ret=0;
    uint32_t val=0;
    struct adFATLinkList_s *cur, *pre;
    if (!list) return -1;
    if (!fat) return -2;

    cur = list;

    while (cur) {
        val = mspSD_getNextFreeFAT(cur->ftStart, fat, max);
        if (val) {
#if LOG_FS_EN
            printf("  [FS] Warning!!! FAT should be zero val = 0x%x \n", val);
#endif
        } else {
#if LOG_FS_EN
            printf("  [FS] start FAT is zero idx: %d len: %d\n", cur->ftStart, cur->ftLen);
#endif
        }

        ret = mspSD_writeList2FAT(cur->ftStart, cur->ftLen, fat, max);
        if (ret) return -3;
        pre = cur;
        cur = cur->n;
        if (cur) {
            mspSD_WriteFAT(pre->ftStart+pre->ftLen-1, cur->ftStart, fat, max);
#if LOG_FS_EN
            printf("  [FS] CONT last idx: %d, next start: %d\n", pre->ftStart+pre->ftLen-1, cur->ftStart);
#endif
        } else {
            mspSD_WriteFAT(pre->ftStart+pre->ftLen-1, 0x0fffffff, fat, max);
#if LOG_FS_EN
            printf("  [FS] END last idx: %d, next start: %d\n", pre->ftStart+pre->ftLen-1);
#endif
        }
    }
    
    return 0;    
}

static int mspSD_rangeFATLinkList(struct adFATLinkList_s *list, int *start, int *last)
{
    int upb=-1, lob=-1;
    int bgn=0, end=0;
    struct adFATLinkList_s *cur;

    if (!list) return -1;
    if (!start) return -2;
    if (!last) return -3;
    
    cur = list;

    while (cur) {
        bgn = cur->ftStart;
        end = bgn + cur->ftLen;
#if LOG_FS_EN
        printf("  range: [%d + %d = %d]\n", bgn, cur->ftLen, end);
#endif
        if (lob < 0) {
            lob = bgn;
        } else {
            if (lob > bgn) {
                lob = bgn;
            }
        }

        if (upb < 0) {
            upb = end;
        } else {
            if (upb < end) {
                upb = end;
            }
        }
        
        cur = cur->n;
#if LOG_FS_EN
        printf("  range: [lob:%d, upb:%d]\n", lob, upb);
#endif
    }

    if ((upb < 0) || (lob < 0)) {
        return -4;
    } 

    *start = lob;
    *last = upb;
    
    return 0;
}

static int mspSD_createFATLinkList(struct adFATLinkList_s **list)
{
    struct adFATLinkList_s *newList=0;

    newList = (struct adFATLinkList_s *)aspMemalloc(sizeof(struct adFATLinkList_s), 9);  /* FAT free cls */
    if (!newList) return -1;

    memset(newList, 0, sizeof(struct adFATLinkList_s));

    *list = newList;
    return 0;
}

static uint32_t mspSD_getNextFAT(uint32_t idx, uint8_t *fat, uint32_t max) 
{
    uint8_t *uch;
    uint32_t offset=0, i=0;
    uint32_t val = 0;

    if (idx > max) {
        //printf(" ERROR!! Get next FAT idx: %d > max: %d\n", idx, max);
        return 0xffffffff;
    }

    if (!idx) {
        return 0;
    }
    offset = idx * 4;

    uch = fat + offset;
    msync(uch, 16, MS_SYNC);
    
    i = 0;
    while (i < 4) {
        val |= uch[i] << (i * 8);
        i++;
    }

    //printf("   Get next FAT val: %d\n", val);

    return val;    
}

inline int mspSD_parseFAT2LinkList(struct adFATLinkList_s **head, uint32_t idx, uint8_t *fat, uint32_t max)
{
    struct adFATLinkList_s *p=0;
    uint32_t llen=0, lstr=0, nxt=0, cur=0, ret=0;
    struct adFATLinkList_s *ls=0, *nt=0;
    cur = idx;

    ret = mspSD_createFATLinkList(&ls);
    if (ret) return ret;

    *head = ls;

    if (cur < 2) {
        cur = 0;
    }

    lstr = cur; 
    llen = 1;
#if LOG_FS_EN
    printf("  start %d, %d\n", lstr, llen);
#endif
    
    nxt = mspSD_getNextFAT(cur, fat, max);
    while (nxt) {
        if (nxt == 0x0ffffff8) {
#if LOG_FS_EN
            printf("  empty %d, %d\n", lstr, llen);
#endif
            break;
        } else if (nxt == 0x0fffffff) {
#if LOG_FS_EN
            printf("  end %d, %d\n", lstr, llen);
#endif
            break;
        } else if (nxt == 0xffffffff) {
#if LOG_FS_EN
            printf("  error %d, %d\n", lstr, llen);
#endif
            return -1;
            break;
        }

        //printf("  compare nxt:%d and cur:%d\n", nxt, cur);    
        
        if (nxt == (cur+1)) {
            cur = nxt;
            nxt = 0;
            llen += 1;
        } else {
            ls->ftStart = lstr;
            ls->ftLen = llen;

            ret = mspSD_createFATLinkList(&ls->n);
            if (ret) return ret;

            //printf("  diff nxt:%d, cur:%d str:%d, len:%d\n", nxt, cur, lstr, llen);

            cur = nxt;
            lstr = cur;
            llen = 1; 
            ls = ls->n;
        }
        nxt = mspSD_getNextFAT(cur, fat, max);
        //printf("  return nxt:%d\n", nxt);
    }

    if (!lstr) {
        llen = 0;
        printf("  empty %d, %d\n", lstr, llen);
    }

    ls->ftStart = lstr;
    ls->ftLen = llen;
    ls->n = 0;

    return 0;
}

static uint32_t mspSD_getNextFreeFAT(uint32_t idx, uint8_t *fat, uint32_t max) 
{
    uint8_t *uch;
    uint32_t offset=0, i=0;
    uint32_t val = 0;

    if (idx > max) {
        printf(" ERROR!! Get next Free FAT idx: %d > max: %d\n", idx, max);
        return 0xffffffff;
    }

    offset = idx * 4;

    uch = fat + offset;

    i = 0;
    while (i < 4) {
        val |= uch[i] << (i * 8);
        i++;
    }

    //printf("   Get next Free FAT val: %d\n", val);

    return val;    
}

static int mspSD_getFreeFATList(struct adFATLinkList_s **head, uint32_t idx, uint8_t *fat, uint32_t max)
{
    uint32_t llen=0, lstr=0, nxt=0, cur=0, ret=0, ocp=0, fri=0;
    struct adFATLinkList_s *ls=0, *nt=0;
    cur = idx;

    ret = mspSD_createFATLinkList(&ls);
    if (ret) return ret;

    *head = ls;

    lstr = cur; 
    llen = 0;
    
#if LOG_FS_EN
    printf("  start %d, %d\n", lstr, llen);
#endif

    while (cur < max) {
        nxt = mspSD_getNextFreeFAT(cur, fat, max);

        if (nxt == 0x0ffffff8) {
#if LOG_FS_EN
            printf(" search start ...\n");
#endif
        } else if (nxt == 0xffffffff) {
#if LOG_FS_EN
            printf(" just start ... \n");
#endif
        } else if (nxt == 0x0fffffff) {
            ocp++;
            //printf("  [%d] ocp %d\n", cur, ocp);
        } else if (nxt == 0xffffffff) {
#if LOG_FS_EN
            printf("  [%d] error %d, %d\n", cur, lstr, llen);
#endif
            return -1;
        } else {

            if (!nxt) {
                fri ++;
                if (!lstr) {
                    lstr = cur;
                }
                llen += 1;
            } else {
                if (lstr) {
                    ls->ftStart = lstr;
                    ls->ftLen = llen;
                    ret = mspSD_createFATLinkList(&ls->n);
                    if (ret) return ret;
#if LOG_FS_EN
                    printf(" free sector, start:%d len:%d \n", lstr, llen);
#endif
                    lstr = 0;
                    llen = 0; 
                    ls = ls->n;
                } else {
                    ocp++;
                    //printf("  [%d] ocp %d\n", cur, ocp);
                }
            }
        }
        cur++;
    }

    if (ls->n) {
        aspMemFree(ls->n, 9);
        ls->n = 0;
    } else {
        ls->ftStart = lstr;
        ls->ftLen = llen;
    }
#if LOG_FS_EN
    printf(" total free cluster %d, total used cluster %d \n", fri, ocp);
#endif
    return 0;
}

static int mspSD_getLastFATList(struct adFATLinkList_s **head, struct adFATLinkList_s *f)
{
    int ret=0;
    uint32_t str=0, len=0, acu=0;
    struct adFATLinkList_s *c=0, *t=0;
    struct adFATLinkList_s *ls=0, *nt=0;
    
    if (!f) return -1;
    ret = mspSD_createFATLinkList(&ls);
    if (ret) return ret;

    *head = ls;
    c = f;

    while (c->n) {
        c = c->n;
    }

    ls->ftLen = c->ftLen;
    ls->ftStart = c->ftStart;

    return 0;
}

static int mspSD_allocFreeFATList(struct adFATLinkList_s **head, uint32_t length, struct adFATLinkList_s *f, struct adFATLinkList_s **n)
{
    int ret=0;
    uint32_t str=0, len=0, acu=0;
    struct adFATLinkList_s *c=0, *t=0;
    struct adFATLinkList_s *ls=0, *nt=0;
    
    if (!f) return -1;
    ret = mspSD_createFATLinkList(&ls);
    if (ret) return ret;

    *head = ls;
    c = f;
    
    while (length) {
        if (!c) {
            return -2;
        }

        str = c->ftStart;
        len = c->ftLen;
        if (len > length) {
            ls->ftStart = str;
            ls->ftLen = length;
            
            len = len - length;
            str = str + length;

            c->ftStart = str;
            c->ftLen = len;
            length = 0;
            t = ls;
            break;
        } else {
            length = length - len;
            nt = c;
            
            ret = mspSD_createFATLinkList(&ls->n);
            if (ret) return ret;

            ls->ftStart = str;
            ls->ftLen = len;
            t = ls;
            ls = ls->n;
        }
        
        c = c->n;        
        
        if (nt) {
            aspMemFree(nt, 9);
            nt = 0;
        }
    }

    if (!ls->ftLen) {
        t->n = 0;
        aspMemFree(ls, 9);
    }

    *n = c;

    return 0;
}

static int mspFS_allocDir(struct sdFatDir_s  *pfatDir, struct directnFile_s **dir, int pidx)
{
    char mlog[256];
    int cid=0, lv=0;

    struct sdDirPool_s *pool=0;

    //pfatDir = &psFat->fatDirTr;

    //printf("[ALC] dir pool number: %d \n", pfatDir->dirFATUsed);

    if (pfatDir->dirFATUsed == 0) {
        cid = pfatDir->dirFATUsed;
        //pool = aspMalloc(sizeof(struct sdDirPool_s), 8);
        pool = aspMemalloc(sizeof(struct sdDirPool_s), pidx);
        if (!pool) {
            *dir = 0;
            return -1;
        }
        memset(pool, 0, sizeof(struct sdDirPool_s));
        
        mspFS_preSetPool(pool, cid+1);
        pfatDir->fatDirPool[cid] = pool;
        
        pfatDir->dirFATUsed += 1;
    } else if (pfatDir->dirFATUsed > 0) {
        if (pfatDir->dirFATUsed > pfatDir->dirFATMax) {
            *dir = 0;
            return -2;
        }
        cid = pfatDir->dirFATUsed - 1;    
        pool = pfatDir->fatDirPool[cid];
    } else {
        *dir = 0;
        return -3;
    }

    //printf("[ALC] pool-%d. max: %d, used: %d - 1\n", cid, pool->dirMax, pool->dirUsed);

    if (pool->dirUsed >= pool->dirMax) {
        cid = pfatDir->dirFATUsed;
        //pool = aspMalloc(sizeof(struct sdDirPool_s), 8);
        pool = aspMemalloc(sizeof(struct sdDirPool_s), pidx);        
        if (!pool) {
            *dir = 0;
            return -4;
        }
        memset(pool, 0, sizeof(struct sdDirPool_s));
        
        mspFS_preSetPool(pool, cid+1);
        pfatDir->fatDirPool[cid] = pool;
        
        pfatDir->dirFATUsed += 1;
    }

    //printf("[ALC] pool-%d. max: %d, used: %d - 2\n", cid, pool->dirMax, pool->dirUsed);

    *dir = &pool->dirPool[pool->dirUsed];
    pool->dirUsed += 1;
    
    sprintf_f(mlog, "Pool [%d] used, findex:0x%x\n", pool->dirUsed, (*dir)->dfindex);
    print_f(mlogPool, "FS", mlog);

    pfatDir->dirFATDirty = 1;

    return 0;
}

static int mspFS_createRoot(struct directnFile_s **root, struct sdFAT_s *psFat, char *dir)
{
    char mlog[256];
    DIR *dp;
    struct directnFile_s *r = 0, *c = 0;

    sprintf_f(mlog, "open directory [%s]\n", dir);
    print_f(mlogPool, "FS", mlog);

    if ((dp = opendir(dir)) == NULL) {
        sprintf_f(mlog, "Can`t open directory [%s]\n", dir);
        print_f(mlogPool, "FS", mlog);
        return (-1);
    }
    sprintf_f(mlog, "open directory [%s] done\n", dir);
    print_f(mlogPool, "FS", mlog);

    mspFS_allocDir(&psFat->fatDirTr, &r, 9);
    //r = (struct directnFile_s *) aspMemalloc(sizeof(struct directnFile_s));
    if (!r) {
        return (-2);
    }else {
            sprintf_f(mlog, "alloc root fs done [0x%x]\n", (uint32_t)r);
            print_f(mlogPool, "FS", mlog);
    }

    mspFS_allocDir(&psFat->fatDirTr, &c, 9);
    //c = (struct directnFile_s *) aspMemalloc(sizeof(struct directnFile_s));
    if (!c) {
        return (-3);
    }else {
        sprintf_f(mlog, "alloc root fs first child done [0x%x]\n", (uint32_t)c);
        print_f(mlogPool, "FS", mlog);
    }

    c->pa = r;
    c->dfpaid = r->dfindex;
    c->br = 0;
    c->ch = 0;
    c->dftype = ASPFS_TYPE_DIR;
    c->dfattrib = 0;
    c->dfstats = 0;
    c->dflen = 2;
    strcpy(c->dfLFN, "..");

    r->pa = 0;
    r->br = 0;
    r->ch = c;
    r->dfchid = c->dfindex;
    r->dftype = ASPFS_TYPE_ROOT;
    r->dfattrib = 0;
    r->dfstats = 0;

    r->dflen = strlen(dir);
    //sprintf_f(mlog, "[%s] len: %d\n", dir, r->dflen);
    //print_f(mlogPool, "FS", mlog);
    if (r->dflen > 255) r->dflen = 255;
    strncpy(r->dfLFN, dir, r->dflen);

    *root = r;

    return 0;
}

static int mspFS_insertChilds(struct sdFAT_s *psFat, struct directnFile_s *root)
{
#define TAB_DEPTH   4
    int ret = 0;
    char mlog[256];
    DIR *dp;
    struct dirent *entry;
    struct stat statbuf;

    if (!root) {
        sprintf_f(mlog, "root error 0x%x\n", (uint32_t)root);
        print_f(mlogPool, "FS", mlog);
        ret = -1;
        goto insertEnd;
    }

    //sprintf_f(mlog, "open directory [%s]\n", root->dfLFN);
    //print_f(mlogPool, "FS", mlog);

    if ((dp = opendir(root->dfLFN)) == NULL) {
        printf("Can`t open directory [%s]\n", root->dfLFN);
        ret = -2;
        goto insertEnd;
    }

    //sprintf_f(mlog, "open directory [%s] done\n", root->dfLFN);
    //print_f(mlogPool, "FS", mlog);
    
    chdir(root->dfLFN);
    while ((entry = readdir(dp)) != NULL) {
        lstat(entry->d_name, &statbuf);
        if (S_ISDIR(statbuf.st_mode)) {
            if (strcmp(entry->d_name, ".") == 0 || 
                strcmp(entry->d_name, "..") == 0 ) {
                continue;   
            }
            //sprintf_f(mlog, "%*s%s\n", TAB_DEPTH, "", entry->d_name, TAB_DEPTH);
            //print_f(mlogPool, "FS", mlog);
            //printdir(entry->d_name, TAB_DEPTH+4);
            ret = mspFS_insertChildDir(psFat, root, entry->d_name);
            if (ret) goto insertEnd;
        } else {
            //sprintf_f(mlog, "%*s%s\n", TAB_DEPTH, "", entry->d_name, TAB_DEPTH);
            //print_f(mlogPool, "FS", mlog);
            ret = mspFS_insertChildFile(psFat, root, entry->d_name);
            if (ret) goto insertEnd;
        }
    }
    chdir("..");    

insertEnd:
    closedir(dp);   

    return ret;
}
static int mspFS_insertChildDir(struct sdFAT_s *psFat, struct directnFile_s *parent, char *dir)
{
    int ret;
    char mlog[256];
    DIR *dp;
    struct dirent *entry;
    struct stat statbuf;
    struct directnFile_s *r = 0, *c = 0;
    struct directnFile_s *brt = 0;

    mspFS_allocDir(&psFat->fatDirTr, &r, 9);
    //r = (struct directnFile_s *) aspMemalloc(sizeof(struct directnFile_s));
    if (!r) return (-2);

    mspFS_allocDir(&psFat->fatDirTr, &c, 9);
    //c = (struct directnFile_s *) aspMemalloc(sizeof(struct directnFile_s));
    if (!c) {
        return (-3);
    }else {
        //sprintf_f(mlog, "alloc root fs first child done [0x%x]\n", c);
        //print_f(mlogPool, "FS", mlog);
    }

    c->pa = r;
    c->dfpaid = r->dfindex;
    c->br = 0;
    c->ch = 0;
    c->dftype = ASPFS_TYPE_DIR;
    c->dfattrib = 0;
    c->dfstats = 0;
    c->dflen = 2;
    strcpy(c->dfLFN, "..");

    r->pa = parent;
    r->dfpaid = parent->dfindex;
    r->br = 0;
    r->ch = c;
    r->dfchid = c->dfindex;
    r->dfattrib = 0;
    r->dfstats = 0;
    r->dftype = ASPFS_TYPE_DIR;

    r->dflen = strlen(dir);
    //sprintf_f(mlog, "[%d][%s] len: %d \n", r->dftype, dir, r->dflen);
    //print_f(mlogPool, "FS", mlog);
    if (r->dflen > 255) r->dflen = 255;
    strncpy(r->dfLFN, dir, r->dflen+1);

    if (parent->ch == 0) {
        parent->ch = r;
        parent->dfchid = r->dfindex;
    } else {
        brt = parent->ch;
        if (brt->br == 0) {
            brt->br = r;
            brt->dfbrid = r->dfindex;
        } else {
            r->br = brt->br;
            r->dfbrid = brt->br->dfindex;
            brt->br = r;
            brt->dfbrid = r->dfindex;
        }
    }

    ret = mspFS_insertChilds(psFat, r);
 
    return ret;
}

static int mspFS_insertChildFile(struct sdFAT_s *psFat, struct directnFile_s *parent, char *str)
{
    char mlog[256];
    struct directnFile_s *r = 0;
    struct directnFile_s *brt = 0;

    mspFS_allocDir(&psFat->fatDirTr, &r, 9);
    //r = (struct directnFile_s *) aspMemalloc(sizeof(struct directnFile_s));
    if (!r) return (-2);

    r->pa = parent;
    r->dfpaid = parent->dfindex;
    r->br = 0;
    r->ch = 0;
    r->dfattrib = 0;
    r->dfstats = 0;
    r->dftype = ASPFS_TYPE_FILE;

    r->dflen = strlen(str);
    //sprintf_f(mlog, "[%d][%s] len: %d \n", r->dftype, str, r->dflen);
    //print_f(mlogPool, "FS", mlog);
    if (r->dflen > 255) r->dflen = 255;
    strncpy(r->dfLFN, str, r->dflen+1);

    if (parent->ch == 0) {
        parent->ch = r;
        parent->dfchid = r->dfindex;
    } else {
        brt = parent->ch;
        if (brt->br == 0) {
            brt->br = r;
            brt->dfbrid = r->dfindex;
        } else {
            r->br = brt->br;
            r->dfbrid = brt->br->dfindex;
            brt->br = r;
            brt->dfbrid = r->dfindex;
        }
    }
 
    return 0;
}

static int mspFS_listDetail(struct directnFile_s *root, int depth)
{
    char mlog[512];
    struct directnFile_s *fs = 0;
    if (!root) return (-1);

    fs = root->ch;
    while (fs) {
        if (fs->dflen) {
            sprintf_f(mlog, "%*s%s[%d]\n", depth, "", fs->dfLFN, fs->dftype);
            print_f(mlogPool, "FS", mlog);
        } else {
            sprintf_f(mlog, "%*s%s[%d]\n", depth, "", fs->dfSFN, fs->dftype);
            print_f(mlogPool, "FS", mlog);
        }

        debugPrintDir(fs);

        if (fs->dftype == ASPFS_TYPE_DIR) {
            mspFS_listDetail(fs, depth + 4);
        }
        fs = fs->br;
    }

    return 0;
}

static int mspFS_list(struct directnFile_s *root, int depth)
{
    char mlog[512];
    struct directnFile_s *fs = 0;
    if (!root) return (-1);

    fs = root->ch;
    while (fs) {
        if (fs->dflen) {
            sprintf_f(mlog, "%*s%s[%d:0x%.2x]\n", depth, "", fs->dfLFN, fs->dftype, fs->dfstats);
            print_f(mlogPool, "FS", mlog);
        } else {
            sprintf_f(mlog, "%*s%s[%d:0x%.2x]\n", depth, "", fs->dfSFN, fs->dftype, fs->dfstats);
            print_f(mlogPool, "FS", mlog);
        }

        if (fs->dftype == ASPFS_TYPE_DIR) {
            mspFS_list(fs, depth + 4);
        }
        fs = fs->br;
    }

    return 0;
}

static int mspFS_folderList(struct directnFile_s *root, int depth)
{
    char mlog[512];
    struct directnFile_s *fs = 0;
    if (!root) return (-1);

    fs = root->ch;
    while (fs) {
        if (fs->dflen) {
            sprintf_f(mlog, "%*s%s[%d]\n", depth, "", fs->dfLFN, fs->dftype);
            print_f(mlogPool, "FS", mlog);
        } else {
            sprintf_f(mlog, "%*s%s[%d]\n", depth, "", fs->dfSFN, fs->dftype);
            print_f(mlogPool, "FS", mlog);
        }

        fs = fs->br;
    }

    return 0;
}

static int mspFS_Search(struct directnFile_s **dir, struct directnFile_s *root, char *path, int type)
{
    char mlog[256];
    int ret = 0;
    char split = '/';
    char *ch;
    char rmp[32][128];
    //char **rmp;
    int a = 0, b = 0, t = 0;
    struct directnFile_s *brt;

    ret = strlen(path);
    sprintf_f(mlog, "path[%s] root[%s] len:%d\n", path, root->dfSFN, ret);
    print_f(mlogPool, "FSRH2", mlog);

    memset(rmp, 0, 32*128);
    
    ch = path;
    while (ret > 0) {
        if (*ch == split) {
            if (b > 0) {
                b = 0;
                a++;
            }
        } else {
            rmp[a][b] = *ch;
            b++;
            //sprintf_f(mlog, "%x ", *ch);
            //print_f(mlogPool, "FS", mlog);
        }
        ch++;
        ret --;
    }

    sprintf_f(mlog, "\n a:%d, b:%d \n", a, b);
    print_f(mlogPool, "FSRH2", mlog);

    for (b = 0; b <= a; b++) {
        sprintf_f(mlog, "[%d.%d]%s \n", a, b, rmp[b]);
        print_f(mlogPool, "FSRH2", mlog);
    }

    sprintf_f(mlog, "search prepare: \n");
    print_f(mlogPool, "FSRH2", mlog);


    ret = -1;
    b = 0; t = 0;
    brt = root;
    while (brt) {
        //sprintf_f(mlog, "b:%d, [%s][0x%x][0x%x] pa[%s]\n", b, brt->dfSFN, brt->dfstats, brt->dftype, (brt->pa == 0)?"NONE":brt->pa->dfSFN);
        //print_f(mlogPool, "FSRH2", mlog);
        if (brt->dfstats != ASPFS_STATUS_EN) {
            //sprintf_f(mlog, "skip disable file in path [%s][%s][%s] \n", brt->dfLFN, brt->dfSFN, &rmp[b][0]);
            //print_f(mlogPool, "FSRH2", mlog);
        } else if (b == a) {
            if ((brt->dftype == type) || (brt->dftype == ASPFS_TYPE_ROOT)) {
                if ((strcmp(brt->dfLFN, &rmp[b][0]) == 0) || 
                    (strcmp(brt->dfSFN, &rmp[b][0]) == 0)) {
                    *dir = brt;
                    ret = 0;
                    break;
                }
            }
        } else {
            if (brt->dftype == ASPFS_TYPE_FILE) {
                //sprintf_f(mlog, "skip file in path [%s][%s][%s] \n", brt->dfLFN, brt->dfSFN, &rmp[b][0]);
                //print_f(mlogPool, "FSRH2", mlog);
            } else {
                if (brt->dflen) {
                    if (brt->dflen < 128) {
                        if (strcmp(brt->dfLFN, &rmp[b][0]) == 0) {
                            b++;
                        }
                    } else {
                        if (strcmp(brt->dfSFN, &rmp[b][0]) == 0) {
                            b++;
                        }
                    }
                } else {
                    if (strcmp(brt->dfSFN, &rmp[b][0]) == 0) {
                        b++;
                    }
                }
            }
        }

        if (b > t) {
            t = b;
            brt = brt->ch;
            if (!brt) break;
            //sprintf_f(mlog, "Next folder[%s] pa[%s]!!!\n", brt->dfSFN, brt->pa->dfSFN);
            //print_f(mlogPool, "FSRH2", mlog);
        } else {
            brt = brt->br;
        }
        
        if (b > a) {
            break;
        }
        
    }

    if (ret) {
        sprintf_f(mlog, "not found !!\n");
        print_f(mlogPool, "FSRH2", mlog);
    } else {
        sprintf_f(mlog, "found!! brt[%s] \n", brt->dfSFN);
        print_f(mlogPool, "FSRH2", mlog);
/*
        while((brt) && (b>=0)) {
            sprintf_f(mlog, "[%d][%s][%s] \n", b, &rmp[b][0], brt->dfLFN);
            print_f(mlogPool, "FSRH2", mlog);
            b--;
            brt = brt->pa;
        }
*/
    }

    aspMemFree(rmp, 9);
    return ret;
}

static int mspFS_SearchInFolder(struct directnFile_s **dir, struct directnFile_s *folder, char *fname)
{
    char mlog[512];
    int ret = 0;
    struct directnFile_s *brt=0;

    if (!fname) return -1;
    if (!folder) return -2;

    *dir = 0;

    ret = strlen(fname);
    sprintf_f(mlog, "fname[%s] folder[%s] len:%d\n", fname, (folder->dflen==0)?folder->dfSFN:folder->dfLFN, ret);
    print_f(mlogPool, "FSRH3", mlog);

    ret = -1;
    brt = folder->ch;
    while (brt) {
        if ((brt->dfstats == ASPFS_STATUS_EN) && 
            (brt->dftype == ASPFS_TYPE_FILE)) {
            if ((strcmp(brt->dfLFN, fname) == 0) || 
                (strcmp(brt->dfSFN, fname) == 0)) {
                *dir = brt;
                ret = 0;
                break;
            }
        }
        
        brt = brt->br;        
    }

    if (ret) {
        sprintf_f(mlog, "[%s] not found !!\n", fname);
        print_f(mlogPool, "FSRH3", mlog);
    } else {
        sprintf_f(mlog, "found!! brt[%s] \n", brt->dfSFN);
        print_f(mlogPool, "FSRH3", mlog);
    }

    return ret;
}

static int mspFS_FileSearch(struct directnFile_s **dir, struct directnFile_s *root, char *path)
{
    char mlog[512];
    int ret = 0;
    char split = '/';
    char *ch;
    char rmp[32][128];
    //char **rmp;
    int a = 0, b = 0;
    struct directnFile_s *brt;

    ret = strlen(path);
    sprintf_f(mlog, "path[%s] root[%s] len:%d\n", path, root->dfSFN, ret);
    print_f(mlogPool, "FSRH", mlog);

    memset(rmp, 0, 32*128);
    
    ch = path;
    while (ret > 0) {
        if (*ch == split) {
            if (b > 0) {
                b = 0;
                a++;
            }
        } else {
            rmp[a][b] = *ch;
            b++;
            //sprintf_f(mlog, "%x ", *ch);
            //print_f(mlogPool, "FS", mlog);
        }
        ch++;
        ret --;
    }

    sprintf_f(mlog, "\n a:%d, b:%d \n", a, b);
    print_f(mlogPool, "FSRH", mlog);

    for (b = 0; b <= a; b++) {
        sprintf_f(mlog, "[%d.%d]%s \n", a, b, rmp[b]);
        print_f(mlogPool, "FSRH", mlog);
    }

    ret = -1;
    b = 0;
    brt = root;
    while (brt) {
        sprintf_f(mlog, "%d/ %s\n", b, brt->dfSFN);
        print_f(mlogPool, "FSRH", mlog);
        if (brt->dfstats != ASPFS_STATUS_EN) {
            sprintf_f(mlog, "skip disable file in path [%s][%s][%s] \n", brt->dfLFN, brt->dfSFN, &rmp[b][0]);
            print_f(mlogPool, "FSRH", mlog);
            brt = brt->br;
        } else if ((b < a) && (brt->dftype == ASPFS_TYPE_FILE)) {
            sprintf_f(mlog, "skip file in path [%s][%s][%s] \n", brt->dfLFN, brt->dfSFN, &rmp[b][0]);
            print_f(mlogPool, "FSRH", mlog);
            brt = brt->br;
        }
        else if ((b == a) && (brt->dftype == ASPFS_TYPE_DIR)) {
            sprintf_f(mlog, "skip folder in path [%s][%s][%s][0x%x] \n", brt->dfLFN, brt->dfSFN, &rmp[b][0], brt->dftype);
            print_f(mlogPool, "FSRH", mlog);
            brt = brt->br;
        }
        else if (strcmp("..", &rmp[b][0]) == 0) {
            b++;
            brt = brt->pa;
        } else if (strcmp(".", &rmp[b][0]) == 0) {
            b++;
            brt = brt->br;
        } else if (strcmp(brt->dfLFN, &rmp[b][0]) == 0) {
            b++;
            if (b > a) {
               *dir = brt;
                ret = 0;
                break;
            }
            brt = brt->ch;
        } else if ((!brt->dflen) && (strcmp(brt->dfSFN, &rmp[b][0]) == 0)) {
            b++;
            if (b > a) {
               *dir = brt;
                ret = 0;
                break;
            }
            brt = brt->ch;
        } else {
            brt = brt->br;
        }
    }

    sprintf_f(mlog, "path len: %d, match num: %d, brt:0x%x \n", a, b, (uint32_t)brt);
    print_f(mlogPool, "FSRH", mlog);
/*
    while((brt) && (b>=0)) {
        //sprintf_f(mlog, "[%d][%s][%s] \n", b, &rmp[b][0], brt->dfLFN);
        //print_f(mlogPool, "FS", mlog);
        b--;
        brt = brt->pa;
    }
*/
    return ret;
}

static int mspFS_FolderSearch(struct directnFile_s **dir, struct directnFile_s *root, char *path)
{
    char mlog[512];
    int ret = 0;
    char split = '/';
    char *ch;
    char rmp[32][128];
    //char **rmp;
    int a = 0, b = 0;
    struct directnFile_s *brt;

    ret = strlen(path);
    sprintf_f(mlog, "path[%s] root[%s] len:%d\n", path, root->dfSFN, ret);
    print_f(mlogPool, "DSRH", mlog);

    //rmp = aspMemalloc(256*256);
    memset(rmp, 0, 32*128);
    
    ch = path;
    while (ret > 0) {
        if (*ch == split) {
            if (b > 0) {
                b = 0;
                a++;
            }
        } else {
            rmp[a][b] = *ch;
            b++;
            //sprintf_f(mlog, "%x ", *ch);
            //print_f(mlogPool, "FS", mlog);
        }
        ch++;
        ret --;
    }

    /* fix the hanging bug */
    sprintf_f(mlog, "\n a:%d, b:%d \n", a, b);
    print_f(mlogPool, "DSRH", mlog);

    for (b = 0; b <= a; b++) {
        sprintf_f(mlog, "[%d.%d]%s \n", a, b, rmp[b]);
        print_f(mlogPool, "DSRH", mlog);
    }

    ret = -1;
    b = 0;
    brt = root;
    while (brt) {
        sprintf_f(mlog, "%d. %s\n", b, brt->dfSFN);
        print_f(mlogPool, "DSRH", mlog);
        if (brt->dfstats != ASPFS_STATUS_EN) {
            sprintf_f(mlog, "skip disable file in path [%s][%s][%s] \n", brt->dfLFN, brt->dfSFN, &rmp[b][0]);
            print_f(mlogPool, "FSRH", mlog);
            brt = brt->br;
        }
        else if ((b < a) && (brt->dftype == ASPFS_TYPE_FILE)) {
            sprintf_f(mlog, "skip file in path [%s][%s][%s] \n", brt->dfLFN, brt->dfSFN, &rmp[b][0]);
            print_f(mlogPool, "DSRH", mlog);
            brt = brt->br;
        }
        else if ((b == a) && (brt->dftype == ASPFS_TYPE_FILE)) {
            sprintf_f(mlog, "skip folder in path [%s][%s][%s] \n", brt->dfLFN, brt->dfSFN, &rmp[b][0]);
            print_f(mlogPool, "DSRH", mlog);
            brt = brt->br;
        }
        else if (strcmp("..", &rmp[b][0]) == 0) {
            b++;
            brt = brt->pa->pa;
            if (b > a) {
               *dir = brt;
                ret = 0;
                break;
            }
        } else if (strcmp(".", &rmp[b][0]) == 0) {
            b++;
            if (b > a) {
               *dir = brt;
                ret = 0;
                break;
            }            
            brt = brt->br;
        } else if (strcmp(brt->dfLFN, &rmp[b][0]) == 0) {
            b++;
            if (b > a) {
               *dir = brt;
                ret = 0;
                break;
            }
            brt = brt->ch;
        } else if ((!brt->dflen) && (strcmp(brt->dfSFN, &rmp[b][0]) == 0)) {
            b++;
            if (b > a) {
               *dir = brt;
                ret = 0;
                break;
            }
            brt = brt->ch;
        } else {
            brt = brt->br;
        }
    }

    sprintf_f(mlog, "path len: %d, match num: %d, brt:%s \n", a, b, brt->dfSFN);
    print_f(mlogPool, "DSRH", mlog);

/*
    while((brt) && (b>=0)) {
        //sprintf_f(mlog, "[%d][%s][%s] \n", b, &rmp[b][0], brt->dfLFN);
        //print_f(mlogPool, "FS", mlog);
        b--;
        brt = brt->pa;
    }
*/

    return ret;
}
static int mspFS_showFolder(struct directnFile_s *root)
{
    char mlog[512];
    struct directnFile_s *brt = 0;
    if (!root) return (-1);
    if (root->dftype == ASPFS_TYPE_FILE) return (-2);
    
    sprintf_f(mlog, "%s \n", root->dfLFN);
    print_f(mlogPool, "FS", mlog);

    brt = root->ch;
    while (brt) {
        sprintf_f(mlog, "|-[%c] %s\n", brt->dftype == ASPFS_TYPE_DIR?'D':'F', brt->dflen==0?brt->dfSFN:brt->dfLFN);
        print_f(mlogPool, "FS", mlog);
        brt = brt->br;
    }
    return 0;
}

static int mspFS_folderJump(struct directnFile_s **dir, struct directnFile_s *root, char *path)
{
    char mlog[256];
    int retval = 0;
    struct directnFile_s *brt;

    if ((!path) || (!root) || (!dir)) return (-1);
    if (root->dftype == ASPFS_TYPE_FILE) return (-2);

    if (strcmp("..", path) == 0) {
        if (root->dftype == ASPFS_TYPE_ROOT) {
            *dir = root;
            retval = 1;
        } else {
            *dir = root->pa;
            retval = 2;
        }
    } else if (strcmp(".", path) == 0) {
        *dir = root;
        retval = 3;
    } else {
        brt = root->ch;

        while (brt) {
            if (brt->dftype != ASPFS_TYPE_FILE) {
                if (brt->dflen) {
                    if (strcmp(brt->dfLFN, path) == 0) {
                        *dir = brt;
                        retval = 4;
                        break;
                    }
                } else {
                    if (strcmp(brt->dfSFN, path) == 0) {
                        *dir = brt;
                        retval = 5;
                        break;
                    }
                }
            }
            brt = brt->br;
        }

        if (!brt) retval = (-3);
    }

    return retval;
}

static int error_handle(char *log, int line)
{
#define MAX_LEN 5000
#define TOT_LEN (MAX_LEN + 64)

    char str[TOT_LEN];
    int len=0;

    len = strlen(log);   
    if (len > 0) {
        if (len >= MAX_LEN) {
            len = MAX_LEN;
            log[len-1] = '\0';
        }

        sprintf_f(str, "warning: %s - line: %d\n", log, line); 
        print_f(mlogPool, "error", str); 

    } else {
        sprintf_f(str, "warning: read log failed - line: %d\n", line); 
        print_f(mlogPool, "error", str); 
    }

    //while(1);

    return 0;

}
static uint16_t abs_info(struct info16Bit_s *p, uint16_t info)
{
    char str[128];

    p->data = info & 0xff;
    p->opcode = (info >> 8) & 0xff;
    //p->seqnum = (info >> 12) & 0x7;
    //p->inout = (info >> 15) & 0x1;

    //sprintf_f(str, "info: 0x%.4x \n", info); 
    //print_f(mlogPool, "abs_info", str); 

    return info;
}

static uint16_t pkg_info(struct info16Bit_s *p)
{
    char str[128];
    uint16_t info = 0;
    info |= p->data & 0xff;
    info |= (p->opcode & 0xff) << 8;
    //info |= (p->seqnum & 0x7) << 12;
    //info |= (p->inout & 0x1) << 15;

    //sprintf_f(str, "info: 0x%.4x \n", info); 
    //print_f(mlogPool, "pkg_info", str); 

    return info;
}

static uint32_t chk_bk(uint32_t bkf) 
{
    return (bkf & 0xffff0000);
}

static uint32_t clr_bk(uint32_t bkf) 
{
    bkf &= ~0xffff0000;
    return bkf;
}

static uint32_t emb_bk(uint32_t bkf, uint8_t evt, uint8_t ste) 
{
    bkf &= ~0xffff0000;
    bkf |= ((evt << 8) | ste) << 16;
    return bkf;
}

static uint32_t chk_fw(uint32_t bkf) 
{
    return (bkf & 0x0000ffff);
}

static uint32_t clr_fw(uint32_t bkf) 
{
    bkf &= ~0x0000ffff;
    return bkf;
}

static uint32_t emb_fw(uint32_t bkf, uint8_t evt, uint8_t ste) 
{
    bkf &= ~0x0000ffff;
    bkf |= (evt << 8) | ste;
    return bkf;
}

static uint32_t abs_result(uint32_t result)
{
    result = result >> 16;
    return (result & 0xff);
}
static uint32_t emb_result(uint32_t result, uint32_t flag) 
{
    result &= ~0xff0000;
    result |= (flag << 16) & 0xff0000;
    return result;
}

static uint32_t emb_stanPro(uint32_t result, uint32_t rlt, uint32_t sta, uint32_t pro) 
{
    result &= ~0xffffff;
    result |= ((rlt & 0xff) << 16) | ((sta & 0xff) << 8) | (pro & 0xff);
    return result;
}

static uint32_t emb_event(uint32_t result, uint32_t flag) 
{
    result &= ~0xff000000;
    result |= (flag & 0xff) << 24;
    return result;
}

static uint32_t emb_state(uint32_t result, uint32_t flag) 
{
    char str[32];
    static int pre=0;
    pre = result;
    result &= ~0xff00;
    result |= (flag & 0xff) << 8;

    if (pre != result) {
        sprintf_f(str, "0x%.8x -> 0x%.8x\n", pre, result); 
        print_f(mlogPool, "state", str); 
    }

    return result;
}

static uint32_t emb_process(uint32_t result, uint32_t flag) 
{
    result &= ~0xff;
    result |= flag & 0xff;
    return result;
}

static uint32_t next_MDUOU(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSACT;
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSWT;                
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str);
                next = PSACT;
                evt = MTSDV; 
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }
        
#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif
    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }
    
    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_BMFA(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;
                //evt = FATH; 
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str);
                next = PSMAX;
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }
    
    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_USBZ(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;
                //evt = FATH; 
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str);
                next = PSMAX;
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }
    
    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_FMTY(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                evt = FATH; 
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                evt = FATH; 
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str);
                next = PSMAX;
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }
    
    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_FMTX(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSWT;
                evt = OCRW; 
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                evt = FATH; 
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                evt = FATH; 
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                evt = FATH; 
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str);
                next = PSTSM;
                evt = FATH; 
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }
    
    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_OCRW(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSACT;
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                evt = FMTX;
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSRLT;
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str);
                next = PSRLT;
                evt = SINJ; 
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }
    
    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_MTSDV(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSACT;
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSWT;
                evt = FATH; 
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str);
                next = PSSET;
                evt = OCRW;
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_METAT(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSACT;
                evt = SAVPARM; 
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;                
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSRLT;
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str);
                next = PSSET;
                evt = MDUOU; 
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_SAVPARM(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSWT;                
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSACT;
                evt = METAT; 
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSACT;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str);
                next = PSACT;
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_VECTORS(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                evt = CROPR; 
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                if (tmpAns == 1) {
                    next = PSRLT;
                } else if (tmpAns == 2) {
                    next = PSTSM;
                } else {
                    next = PSMAX;
                }
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str);
                next = PSMAX;
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_CROPR(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSACT;
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSWT;
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSRLT;
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str);
                next = PSSET;
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_WTBAKQ(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                if (tmpAns == 1) {
                    next = PSWT;
                } else if (tmpAns == 2) {
                    next = PSMAX;
                } else if (tmpAns == 3) {
                    next = PSSET;
                    evt = SDAM;
                } else {
                    next = PSMAX;
                }
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                if (tmpAns == 1) {
                    next = PSWT;
                    evt = SDAO;
                } else if (tmpAns == 2) {
                    next = PSMAX;
                } else if (tmpAns == 3) {
                    next = PSSET;
                    evt = SDAO;
                } else {
                    next = PSMAX;
                }
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                if (tmpAns == SINSCAN_WIFI_SD) {
                    next = PSWT;
                    evt = SUPI;
                } else if (tmpAns == SINSCAN_SD_ONLY) {
                    next = PSWT;
                    evt = WTBAKP;
                } else if (tmpAns == SINSCAN_DUAL_SD) {
                    next = PSSET;
                    evt = BULLET;
                } else {
                    next = PSMAX;
                }
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                if (tmpAns == SINSCAN_WIFI_SD) {
                    next = PSMAX;
                } else if (tmpAns == SINSCAN_SD_ONLY) {
                    next = PSMAX;
                } else if (tmpAns == SINSCAN_DUAL_SD) {
                    next = PSMAX;
                } else {
                    next = PSMAX;
                }
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str);
                next = PSSET;
                evt = CROPR; 
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif
        
    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_WTBAKP(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                if (tmpAns == 1) {
                    next = PSWT;
                    evt = SUPI;
                } else if (tmpAns == 2) {
                    next = PSWT;
                    evt = WTBAKP;
                } else if (tmpAns == 3) {
                    next = PSSET;
                    evt = BULLET;
                } else {
                    next = PSMAX;
                }
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                if (tmpAns == 1) {
                    next = PSMAX;
                } else if (tmpAns == 2) {
                    next = PSMAX;
                } else if (tmpAns == 3) {
                    next = PSMAX;;
                } else {
                    next = PSMAX;
                }
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSRLT;
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str);
                next = PSACT;
                evt = WTBAKQ; 
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_SDAO(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSACT;
                evt = SDAM; 
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                evt = FATH; 
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                evt = FATH; 
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str);
                next = PSTSM;
                evt = FATH; 
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_SDAN(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSACT;
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSWT;
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSRLT;
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str);
                next = PSACT;
                evt = SDAO; 
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_SDAM(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSACT;
                evt = SAVK; 
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSWT;
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSRLT;
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str);
                next = PSSET;
                evt = SDAN; 
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_SDAL(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSACT;
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSWT;
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSRLT;
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str);
                next = PSMAX;
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_SAVK(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSWT;
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSRLT;
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str);
                next = PSSET;
                evt = SDAL; 
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_SINJ(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX; 
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                evt = FATH; 
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                evt = FATH; 
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str);
                next = PSMAX;
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_SUPI(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSACT;
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSRLT;
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str);
                next = PSSET;
                evt = SINJ; 
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_FATH(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSACT;
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSWT;
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSRLT;                                /* end CFLOAT side scan */
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str); 
                if (tmpAns == 1) {
                    evt = FATH; 
                    next = PSTSM;
                } else if (tmpAns == 2) {
#if SD_RDWT_USING_META
                    evt = MDUOU; 
                    next = PSTSM;
#else
                    evt = REGF; 
                    next = PSWT;
#endif
                } else if (tmpAns == 3) {
#if SD_RDWT_USING_META
                    evt = MTSDV; 
                    next = PSSET;
#else
                    evt = REGF; 
                    next = PSRLT;
#endif
                } else {
                    next = PSMAX;
                }
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_FATG(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSACT;
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSWT;
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSRLT;                                /* end CFLOAT side scan */
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str); 
                evt = FATH; /* jump to next stage */
                next = PSSET;
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_registerE(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSACT;
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSWT;
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;                                /* end CFLOAT side scan */
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str); 
                evt = REGF; /* jump to next stage */
                next = PSSET;
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_registerF(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSACT;
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;                                /* end CFLOAT side scan */
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str); 
                evt = FATG; /* jump to next stage */
                next = PSSET;
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_doubleC(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSACT;
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSWT;
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                if (tmpAns == DOUSCAN_WIFI_ONLY) {
                    next = PSRLT;                
                } else if (tmpAns == DOUSCAN_WIFI_SD) {
                    next = PSSET;
                    evt = DOUBLED;
                } else {
                    next = PSMAX;
                }
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;
                //evt = DOUBLED; /* jump to next stage */
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_doubleD(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSRLT;
                evt = DOUBLEC;
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                if (tmpAns == 1) {
                    next = PSWT;
                    evt = SDAO;
                } else if (tmpAns == 2) {
                    next = PSMAX;  
                } else {
                    next = PSMAX;
                }
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                if (tmpAns == 1) {
                    next = PSMAX;                
                } else if (tmpAns == 2) {
                    next = PSWT;
                    evt = SDAO;
                } else {
                    next = PSMAX;
                }
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSMAX;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str); 
                evt = REGE; /* jump to next stage */
                next = PSSET;
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static int next_spy(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "spy", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {

        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "spy", str); 
                next = PSMAX;
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "spy", str); 
                //next = PSWT;
                next = PSMAX; /* skip power on sequence */              
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "spy", str); 
                //next = PSRLT;
                next = PSMAX; /* skip power on sequence */
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "spy", str); 
                //next = PSTSM;
                next = PSMAX;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "spy", str); 
                next = PSSET; /* jump to next stage */
                evt = BULLET; /* jump to next stage */
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "spy", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static uint32_t next_bullet(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "bullet", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        /* reset pro */  
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSACT;
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSWT;
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSRLT;
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSTSM;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                evt = LASER; /* jump to next stage */
                //next = PSMAX;
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "bullet", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static int next_laser(struct psdata_s *data)
{
    int pro, rlt, next = 0;
    uint32_t tmpAns = 0, evt = 0, tmpRlt = 0;
    char str[256];
    uint32_t bkf;
    bkf = data->bkofw;
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "laser", str); 

    tmpRlt = data->result;
    if (rlt == WAIT) {
        next = pro;
    } else if (rlt == NEXT) {
        tmpAns = data->ansp0;
        data->ansp0 = 0;
        tmpRlt = emb_result(tmpRlt, STINIT);
        switch (pro) {
            case PSSET:
                //sprintf_f(str, "PSSET\n"); 
                //print_f(mlogPool, "laser", str); 
                next = PSACT;
                break;
            case PSACT:
                //sprintf_f(str, "PSACT\n"); 
                //print_f(mlogPool, "laser", str); 
                next = PSMAX; 
                break;
            case PSWT:
                //sprintf_f(str, "PSWT\n"); 
                //print_f(mlogPool, "laser", str); 
                next = PSRLT;
                break;
            case PSRLT:
                //sprintf_f(str, "PSRLT\n"); 
                //print_f(mlogPool, "laser", str); 
                next = PSTSM;
                break;
            case PSTSM:
                //sprintf_f(str, "PSTSM\n"); 
                //print_f(mlogPool, "laser", str); 
                next = PSSET;
                evt = SPY; 
                break;
            default:
                //sprintf_f(str, "default\n"); 
                //print_f(mlogPool, "laser", str); 
                next = PSSET;
                break;
        }

#if ANSP0_RECOVER
        data->ansp0 = tmpAns;
#endif

    }
    else if (rlt == BREAK) {
        tmpRlt = emb_result(tmpRlt, WAIT);
        next = pro;
    } else if (rlt == BKWRD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = (bkf >> 16) & 0xff;
            evt = (bkf >> 24) & 0xff;
            data->bkofw = clr_bk(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else if (rlt == FWORD) {
        if (bkf) {
            tmpRlt = emb_result(tmpRlt, STINIT);
            next = bkf & 0xff;
            evt = (bkf >> 8) & 0xff;
            data->bkofw = clr_fw(data->bkofw);
        } else {
            next = PSMAX;
        }
    } else {
        next = PSMAX;
    }

    if (next == PSMAX) {
        data->bkofw = clr_bk(data->bkofw);        
        data->bkofw = clr_fw(data->bkofw);
    }

    tmpRlt = emb_event(tmpRlt, evt);
    return emb_process(tmpRlt, next);
}

static int next_error(struct psdata_s *data)
{
    int pro, rlt, next;
    char str[256];
    rlt = (data->result >> 16) & 0xff;
    pro = data->result & 0xff;

    //sprintf_f(str, "%d-%d\n", pro, rlt); 
    //print_f(mlogPool, "error", str); 
                    
    if (rlt == NEXT) {
        switch (pro) {
            case PSSET:
                sprintf_f(str, "PSSET\n"); 
                print_f(mlogPool, "error", str); 
                next = PSACT;
                break;
            case PSACT:
                sprintf_f(str, "PSACT\n"); 
                print_f(mlogPool, "error", str); 
                next = PSWT;
                break;
            case PSWT:
                sprintf_f(str, "PSWT\n"); 
                print_f(mlogPool, "error", str); 
                next = PSRLT;
                break;
            case PSRLT:
                sprintf_f(str, "PSRLT\n"); 
                print_f(mlogPool, "error", str); 
                next = PSTSM;
                break;
            case PSTSM:
                sprintf_f(str, "PSTSM\n"); 
                print_f(mlogPool, "error", str); 
                next = PSSET;
                break;
            default:
                sprintf_f(str, "default\n"); 
                print_f(mlogPool, "error", str); 
                next = PSSET;
                break;
        }
    }
    next = 0; /* error handle, return to 0 */

    return emb_process(data->result, next);
}
static int ps_next(struct psdata_s *data)
{
    int sta, ret, evt, nxtst = -1, nxtrlt = 0;
    char str[256];

    sta = (data->result >> 8) & 0xff;
    nxtst = sta;

    //sprintf_f(str, "sta: 0x%x\n", sta); 
    //print_f(mlogPool, "ps_next", str); 

    switch (sta) {
        case SPY:
            ret = next_spy(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case BULLET:
            ret = next_bullet(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case LASER:
            ret = next_laser(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            //if (evt == 0x1) nxtst = SPY; /* end the test loop */
            break;
        case DOUBLEC:
            ret = next_doubleC(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case DOUBLED:
            ret = next_doubleD(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case REGE:
            ret = next_registerE(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case REGF:
            ret = next_registerF(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case FATG:
            ret = next_FATG(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case FATH:
            ret = next_FATH(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case SUPI:
            ret = next_SUPI(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case SINJ:
            ret = next_SINJ(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case SAVK:
            ret = next_SAVK(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case SDAL:
            ret = next_SDAL(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case SDAM:
            ret = next_SDAM(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case SDAN:
            ret = next_SDAN(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case SDAO:
            ret = next_SDAO(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case WTBAKP:
            ret = next_WTBAKP(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case WTBAKQ:
            ret = next_WTBAKQ(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case CROPR:
            ret = next_CROPR(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case VECTORS:
            ret = next_VECTORS(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case SAVPARM:
            ret = next_SAVPARM(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case METAT:
            ret = next_METAT(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case MDUOU:
            ret = next_MDUOU(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case MTSDV:
            ret = next_MTSDV(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case OCRW:
            ret = next_OCRW(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case FMTX:
            ret = next_FMTX(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case FMTY:
            ret = next_FMTY(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case USBZ:
            ret = next_USBZ(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        case BMFA:
            ret = next_BMFA(data);
            evt = (ret >> 24) & 0xff;
            if (evt) nxtst = evt; /* long jump */
            break;
        default:
            ret = next_error(data);
            evt = (ret >> 24) & 0xff;
            //if (evt == 0x1) nxtst = SPY;
            break;
    }

    nxtrlt = emb_state(ret, nxtst);

    //sprintf_f(str, "ret: 0x%.4x nxtst: 0x%x nxtrlt: 0x%.4x\n", ret, nxtst, nxtrlt); 
    //print_f(mlogPool, "ps_next", str); 
    
#if 0
    data->result += 1;
    if ((data->result & 0xf) == PSMAX) {
        data->result = (data->result & 0xf0) + 0x10;
    }

    if (((data->result & 0xf0) >> 4)== SMAX) {
        data->result = -1;
    }
#endif

    return nxtrlt;

}
static int stdob_01(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;

    struct info16Bit_s *p;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;

    rlt = abs_result(data->result); 

    //sprintf_f(str, "op_01 - rlt:0x%x \n", rlt); 
    //print_f(mlogPool, "DOB", str); 

    switch (rlt) {
        case STINIT:
        
#if CHECK_SOCKET_STATUS
            ch = 25; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
#else
            data->ansp0 = 1;
            data->result = emb_result(data->result, NEXT);
#endif

            sprintf_f(rs->logs, "op_01: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "DOB", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stdob_02(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    struct info16Bit_s *p;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;

    rlt = abs_result(data->result); 

    //sprintf_f(str, "op_02 - rlt:0x%.8x \n", data->result); 
    //print_f(mlogPool, "DOB", str); 

    switch (rlt) {
        case STINIT:
        
#if CHECK_SOCKET_STATUS
            ch = 27; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
#else
            data->ansp0 = 1;
            data->result = emb_result(data->result, NEXT);
#endif

            sprintf_f(rs->logs, "op_02: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "DOB", rs->logs);  
            break;
        case WAIT:
            //sprintf_f(rs->logs, "op_02: ans: %x, result: 0x%.8x before\n", data->ansp0, data->result); 
            //print_f(rs->plogs, "DOB", rs->logs);  

            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }

            //sprintf_f(rs->logs, "op_02: ans: %x, result: 0x%.8x after \n", data->ansp0, data->result); 
            //print_f(rs->plogs, "DOB", rs->logs);  

            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stdob_03(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct info16Bit_s *p=0, *c=0, *t=0;
    uint32_t secStr=0, secLen = 0;
    struct aspConfig_s *pct=0, *pdt=0;

    rs = data->rs;
    rlt = abs_result(data->result); 
    t = &rs->pmch->tmp;
    c = &rs->pmch->cur;
    p = &rs->pmch->get;
    pct = data->rs->pcfgTable;

    //sprintf_f(str, "op_03 - rlt:0x%.8x \n", data->result); 
    //print_f(mlogPool, "DOB", str); 

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SCAN_DOUBLE];
            if ((pdt->opCode != OP_DOUBLE) && (pdt->opCode != OP_MDOUBLE)) {
                sprintf_f(rs->logs, "op_03, OP_DOUBLE opcode is wrong val:0x%x\n", pdt->opCode); 
                print_f(rs->plogs, "DOB", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (!(pdt->opStatus & ASPOP_STA_WR)) {
                sprintf_f(rs->logs, "op_03, OP_DOUBLE status is wrong val:%x\n", pdt->opStatus); 
                print_f(rs->plogs, "DOB", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                switch(pdt->opValue) {
                    case DOUSCAN_WIFI_ONLY:
                    case DOUSCAN_WIFI_SD:
                    //case DOUSCAN_SD_ONLY:

                        ch = 41; 
                        c->opcode =  pdt->opCode;
                        c->data = pdt->opValue;
                        memset(p, 0, sizeof(struct info16Bit_s));

                        rs_ipc_put(data->rs, &ch, 1);
                        data->result = emb_result(data->result, WAIT);
                        //sprintf_f(rs->logs, "op_03: result: %x, goto %d\n", data->result, ch); 
                        //print_f(rs->plogs, "DOB", rs->logs);  
                        break;
                    default:
                        sprintf_f(rs->logs, "WARNING!!! op_03, opValue is unexpected val:%x\n", pdt->opValue);
                        print_f(rs->plogs, "DOB", rs->logs);  
                        /* todo: should clear socket connection here */
                        data->result = emb_result(data->result, EVTMAX);
                        break;
                }
            }        
            break;            
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SCAN_DOUBLE];
                data->ansp0 = pdt->opValue;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stdob_04(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    rlt = abs_result(data->result); 
    struct procRes_s *rs;

    rs = data->rs;
    //sprintf_f(rs->logs, "op_04, rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "DOB", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 33; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(str, "op_04: result: %x\n", data->result); 
            //print_f(mlogPool, "DOB", str);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stdob_05(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct aspConfig_s *pct=0, *pdt=0;

    pct = data->rs->pcfgTable;

    rs = data->rs;
    //sprintf_f(rs->logs, "op_05, rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "DOB", rs->logs);  

    rlt = abs_result(data->result); 
    switch (rlt) {
        case STINIT:
            ch = 48; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_05: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "DOB", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SCAN_DOUBLE];
                data->ansp0 = pdt->opValue;

                sprintf_f(rs->logs, "op_05, set FORWARD to status check \n");
                print_f(rs->plogs, "DOB", rs->logs);  
                data->bkofw = emb_fw(data->bkofw, DOUBLED, PSWT);

                pdt = &pct[ASPOP_EG_DECT];
                if ((pdt->opStatus == ASPOP_STA_UPD) && (pdt->opValue == 1)) {
#if CROP_USE_META
                    data->bkofw = emb_bk(data->bkofw, MDUOU, PSRLT);
#else
                    data->bkofw = emb_bk(data->bkofw, WTBAKQ, PSTSM);
#endif
                    data->result = emb_result(data->result, BKWRD);
                } else {
                    data->result = emb_result(data->result, FWORD);                
                }                
            }
            else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stdob_06(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_04, rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "DOB", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 122; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stdob_07(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_07, rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "DOB", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 123; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
                data->bkofw = emb_fw(data->bkofw, DOUBLED, PSACT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stdob_08(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    rlt = abs_result(data->result); 
    struct aspConfig_s *pct=0, *pdt=0;
    struct procRes_s *rs;

    rs = data->rs;
    pct = data->rs->pcfgTable;
    //sprintf_f(rs->logs, "op_08, rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "DOB", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SCAN_DOUBLE];
            if ((pdt->opCode != OP_DOUBLE) && (pdt->opCode != OP_MDOUBLE)) {
                sprintf_f(rs->logs, "op_08, OP_DOUBLE opcode is wrong val:%x\n", pdt->opCode); 
                print_f(rs->plogs, "DOB", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (!(pdt->opStatus & ASPOP_STA_WR)) {
                sprintf_f(rs->logs, "op_08, OP_DOUBLE status is wrong val:%x\n", pdt->opStatus); 
                print_f(rs->plogs, "DOB", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                //pct[ASPOP_IMG_LEN].opValue = 0;
                //pct[ASPOP_IMG_LEN].opStatus = ASPOP_STA_APP;

                if (pdt->opValue == DOUSCAN_WIFI_ONLY) {
                    pdt->opStatus = ASPOP_STA_UPD;
                    data->ansp0 = 1;
                    data->result = emb_result(data->result, NEXT);
                    sprintf_f(rs->logs, "op_08: DOUSCAN_WIFI_ONLY go to next!!\n"); 
                    print_f(rs->plogs, "DOB", rs->logs);  
                } else if (pdt->opValue == DOUSCAN_WIFI_SD) {
                    pdt->opStatus = ASPOP_STA_UPD;
                    data->ansp0 = 2;
                    data->result = emb_result(data->result, NEXT);
                    data->bkofw = emb_fw(data->bkofw, DOUBLED, PSACT);
                    sprintf_f(rs->logs, "op_08: DOUSCAN_WIFI_SD go to next!!\n"); 
                    print_f(rs->plogs, "DOB", rs->logs);  
                } else if (pdt->opValue == DOUSCAN_SD_ONLY) {
                    pdt->opStatus = ASPOP_STA_UPD;
                    data->ansp0 = 3;
                    data->result = emb_result(data->result, NEXT);
                    sprintf_f(rs->logs, "op_08: DOUSCAN_SD_ONLY go to next!!\n"); 
                    print_f(rs->plogs, "DOB", rs->logs);  
                } else {
                    sprintf_f(rs->logs, "WARNING!!! op_74, opValue is unexpected val:%x\n", pdt->opValue);
                    print_f(rs->plogs, "DOB", rs->logs);  
                    data->result = emb_result(data->result, EVTMAX);
                }
            }
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stdob_09(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    
    rlt = abs_result(data->result); 

    //sprintf_f(str, "wt_01 - rlt:0x%.8x \n", data->result); 
    //print_f(mlogPool, "wt", str); 

    switch (rlt) {
        case STINIT:
            ch = 101; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(str, "wt_01: result: 0x%.8x\n", data->result); 
            //print_f(mlogPool, "wt", str);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            //sprintf_f(str, "wt_01 - ans:0x%x \n", data->ansp0); 
            //print_f(mlogPool, "wt", str); 
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

#if test
    ASPOP_REG_RD,
    ASPOP_REG_WT,
    ASPOP_REG_ADDRH,
    ASPOP_REG_ADDRL,
    ASPOP_REG_DAT,
#endif
static int stdob_10(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;
    pct = rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op10 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "reg", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_REG_RD];
            if (pdt->opCode != OP_RGRD) {
                sprintf_f(rs->logs, "op10, REG_RD opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "reg", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (!(pdt->opStatus & ASPOP_STA_CON)) {
                sprintf_f(rs->logs, "op10, REG_RD status is wrong op:%x\n", pdt->opStatus); 
                print_f(rs->plogs, "reg", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_REG_RD];
                //pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int streg_11(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op11 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "reg", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_REG_ADDRH];
            if (pdt->opCode != OP_RGADD_H) {
                sprintf_f(rs->logs, "op11, OP_RGADD_H opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "reg", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (!(pdt->opStatus & ASPOP_STA_CON)) {
                sprintf_f(rs->logs, "op11, OP_RGADD_H status is wrong op:%x\n", pdt->opStatus); 
                print_f(rs->plogs, "reg", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_REG_ADDRH];
                //pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int streg_12(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op12 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "reg", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_REG_ADDRL];
            if (pdt->opCode != OP_RGADD_L) {
                sprintf_f(rs->logs, "op12, OP_RGADD_L opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "reg", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (!(pdt->opStatus & ASPOP_STA_CON)) {
                sprintf_f(rs->logs, "op12, OP_RGADD_L status is wrong op:%x\n", pdt->opStatus); 
                print_f(rs->plogs, "reg", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_REG_ADDRL];
                //pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int streg_13(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op13 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "reg", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_REG_DAT];
            if (pdt->opCode != OP_RGDAT) {
                sprintf_f(rs->logs, "op13, OP_RGDAT opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "reg", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (!(pdt->opStatus & ASPOP_STA_CON)) {
                sprintf_f(rs->logs, "op13, OP_RGDAT status is wrong op:%x\n", pdt->opStatus); 
                print_f(rs->plogs, "reg", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            } 
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_REG_DAT];
                //pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, STINIT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int streg_14(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;
    pct = rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op14 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "reg", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_REG_WT];
            if (pdt->opCode != OP_RGWT) {
                sprintf_f(rs->logs, "op14, REG_WT opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "reg", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (!(pdt->opStatus & ASPOP_STA_CON)) {
                sprintf_f(rs->logs, "op14, REG_WT status is wrong op:%x\n", pdt->opStatus); 
                print_f(rs->plogs, "reg", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_REG_WT];
                //pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int streg_15(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op15 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "reg", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_REG_ADDRH];
            if (pdt->opCode != OP_RGADD_H) {
                sprintf_f(rs->logs, "op15, OP_RGADD_H opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "reg", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (!(pdt->opStatus & ASPOP_STA_CON)) {
                sprintf_f(rs->logs, "op15, OP_RGADD_H status is wrong op:%x\n", pdt->opStatus); 
                print_f(rs->plogs, "reg", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_REG_ADDRH];
                //pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int streg_16(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op16 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "reg", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_REG_ADDRL];
            if (pdt->opCode != OP_RGADD_L) {
                sprintf_f(rs->logs, "op16, OP_RGADD_L opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "reg", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (!(pdt->opStatus & ASPOP_STA_CON)) {
                sprintf_f(rs->logs, "op16, OP_RGADD_L status is wrong op:%x\n", pdt->opStatus); 
                print_f(rs->plogs, "reg", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_REG_ADDRL];
                //pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int streg_17(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op17 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "reg", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_REG_DAT];
            if (pdt->opCode != OP_RGDAT) {
                sprintf_f(rs->logs, "op17, OP_RGDAT opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "reg", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (!(pdt->opStatus & ASPOP_STA_CON)) {
                sprintf_f(rs->logs, "op17, OP_RGDAT status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "reg", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_REG_DAT];
                //pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stfat_18(struct psdata_s *data)
{
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_18 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "FAT", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDFAT_RD];
            if (pdt->opCode != OP_SDRD) {
                sprintf_f(rs->logs, "op18, OP_SDRD opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "FAT", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op18, OP_SDRD status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDFAT_RD];
                //pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stfat_19(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_19 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "FAT", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDFAT_WT];
            if (pdt->opCode != OP_SDWT) {
                sprintf_f(rs->logs, "op19, OP_SDWT opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "FAT", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op19, OP_SDWT status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDFAT_WT];
                //pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stfat_20(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_20 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "FAT", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDFAT_STR01];
            if (pdt->opCode != OP_STSEC_00) {
                sprintf_f(rs->logs, "op20, OP_STSEC_0 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "FAT", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op20, OP_STSEC_0 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
            
                //sprintf_f(rs->logs, "!!!! op20, ASPOP_SDFAT_STR01: %d !!!!\n", pdt->opValue); 
                //print_f(rs->plogs, "FAT", rs->logs);  

                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDFAT_STR01];
                //pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stfat_21(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_21 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "FAT", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDFAT_STR02];
            if (pdt->opCode != OP_STSEC_01) {
                sprintf_f(rs->logs, "op21, OP_STSEC_1 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "FAT", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op21, OP_STSEC_1 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
            
                //sprintf_f(rs->logs, "!!!! op21, ASPOP_SDFAT_STR02: %d !!!!\n", pdt->opValue); 
                //print_f(rs->plogs, "FAT", rs->logs);  

                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDFAT_STR02];
                //pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stfat_22(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_22 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "FAT", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDFAT_STR03];
            if (pdt->opCode != OP_STSEC_02) {
                sprintf_f(rs->logs, "op22, OP_STSEC_2 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "FAT", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op22, OP_STSEC_2 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
            
                //sprintf_f(rs->logs, "!!!! op22, ASPOP_SDFAT_STR03: %d !!!!\n", pdt->opValue); 
                //print_f(rs->plogs, "FAT", rs->logs);  

                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDFAT_STR03];
                //pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stfat_23(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_23 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "FAT", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDFAT_STR04];
            if (pdt->opCode != OP_STSEC_03) {
                sprintf_f(rs->logs, "op23, OP_STSEC_3 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "FAT", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op23, OP_STSEC_3 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
            
                //sprintf_f(rs->logs, "!!!! op23, ASPOP_SDFAT_STR04: %d !!!!\n", pdt->opValue); 
                //print_f(rs->plogs, "FAT", rs->logs);  

                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDFAT_STR04];
                //pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stfat_24(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_24 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "FAT", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDFAT_LEN01];
            if (pdt->opCode != OP_STLEN_00) {
                sprintf_f(rs->logs, "op24, OP_STLEN_0 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "FAT", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op24, OP_STLEN_0 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDFAT_LEN01];
                //pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stfat_25(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_25 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "FAT", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDFAT_LEN02];
            if (pdt->opCode != OP_STLEN_01) {
                sprintf_f(rs->logs, "op25, OP_STLEN_1 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "FAT", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op25, OP_STLEN_1 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDFAT_LEN02];
                //pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stfat_26(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_26 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "FAT", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDFAT_LEN03];
            if (pdt->opCode != OP_STLEN_02) {
                sprintf_f(rs->logs, "op26, OP_STLEN_2 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "FAT", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op26, OP_STLEN_2 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDFAT_LEN03];
                //pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stfat_27(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_27 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "FAT", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDFAT_LEN04];
            if (pdt->opCode != OP_STLEN_03) {
                sprintf_f(rs->logs, "op27, OP_STLEN_3 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "FAT", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op27, OP_STLEN_3 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDFAT_LEN04];
                //pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stfat_28(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_28 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "FAT", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDFAT_SDAT];
            if (pdt->opCode != OP_SDAT) {
                sprintf_f(rs->logs, "op28, OP_SDAT opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "FAT", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op28, OP_SDAT status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDFAT_SDAT];
                //pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stfat_29(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct sdFAT_s *pFat=0;
    struct info16Bit_s *p=0, *c=0;

    pFat = data->rs->psFat;
    
    rs = data->rs;
    rlt = abs_result(data->result); 
    
    p = &rs->pmch->tmp;
    c = &rs->pmch->cur;

    //sprintf_f(rs->logs, "op_29 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "FAT", rs->logs);  

    switch (rlt) {
        case STINIT:

            if (!(pFat->fatStatus & ASPFAT_STATUS_BOOT_SEC)) {
                ch = 45;             
            } else {
                if (pFat->fatStatus & ASPFAT_STATUS_SDRD) {
                    ch = 72;
                } else if (pFat->fatStatus & ASPFAT_STATUS_SDWT) {
                    ch = 77;
                } else if (pFat->fatStatus & ASPFAT_STATUS_SDWBK) {
                    ch = 95;
                } else if (pFat->fatStatus & ASPFAT_STATUS_FOLDRWT) {
                    ch = 141;
                } else if (pFat->fatStatus & ASPFAT_STATUS_FATWT) {
                    ch = 82;
                } else if (pFat->fatStatus & ASPFAT_STATUS_DFECHK) {
                    ch = 45;
                } else if (pFat->fatStatus & ASPFAT_STATUS_DFERD) {
                    ch = 45;
                } else if (pFat->fatStatus & ASPFAT_STATUS_DFEWT) {
                    ch = 89;
                } else if (pFat->fatStatus & ASPFAT_STATUS_FMTBSEC) {
                    ch = 128;
                } else if (pFat->fatStatus & ASPFAT_STATUS_FMTFAT) {
                    ch = 131;
                } else if (pFat->fatStatus & ASPFAT_STATUS_FMTROOT) {
                    ch = 00;
                } else if ((c->opinfo == pFat->fatBootsec.secWhfat) && 
                    (p->opinfo == pFat->fatBootsec.secPrfat)) {
                    ch = 54; 
                } else {
                    ch = 45; 
                }
            }

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_29: result: %x, goto %d, fatStatus: %x\n", data->result, ch, pFat->fatStatus); 
            print_f(rs->plogs, "FAT", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stfat_30(struct psdata_s *data)
{ 
    int ret=0, offset=0, val=0;
    struct sdFAT_s *pFat=0;
    uint32_t secStr=0, secLen=0;
    char str[128], ch = 0; 
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->tmp;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    uint32_t rlt, chk;
    rlt = abs_result(data->result); 
    pFat = data->rs->psFat;

    //sprintf_f(rs->logs, "op_30 rlt:0x%x fat:0x%.8x ansp:0x%x\n", rlt, pFat->fatStatus, data->ansp0); 
    //print_f(rs->plogs, "FAT", rs->logs);  

    switch (rlt) {
        case STINIT:
        
            if (!(pFat->fatStatus & ASPFAT_STATUS_MBR)) {
                secStr = 0;
                secLen = 16;
                c->opinfo = secStr;
                p->opinfo = secLen;

                sprintf_f(rs->logs, "MBR_SEC secStr:%d, secLen:%d, fat status:0x%.8x \n", secStr, secLen, pFat->fatStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  

                ch = 136;
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            } else if (!(pFat->fatStatus & ASPFAT_STATUS_BOOT_SEC)) {
                secStr = 0 + pFat->fatBootsec.secBoffset;
                secLen = 16;
                c->opinfo = secStr;
                p->opinfo = secLen;

                sprintf_f(rs->logs, "BOOT_SEC secStr:%d, secLen:%d, fat status:0x%.8x \n", secStr, secLen, pFat->fatStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  

                ch = 50;
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            } else if (!(pFat->fatStatus & ASPFAT_STATUS_FAT)) {
                secStr = pFat->fatBootsec.secWhfat;
                secLen = pFat->fatBootsec.secPrfat;

                c->opinfo = secStr;
                p->opinfo = secLen;
                
                ch = 53;
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            } else if (!(pFat->fatStatus & ASPFAT_STATUS_ROOT_DIR)) {
                secStr = pFat->fatBootsec.secWhroot;
                secLen = pFat->fatBootsec.secPrClst;

                c->opinfo = secStr;
                p->opinfo = secLen;

                if (secLen < 16) secLen = 16;

                sprintf_f(rs->logs, "ROOT_DIR secStr:%d, secLen:%d, fat status:0x%.8x \n", secStr, secLen, pFat->fatStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  
                
                ch = 51;
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            } else if (!(pFat->fatStatus & ASPFAT_STATUS_FOLDER)) {
                sprintf_f(rs->logs, "FOLDER fat status:0x%.8x \n", pFat->fatStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  

                ch = 52;
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            } else if ((pFat->fatStatus & ASPFAT_STATUS_SDRD)) {
                sprintf_f(rs->logs, "SD Read to APP status:0x%.8x \n", pFat->fatStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  

                ch = 71; /* LOV->MSP->APP */
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            } else if ((pFat->fatStatus & ASPFAT_STATUS_SDWT)) {
                sprintf_f(rs->logs, "APP write data to SD status:0x%.8x \n", pFat->fatStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  

                ch = 76; /* APP->MSP->LOV */
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            } else if ((pFat->fatStatus & ASPFAT_STATUS_SDWBK)) {
                sprintf_f(rs->logs, "APP write SD data BACK to SD status:0x%.8x \n", pFat->fatStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  

                ch = 94; /* MSP->LOV */
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            } else if ((pFat->fatStatus & ASPFAT_STATUS_FOLDRWT)) {
                sprintf_f(rs->logs, "APP write SD folder data BACK to SD status:0x%.8x \n", pFat->fatStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  

                ch = 140; /* MSP->LOV */
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            } else if ((pFat->fatStatus & ASPFAT_STATUS_FATWT)) {
                sprintf_f(rs->logs, "APP write FAT to SD status:0x%.8x \n", pFat->fatStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  

                ch = 80; /* APP->MSP->LOV */
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            } else if ((pFat->fatStatus & ASPFAT_STATUS_DFECHK)) {
                sprintf_f(rs->logs, "APP read DFE from SD status:0x%.8x \n", pFat->fatStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  

                ch = 81; /* APP->MSP->LOV */
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            } else if ((pFat->fatStatus & ASPFAT_STATUS_DFEWT)) {
                sprintf_f(rs->logs, "APP write DFE to SD status:0x%.8x \n", pFat->fatStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  

                ch = 88; /* APP->MSP->LOV */
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            } else if ((pFat->fatStatus & ASPFAT_STATUS_FMTBSEC)) {
                sprintf_f(rs->logs, "APP write DFE to SD status:0x%.8x \n", pFat->fatStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  

                ch = 127; /* MSP->LOV */
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            } else if ((pFat->fatStatus & ASPFAT_STATUS_FMTFAT)) {
                sprintf_f(rs->logs, "APP write DFE to SD status:0x%.8x \n", pFat->fatStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  

                ch = 130; /* MSP->LOV */
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            } else if ((pFat->fatStatus & ASPFAT_STATUS_FMTROOT)) {
                sprintf_f(rs->logs, "APP write DFE to SD status:0x%.8x \n", pFat->fatStatus); 
                print_f(rs->plogs, "FAT", rs->logs);  

                ch = 00; /* MSP->LOV */
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            } else {
                ch = 56; /* show the folder tree */
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }
            
            //sprintf_f(str, "op_30: result: %x\n", data->result); 
            //print_f(mlogPool, "FAT", str);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 3) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 4) {
                chk = chk_bk(data->bkofw);
                if (chk) {
                    data->result = emb_result(data->result, BKWRD);
                } else {
                    data->result = emb_result(data->result, FWORD);
                }
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
/*
            else {
                data->result = emb_result(data->result, EVTMAX);
            }
*/
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsup_31(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct sdFAT_s *pFat=0;
    struct info16Bit_s *p=0, *c=0;

    pFat = data->rs->psFat;
    
    rs = data->rs;
    rlt = abs_result(data->result); 
    
    p = &rs->pmch->tmp;
    c = &rs->pmch->cur;

    //sprintf_f(rs->logs, "op_31 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SUP", rs->logs);  

    switch (rlt) {
        case STINIT:

            ch = 60;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_31: result: %x, goto %d \n", data->result, ch); 
            print_f(rs->plogs, "SUP", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsup_32(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct sdFAT_s *pFat=0;
    struct info16Bit_s *p=0, *c=0;

    pFat = data->rs->psFat;
    
    rs = data->rs;
    rlt = abs_result(data->result); 
    
    p = &rs->pmch->tmp;
    c = &rs->pmch->cur;

    //sprintf_f(rs->logs, "op_32 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SUP", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 48; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_32: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "SUP", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsup_33(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    
    rs = data->rs;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_33 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SIG", rs->logs);  

    switch (rlt) {
        case STINIT:
        
#if CHECK_SOCKET_STATUS
            ch = 25; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
#else
            data->ansp0 = 1;
            data->result = emb_result(data->result, NEXT);
#endif

            //sprintf_f(rs->logs, "op_33: result: %x, goto %d\n", data->result, ch); 
            //print_f(rs->plogs, "SIG", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsup_34(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct info16Bit_s *p=0, *c=0, *t=0;
    struct aspConfig_s *pct=0, *pdt=0;

    pct = data->rs->pcfgTable;
    rs = data->rs;
    rlt = abs_result(data->result); 
    
    p = &rs->pmch->get;
    c = &rs->pmch->cur;
    t = &rs->pmch->tmp;

    //sprintf_f(rs->logs, "op_34 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SIG", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SCAN_SINGLE];
            if ((pdt->opCode != OP_SINGLE) && (pdt->opCode != OP_MSINGLE)
                && (pdt->opCode != OP_HANDSCAN)) {
                sprintf_f(rs->logs, "op34, OP_SINGLE opcode is wrong val:%x\n", pdt->opCode); 
                print_f(rs->plogs, "SIG", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (!(pdt->opStatus & ASPOP_STA_WR)) {
                sprintf_f(rs->logs, "op34, OP_SINGLE status is wrong val:%x\n", pdt->opStatus); 
                print_f(rs->plogs, "SIG", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {

                sprintf_f(rs->logs, "op34 opcode:%x value:%x\n", pdt->opCode, pdt->opValue); 
                print_f(rs->plogs, "SIG", rs->logs);  

                switch(pdt->opValue) {
                    case SINSCAN_WIFI_ONLY:
                    //case SINSCAN_SD_ONLY:
                    case SINSCAN_WIFI_SD:
                    //case SINSCAN_WHIT_BLNC:
                    //case SINSCAN_USB:
                    //case SINSCAN_DUAL_STRM: /*not going here*/
                    //case SINSCAN_DUAL_SD:
                        ch = 41; 
/*
                        if (pdt->opCode != t->opcode) {
                            c->opcode =  t->opcode;

                            sprintf_f(rs->logs, "op34 WARNING!!! use temp opcode:%x \n", t->opcode); 
                            print_f(rs->plogs, "SIG", rs->logs);  
                            
                        } else {
                            c->opcode =  pdt->opCode;
                        }
*/
                        c->opcode =  pdt->opCode;
                        c->data = pdt->opValue;
                        memset(p, 0, sizeof(struct info16Bit_s));

                        rs_ipc_put(data->rs, &ch, 1);
                        data->result = emb_result(data->result, WAIT);
                        //sprintf_f(rs->logs, "op_34: result: %x, goto %d\n", data->result, ch); 
                        //print_f(rs->plogs, "SIG", rs->logs);  
                        break;
                    default:
                        sprintf_f(rs->logs, "ERROR!!! op34, opValue is unexpected val:%x\n", pdt->opValue);
                        print_f(rs->plogs, "SIG", rs->logs);  
                        data->result = emb_result(data->result, EVTMAX);
                        break;
                }
            }        
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                if (p->data == c->data) {
                    data->result = emb_result(data->result, NEXT);
                } else {
                    data->result = emb_result(data->result, EVTMAX);
                }
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsup_35(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;

    rs = data->rs;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_35 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SIG", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 67; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(rs->logs, "op_35: result: %x, goto %d\n", data->result, ch); 
            //print_f(rs->plogs, "SIG", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsin_36(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct aspConfig_s *pct=0, *pdt=0;

    pct = data->rs->pcfgTable;
    rs = data->rs;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_36 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SIN", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 48; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(rs->logs, "op_36: result: %x, goto %d\n", data->result, ch); 
            //print_f(rs->plogs, "SIN", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_EG_DECT];
                if ((pdt->opStatus == ASPOP_STA_UPD) && (pdt->opValue == 1)) {
#if CROP_USE_META
                    data->bkofw = emb_bk(data->bkofw, SAVPARM, PSRLT);
#else
                    data->bkofw = emb_bk(data->bkofw, WTBAKQ, PSTSM);
#endif
                    data->result = emb_result(data->result, BKWRD);
                } else {
                    data->result = emb_result(data->result, FWORD);
                }
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stdow_37(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    
    rs = data->rs;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_37 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "DOW", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 70; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(rs->logs, "op_37: result: 0x%x, goto %d\n", data->result, ch); 
            //print_f(rs->plogs, "DOW", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stupd_38(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    
    rs = data->rs;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_38 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "UPD", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 75; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(rs->logs, "op_38: result: %x, goto %d\n", data->result, ch); 
            //print_f(rs->plogs, "UPD", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stupd_39(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct info16Bit_s *p=0, *c=0, *t=0;

    rs = data->rs;
    rlt = abs_result(data->result); 
    //sprintf_f(rs->logs, "op_39 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "OCR", rs->logs);  

    switch (rlt) {
        case STINIT:
            aspMetaClear(0, rs, ASPMETA_INPUT);
            
            ch = 110;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(rs->logs, "op_39: result: %x, goto %d\n", data->result, ch); 
            //print_f(rs->plogs, "OCR", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stupd_40(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct aspMetaMass_s *pmass;
    
    rs = data->rs;
    rlt = abs_result(data->result); 
    pmass = rs->pmetaMass;
    
    //sprintf_f(rs->logs, "op_40 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "OCR", rs->logs);  

    switch (rlt) {
        case STINIT:
            sprintf_f(rs->logs, "op_40: dump meta input (used:%d) \n", pmass->massUsed); 
            print_f(rs->plogs, "OCR", rs->logs);  

            memset(str, 0, 128);
            shmem_dump(pmass->masspt, 32);
            bin2hex(str, pmass->masspt, 32);

            sprintf_f(rs->logs, "op_40: bin to hex :\n [%s]\n", str); 
            print_f(rs->plogs, "OCR", rs->logs);  
            
#if 0
            data->result = emb_result(data->result, NEXT);            
#else     
            ch = 112; 
            
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
#endif

            //sprintf_f(rs->logs, "op_40: result: %x, goto %d\n", data->result, ch); 
            //print_f(rs->plogs, "OCR", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsav_41(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    
    rs = data->rs;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_41 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SAV", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 84; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(rs->logs, "op_41: result: %x, goto %d\n", data->result, ch); 
            //print_f(rs->plogs, "SAV", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsda_42(struct psdata_s *data)
{
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_42 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDA", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDFREE_FREESEC];
            if (pdt->opCode != OP_FREESEC) {
                sprintf_f(rs->logs, "op42, OP_FREESEC opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op42, OP_FREESEC status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDFREE_FREESEC];
                pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsda_43(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_43 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDA", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDFREE_STR01];
            if (pdt->opCode != OP_STSEC_00) {
                sprintf_f(rs->logs, "op43, OP_STSEC_0 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op43, OP_STSEC_0 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDFREE_STR01];
                pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsda_44(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_44 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDA", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDFREE_STR02];
            if (pdt->opCode != OP_STSEC_01) {
                sprintf_f(rs->logs, "op44, OP_STSEC_1 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op44, OP_STSEC_1 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDFREE_STR02];
                pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsda_45(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_45 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDA", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDFREE_STR03];
            if (pdt->opCode != OP_STSEC_02) {
                sprintf_f(rs->logs, "op45, OP_STSEC_2 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op45, OP_STSEC_2 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDFREE_STR03];
                pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsda_46(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_46 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDA", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDFREE_STR04];
            if (pdt->opCode != OP_STSEC_03) {
                sprintf_f(rs->logs, "op46, OP_STSEC_3 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op46, OP_STSEC_3 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDFREE_STR04];
                pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsda_47(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_47 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDA", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDFREE_LEN01];
            if (pdt->opCode != OP_STLEN_00) {
                sprintf_f(rs->logs, "op47, OP_STLEN_0 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op47, OP_STLEN_0 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDFREE_LEN01];
                pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsda_48(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_48 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDA", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDFREE_LEN02];
            if (pdt->opCode != OP_STLEN_01) {
                sprintf_f(rs->logs, "op48, OP_STLEN_1 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op48, OP_STLEN_1 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDFREE_LEN02];
                pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsda_49(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_49 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDA", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDFREE_LEN03];
            if (pdt->opCode != OP_STLEN_02) {
                sprintf_f(rs->logs, "op49, OP_STLEN_2 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op49, OP_STLEN_2 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDFREE_LEN03];
                pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsda_50(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_50 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDA", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDFREE_LEN04];
            if (pdt->opCode != OP_STLEN_03) {
                sprintf_f(rs->logs, "op50, OP_STLEN_3 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op50, OP_STLEN_3 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDFREE_LEN04];
                pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, FWORD);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsda_51(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct sdFAT_s *pFat=0;
    struct info16Bit_s *p=0, *c=0;

    pFat = data->rs->psFat;
    
    rs = data->rs;
    rlt = abs_result(data->result); 
    
    p = &rs->pmch->tmp;
    c = &rs->pmch->cur;

    //sprintf_f(rs->logs, "op_51 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDA", rs->logs);  

    switch (rlt) {
        case STINIT:
            if (!(pFat->fatStatus & ASPFAT_STATUS_FAT)) {
                ch = 137;
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
                sprintf_f(rs->logs, "op_51: fatStatus: %x, Error !!not doing boot yet !!\n", pFat->fatStatus); 
                print_f(rs->plogs, "SDA", rs->logs);  

                //data->result = emb_result(data->result, EVTMAX);
            } else {
                ch = 91;
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }

            sprintf_f(rs->logs, "op_51: result: %x, goto %d, fatStatus: %x\n", data->result, ch, pFat->fatStatus); 
            print_f(rs->plogs, "SDA", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsda_52(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_52 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDA", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDUSED_USEDSEC];
            if (pdt->opCode != OP_USEDSEC) {
                sprintf_f(rs->logs, "op52, OP_USEDSEC opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op52, OP_USEDSEC status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDUSED_USEDSEC];
                pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}


static int stsda_53(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_53 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDA", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDUSED_STR01];
            if (pdt->opCode != OP_STSEC_00) {
                sprintf_f(rs->logs, "op53, OP_STSEC_0 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op53, OP_STSEC_0 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDUSED_STR01];
                pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsda_54(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_54 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDA", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDUSED_STR02];
            if (pdt->opCode != OP_STSEC_01) {
                sprintf_f(rs->logs, "op54, OP_STSEC_1 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op54, OP_STSEC_1 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDUSED_STR02];
                pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsda_55(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_55 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDA", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDUSED_STR03];
            if (pdt->opCode != OP_STSEC_02) {
                sprintf_f(rs->logs, "op55, OP_STSEC_2 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op55, OP_STSEC_2 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDUSED_STR03];
                pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsda_56(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_56 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDA", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDUSED_STR04];
            if (pdt->opCode != OP_STSEC_03) {
                sprintf_f(rs->logs, "op56, OP_STSEC_3 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op56, OP_STSEC_3 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDUSED_STR04];
                pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsda_57(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_57 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDA", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDUSED_LEN01];
            if (pdt->opCode != OP_STLEN_00) {
                sprintf_f(rs->logs, "op57, OP_STLEN_0 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op57, OP_STLEN_0 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDUSED_LEN01];
                pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsda_58(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_58 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDA", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDUSED_LEN02];
            if (pdt->opCode != OP_STLEN_01) {
                sprintf_f(rs->logs, "op58, OP_STLEN_1 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op58, OP_STLEN_1 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDUSED_LEN02];
                pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsda_59(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_59 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDA", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDUSED_LEN03];
            if (pdt->opCode != OP_STLEN_02) {
                sprintf_f(rs->logs, "op59, OP_STLEN_2 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op59, OP_STLEN_2 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDUSED_LEN03];
                pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsda_60(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_60 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDA", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDUSED_LEN04];
            if (pdt->opCode != OP_STLEN_03) {
                sprintf_f(rs->logs, "op60, OP_STLEN_3 opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op60, OP_STLEN_3 status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "SDA", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SDUSED_LEN04];
                pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsda_61(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct sdFAT_s *pFat=0;
    struct info16Bit_s *p=0, *c=0;

    pFat = data->rs->psFat;
    
    rs = data->rs;
    rlt = abs_result(data->result); 
    
    p = &rs->pmch->tmp;
    c = &rs->pmch->cur;

    //sprintf_f(rs->logs, "op_61 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDA", rs->logs);  

    switch (rlt) {
        case STINIT:
            if (!(pFat->fatStatus & ASPFAT_STATUS_FAT)) {
                data->result = emb_result(data->result, EVTMAX);
            } else {
                ch = 92;
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }
            
            //sprintf_f(rs->logs, "op_61: result: %x, goto %d, fatStatus: %x\n", data->result, ch, pFat->fatStatus); 
            //print_f(rs->plogs, "SDA", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsda_62(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    
    rs = data->rs;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_62 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDA", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 93; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(rs->logs, "op_62: result: %x, goto %d\n", data->result, ch); 
            //print_f(rs->plogs, "SDA", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stwbk_63(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt, chk;
    struct procRes_s *rs;
    
    rs = data->rs;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_63 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDWBK", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 98; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(rs->logs, "op_63: result: %x, goto %d\n", data->result, ch); 
            //print_f(rs->plogs, "SDWBK", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                chk = chk_bk(data->bkofw);
                if (!chk) {
                    data->bkofw = emb_bk(data->bkofw, SDAO, PSWT);
                    data->result = emb_result(data->result, NEXT);
                } else {
                    data->result = emb_result(data->result, EVTMAX);
                }
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsdinit_64(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;


    rs = data->rs;
    rlt = abs_result(data->result); 
    
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    //sprintf_f(rs->logs, "op_64 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDINIT", rs->logs);  

    switch (rlt) {
        case STINIT:
            c->opcode = OP_SDINIT;
            c->data = 0;
            memset(p, 0, sizeof(struct info16Bit_s));

            ch = 41; 

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(rs->logs, "op_64: result: %x, goto %d\n", data->result, ch); 
            //print_f(rs->plogs, "SDINIT", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsdinit_65(struct psdata_s *data)
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;


    rs = data->rs;
    rlt = abs_result(data->result); 
    
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    //sprintf_f(rs->logs, "op_65 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SDINIT", rs->logs);  

    switch (rlt) {
        case STINIT:
            c->opcode = OP_SDSTATS;
            c->data = 0;
            memset(p, 0, sizeof(struct info16Bit_s));

            ch = 41; 

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(rs->logs, "op_65: result: %x, goto %d\n", data->result, ch); 
            //print_f(rs->plogs, "SDINIT", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                if (p->data == SDSTATS_OK) {
                    data->result = emb_result(data->result, NEXT);
                } else {
                    data->result = emb_result(data->result, EVTMAX);
                }
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);

}

static int stwtbak_66(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;
    struct aspConfig_s *pct=0, *pdt=0;

    pct = data->rs->pcfgTable;
    rs = data->rs;
    rlt = abs_result(data->result); 
    
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    //sprintf_f(rs->logs, "op_66 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "WTBAK", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SCAN_SINGLE];
            if ((pdt->opCode != OP_SINGLE) && (pdt->opCode != OP_MSINGLE)
                && (pdt->opCode != OP_HANDSCAN)) {
                sprintf_f(rs->logs, "op66, OP_SINGLE opcode is wrong val:%x\n", pdt->opCode); 
                print_f(rs->plogs, "WTBAK", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (!(pdt->opStatus & ASPOP_STA_WR)) {
                sprintf_f(rs->logs, "op66, OP_SINGLE status is wrong val:%x\n", pdt->opStatus); 
                print_f(rs->plogs, "WTBAK", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                if (pdt->opValue == SINSCAN_WIFI_SD) {
                    data->ansp0 = 1;
                    data->result = emb_result(data->result, NEXT);
                    data->bkofw = emb_fw(data->bkofw, WTBAKQ, PSACT);
                    sprintf_f(rs->logs, "op_66: SINSCAN_WIFI_SD go to next!!\n"); 
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                } else if (pdt->opValue == SINSCAN_SD_ONLY) {
                    data->ansp0 = 2;
                    data->result = emb_result(data->result, NEXT);
                    data->bkofw = emb_fw(data->bkofw, WTBAKQ, PSACT);
                    sprintf_f(rs->logs, "op_66: SINSCAN_SD_ONLY go to next!!\n"); 
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                } else if (pdt->opValue == SINSCAN_DUAL_SD) {
                    data->ansp0 = 3;
                    data->result = emb_result(data->result, NEXT);
                    data->bkofw = emb_fw(data->bkofw, WTBAKQ, PSACT);
                    sprintf_f(rs->logs, "op_66: SINSCAN_DUAL_SD go to next!!\n"); 
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                } else {
                    sprintf_f(rs->logs, "WARNING!!! op66, opValue is unexpected val:%x\n", pdt->opValue);
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                    data->result = emb_result(data->result, EVTMAX);
                }
            }
        
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stwtbak_67(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;
    struct aspConfig_s *pct=0, *pdt=0;

    pct = data->rs->pcfgTable;
    rs = data->rs;
    rlt = abs_result(data->result); 
    
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    //sprintf_f(rs->logs, "op_67 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "WTBAK", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SCAN_SINGLE];
            if ((pdt->opCode != OP_SINGLE) && (pdt->opCode != OP_MSINGLE)
                && (pdt->opCode != OP_HANDSCAN)) {
                sprintf_f(rs->logs, "op67, OP_SINGLE opcode is wrong val:%x\n", pdt->opCode); 
                print_f(rs->plogs, "WTBAK", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (!(pdt->opStatus & ASPOP_STA_WR)) {
                sprintf_f(rs->logs, "op67, OP_SINGLE status is wrong val:%x\n", pdt->opStatus); 
                print_f(rs->plogs, "WTBAK", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                if (pdt->opValue == SINSCAN_WIFI_SD) {
                    pdt->opStatus = ASPOP_STA_UPD;
                    data->ansp0 = 1;
                    data->result = emb_result(data->result, NEXT);
                    sprintf_f(rs->logs, "op_67: SINSCAN_WIFI_SD go to next!!\n"); 
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                } else if (pdt->opValue == SINSCAN_SD_ONLY) {
                    pdt->opStatus = ASPOP_STA_UPD;
                    data->ansp0 = 2;
                    data->result = emb_result(data->result, NEXT);
                    sprintf_f(rs->logs, "op_67: SINSCAN_SD_ONLY go to next!!\n"); 
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                } else if (pdt->opValue == SINSCAN_DUAL_SD) {
                    pdt->opStatus = ASPOP_STA_UPD;
                    data->ansp0 = 3;
                    data->result = emb_result(data->result, NEXT);
                    sprintf_f(rs->logs, "op_67: SINSCAN_DUAL_SD go to next!!\n"); 
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                } else {
                    sprintf_f(rs->logs, "WARNING!!! op67, opValue is unexpected val:%x\n", pdt->opValue);
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                    data->result = emb_result(data->result, EVTMAX);
                }
            }
        
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stwtbak_68(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;


    rs = data->rs;
    rlt = abs_result(data->result); 
    
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    //sprintf_f(rs->logs, "op_68 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "WTBAK", rs->logs);  

    switch (rlt) {
        case STINIT:
            c->opcode = OP_SINGLE;
            c->data = SINSCAN_SD_ONLY;
            memset(p, 0, sizeof(struct info16Bit_s));

            ch = 41; 

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(rs->logs, "op_68: result: %x, goto %d\n", data->result, ch); 
            //print_f(rs->plogs, "WTBAK", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                if (p->data == c->data) {
                    data->result = emb_result(data->result, NEXT);
                } else {
                    data->result = emb_result(data->result, EVTMAX);    
                }
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stwtbak_69(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;

    rs = data->rs;
    rlt = abs_result(data->result); 
    
    //sprintf_f(rs->logs, "op_69 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "WTBAK", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 99; 

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(rs->logs, "op_69: result: %x, goto %d\n", data->result, ch); 
            //print_f(rs->plogs, "WTBAK", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stwtbak_70(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct aspConfig_s *pct=0, *pdt=0;

    pct = data->rs->pcfgTable;
    rs = data->rs;
    rlt = abs_result(data->result); 
    
    //sprintf_f(rs->logs, "op_70 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "WTBAK", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 48; 

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(rs->logs, "op_70: result: %x, goto %d\n", data->result, ch); 
            //print_f(rs->plogs, "WTBAK", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_EG_DECT];
                if ((pdt->opStatus == ASPOP_STA_UPD) && (pdt->opValue == 1)) {
#if CROP_USE_META
                    data->bkofw = emb_bk(data->bkofw, SAVPARM, PSRLT);
#else
                    data->bkofw = emb_bk(data->bkofw, WTBAKQ, PSTSM);
#endif
                    data->result = emb_result(data->result, BKWRD);
                } else {
                    data->result = emb_result(data->result, FWORD);
                }
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stwtbak_71(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;
    struct aspConfig_s *pct=0, *pdt=0;

    pct = data->rs->pcfgTable;
    rs = data->rs;
    rlt = abs_result(data->result); 
    
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    //sprintf_f(rs->logs, "op_71 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "WTBAK", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SUP_SAVE];
            if (pdt->opCode != OP_SUPBACK) {
                sprintf_f(rs->logs, "op_71, ASPOP_SUP_SAVE opcode is wrong val:%x\n", pdt->opCode); 
                print_f(rs->plogs, "WTBAK", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (!(pdt->opStatus & ASPOP_STA_CON)) {
                sprintf_f(rs->logs, "op_71, ASPOP_SUP_SAVE status is wrong val:%x\n", pdt->opStatus); 
                print_f(rs->plogs, "WTBAK", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                if (pdt->opValue == SUPBACK_SD) {
                    data->ansp0 = 1;
                    data->result = emb_result(data->result, NEXT);
                    data->bkofw = emb_fw(data->bkofw, WTBAKQ, PSWT);
                    sprintf_f(rs->logs, "op_71: SUPBACK_SD go to next!!\n"); 
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                } else if (pdt->opValue == SUPBACK_RAW) {
                    data->ansp0 = 2;
                    data->result = emb_result(data->result, NEXT);
                    sprintf_f(rs->logs, "op_71: SUPBACK_RAW go to next!!\n"); 
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                } else if (pdt->opValue == SUPBACK_FAT) {
                    data->ansp0 = 3;
                    data->result = emb_result(data->result, NEXT);
                    data->bkofw = emb_fw(data->bkofw, WTBAKP, PSSET);
                    sprintf_f(rs->logs, "op_71: SUPBACK_FAT go to next!!\n"); 
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                } else {
                    sprintf_f(rs->logs, "WARNING!!! op_71, opValue is unexpected val:%x\n", pdt->opValue);
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                    data->result = emb_result(data->result, EVTMAX);
                }
            }
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stwtbak_72(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;
    struct aspConfig_s *pct=0, *pdt=0;

    pct = data->rs->pcfgTable;
    rs = data->rs;
    rlt = abs_result(data->result); 
    
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    //sprintf_f(rs->logs, "op_72 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "WTBAK", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SUP_SAVE];
            if (pdt->opCode != OP_SUPBACK) {
                sprintf_f(rs->logs, "op_72, OP_SUPBACK opcode is wrong val:%x\n", pdt->opCode); 
                print_f(rs->plogs, "WTBAK", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (!(pdt->opStatus & ASPOP_STA_CON)) {
                sprintf_f(rs->logs, "op_72, OP_SUPBACK status is wrong val:%x\n", pdt->opStatus); 
                print_f(rs->plogs, "WTBAK", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                if (pdt->opValue == SUPBACK_SD) {
                    data->ansp0 = 1;
                    data->result = emb_result(data->result, NEXT);
                    data->bkofw = emb_fw(data->bkofw, WTBAKQ, PSRLT);
                    sprintf_f(rs->logs, "op_72: SINSCAN_WIFI_SD go to next!!\n"); 
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                } else if (pdt->opValue == SUPBACK_RAW) {
                    data->ansp0 = 2;
                    data->result = emb_result(data->result, NEXT);
                    sprintf_f(rs->logs, "op_72: SINSCAN_SD_ONLY go to next!!\n"); 
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                } else if (pdt->opValue == SUPBACK_FAT) {
                    data->ansp0 = 3;
                    data->result = emb_result(data->result, NEXT);
                    data->bkofw = emb_fw(data->bkofw, WTBAKP, PSACT);
                    sprintf_f(rs->logs, "op_72: SINSCAN_DUAL_SD go to next!!\n"); 
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                } else {
                    sprintf_f(rs->logs, "WARNING!!! op_72, opValue is unexpected val:%x\n", pdt->opValue);
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                    data->result = emb_result(data->result, EVTMAX);
                }
            }
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stwtbak_73(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;
    struct aspConfig_s *pct=0, *pdt=0;

    pct = data->rs->pcfgTable;
    rs = data->rs;
    rlt = abs_result(data->result); 
    
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    //sprintf_f(rs->logs, "op_73 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "WTBAK", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SCAN_SINGLE];
            if ((pdt->opCode != OP_SINGLE) && (pdt->opCode != OP_MSINGLE)
                && (pdt->opCode != OP_HANDSCAN)) {
                sprintf_f(rs->logs, "op_73, OP_SINGLE opcode is wrong val:%x\n", pdt->opCode); 
                print_f(rs->plogs, "WTBAK", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (!(pdt->opStatus & ASPOP_STA_WR)) {
                sprintf_f(rs->logs, "op_73, OP_SINGLE status is wrong val:%x\n", pdt->opStatus); 
                print_f(rs->plogs, "WTBAK", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                if (pdt->opValue == SINSCAN_WIFI_SD) {

                    ch = 59; 
                    rs_ipc_put(data->rs, &ch, 1);
                    data->result = emb_result(data->result, WAIT);

                    sprintf_f(rs->logs, "op_73: SINSCAN_WIFI_SD go to next!!\n"); 
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                } else if (pdt->opValue == SINSCAN_SD_ONLY) {
                
                    ch = 59; 
                    rs_ipc_put(data->rs, &ch, 1);
                    data->result = emb_result(data->result, WAIT);

                    sprintf_f(rs->logs, "op_73: SINSCAN_SD_ONLY go to next!!\n"); 
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                } else if (pdt->opValue == SINSCAN_DUAL_SD) {

                    ch = 59; 
                    rs_ipc_put(data->rs, &ch, 1);
                    data->result = emb_result(data->result, WAIT);

                    sprintf_f(rs->logs, "op_73: SINSCAN_DUAL_SD go to next!!\n"); 
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                } else {
                    sprintf_f(rs->logs, "WARNING!!! op_73, opValue is unexpected val:%x\n", pdt->opValue);
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                    data->result = emb_result(data->result, EVTMAX);
                }
            }
        
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SCAN_SINGLE];
                data->ansp0 = pdt->opValue;
                data->result = emb_result(data->result, NEXT);
                data->bkofw = emb_fw(data->bkofw, WTBAKQ, PSACT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stwtbak_74(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;
    struct aspConfig_s *pct=0, *pdt=0;

    pct = data->rs->pcfgTable;
    rs = data->rs;
    rlt = abs_result(data->result); 
    
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    //sprintf_f(rs->logs, "op_74 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "WTBAK", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SCAN_SINGLE];
            if ((pdt->opCode != OP_SINGLE) && (pdt->opCode != OP_MSINGLE)
                && (pdt->opCode != OP_HANDSCAN)) {
                sprintf_f(rs->logs, "op_74, OP_SINGLE opcode is wrong val:%x\n", pdt->opCode); 
                print_f(rs->plogs, "WTBAK", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (!(pdt->opStatus & ASPOP_STA_WR)) {
                sprintf_f(rs->logs, "op_74, OP_SINGLE status is wrong val:%x\n", pdt->opStatus); 
                print_f(rs->plogs, "WTBAK", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                if (pdt->opValue == SINSCAN_WIFI_SD) {
                    pdt->opStatus = ASPOP_STA_UPD;

                    ch = 124; 
                    rs_ipc_put(data->rs, &ch, 1);
                    data->result = emb_result(data->result, WAIT);

                    //data->ansp0 = 1;
                    //data->result = emb_result(data->result, NEXT);
                    sprintf_f(rs->logs, "op_74: SINSCAN_WIFI_SD go to next!!\n"); 
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                } else if (pdt->opValue == SINSCAN_SD_ONLY) {
                    pdt->opStatus = ASPOP_STA_UPD;
                    
                    ch = 124; 
                    rs_ipc_put(data->rs, &ch, 1);
                    data->result = emb_result(data->result, WAIT);

                    //data->ansp0 = 2;
                    //data->result = emb_result(data->result, NEXT);
                    sprintf_f(rs->logs, "op_74: SINSCAN_SD_ONLY go to next!!\n"); 
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                } else if (pdt->opValue == SINSCAN_DUAL_SD) {
                    pdt->opStatus = ASPOP_STA_UPD;

                    ch = 124; 
                    rs_ipc_put(data->rs, &ch, 1);
                    data->result = emb_result(data->result, WAIT);

                    //data->ansp0 = 3;
                    //data->result = emb_result(data->result, NEXT);
                    sprintf_f(rs->logs, "op_74: SINSCAN_DUAL_SD go to next!!\n"); 
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                } else {
                    sprintf_f(rs->logs, "WARNING!!! op_74, opValue is unexpected val:%x\n", pdt->opValue);
                    print_f(rs->plogs, "WTBAK", rs->logs);  
                    data->result = emb_result(data->result, EVTMAX);
                }
            }
        
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_SCAN_SINGLE];
                data->ansp0 = pdt->opValue;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stcrop_75(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;
    struct aspConfig_s *pct=0, *pdt=0;

    pct = data->rs->pcfgTable;
    rs = data->rs;
    rlt = abs_result(data->result); 
    
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    //sprintf_f(rs->logs, "op_75 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "CROP", rs->logs);  

    switch (rlt) {
        case STINIT:
            
            pct[ASPOP_CROP_01].opValue = 0;
            pct[ASPOP_CROP_01].opStatus = ASPOP_STA_APP;

            pct[ASPOP_CROP_02].opValue = 0;
            pct[ASPOP_CROP_02].opStatus = ASPOP_STA_APP;

            pct[ASPOP_CROP_03].opValue = 0;
            pct[ASPOP_CROP_03].opStatus = ASPOP_STA_APP;

            pct[ASPOP_CROP_04].opValue = 0;
            pct[ASPOP_CROP_04].opStatus = ASPOP_STA_APP;

            pct[ASPOP_CROP_05].opValue = 0;
            pct[ASPOP_CROP_05].opStatus = ASPOP_STA_APP;

            pct[ASPOP_CROP_06].opValue = 0;
            pct[ASPOP_CROP_06].opStatus = ASPOP_STA_APP;

            //pct[ASPOP_IMG_LEN].opValue = 0;
            //pct[ASPOP_IMG_LEN].opStatus = ASPOP_STA_APP;

            sprintf_f(rs->logs, "op_75, reset CROP value"); 
            print_f(rs->plogs, "CROP", rs->logs);  
            data->result = emb_result(data->result, NEXT);
        
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stcrop_76(struct psdata_s *data)
{ 
    uint8_t uch=0;
    int xyAr[7];
    int id=0, err=0;
    uint32_t coord[2];
    char ch = 0; 
    uint32_t rlt;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;
    struct aspConfig_s *pct=0, *pdt=0;

    pct = data->rs->pcfgTable;
    rs = data->rs;
    rlt = abs_result(data->result); 
    
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    //sprintf_f(rs->logs, "op_76 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "CROP", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = 0;
            for (id=0; id < 7; id++) {
                if ((!pdt) && (pct[ASPOP_CROP_01 + id].opStatus == ASPOP_STA_WR)) {
                    pdt = &pct[ASPOP_CROP_01 + id];
                }

                xyAr[id] = -1;
            }
            if (pdt) {
                for (id=0; id < 4; id++) {            
                    if (pct[ASPOP_CROP_COOR_XH + id].opStatus == ASPOP_STA_UPD) {
                        xyAr[id] = pct[ASPOP_CROP_COOR_XH + id].opValue;
                    }
                }

                pdt->opValue = 0;
                err = 0;
                for (id=0; id < 4; id++) {
                    if (xyAr[id] < 0) {
                        sprintf_f(rs->logs, "ERROR!! wrong xy value - %d\n", xyAr[id]); 
                        print_f(rs->plogs, "CROP", rs->logs);  
                        err++;
                    } else {
                        uch = xyAr[id] & 0xff;
                        pdt->opValue |= uch << (8 * id); // low byte first or high byte first
                    }
                }

                if (!err) {
                    pdt->opStatus = ASPOP_STA_UPD;
                    //sprintf_f(rs->logs, "DONE!! crop value - 0x%.8x\n", pdt->opValue); 
                    //print_f(rs->plogs, "CROP", rs->logs);  
                } else {
                    pdt->opStatus = ASPOP_STA_APP;
                }
            }
            
            pdt = 0;
            for (id=0; id < 7; id++) {
                if ((!pdt) && (pct[ASPOP_CROP_01 + id].opStatus == ASPOP_STA_APP)) {
                    pdt = &pct[ASPOP_CROP_01 + id];
                }
            }

            if (!pdt) {
                for (id=0; id < 7; id++) {
                    if (id == 6) {
                        pdt = &pct[ASPOP_CROP_01 + id];
                        sprintf_f(rs->logs, "%d. %x (%d) [0x%.8x]\n", id, pdt->opStatus, pdt->opValue, pdt->opValue); 
                        print_f(rs->plogs, "CROP", rs->logs);  
                    } else {
                        pdt = &pct[ASPOP_CROP_01 + id];
                        coord[0] = pdt->opValue >> 16;
                        coord[1] = pdt->opValue & 0xffff;
                        sprintf_f(rs->logs, "%d. %x (%.4d, %.4d) / 2 = (%.4d, %.4d)\n", id, pdt->opStatus, coord[0], coord[1], (coord[0] / 2), (coord[1] / 2));
                        print_f(rs->plogs, "CROP", rs->logs);  
                    }
                }

                sprintf_f(rs->logs, "op_76, update CROP coordinates DONE!!\n"); 
                print_f(rs->plogs, "CROP", rs->logs);  
                data->result = emb_result(data->result, FWORD);
                //data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 

                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
                //sprintf_f(rs->logs, "op_76, send 0x%.2x, 0x%.2x\n", c->opcode, c->data); 
                //print_f(rs->plogs, "CROP", rs->logs);  
            }
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = 0;
                for (id=0; id < 7; id++) {
                    if ((!pdt) && (pct[ASPOP_CROP_01 + id].opStatus == ASPOP_STA_APP)) {
                        pdt = &pct[ASPOP_CROP_01 + id];
                    }

                    if (id < 4) {
                        pct[ASPOP_CROP_COOR_XH + id].opStatus = ASPOP_STA_WR;
                        pct[ASPOP_CROP_COOR_XH + id].opValue = 0;
                    }
                }

                //pdt->opValue = p->data;
                if (pdt) {
                    pdt->opStatus = ASPOP_STA_WR;
                    data->result = emb_result(data->result, NEXT);
                } else {
                    data->result = emb_result(data->result, FWORD);
                    //data->result = emb_result(data->result, EVTMAX);                
                    sprintf_f(rs->logs, "op_76, can't find target table \n"); 
                    print_f(rs->plogs, "CROP", rs->logs);  
                }

            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stcrop_77(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_77 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "CROP", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_CROP_COOR_XH];
            if (pdt->opCode != OP_STLEN_00) {
                sprintf_f(rs->logs, "op77, ASPOP_CROP_COOR_XH opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "CROP", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op77, ASPOP_CROP_COOR_XH status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "CROP", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_CROP_COOR_XH];
                pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stcrop_78(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_78 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "CROP", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_CROP_COOR_XL];
            if (pdt->opCode != OP_STLEN_01) {
                sprintf_f(rs->logs, "op78, ASPOP_CROP_COOR_XL opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "CROP", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op78, ASPOP_CROP_COOR_XL status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "CROP", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_CROP_COOR_XL];
                pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stcrop_79(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_79 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "CROP", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_CROP_COOR_YH];
            if (pdt->opCode != OP_STLEN_02) {
                sprintf_f(rs->logs, "op79, ASPOP_CROP_COOR_YH opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "CROP", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op79, ASPOP_CROP_COOR_YH status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "CROP", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_CROP_COOR_YH];
                pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stcrop_80(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_80 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "CROP", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_CROP_COOR_YL];
            if (pdt->opCode != OP_STLEN_03) {
                sprintf_f(rs->logs, "op80, ASPOP_CROP_COOR_YL opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "CROP", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op80, ASPOP_CROP_COOR_YL status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "CROP", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                c->opcode = pdt->opCode;
                c->data = pdt->opValue;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_CROP_COOR_YL];
                pdt->opStatus = ASPOP_STA_UPD;
                pdt->opValue = p->data;
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stvector_81(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;

    rs = data->rs;
    rlt = abs_result(data->result); 
    
    sprintf_f(rs->logs, "op_81 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "VECTOR", rs->logs);  

    switch (rlt) {
        case STINIT:

            ch = 105; 

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_81: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "VECTOR", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stvector_82(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct info16Bit_s *p=0, *c=0;
    struct procRes_s *rs;
    struct aspConfig_s *pct=0, *pdt=0;

    pct = data->rs->pcfgTable;
    rs = data->rs;
    rlt = abs_result(data->result); 
    
    p = &rs->pmch->get;
    c = &rs->pmch->cur;

    sprintf_f(rs->logs, "op_82 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "VECTOR", rs->logs);  

    switch (rlt) {
        case STINIT:
            //pct[ASPOP_IMG_LEN].opValue = 0;
            //pct[ASPOP_IMG_LEN].opStatus = ASPOP_STA_APP;

            sprintf_f(rs->logs, "op_82, reset value"); 
            print_f(rs->plogs, "VECTOR", rs->logs);  
            data->result = emb_result(data->result, NEXT);
        
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stapm_83(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct aspConfig_s *pct=0, *pdt=0;

    pct = data->rs->pcfgTable;
    rs = data->rs;
    rlt = abs_result(data->result); 
    
    sprintf_f(rs->logs, "op_83 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "APM", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_AP_MODE];
            if (pdt->opCode != OP_AP_MODEN) {
                sprintf_f(rs->logs, "op83, OP_AP_MODEN opcode is wrong val:%x\n", pdt->opCode); 
                print_f(rs->plogs, "APM", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (!(pdt->opStatus & ASPOP_STA_APP)) {
                sprintf_f(rs->logs, "op83, OP_AP_MODEN status is wrong val:%x\n", pdt->opStatus); 
                print_f(rs->plogs, "APM", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                switch(pdt->opValue) {
                    case APM_DIRECT:

                        ch = 106; 
                        
                        rs_ipc_put(data->rs, &ch, 1);
                        data->result = emb_result(data->result, WAIT);
                        sprintf_f(rs->logs, "op_83: result: %x, goto %d\n", data->result, ch); 
                        print_f(rs->plogs, "APM", rs->logs);  
                        
                        data->bkofw = emb_fw(data->bkofw, VECTORS, PSRLT);
                        
                        //pdt->opValue = APM_AP; /* for debug */
                        break;
                    case APM_AP:

                        ch = 106; 
                        
                        rs_ipc_put(data->rs, &ch, 1);
                        data->result = emb_result(data->result, WAIT);
                        sprintf_f(rs->logs, "op_83: result: %x, goto %d\n", data->result, ch); 
                        print_f(rs->plogs, "APM", rs->logs);  

                        data->bkofw = emb_fw(data->bkofw, VECTORS, PSTSM);
                        
                        //pdt->opValue = APM_DIRECT; /* for debug */
                        break;
                    default:
                        sprintf_f(rs->logs, "WARNING!!! op83, opValue is unexpected val:%x\n", pdt->opValue);
                        print_f(rs->plogs, "APM", rs->logs);  
                        data->result = emb_result(data->result, EVTMAX);
                        break;
                }
            }        
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, FWORD);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stapm_84(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;

    rs = data->rs;
    rlt = abs_result(data->result); 
    
    sprintf_f(rs->logs, "op_84 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "APM", rs->logs);  

    switch (rlt) {
        case STINIT:

            ch = 107; 

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_84: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "APM", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stapm_85(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;

    rs = data->rs;
    rlt = abs_result(data->result); 
    
    sprintf_f(rs->logs, "op_85 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "APM", rs->logs);  

    switch (rlt) {
        case STINIT:

            ch = 108; 

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_85: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "APM", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsparam_86(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;

    rs = data->rs;
    rlt = abs_result(data->result); 
    
    sprintf_f(rs->logs, "op_86 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "SPM", rs->logs);  

    switch (rlt) {
        case STINIT:

            ch = 109; 

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_86: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "SPM", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsparam_87(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct info16Bit_s *p=0, *c=0, *t=0;
    struct procRes_s *rs;


    rs = data->rs;
    rlt = abs_result(data->result); 
    
    p = &rs->pmch->get;
    c = &rs->pmch->cur;
    t = &rs->pmch->tmp;
    
    //sprintf_f(rs->logs, "op_87 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "META", rs->logs);  

    switch (rlt) {
        case STINIT:
            if (t->opcode == OP_META_DAT) {
                c->opcode = OP_META_DAT;
                c->data = t->data;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 

                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
                sprintf_f(rs->logs, "op_87: result: %x, goto %d\n", data->result, ch); 
                print_f(rs->plogs, "META", rs->logs);  
            } else {
                sprintf_f(rs->logs, "op_87 error!! tmp opcode: %x break!!\n", t->opcode); 
                print_f(rs->plogs, "META", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);                
            }
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                if (p->data == c->data) {
                    data->result = emb_result(data->result, NEXT);
                } else {
                    data->result = emb_result(data->result, EVTMAX);    
                }
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stsparam_88(struct psdata_s *data)
{ 
    int act=0;
    char ch = 0; 
    uint32_t rlt, chk=0;
    struct procRes_s *rs;
    struct aspMetaData_s *pmetaIn, *pmetaOut;
    struct aspMetaMass_s *pmass;
    struct aspConfig_s *pct=0;
#if SAVE_CROP_MASS
    int ret=0;
    struct aspConfig_s *pdt=0;
    
    FILE *f=0;
    char supPath[128] = "/mnt/mmc2/crop/g%d_s%d_c%d_%.4d%.2d%.2d-%.2d%.2d%.2d.bin";
    char tail[32] = "_%d.bin\0";
    char supPathCp1[512];
    char supDst[128];
    int slen=0, dlen=0;
#endif
    uint32_t val = 0;
    struct info16Bit_s *p=0, *c=0, *t=0;
    
    pct = data->rs->pcfgTable;
    rs = data->rs;
    rlt = abs_result(data->result); 
    pmetaIn = rs->pmetain;
    pmetaOut= rs->pmetaout;
    pmass = rs->pmetaMass;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;
    t = &rs->pmch->tmp;
    //sprintf_f(rs->logs, "op_88 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SPM", rs->logs);  

    switch (rlt) {
        case STINIT:
            aspMetaClear(0, rs, ASPMETA_INPUT);
            
            sprintf_f(rs->logs, "dump meta output\n"); 
            print_f(rs->plogs, "SPM", rs->logs);  
            //shmem_dump((char *)rs->pmetaout, sizeof(struct aspMetaData_s));            
            //dbgMeta(msb2lsb32(&pmetaOut->FUNC_BITS), pmetaOut);
            
            ch = 110; 

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_88: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "SPM", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                msync(pmass, sizeof(struct aspMetaMass_s), MS_SYNC);
                
                sprintf_f(rs->logs, "op_88: dump meta input (used:%d recd:%d) (op:0x%.2x, dt:0x%.2x)\n", pmass->massUsed, pmass->massRecd, t->opcode, t->data); 
                print_f(rs->plogs, "SPM", rs->logs);  

                if (t->opcode != OP_META_DAT) {
                    data->ansp0 = 0xed;
                    data->result = emb_result(data->result, EVTMAX);
                } else if (pmass->massRecd > 1) {
                    sprintf_f(rs->logs, "dump meta mass: (gap:%d, linStart:%d, linRecd:%d)\n", pmass->massGap, pmass->massStart, pmass->massRecd); 
                    print_f(rs->plogs, "SPM", rs->logs);  
#if SAVE_CROP_MASS
                    char syscmd[128] = "mkdir -p /mnt/mmc2/crop";
                    char *wday[]={"Sun","Mon","Tue","Wed","Thu","Fri","Sat"}; 
                    struct tm *p; 
                    time_t timep;
    
                    time(&timep);
                    p=localtime(&timep);
                    //sprintf_f(rs->logs, "%.4d%.2d%.2d \n", (1900+p->tm_year),( 1+p-> tm_mon), p->tm_mday); 
                    //print_f(rs->plogs, "SPM", rs->logs);
                    //sprintf_f(rs->logs, "%s,%.2d:%.2d:%.2d\n", wday[p->tm_wday],p->tm_hour, p->tm_min, p->tm_sec); 
                    //print_f(rs->plogs, "SPM", rs->logs);       

                    pdt = &pct[ASPOP_CROP_01];
                    sprintf(supPathCp1, supPath, pmass->massGap, pmass->massStart, pmass->massRecd, (1900+p->tm_year),( 1+p-> tm_mon), p->tm_mday,  p->tm_hour, p->tm_min, p->tm_sec);
/*
                    dlen = strlen(supPathCp1) - 1;
                    slen = strlen(tail);
                    memcpy(&supPathCp1[dlen], tail, slen);
*/
                    //supPathCp1[dlen+slen] = '\0';

                    sprintf_f(rs->logs, "plan to save crop mass to [%s] size: %d\n", supPathCp1, pmass->massUsed);
                    print_f(rs->plogs, "SPM", rs->logs);  
                    
                    f = find_save(supDst, supPathCp1);
                    if (f) {
                        fwrite((char *)pmass->masspt, 1, pmass->massUsed, f);
                        sprintf_f(rs->logs, "save crop mass to [%s] size: %d\n", supDst, pmass->massUsed);
                        print_f(rs->plogs, "SPM", rs->logs);  

                        fflush(f);
                        fclose(f);

                        sync();
                    } else {
                        ret = doSystemCmd(syscmd);

                        f = find_save(supDst, supPathCp1);
                        if (f) {
                            fwrite((char *)pmass->masspt, 1, pmass->massUsed, f);
                            sprintf_f(rs->logs, "save crop mass to [%s] size: %d\n", supDst, pmass->massUsed);
                            print_f(rs->plogs, "SPM", rs->logs);  

                            fflush(f);
                            fclose(f);

                            sync();
                        } else {
                            sprintf_f(rs->logs, "Error!!! failed to save crop mass to [%s] size: %d\n", supPathCp1, pmass->massUsed);
                            print_f(rs->plogs, "SPM", rs->logs);  
                        }
                    }
#endif
                    //mem_dump((char *)pmass->masspt, pmass->massUsed);
                    
                    //data->result = emb_result(data->result, FWORD);                
                    data->result = emb_result(data->result, NEXT);                
                    //pmass->massRecd = 0;
                    //pmass->massUsed = 0;
                }
                else {
                    //shmem_dump((char *)rs->pmetain, sizeof(struct aspMetaData_s));
                    dbgMeta(msb2lsb32(&pmetaIn->FUNC_BITS), pmetaIn);
                    act = aspMetaRelease(msb2lsb32(&pmetaIn->FUNC_BITS), 0, rs);

                    switch(t->data) {
                        case ASPMETA_POWON_INIT:
                            data->result = emb_result(data->result, FWORD);
                            break;
                        case ASPMETA_SCAN_GO:
                            data->ansp0 = 0xed;
                            data->result = emb_result(data->result, EVTMAX);
                            break;
                        case ASPMETA_SCAN_COMPLETE:
                        case ASPMETA_CROP_300DPI:
                        case ASPMETA_CROP_600DPI:
                            if (act < 0) {
                                //cfgTableSet(pct, ASPOP_IMG_LEN, 0);
                                
                                sprintf_f(rs->logs, "ERROR!!! wrong meta data, break!!\n"); 
                                print_f(rs->plogs, "SPM", rs->logs);  

                                data->result = emb_result(data->result, NEXT);                            

                                shmem_dump((char *)rs->pmetain, sizeof(struct aspMetaData_s));
                            }
                            else if (act & ASPMETA_FUNC_CROP) {
                                cfgTableGet(pct, ASPOP_XCROP_LINREC, &val);

                                sprintf_f(rs->logs, "Yline_recorder: %d!!\n", val); 
                                print_f(rs->plogs, "SPM", rs->logs);  

                                if (val > 1) {
                                    data->bkofw = emb_bk(data->bkofw, METAT, PSSET);
                                    data->result = emb_result(data->result, BKWRD);

                                    sprintf_f(rs->logs, "act:0x%x, metamass gap:%d, start:%d, record:%d\n", act, pmass->massGap, pmass->massStart, pmass->massRecd); 
                                    print_f(rs->plogs, "SPM", rs->logs);  
                                } else {
                                    sprintf_f(rs->logs, "record line > 1 go next \n"); 
                                    print_f(rs->plogs, "SPM", rs->logs);  

                                    data->result = emb_result(data->result, NEXT);
                                }
                            } else {
                                //data->result = emb_result(data->result, NEXT);
                                data->result = emb_result(data->result, FWORD);
                            }
                            break;
                        case ASPMETA_SD:
                            data->result = emb_result(data->result, FWORD);
                            break;
                        case ASPMETA_OCR:
                            data->result = emb_result(data->result, FWORD);
                            break;
                        case ASPMETA_SCAN_COMPLE_DUO:
                        case ASPMETA_CROP_300DPI_DUO:
                        case ASPMETA_CROP_600DPI_DUO:
                        default:
                            data->ansp0 = 0xed;
                            data->result = emb_result(data->result, EVTMAX);
                            break;
                    }
                }

            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stcropmeta_89(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct aspMetaData_s * pmeta;
    struct info16Bit_s *p=0, *c=0, *t=0;

    rs = data->rs;
    rlt = abs_result(data->result); 
    pmeta = rs->pmetaout;
    t = &rs->pmch->tmp;
    sprintf_f(rs->logs, "op_89 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "CPM", rs->logs);  

    switch (rlt) {
        case STINIT:
            t->opcode = OP_META_DAT;
            t->data = ASPMETA_SCAN_COMPLETE;
            aspMetaClear(0, rs, ASPMETA_OUTPUT);
            //aspMetaBuild(ASPMETA_FUNC_CONF, 0, rs);
            //dbgMeta(pmeta->FUNC_BITS, pmeta);

            data->result = emb_result(data->result, NEXT);
            sprintf_f(rs->logs, "op_89: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "CPM", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stcropmeta_90(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct aspMetaData_s * pmeta;
    struct info16Bit_s *p=0, *c=0, *t=0;

    rs = data->rs;
    rlt = abs_result(data->result); 
    pmeta = rs->pmetaout;
    t = &rs->pmch->tmp;
    sprintf_f(rs->logs, "op_90 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "CPM", rs->logs);  

    switch (rlt) {
        case STINIT:
            t->opcode = OP_META_DAT;
            t->data = ASPMETA_POWON_INIT;
            aspMetaClear(0, rs, ASPMETA_OUTPUT);
            aspMetaBuild(ASPMETA_FUNC_CONF, 0, rs);
            dbgMeta(msb2lsb32(&pmeta->FUNC_BITS), pmeta);

            data->result = emb_result(data->result, NEXT);
            sprintf_f(rs->logs, "op_90: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "CPM", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stcropmeta_91(struct psdata_s *data)
{ 
    int ret=0;
    char ch = 0; 
    uint32_t rlt=0;
    uint32_t rval=0;
    struct procRes_s *rs;
    struct aspMetaData_s * pmeta;
    struct info16Bit_s *p=0, *c=0, *t=0;
    struct aspConfig_s *pct=0, *pdt=0;

    pct = data->rs->pcfgTable;
    rs = data->rs;
    rlt = abs_result(data->result); 
    pmeta = rs->pmetaout;
    t = &rs->pmch->tmp;
    sprintf_f(rs->logs, "op_91 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "CPM", rs->logs);  

    switch (rlt) {
        case STINIT:
            t->opcode = OP_META_DAT;
            ret = cfgTableGet(pct, ASPOP_RESOLUTION, &rval);
            if (ret < 0) {
                data->result = emb_result(data->result, EVTMAX);
                sprintf_f(rs->logs, "Error!!! op_91 get ASPOP_RESOLUTION failed!!!ret = %d \n", ret); 
                print_f(rs->plogs, "CPM", rs->logs);  
            } else {
                switch (rval) {
                case RESOLUTION_1200:
                case RESOLUTION_600:
                    t->data = ASPMETA_CROP_600DPI;
                    data->result = emb_result(data->result, NEXT);
                    sprintf_f(rs->logs, "op_91: result: %x, goto %d\n", data->result, ch); 
                    print_f(rs->plogs, "CPM", rs->logs);  
                    rs->pmetaMass->massUsed = 0;
                    break;
                case RESOLUTION_300:
                case RESOLUTION_200:
                case RESOLUTION_150:
                    t->data = ASPMETA_CROP_300DPI;
                    data->result = emb_result(data->result, NEXT);
                    sprintf_f(rs->logs, "op_91: result: %x, goto %d\n", data->result, ch); 
                    print_f(rs->plogs, "CPM", rs->logs);  
                    rs->pmetaMass->massUsed = 0;
                    break;
                default:
                    data->result = emb_result(data->result, EVTMAX);
                    sprintf_f(rs->logs, "Error!!! op_91 get ASPOP_RESOLUTION failed!!!rval = %d \n", rval); 
                    print_f(rs->plogs, "CPM", rs->logs);  
                    break;
                }
            }
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stcropmeta_92(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct aspMetaData_s * pmeta;
    struct info16Bit_s *p=0, *c=0, *t=0;

    rs = data->rs;
    rlt = abs_result(data->result); 
    pmeta = rs->pmetaout;
    t = &rs->pmch->tmp;
    //sprintf_f(rs->logs, "op_92 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "CPM", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 112;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_92: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "CPM", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, FWORD);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stcropmeta_93(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct info16Bit_s *p=0, *c=0, *t=0;

    rs = data->rs;
    rlt = abs_result(data->result); 
        
    sprintf_f(rs->logs, "op_93 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "RAW", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 41; 

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_93: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "RAW", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                p = &rs->pmch->get;
                c = &rs->pmch->cur;

                if (p->data == c->data) {
                    data->result = emb_result(data->result, NEXT);
                } else {
                    data->result = emb_result(data->result, EVTMAX);    
                }
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stcropmeta_94(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;

    rs = data->rs;
    rlt = abs_result(data->result); 
        
    //sprintf_f(rs->logs, "op_94 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "RAW", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 114; 

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_94: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "RAW", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stmetaduo_95(struct psdata_s *data)
{ 
    int ret=0;
    char ch = 0; 
    uint32_t rlt=0;
    uint32_t rval=0;
    struct procRes_s *rs;
    struct aspMetaData_s * pmeta;
    struct info16Bit_s *p=0, *c=0, *t=0;
    struct aspConfig_s *pct=0, *pdt=0;

    pct = data->rs->pcfgTable;
    rs = data->rs;
    rlt = abs_result(data->result); 
    pmeta = rs->pmetaout;
    t = &rs->pmch->tmp;
    sprintf_f(rs->logs, "op_95: rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "MDUO", rs->logs);  

    switch (rlt) {
        case STINIT:
            t->opcode = OP_META_DAT;
            ret = cfgTableGet(pct, ASPOP_RESOLUTION, &rval);
            if (ret < 0) {
                data->result = emb_result(data->result, EVTMAX);
                sprintf_f(rs->logs, "op_95: Error!!! op_91 get ASPOP_RESOLUTION failed!!!ret = %d \n", ret); 
                print_f(rs->plogs, "MDUO", rs->logs);  
            } else {
                switch (rval) {
                case RESOLUTION_1200:
                case RESOLUTION_600:
                    t->data = ASPMETA_CROP_600DPI_DUO;
                    data->result = emb_result(data->result, NEXT);
                    sprintf_f(rs->logs, "op_95:: result: %x, goto %d\n", data->result, ch); 
                    print_f(rs->plogs, "MDUO", rs->logs);  
                    rs->pmetaMass->massUsed = 0;
                    break;
                case RESOLUTION_300:
                case RESOLUTION_200:
                case RESOLUTION_150:
                    t->data = ASPMETA_CROP_300DPI_DUO;
                    data->result = emb_result(data->result, NEXT);
                    sprintf_f(rs->logs, "op_95:: result: %x, goto %d\n", data->result, ch); 
                    print_f(rs->plogs, "MDUO", rs->logs);  
                    rs->pmetaMass->massUsed = 0;
                    break;
                default:
                    data->result = emb_result(data->result, EVTMAX);
                    sprintf_f(rs->logs, "op_95: Error!!! op_91 get ASPOP_RESOLUTION failed!!!rval = %d \n", rval); 
                    print_f(rs->plogs, "MDUO", rs->logs);  
                    break;
                }
            }
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stmetaduo_96(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct info16Bit_s *p=0, *c=0, *t=0;
    struct procRes_s *rs;


    rs = data->rs;
    rlt = abs_result(data->result); 
    
    p = &rs->pmch->get;
    c = &rs->pmch->cur;
    t = &rs->pmch->tmp;
    
    //sprintf_f(rs->logs, "op_95 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "MDUO", rs->logs);  

    switch (rlt) {
        case STINIT:
            if (t->opcode == OP_META_DAT) {
                c->opcode = OP_META_DAT;
                c->data = t->data;
                memset(p, 0, sizeof(struct info16Bit_s));

                ch = 41; 

                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
                sprintf_f(rs->logs, "op_96: result: %x, goto %d\n", data->result, ch); 
                print_f(rs->plogs, "MDUO", rs->logs);  
            } else {
                sprintf_f(rs->logs, "op_96: error!! tmp opcode: %x break!!\n", t->opcode); 
                print_f(rs->plogs, "MDUO", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);                
            }
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                if (p->data == c->data) {
                    data->result = emb_result(data->result, NEXT);
                } else {
                    data->result = emb_result(data->result, EVTMAX);    
                }
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stmetaduo_97(struct psdata_s *data)
{ 
    int act=0;
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct aspMetaData_s *pmetaIn, *pmetaOut;
    struct aspMetaData_s *pmetaInduo;
    struct aspMetaMass_s *pmass;
    struct aspMetaMass_s *pmassduo;
    struct aspConfig_s *pct=0;
#if SAVE_CROP_MASS
    int ret=0;
    struct aspConfig_s *pdt=0;

    FILE *f=0;
    char supPath[128] = "/mnt/mmc2/crop/g%d_s%d_c%d_%.4d%.2d%.2d-%.2d%.2d%.2d.bin";
    char tail[32] = "_%d.bin\0";
    char supPathCp1[512];
    char supDst[128];
    int slen=0, dlen=0;
#endif
    uint32_t val = 0;
    struct info16Bit_s *p=0, *c=0, *t=0;
    
    pct = data->rs->pcfgTable;
    rs = data->rs;
    rlt = abs_result(data->result); 
    pmetaIn = rs->pmetain;
    pmetaOut= rs->pmetaout;
    pmetaInduo= rs->pmetainduo;

    pmass = rs->pmetaMass;
    pmassduo = rs->pmetaMassduo;
    p = &rs->pmch->get;
    c = &rs->pmch->cur;
    t = &rs->pmch->tmp;

    //sprintf_f(rs->logs, "op_88 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "SPM", rs->logs);  

    switch (rlt) {
        case STINIT:
            aspMetaClear(0, rs, ASPMETA_INPUT);
            
            sprintf_f(rs->logs, "op_97: dump meta output\n"); 
            print_f(rs->plogs, "MDUO", rs->logs);  
            //shmem_dump((char *)rs->pmetaout, sizeof(struct aspMetaData_s));            
            dbgMeta(msb2lsb32(&pmetaOut->FUNC_BITS), pmetaOut);
            
            ch = 118; 

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_97: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "MDUO", rs->logs);  
            break;
        case WAIT:
        
            if (data->ansp0 == 1) {
                msync(pmass, sizeof(struct aspMetaMass_s), MS_SYNC);
                sprintf_f(rs->logs, "op_97: dump meta input (used:%d recd:%d)  (op:0x%.2x, dt:0x%.2x)\n", pmass->massUsed, pmass->massRecd, t->opcode, t->opcode); 
                print_f(rs->plogs, "MDUO", rs->logs);  
                
                if (t->opcode != OP_META_DAT) {
                    data->ansp0 = 0xed;
                    data->result = emb_result(data->result, EVTMAX);
                } else if (pmass->massRecd > 1) {
                    sprintf_f(rs->logs, "op_97: dump meta mass: (gap:%d, linStart:%d, linRecd:%d)\n", pmass->massGap, pmass->massStart, pmass->massRecd); 
                    print_f(rs->plogs, "MDUO", rs->logs);  
#if SAVE_CROP_MASS
                    char syscmd[128] = "mkdir -p /mnt/mmc2/crop";
                    char *wday[]={"Sun","Mon","Tue","Wed","Thu","Fri","Sat"}; 
                    struct tm *p; 
                    time_t timep;
    
                    time(&timep);
                    p=localtime(&timep);
                    //sprintf_f(rs->logs, "%.4d%.2d%.2d \n", (1900+p->tm_year),( 1+p-> tm_mon), p->tm_mday); 
                    //print_f(rs->plogs, "SPM", rs->logs);
                    //sprintf_f(rs->logs, "%s,%.2d:%.2d:%.2d\n", wday[p->tm_wday],p->tm_hour, p->tm_min, p->tm_sec); 
                    //print_f(rs->plogs, "SPM", rs->logs);       

                    pdt = &pct[ASPOP_CROP_01];
                    sprintf(supPathCp1, supPath, pmass->massGap, pmass->massStart, pmass->massRecd, (1900+p->tm_year),( 1+p-> tm_mon), p->tm_mday,  p->tm_hour, p->tm_min, p->tm_sec);
/*
                    dlen = strlen(supPathCp1) - 1;
                    slen = strlen(tail);
                    memcpy(&supPathCp1[dlen], tail, slen);
*/
                    //supPathCp1[dlen+slen] = '\0';

                    sprintf_f(rs->logs, "op_97: plan to save crop mass to [%s] size: %d\n", supPathCp1, pmass->massUsed);
                    print_f(rs->plogs, "MDUO", rs->logs);  
                    
                    f = find_save(supDst, supPathCp1);
                    if (f) {
                        fwrite((char *)pmass->masspt, 1, pmass->massUsed, f);
                        sprintf_f(rs->logs, "op_97: save crop mass to [%s] size: %d\n", supDst, pmass->massUsed);
                        print_f(rs->plogs, "MDUO", rs->logs);  

                        fflush(f);
                        fclose(f);

                        sync();
                    } else {
                        ret = doSystemCmd(syscmd);

                        f = find_save(supDst, supPathCp1);
                        if (f) {
                            fwrite((char *)pmass->masspt, 1, pmass->massUsed, f);
                            sprintf_f(rs->logs, "op_97: save crop mass to [%s] size: %d\n", supDst, pmass->massUsed);
                            print_f(rs->plogs, "MDUO", rs->logs);  

                            fflush(f);
                            fclose(f);

                            sync();
                        } else {
                            sprintf_f(rs->logs, "op_97: Error!!! failed to save crop mass to [%s] size: %d\n", supPathCp1, pmass->massUsed);
                            print_f(rs->plogs, "MDUO", rs->logs);  
                        }
                    }
                    
#endif
                    //mem_dump((char *)pmass->masspt, pmass->massUsed);
                    

                    //data->result = emb_result(data->result, FWORD);                
                    data->result = emb_result(data->result, NEXT);                
                    //pmass->massRecd = 0;
                    //pmass->massUsed = 0;
                } else {
                    //shmem_dump((char *)rs->pmetain, sizeof(struct aspMetaData_s));
                    dbgMeta(msb2lsb32(&pmetaIn->FUNC_BITS), pmetaIn);
                    dbgMeta(msb2lsb32(&pmetaInduo->FUNC_BITS), pmetaInduo);
                    act = aspMetaRelease(msb2lsb32(&pmetaIn->FUNC_BITS), 0, rs);
                    aspMetaReleaseDuo(msb2lsb32(&pmetaInduo->FUNC_BITS), 0, rs);

                    switch(t->data) {
                        case ASPMETA_POWON_INIT:
                            data->result = emb_result(data->result, FWORD);
                            break;
                        case ASPMETA_SCAN_GO:
                            data->ansp0 = 0xed;
                            data->result = emb_result(data->result, EVTMAX);
                            break;
                        case ASPMETA_SD:
                            data->result = emb_result(data->result, FWORD);
                            break;
                        case ASPMETA_OCR:
                            data->result = emb_result(data->result, FWORD);
                            break;
                        case ASPMETA_SCAN_COMPLE_DUO:
                        case ASPMETA_CROP_300DPI_DUO:
                        case ASPMETA_CROP_600DPI_DUO:
                            if (act < 0) {
                                //cfgTableSet(pct, ASPOP_IMG_LEN, 0);
                                
                                sprintf_f(rs->logs, "ERROR!!! wrong meta data, break!!\n"); 
                                print_f(rs->plogs, "MDUO", rs->logs);  

                                data->result = emb_result(data->result, NEXT);

                                shmem_dump((char *)rs->pmetain, sizeof(struct aspMetaData_s));
                            }
                            else if (act & ASPMETA_FUNC_CROP) {
                                cfgTableGet(pct, ASPOP_XCROP_LINREC, &val);

                                if (val > 1) {
                                    data->bkofw = emb_bk(data->bkofw, METAT, PSTSM);
                                    data->result = emb_result(data->result, BKWRD);

                                    sprintf_f(rs->logs, "op_97: act:0x%x, metamass gap:%d, start:%d, record:%d\n", act, pmass->massGap, pmass->massStart, pmass->massRecd); 
                                    print_f(rs->plogs, "MDUO", rs->logs);  

                                    sprintf_f(rs->logs, "op_97: act:0x%x, metamass gap:%d, start:%d, record:%d (duo)\n", act, pmassduo->massGap, pmassduo->massStart, pmassduo->massRecd); 
                                    print_f(rs->plogs, "MDUO", rs->logs);  
                                } else {
                                    data->result = emb_result(data->result, NEXT);
                                    sprintf_f(rs->logs, "record line > 1, go next \n"); 
                                    print_f(rs->plogs, "MDUO", rs->logs);  
                                }
                            } else {
                                //data->result = emb_result(data->result, NEXT);
                                data->result = emb_result(data->result, FWORD);
                            }
                            break;
                        case ASPMETA_SCAN_COMPLETE:
                        case ASPMETA_CROP_300DPI:
                        case ASPMETA_CROP_600DPI:
                        default:
                            data->ansp0 = 0xed;
                            data->result = emb_result(data->result, EVTMAX);
                            break;
                    }
                }

            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stmetaduo_98(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct aspMetaData_s * pmeta;
    struct info16Bit_s *p=0, *c=0, *t=0;

    rs = data->rs;
    rlt = abs_result(data->result); 
    pmeta = rs->pmetaout;
    t = &rs->pmch->tmp;
    //sprintf_f(rs->logs, "op_98 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "MDUO", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 120;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_98: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "MDUO", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, FWORD);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stmetaduo_99(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct aspMetaData_s * pmeta;
    struct info16Bit_s *p=0, *c=0, *t=0;

    rs = data->rs;
    rlt = abs_result(data->result); 
    pmeta = rs->pmetaout;
    t = &rs->pmch->tmp;
    sprintf_f(rs->logs, "op_99 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "MDUO", rs->logs);  

    switch (rlt) {
        case STINIT:
            t->opcode = OP_META_DAT;
            t->data = ASPMETA_SCAN_COMPLE_DUO;
            aspMetaClear(0, rs, ASPMETA_OUTPUT);
            //aspMetaBuild(ASPMETA_FUNC_CONF, 0, rs);
            //dbgMeta(msb2lsb32(&pmeta->FUNC_BITS), pmeta);

            data->result = emb_result(data->result, NEXT);
            sprintf_f(rs->logs, "op_99: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "MDUO", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stmetasd_100(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct aspMetaData_s * pmeta;
    struct info16Bit_s *p=0, *c=0, *t=0;
    uint32_t secStr=0, secLen = 0;
    struct aspConfig_s *pct=0, *pdt=0;

    rs = data->rs;
    rlt = abs_result(data->result); 
    pmeta = rs->pmetaout;
    t = &rs->pmch->tmp;
    c = &rs->pmch->cur;
    p = &rs->pmch->get;
    pct = data->rs->pcfgTable;
    //sprintf_f(rs->logs, "op_100 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "MTSD", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDFAT_RD];
            if (pdt->opCode != OP_SDRD) {
                sprintf_f(rs->logs, "op_100, OP_SDRD opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "MTSD", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op_100, OP_SDRD status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "MTSD", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                secStr = c->opinfo;
                secLen = p->opinfo;

                c->opcode = OP_META_DAT;
                c->data = ASPMETA_SD;
                
                memset(p, 0, sizeof(struct info16Bit_s));

                sprintf_f(rs->logs, "op_100: set str:%d(0x%x), len:%d \n", secStr, secStr, secLen);
                print_f(rs->plogs, "MTSD", rs->logs);  

                aspMetaClear(0, rs, ASPMETA_OUTPUT);
                aspMetaBuild(ASPMETA_FUNC_SDRD, 0, rs);
                dbgMeta(msb2lsb32(&pmeta->FUNC_BITS), pmeta);
                
                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                data->result = emb_result(data->result, WAIT);
            }            
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stmetasd_101(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct aspMetaData_s * pmeta;
    struct info16Bit_s *p=0, *c=0, *t=0;
    uint32_t secStr=0, secLen = 0;
    struct aspConfig_s *pct=0, *pdt=0;
    
    rs = data->rs;
    rlt = abs_result(data->result); 
    pmeta = rs->pmetaout;
    t = &rs->pmch->tmp;
    c = &rs->pmch->cur;
    p = &rs->pmch->get;
    pct = data->rs->pcfgTable;
    
    //sprintf_f(rs->logs, "op_101 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "MTSD", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SDFAT_WT];
            if (pdt->opCode != OP_SDWT) {
                sprintf_f(rs->logs, "op_101, OP_SDWT opcode is wrong op:%x\n", pdt->opCode); 
                print_f(rs->plogs, "MTSD", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (pdt->opStatus != ASPOP_STA_WR) {
                sprintf_f(rs->logs, "op_101, OP_SDWT status is wrong, %x\n", pdt->opStatus); 
                print_f(rs->plogs, "MTSD", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                secStr = c->opinfo;
                secLen = p->opinfo;
                
                c->opcode = OP_META_DAT;
                c->data = ASPMETA_SD;
                
                memset(p, 0, sizeof(struct info16Bit_s));

                sprintf_f(rs->logs, "op_101: set str:%d(0x%x), len:%d \n", secStr, secStr, secLen);
                print_f(rs->plogs, "MTSD", rs->logs);  

                aspMetaClear(0, rs, ASPMETA_OUTPUT);
                aspMetaBuild(ASPMETA_FUNC_SDWT, 0, rs);
                dbgMeta(msb2lsb32(&pmeta->FUNC_BITS), pmeta);

                ch = 41; 
                rs_ipc_put(data->rs, &ch, 1);
                
                data->result = emb_result(data->result, WAIT);
                sprintf_f(rs->logs, "op_101: result: %x, goto %d\n", data->result, ch); 
                print_f(rs->plogs, "MTSD", rs->logs);  
            }     
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stmetasd_102(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct aspMetaData_s * pmeta;
    struct info16Bit_s *p=0, *c=0, *t=0;
    struct aspMetaData_s *pmetaIn, *pmetaOut;
    struct aspMetaMass_s *pmass;

    rs = data->rs;
    rlt = abs_result(data->result); 
    pmeta = rs->pmetaout;
    t = &rs->pmch->tmp;
    pmetaIn = rs->pmetain;
    pmetaOut= rs->pmetaout;
    pmass = rs->pmetaMass;
    //sprintf_f(rs->logs, "op_102 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "MTSD", rs->logs);  

    switch (rlt) {
        case STINIT:
            aspMetaClear(0, rs, ASPMETA_INPUT);
            
            sprintf_f(rs->logs, "op_102: dump meta output\n"); 
            print_f(rs->plogs, "MTSD", rs->logs);  
            //shmem_dump((char *)rs->pmetaout, sizeof(struct aspMetaData_s));            
            dbgMeta(msb2lsb32(&pmetaOut->FUNC_BITS), pmetaOut);
            
            ch = 110; 

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_102: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "MTSD", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                msync(pmass, sizeof(struct aspMetaMass_s), MS_SYNC);
                sprintf_f(rs->logs, "op_102: meta input (used:%d) \n", pmass->massUsed); 
                print_f(rs->plogs, "MTSD", rs->logs);  
                data->result = emb_result(data->result, NEXT);
            }
            else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            }
            else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stmetasd_103(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct aspMetaData_s * pmeta;
    struct info16Bit_s *p=0, *c=0, *t=0;

    rs = data->rs;
    rlt = abs_result(data->result); 
    pmeta = rs->pmetaout;
    t = &rs->pmch->tmp;
    sprintf_f(rs->logs, "op_103 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "GOSD", rs->logs);  

    switch (rlt) {
        case STINIT:
            t->opcode = OP_META_DAT;
            t->data = ASPMETA_CROP_300DPI;
            aspMetaClear(0, rs, ASPMETA_OUTPUT);
            aspMetaBuild(ASPMETA_FUNC_CONF, 0, rs);
            dbgMeta(msb2lsb32(&pmeta->FUNC_BITS), pmeta);

            data->result = emb_result(data->result, NEXT);
            sprintf_f(rs->logs, "op_103: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "GOSD", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stmetasd_104(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct info16Bit_s *p=0, *c=0, *t=0;

    rs = data->rs;
    rlt = abs_result(data->result); 
    //sprintf_f(rs->logs, "op_104 rlt:0x%x \n", rlt); 
    //sprint_f(rs->plogs, "UPSD", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 125;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_104: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "UPSD", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stmetasd_105(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    
    rs = data->rs;
    rlt = abs_result(data->result); 

    //sprintf_f(rs->logs, "op_105 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "OCR", rs->logs);  

    switch (rlt) {
        case STINIT:
        
#if CHECK_SOCKET_STATUS
            ch = 25; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
#else
            data->ansp0 = 1;
            data->result = emb_result(data->result, NEXT);
#endif

            //sprintf_f(rs->logs, "op_105: result: %x, goto %d\n", data->result, ch); 
            //print_f(rs->plogs, "OCR", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stocrw_106(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct info16Bit_s *p=0, *c=0, *t=0;
    struct aspConfig_s *pct=0, *pdt=0;
    
    rs = data->rs;
    rlt = abs_result(data->result); 
    c = &rs->pmch->cur;
    p = &rs->pmch->get;
    pct = data->rs->pcfgTable;
    
    //sprintf_f(rs->logs, "op106 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "OCR", rs->logs);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SCAN_SINGLE];
            if (pdt->opCode != OP_NOTESCAN) {
                sprintf_f(rs->logs, "op106, OP_NOTESCAN opcode is wrong val:%x\n", pdt->opCode); 
                print_f(rs->plogs, "OCR", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (!(pdt->opStatus & ASPOP_STA_WR)) {
                sprintf_f(rs->logs, "op106, OP_NOTESCAN status is wrong val:%x\n", pdt->opStatus); 
                print_f(rs->plogs, "OCR", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else {
                switch(pdt->opValue) {
                    case NOTESCAN_OPTION_01:
                    case NOTESCAN_OPTION_02:
                    case NOTESCAN_OPTION_03:
                    case NOTESCAN_OPTION_04:
                    case NOTESCAN_OPTION_05:
                    case NOTESCAN_OPTION_06:
                    case NOTESCAN_OPTION_07:

                        ch = 41; 
                        
                        c->opcode = pdt->opCode;
                        c->data = pdt->opValue;
                        memset(p, 0, sizeof(struct info16Bit_s));

                        rs_ipc_put(data->rs, &ch, 1);
                        data->result = emb_result(data->result, WAIT);
                        //sprintf_f(rs->logs, "op106: result: %x, goto %d\n", data->result, ch); 
                        //print_f(rs->plogs, "OCR", rs->logs);  
                        break;
                    default:
                        sprintf_f(rs->logs, "ERROR!!! op106, opValue is unexpected val:%x\n", pdt->opValue);
                        print_f(rs->plogs, "OCR", rs->logs);  
                        data->result = emb_result(data->result, EVTMAX);
                        break;
                }
            }
                           
            //aspMetaClear(0, rs, ASPMETA_OUTPUT);
            //aspMetaBuild(ASPMETA_FUNC_SDWT, 0, rs);
            //dbgMeta(msb2lsb32(&pmeta->FUNC_BITS), pmeta);
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stocrw_107(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct info16Bit_s *p=0, *c=0, *t=0;

    rs = data->rs;
    rlt = abs_result(data->result); 
    //sprintf_f(rs->logs, "op_107 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "OCR", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 67;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(rs->logs, "op_107: result: %x, goto %d\n", data->result, ch); 
            //print_f(rs->plogs, "OCR", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stocrw_108(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct info16Bit_s *p=0, *c=0, *t=0;

    rs = data->rs;
    rlt = abs_result(data->result); 
    c = &rs->pmch->cur;
    p = &rs->pmch->get;
    
    //sprintf_f(rs->logs, "op_108 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "OCR", rs->logs);  

    switch (rlt) {
        case STINIT:

            //c->opcode = OP_META_DAT;
            //c->data = ASPMETA_SD;
            
            c->opcode = OP_META_DAT;
            c->data = ASPMETA_SCAN_COMPLETE;
                
            memset(p, 0, sizeof(struct info16Bit_s));

            //aspMetaClear(0, rs, ASPMETA_OUTPUT);
            //aspMetaBuild(ASPMETA_FUNC_SDWT, 0, rs);
            //dbgMeta(msb2lsb32(&pmeta->FUNC_BITS), pmeta);

            ch = 41; 
            rs_ipc_put(data->rs, &ch, 1);                

            data->result = emb_result(data->result, WAIT);
            //sprintf_f(rs->logs, "op_108: result: %x, goto %d\n", data->result, ch); 
            //print_f(rs->plogs, "OCR", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stocrw_109(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct info16Bit_s *p=0, *c=0, *t=0;

    rs = data->rs;
    rlt = abs_result(data->result); 
    //sprintf_f(rs->logs, "op_109 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "OCR", rs->logs);  

    switch (rlt) {
        case STINIT:
            aspMetaClear(0, rs, ASPMETA_INPUT);
            
            ch = 110;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(rs->logs, "op_109: result: %x, goto %d\n", data->result, ch); 
            //print_f(rs->plogs, "OCR", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stocrw_110(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    int act = 0;
    struct procRes_s *rs;
    struct info16Bit_s *p=0, *c=0, *t=0;
    struct aspMetaData_s *pmetaIn;
    
    rs = data->rs;
    rlt = abs_result(data->result); 
    pmetaIn = rs->pmetain;
    c = &rs->pmch->cur;
    p = &rs->pmch->get;

    //sprintf_f(rs->logs, "op_110 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "OCR", rs->logs);  

    switch (rlt) {
        case STINIT:
            dbgMeta(msb2lsb32(&pmetaIn->FUNC_BITS), pmetaIn);
            act = aspMetaRelease(msb2lsb32(&pmetaIn->FUNC_BITS), 0, rs);

            //sprintf_f(rs->logs, "op_110 act: 0x%x \n", act); 
            //print_f(rs->plogs, "OCR", rs->logs);  
            
            c->opcode = OP_META_DAT;
            
#if 0  /* for test */
            c->data = ASPMETA_CROP_300DPI;
#else
            c->data = ASPMETA_OCR;
#endif
                
            memset(p, 0, sizeof(struct info16Bit_s));

            //aspMetaClear(0, rs, ASPMETA_OUTPUT);
            //aspMetaBuild(ASPMETA_FUNC_SDWT, 0, rs);
            //dbgMeta(msb2lsb32(&pmeta->FUNC_BITS), pmeta);

            ch = 41; 

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_110: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "OCR", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stocrx_111(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;

    rs = data->rs;
    rlt = abs_result(data->result); 
    //sprintf_f(rs->logs, "op_111 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "OCR", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 48;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(rs->logs, "op_111: result: %x, goto %d\n", data->result, ch); 
            //print_f(rs->plogs, "OCR", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stfmtx_112(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct sdFAT_s *pFat=0;
    struct sdFatFormat_s     *pfformat=0;
    
    pFat = data->rs->psFat;
    pfformat = &pFat->fatFormat;
    rs = data->rs;
    rlt = abs_result(data->result); 
    sprintf_f(rs->logs, "op_112 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "FMT", rs->logs);  

    switch (rlt) {
        case STINIT:

            /* 32G */
            pfformat->fmtTotSector = 62325760;
            pfformat->fmtHidnSector = 2048;
            pfformat->fmtSectorPerCls = 128;
            
            ch = 126;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            
            sprintf_f(rs->logs, "op_112: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "FMT", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stfmtx_113(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct sdFAT_s *pFat=0;
    struct sdFatFormat_s     *pfformat=0;
    
    pFat = data->rs->psFat;
    pfformat = &pFat->fatFormat;
    rs = data->rs;
    rlt = abs_result(data->result); 
    sprintf_f(rs->logs, "op_113 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "FMT", rs->logs);  

    switch (rlt) {
        case STINIT:

            /* 16G */
            pfformat->fmtTotSector = 30881792;
            pfformat->fmtHidnSector = 2048;
            pfformat->fmtSectorPerCls = 128;
            
            ch = 126;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            
            sprintf_f(rs->logs, "op_113: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "FMT", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stfmtx_114(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct sdFAT_s *pFat=0;
    struct sdFatFormat_s     *pfformat=0;
    
    pFat = data->rs->psFat;
    pfformat = &pFat->fatFormat;
    rs = data->rs;
    rlt = abs_result(data->result); 
    sprintf_f(rs->logs, "op_114 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "FMT", rs->logs);  

    switch (rlt) {
        case STINIT:

            /* 64G */
            pfformat->fmtTotSector = 125925376;
            pfformat->fmtHidnSector = 2048;
            pfformat->fmtSectorPerCls = 128;
            
            ch = 126;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            
            sprintf_f(rs->logs, "op_114: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "FMT", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stfmtx_115(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct sdFAT_s *pFat=0;
    struct sdFatFormat_s     *pfformat=0;
    
    pFat = data->rs->psFat;
    pfformat = &pFat->fatFormat;
    rs = data->rs;
    rlt = abs_result(data->result); 
    sprintf_f(rs->logs, "op_115 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "FMT", rs->logs);  

    switch (rlt) {
        case STINIT:

            /* 128G */
            pfformat->fmtTotSector = 243220480;
            pfformat->fmtHidnSector = 2048;
            pfformat->fmtSectorPerCls = 128;
            
            ch = 126;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            
            sprintf_f(rs->logs, "op_115: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "FMT", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stfmty_116(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;

    rs = data->rs;
    rlt = abs_result(data->result); 
    sprintf_f(rs->logs, "op_116 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "FMT", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 130;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_116: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "FMT", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stfmty_117(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;
    struct info16Bit_s *p=0, *g=0;
    
    rs = data->rs;
    rlt = abs_result(data->result); 
    p = &rs->pmch->poll;
    g = &rs->pmch->get;
    //sprintf_f(rs->logs, "op_117 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "POLL", rs->logs);  

    switch (rlt) {
        case STINIT:
            p->opcode = OP_POLL;      
            p->data = p->seqnum & 0xff;
            
            p->seqnum = p->seqnum + 1;    
            
            memset(g, 0, sizeof(struct info16Bit_s));

            ch = 131;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_117: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "POLL", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stcrtfdr_118(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;

    rs = data->rs;
    rlt = abs_result(data->result); 
    //sprintf_f(rs->logs, "op_118 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "CFD", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 139;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_118: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "CFD", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stusbscan_119(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;

    rs = data->rs;
    rlt = abs_result(data->result); 
    //sprintf_f(rs->logs, "op_119 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "USN", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 145;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(rs->logs, "op_119: result: %x, goto %d\n", data->result, ch); 
            //print_f(rs->plogs, "USN", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 3) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stusbscan_120(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;

    rs = data->rs;
    rlt = abs_result(data->result); 
    sprintf_f(rs->logs, "op_120 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "WUS", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 146;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_120: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "WUS", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stusbscan_121(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;

    rs = data->rs;
    rlt = abs_result(data->result); 
    sprintf_f(rs->logs, "op_121 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "WUS", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 147;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_121: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "WUS", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stusbscan_122(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;

    rs = data->rs;
    rlt = abs_result(data->result); 
    sprintf_f(rs->logs, "op_122 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "USN", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 148;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_122: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "USN", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stusbscan_123(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;

    rs = data->rs;
    rlt = abs_result(data->result); 
    sprintf_f(rs->logs, "op_123 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "USN", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 149;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_123: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "USN", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stusbscan_124(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;

    rs = data->rs;
    rlt = abs_result(data->result); 
    sprintf_f(rs->logs, "op_124 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "USN", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 150;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_124: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "USN", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stusbscan_125(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;

    rs = data->rs;
    rlt = abs_result(data->result); 
    sprintf_f(rs->logs, "op_125 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "USN", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 151;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_125: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "USN", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stusbbnote_126(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;

    rs = data->rs;
    rlt = abs_result(data->result); 
    //sprintf_f(rs->logs, "op_126 rlt:0x%x \n", rlt); 
    //print_f(rs->plogs, "BM4", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 152;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(rs->logs, "op_126: result: %x, goto %d\n", data->result, ch); 
            //print_f(rs->plogs, "BM4", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stusbbnote_127(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;

    rs = data->rs;
    rlt = abs_result(data->result); 
    sprintf_f(rs->logs, "op_127 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "BM4", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 00;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_127: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "BM4", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stusbbnote_128(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;

    rs = data->rs;
    rlt = abs_result(data->result); 
    sprintf_f(rs->logs, "op_128 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "BM4", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 00;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_128: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "BM4", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stusbbnote_129(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;

    rs = data->rs;
    rlt = abs_result(data->result); 
    sprintf_f(rs->logs, "op_129 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "BM4", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 00;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_129: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "BM4", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stusbbnote_130(struct psdata_s *data)
{ 
    char ch = 0; 
    uint32_t rlt;
    struct procRes_s *rs;

    rs = data->rs;
    rlt = abs_result(data->result); 
    sprintf_f(rs->logs, "op_130 rlt:0x%x \n", rlt); 
    print_f(rs->plogs, "BM4", rs->logs);  

    switch (rlt) {
        case STINIT:
            ch = 00;

            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            sprintf_f(rs->logs, "op_130: result: %x, goto %d\n", data->result, ch); 
            print_f(rs->plogs, "BM4", rs->logs);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}

static int stspy_01(struct psdata_s *data)
{ 
    // keep polling, kind of idle mode
    // jump to next status if receive any op code

    char str[128], ch = 0; 
    uint32_t rlt;
    rlt = abs_result(data->result); 

    //sprintf_f(str, "op_01 - rlt:0x%x ans: 0x%.2x\n", rlt, data->ansp0); 
    //print_f(mlogPool, "spy", str); 

    switch (rlt) {
        case STINIT:
            ch = 1; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(str, "op_01: result: %x\n", data->result); 
            //print_f(mlogPool, "spy", str);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                data->result = emb_result(data->result, EVTMAX);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}
static int stspy_02(struct psdata_s *data) 
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    struct info16Bit_s *p;
    struct procRes_s *rs;
    rs = data->rs;
    p = &rs->pmch->get;

    rlt = abs_result(data->result); 

    //sprintf_f(str, "op_02 - rlt:0x%.8x \n", rlt); 
    //print_f(mlogPool, "spy", str); 

    switch (rlt) {
        case STINIT:
            ch = 5; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //printf(str, "op_02: result: %x\n", data->result); 
            //print_f(mlogPool, "spy", str);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                sprintf_f(str, "op_02: %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
                print_f(mlogPool, "spy", str);  
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }
    return ps_next(data);
}
static int stspy_03(struct psdata_s *data) 
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    rlt = abs_result(data->result); 

    //sprintf_f(str, "op_03 - rlt:0x%x \n", rlt); 
    //print_f(mlogPool, "spy", str); 

    switch (rlt) {
        case STINIT:
            ch = 5; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(str, "op_03: result: %x\n", data->result); 
            //print_f(mlogPool, "spy", str);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}
static int stspy_04(struct psdata_s *data) 
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    rlt = abs_result(data->result); 

    //sprintf_f(str, "op_04 - rlt:0x%.8x \n", rlt); 
    //print_f(mlogPool, "spy", str); 

    switch (rlt) {
        case STINIT:
            ch = 6; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(str, "op_04: result: %x\n", data->result); 
            //print_f(mlogPool, "spy", str);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }
    return ps_next(data);
}
static int stspy_05(struct psdata_s *data) 
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    rlt = abs_result(data->result); 

    //sprintf_f(str, "op_05 - rlt:0x%.8x \n", rlt); 
    //print_f(mlogPool, "spy", str); 

    switch (rlt) {
        case STINIT:
            ch = 8; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            //sprintf_f(str, "op_05: result: %x\n", data->result); 
            //print_f(mlogPool, "spy", str);  
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }
    return ps_next(data);
}
static int stbullet_01(struct psdata_s *data) 
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    struct info16Bit_s *p;
    struct procRes_s *rs;
    struct modersp_s *mch;
    rs = data->rs;
    p = &rs->pmch->get;
    mch = &rs->pmch->mch;
    rlt = abs_result(data->result); 
    //sprintf_f(str, "op_01: rlt: %.8x result: %.8x ans:%d\n", rlt, data->result, data->ansp0); 
    //print_f(mlogPool, "bullet", str);  

    switch (rlt) {
        case STINIT:
#if CHECK_SOCKET_STATUS
            ch = 10; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
#else
            data->ansp0 = 1;
            data->result = emb_result(data->result, NEXT);
#endif
            //sprintf_f(str, "op_01: result: %x\n", data->result); 
            //print_f(mlogPool, "bullet", str);  

            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 2) {
                sprintf_f(str, "op_01: %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
                print_f(mlogPool, "bullet", str);  
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }

    return ps_next(data);
}
static int stbullet_02(struct psdata_s *data) 
{ 
    uint32_t rlt;
    char str[128], ch = 0; 
    struct aspConfig_s *pct=0, *pdt=0;
    struct info16Bit_s *p=0, *t=0, *c=0;
    struct procRes_s *rs;

    rs = data->rs;
    p = &rs->pmch->get;
    t = &rs->pmch->tmp;
    c = &rs->pmch->cur;
    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 
    //sprintf_f(str, "op_02: rlt: %.8x result: %.8x ans:%d\n", rlt, data->result, data->ansp0); 
    //print_f(mlogPool, "bullet", str);  

    switch (rlt) {
        case STINIT:
            pdt = &pct[ASPOP_SCAN_SINGLE];
            if ((pdt->opCode != OP_SINGLE) && (pdt->opCode != OP_MSINGLE)
                && (pdt->opCode != OP_HANDSCAN)) {
                sprintf_f(rs->logs, "op02, OP_SINGLE opcode is wrong val:%x\n", pdt->opCode); 
                print_f(rs->plogs, "SIG", rs->logs);  
                data->result = emb_result(data->result, EVTMAX);
            } else if (!(pdt->opStatus & ASPOP_STA_WR)) {
                sprintf_f(rs->logs, "op02, OP_SINGLE status is wrong val:%x\n", pdt->opStatus); 
                print_f(rs->plogs, "SIG", rs->logs);  

                        ch = 12; 
/*
                        if (pdt->opCode != t->opcode) {
                            c->opcode =  t->opcode;

                            sprintf_f(rs->logs, "op_02 WARNING!!! use temp opcode:%x \n", t->opcode); 
                            print_f(rs->plogs, "SIG", rs->logs);  
                            
                        } else {
                            c->opcode =  pdt->opCode;
                        }
*/
                        t->opcode =  pdt->opCode;;
                        t->data = SINSCAN_DUAL_STRM;
                        memset(p, 0, sizeof(struct info16Bit_s));

                        rs_ipc_put(data->rs, &ch, 1);
                        data->result = emb_result(data->result, WAIT);
                        sprintf_f(rs->logs, "op_02: result: %x, goto %d\n", data->result, ch); 
                        print_f(rs->plogs, "SIG", rs->logs);  

                //data->result = emb_result(data->result, EVTMAX);
            } else {
                switch(pdt->opValue) {
                    //case SINSCAN_WIFI_ONLY:
                    //case SINSCAN_SD_ONLY:
                    //case SINSCAN_WIFI_SD:
                    //case SINSCAN_WHIT_BLNC:
                    //case SINSCAN_USB:
                    case SINSCAN_DUAL_STRM:
                    case SINSCAN_DUAL_SD:
                        ch = 12; 
                        t->opcode =  pdt->opCode;
                        t->data = pdt->opValue;
                        memset(p, 0, sizeof(struct info16Bit_s));

                        rs_ipc_put(data->rs, &ch, 1);
                        data->result = emb_result(data->result, WAIT);
                        sprintf_f(rs->logs, "op_02: result: %x, goto %d\n", data->result, ch); 
                        print_f(rs->plogs, "SIG", rs->logs);  
                        break;
                    default:
                        sprintf_f(rs->logs, "WARNING!!! op02, opValue is unexpected val:%x\n", pdt->opValue);
                        print_f(rs->plogs, "SIG", rs->logs);  
                        data->result = emb_result(data->result, EVTMAX);
                        break;
                }
            }        
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }
    return ps_next(data);
}
static int stbullet_03(struct psdata_s *data) 
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    
    rlt = abs_result(data->result); 
    //sprintf_f(str, "op_03: rlt: %.8x result: %.8x ans:%d\n", rlt, data->result, data->ansp0); 
    //print_f(mlogPool, "bullet", str);  

    switch (rlt) {
        case STINIT:
            ch = 14; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }
    return ps_next(data);
}
static int stbullet_04(struct psdata_s *data) 
{ 
    char str[128], ch = 0; 
    uint32_t rlt;
    rlt = abs_result(data->result); 
    //sprintf_f(str, "op_04: rlt: %x result: %x ans:%d\n", rlt, data->result, data->ansp0); 
    //print_f(mlogPool, "bullet", str);  

    switch (rlt) {
        case STINIT:
            ch = 17; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }
    return ps_next(data);
}
static int stbullet_05(struct psdata_s *data) 
{ 
    char str[128], ch = 0;
    uint32_t rlt;
    rlt = abs_result(data->result); 
    //sprintf_f(str, "op_05: rlt: %x result: %x ans:%d\n", rlt, data->result, data->ansp0);  
    //print_f(mlogPool, "bullet", str);  

    switch (rlt) {
        case STINIT:
            ch = 20; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }
    return ps_next(data);
}
static int stlaser_01(struct psdata_s *data) 
{ 
    char str[128], ch = 0;
    uint32_t rlt;

    rlt = abs_result(data->result); 
    //sprintf_f(str, "op_01: rlt: %x result: %x ans:%d\n", rlt, data->result, data->ansp0);  
    //print_f(mlogPool, "laser", str);  

    switch (rlt) {
        case STINIT:
            ch = 21; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }
    return ps_next(data);
}
static int stlaser_02(struct psdata_s *data) 
{ 
    int ret=0;
    char str[128], ch = 0;
    uint32_t rlt, val=0;
    struct aspConfig_s *pct=0, *pdt=0;

    pct = data->rs->pcfgTable;
    rlt = abs_result(data->result); 
    //sprintf_f(str, "op_02: rlt: %.8x result: %.8x ans:%d\n", rlt, data->result, data->ansp0);  
    //print_f(mlogPool, "laser", str);  

    switch (rlt) {
        case STINIT:
            ch = 6; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                pdt = &pct[ASPOP_EG_DECT];
                if ((pdt->opStatus == ASPOP_STA_UPD) && (pdt->opValue == 1)) {
#if CROP_USE_META
                    data->bkofw = emb_bk(data->bkofw, SAVPARM, PSRLT);
#else
                    data->bkofw = emb_bk(data->bkofw, WTBAKQ, PSTSM);
#endif
                    data->result = emb_result(data->result, BKWRD);
                } else {
                    data->result = emb_result(data->result, FWORD);
                }
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }
    return ps_next(data);
}
static int stlaser_03(struct psdata_s *data) 
{ 
    char str[128], ch = 0;
    uint32_t rlt;
    rlt = abs_result(data->result); 
    //sprintf_f(str, "op_03: rlt: %x result: %x ans:%d\n", rlt, data->result, data->ansp0);  
    //print_f(mlogPool, "laser", str);  

    switch (rlt) {
        case STINIT:
            ch = 17; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }
    return ps_next(data);
}

static int stlaser_04(struct psdata_s *data) 
{ 
    char str[128], ch = 0;
    uint32_t rlt;
    rlt = abs_result(data->result); 
    //sprintf_f(str, "op_04: rlt: %x result: %x ans:%d\n", rlt, data->result, data->ansp0);  
    //print_f(mlogPool, "laser", str);  

    switch (rlt) {
        case STINIT:
            ch = 5; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }
    return ps_next(data);
}

static int stlaser_05(struct psdata_s *data) 
{ 
    char str[128], ch = 0;
    uint32_t rlt;
    rlt = abs_result(data->result); 
    //sprintf_f(str, "op_05: rlt: %.8x result: %.8x ans:%d\n", rlt, data->result, data->ansp0);  
    //print_f(mlogPool, "laser", str);  

    switch (rlt) {
        case STINIT:
            ch = 7; 
            rs_ipc_put(data->rs, &ch, 1);
            data->result = emb_result(data->result, WAIT);
            break;
        case WAIT:
            if (data->ansp0 == 1) {
                data->result = emb_result(data->result, NEXT);
            } else if (data->ansp0 == 0xed) {
                data->result = emb_result(data->result, EVTMAX);
            }
            break;
        case NEXT:
            break;
        case BREAK:
            ch = 0x7f;
            rs_ipc_put(data->rs, &ch, 1);
            break;
        default:
            break;
    }
    return ps_next(data);
}

static int shmem_rlt_get(struct mainRes_s *mrs, int seq, int p)
{
    int ret, sz, len;
    char ch, *stop_at, dst[16];;

    ret = mrs_ipc_get(mrs, &ch, 1, p);
    if (ret > 0) {
        len = mrs_ipc_get(mrs, &ch, 1, p);
        if ((len > 0) && (ch == 'l')) {
            len = mrs_ipc_get(mrs, dst, 8, p);
            if (len == 8) {
                sz = strtoul(dst, &stop_at, 10);
            }
        }
    
        if ((ch == 'l') && (sz == 0)) {
        } else {
            ring_buf_prod_dual(&mrs->dataRx, seq);
        }
        //sprintf_f(mlog, "[dback] ch:%c rt:%d idx:%d \n", ch,  len, seq);
        //shmem_dump(addr[0], sz);
        if (ch == 'l') {
            ring_buf_set_last_dual(&mrs->dataRx, sz, seq);
        }

    }

    return ret;
}

static int shmem_pop_send(struct mainRes_s *mrs, char **addr, int seq, int p)
{
    char str[128];
    int sz = 0;
    sz = ring_buf_get_dual(&mrs->dataRx, addr, seq);
    //sprintf_f(mlog, "shmem pop:0x%.8x, seq:%d sz:%d\n", *addr, seq, sz);
    if (sz < 0) return (-1);
    sprintf_f(str, "d%.8xl%.8d\n", (uint32_t)*addr, sz);
    print_f(mrs->plog, "pop", str);
    //sprintf_f(mlog, "[%s]\n", str);
    mrs_ipc_put(mrs, str, 18, p);

    return sz;
}

static uint32_t shmem_check(char *src, int size)
{
#define CHK_LEN (2048)
    uint32_t tag = 0;

    tag = (uint32_t)src;

    memset(src, tag & 0xff, size);

    return tag;
}

static int shmem_dump(char *src, int size)
{
    char str[128];
    int inc;
    if (!src) return -1;

    inc = 0;
    sprintf_f(str, "memdump[0x%.8x] sz%d: \n", (uint32_t)src, size);
    print_f(mlogPool, "dump", str);
    while (inc < size) {
        sprintf_f(str, "%.2x ", *src);
        print_f(mlogPool, NULL, str);

        if (!((inc+1) % 16)) {
            sprintf_f(str, " %d \n", inc+1);
            print_f(mlogPool, NULL, str);
        }
        inc++;
        src++;
    }

    sprintf_f(str, "\n");
    print_f(mlogPool, NULL, str);

    return inc;
}
static int shmem_from_str(char **addr, char *dst, char *sz)
{
    char *stop_at;
    int size;
    if ((!addr) || (!dst) || (!sz)) return -1;

    *addr = (char *)strtoul(dst, &stop_at, 16);
    size = strtoul(sz, &stop_at, 10);

    return size;
}

static int ring_buf_info_len(struct shmem_s *pp)
{
    int dualn = 0;
    int leadn = 0;
    int folwn = 0;
    int dist;

    folwn = pp->r->folw.run * pp->slotn + pp->r->folw.seq;
    dualn = pp->r->dual.run * pp->slotn + pp->r->dual.seq;
    leadn = pp->r->lead.run * pp->slotn + pp->r->lead.seq;

    if (dualn > leadn) {
        dist = dualn - folwn;
    } else {
        dist = leadn - folwn;
    }

    return dist;
}

#define LOG_DUAL_STREAM_RING (0)
static int ring_buf_init(struct shmem_s *pp)
{
    int idx=0;
    pp->r->lead.run = 0;
    pp->r->lead.seq = 0;
    pp->r->dual.run = 0;
    pp->r->dual.seq = 1;
    pp->r->prelead.run = 0;
    pp->r->prelead.seq = 0;
    pp->r->predual.run = 0;
    pp->r->predual.seq = 1;
    pp->r->folw.run = 0;
    pp->r->folw.seq = 0;
    pp->r->psudo.run = 0;
    pp->r->psudo.seq = 0;
    pp->lastflg = 0;
    pp->lastsz = 0;
    pp->dualsz = 0;

#if 1

    if (pp->r->usbgettig) {
        pp->r->usbgettig->run = 0;
        pp->r->usbgettig->seq = 0;
    }

    if (pp->r->usbrunnig) {
        pp->r->usbrunnig->run = 0;
        pp->r->usbrunnig->seq = 0;
    }

    for (idx=0; idx < pp->slotn; idx++) {
        if (pp->urun) {
            pp->urun[idx] = 0;
        }
        if (pp->uget) {
            pp->uget[idx] = 0;
        }
        
        //memset(pp->pp[idx], 0xa5, pp->chksz);
        //msync(pp->pp[idx], pp->chksz, MS_SYNC);
    }
#endif

    msync(pp, sizeof(struct shmem_s), MS_SYNC);
    return 0;
}

static int ring_buf_get_dual(struct shmem_s *pp, char **addr, int sel)
{
    char str[128];
    int dualn = 0;
    int folwn = 0;
    int dist;
    int tmps;

    sel = sel % 2;

    folwn = pp->r->folw.run * pp->slotn + pp->r->folw.seq;

    if (sel) {
        dualn = pp->r->predual.run * pp->slotn + pp->r->predual.seq;
    } else {
        dualn = pp->r->prelead.run * pp->slotn + pp->r->prelead.seq;
    }

    dist = dualn - folwn;
    //sprintf_f(str, "get d:%d, %d /%d \n", dist, dualn, folwn);
    //print_f(mlogPool, "ring", str);

    if (dist > (pp->slotn - 3))  return -1;

    if (sel) {
        if ((pp->r->predual.seq + 2) < pp->slotn) {
            *addr = pp->pp[pp->r->predual.seq+2];
        } else {
            tmps = (pp->r->predual.seq+2) % pp->slotn;
            *addr = pp->pp[tmps];
        }
    } else {
        if ((pp->r->prelead.seq + 2) < pp->slotn) {
            *addr = pp->pp[pp->r->prelead.seq+2];
        } else {
            tmps = (pp->r->prelead.seq+2) % pp->slotn;
            *addr = pp->pp[tmps];
        }
    }

    if (sel) {
        if ((pp->r->predual.seq + 2) < pp->slotn) {
            pp->r->predual.seq += 2;
        } else {
            pp->r->predual.seq = 1;
            pp->r->predual.run += 1;
        }
    } else {
        if ((pp->r->prelead.seq + 2) < pp->slotn) {
            pp->r->prelead.seq += 2;
        } else {
            pp->r->prelead.seq = 0;
            pp->r->prelead.run += 1;
        }
    }

    return pp->chksz;   
}

static int ring_buf_get(struct shmem_s *pp, char **addr)
{
    char str[128];
    int leadn = 0;
    int folwn = 0;
    int maxn = 0;
    int dist;

    asp_mem_barrier();
    
    folwn = pp->r->folw.run * pp->slotn + pp->r->folw.seq;
    leadn = pp->r->lead.run * pp->slotn + pp->r->lead.seq;
    maxn = pp->slotn; 

    dist = leadn - folwn;
    
    //sprintf_f(str, "rget d:%d, L:%d, f:%d, tot: %d\n", dist, leadn, folwn, maxn);
    //print_f(mlogPool, "ring", str);

    if (dist > (pp->slotn - 2))  return -1;

    if ((pp->r->lead.seq + 1) < pp->slotn) {
        *addr = pp->pp[pp->r->lead.seq+1];
    } else {
        *addr = pp->pp[0];
    }

    return pp->chksz;   
}

static int ring_buf_set_last_dual(struct shmem_s *pp, int size, int sel)
{
    int tlen=0;
    char str[128];
    sel = sel % 2;

    if (size > SPI_TRUNK_SZ) {
        sprintf_f(str, "ERROR!!! set last %d > max %d \n", size, SPI_TRUNK_SZ);
        print_f(mlogPool, "ring", str);
        size = SPI_TRUNK_SZ;
    }
    
    tlen = size % MIN_SECTOR_SIZE;
    if (tlen) {
        size = size + MIN_SECTOR_SIZE - tlen;
    }

    asp_mem_barrier();
    
    if (sel) {
        pp->dualsz = size;
    } else {
        pp->lastsz = size;
    }
    pp->lastflg += 1;

    //sprintf_f(str, "set last d:%d l:%d f:%d \n", pp->dualsz, pp->lastsz, pp->lastflg);
    //print_f(mlogPool, "ring", str);

    msync(pp, sizeof(struct shmem_s), MS_SYNC);
    return pp->lastflg;
}

static int ring_buf_prod_tag(struct shmem_s *pp, int usbrn)
{
    char str[128];
    int leadn = 0;
    int folwn = 0;
    int dist;
    int gdx=0, glp=0, rlp=0, rdx=0, ttn=0;

    asp_mem_barrier();
    
    ttn = pp->slotn;

    gdx = pp->r->usbgettig->seq;
    glp = pp->r->usbgettig->run;

    folwn = glp * pp->slotn + gdx;

    if ((!usbrn) || (usbrn < 0)) {
        return folwn;
    }

    if (usbrn > ttn) {
        rlp = usbrn / ttn;
    } else {
        rlp = 0;
    }
    
    rdx = usbrn - (rlp * ttn);

    asp_mem_barrier();
    
    pp->r->usbrunnig->seq = rdx;
    pp->r->usbrunnig->run = rlp;

    //sprintf_f(str, "cons, d: %d %d/%d - %d\n", dist, leadn, folwn,pp->lastflg);
    //print_f(mlogPool, "ring", str);
    
    //leadn = rlp * pp->slotn + rdx;
    //dist = leadn - folwn;

    msync(pp, sizeof(struct shmem_s), MS_SYNC);

    return folwn;
}

static int ring_buf_prod_u(struct shmem_s *pp, int csz)
{
    char str[128];
    int idx=0, nlp=0;

    asp_mem_barrier();
    
    if ((pp->r->lead.seq + 1) < pp->slotn) {
        pp->r->lead.seq += 1;
    } else {
        pp->r->lead.seq = 0;
        pp->r->lead.run += 1;
    }

    asp_mem_barrier();
    
    idx = pp->r->lead.seq;
    nlp = pp->r->lead.run;
    
    pp->urun[idx] = ((nlp & 0xfff) << 20) | csz;

    //printf("[R] prod u idx %d:%d csz: %d content: 0x%.8x \n", idx, nlp, csz, pp->urun[idx]);

    msync(pp, sizeof(struct shmem_s), MS_SYNC);
    
    //sprintf_f(str, "prod %d %d/\n", pp->r->lead.run, pp->r->lead.seq);
    //print_f(mlogPool, "ring", str);

    return 0;
}

static int ring_buf_set_last_actual(struct shmem_s *pp, int size)
{
    char str[128];
    int tlen=0;

    if (size > SPI_TRUNK_SZ) {
        sprintf_f(str, "ERROR!!! set last %d > max %d \n", size, SPI_TRUNK_SZ);
        print_f(mlogPool, "ring", str);
        size = SPI_TRUNK_SZ;
    }
    
    /*
    tlen = size % MIN_SECTOR_SIZE;
    if (tlen) {
        size = size + MIN_SECTOR_SIZE - tlen;
    }
    */

    pp->lastsz = size;
    pp->lastflg = 1;

    sprintf_f(str, "set last l:%d f:%d actual \n", pp->lastsz, pp->lastflg);
    print_f(mlogPool, "ring", str);

    msync(pp, sizeof(struct shmem_s), MS_SYNC);
    return pp->lastflg;
}

static int ring_buf_set_last(struct shmem_s *pp, int size)
{
    char str[128];
    int tlen=0;
    int idx=0;

#if 0
    if (size > SPI_TRUNK_SZ) {
        sprintf_f(str, "ERROR!!! set last %d > max %d \n", size, SPI_TRUNK_SZ);
        print_f(mlogPool, "ring", str);
        size = SPI_TRUNK_SZ;
    }
#endif

#if 0
    tlen = size % MIN_SECTOR_SIZE;
    if (tlen) {
        size = size + MIN_SECTOR_SIZE - tlen;
    }
#endif

    if (pp->urun) {
        idx = pp->r->lead.seq;
        pp->urun[idx] |= 0x40000;
    }

    pp->lastsz = size;
    pp->lastflg = 1;

    //sprintf_f(str, "set last l:%d f:%d sz:%d min:%d\n", pp->lastsz, pp->lastflg, size, MIN_SECTOR_SIZE);
    //print_f(mlogPool, "ring", str);

    msync(pp, sizeof(struct shmem_s), MS_SYNC);
    return pp->lastflg;
}

static int ring_buf_prod_dual(struct shmem_s *pp, int sel)
{
    char str[128];
    sel = sel % 2;

    asp_mem_barrier();
    
    if (sel) {
        if ((pp->r->dual.seq + 2) < pp->slotn) {
            pp->r->dual.seq += 2;
        } else {
            pp->r->dual.seq = 1;
            pp->r->dual.run += 1;
        }
    } else {
        if ((pp->r->lead.seq + 2) < pp->slotn) {
            pp->r->lead.seq += 2;
        } else {
            pp->r->lead.seq = 0;
            pp->r->lead.run += 1;
        }
    }
    msync(pp, sizeof(struct shmem_s), MS_SYNC);
#if LOG_DUAL_STREAM_RING
    sprintf_f(str, "prod %d %d, %d %d\n", pp->r->lead.run, pp->r->lead.seq, pp->r->dual.run, pp->r->dual.seq);
    print_f(mlogPool, "ring", str);
#endif
    return 0;
}

static int ring_buf_cons_tag(struct shmem_s *pp)
{
    char str[128];
    int leadn = 0;
    int folwn = 0;
    int dist;
    int gdx=0, glp=0, rsz=0, rlp=0, rdx=0, sta=0;

    asp_mem_barrier();
    
    rdx = pp->r->usbrunnig->seq;
    rlp = pp->r->usbrunnig->run;

    //sprintf_f(str, "cons, d: %d %d/%d - %d\n", dist, leadn, folwn,pp->lastflg);
    //print_f(mlogPool, "ring", str);

    gdx = pp->r->folw.seq;
    glp = pp->r->folw.run;

    asp_mem_barrier();
        
    pp->r->usbgettig->seq = gdx;
    pp->r->usbgettig->run = glp;

    folwn = glp * pp->slotn + gdx;
    leadn = rlp * pp->slotn + rdx;
    dist = leadn - folwn;

    msync(pp, sizeof(struct shmem_s), MS_SYNC);

    return dist;
}

static int ring_buf_cons_up(struct shmem_s *pp, char **addr, char **phyr)
{
    char str[128];
    int leadn = 0;
    int folwn = 0;
    int dist;
    int idx=0, nlp=0, rsz=0, rlp=0, sta=0;

    asp_mem_barrier();
    
    folwn = pp->r->folw.run * pp->slotn + pp->r->folw.seq;
    leadn = pp->r->lead.run * pp->slotn + pp->r->lead.seq;
    dist = leadn - folwn;

    //sprintf_f(str, "cons, d: %d %d/%d - %d\n", dist, leadn, folwn,pp->lastflg);
    //print_f(mlogPool, "ring", str);

    if (dist < 1)  return -1;

    if ((pp->r->folw.seq + 1) < pp->slotn) {
        //*addr = pp->pp[pp->r->folw.seq + 1];
        //pp->r->folw.seq += 1;
        idx = pp->r->folw.seq + 1;
        nlp = pp->r->folw.run;
    } else {
        //*addr = pp->pp[0];
        //pp->r->folw.seq = 0;
        //pp->r->folw.run += 1;
        idx = 0;
        nlp = pp->r->folw.run + 1;
    }

    msync(pp->urun, sizeof(int) * RING_BUFF_NUM_USB, MS_SYNC);    

    sta = pp->urun[idx];
    
    //printf("[R] cons u idx %d:%d content: 0x%.8x \n", idx, nlp, sta);

    #if !USB_RECVLEN_ZERO_HANDLE
    if (!sta) {
        return -2;
    }
    #endif

    rlp = (sta >> 20) & 0xfff;
    if (rlp != nlp) {
        printf("[R] %d:%d idx: %d\n", rlp, nlp, idx);
        //return -3;
    }

    rsz = sta & 0x1ffff;
    
    #if USB_RECVLEN_ZERO_HANDLE
    
    if (rsz > pp->chksz) {
        return -4;
    }
    
    #else
    
    if ((rsz == 0) || (rsz > pp->chksz)) {
        return -4;
    }
    
    #endif

    asp_mem_barrier();
    
    pp->urun[idx] = 0;
    pp->uget[idx] = sta;

    pp->r->folw.seq = idx;
    pp->r->folw.run = nlp;

    *addr = pp->pp[idx];
    *phyr = pp->bb[idx];

    msync(pp, sizeof(struct shmem_s), MS_SYNC);

    if (sta & 0x40000) {
        rsz |= 0x40000;
    }

    return rsz;
}

static int ring_buf_cons_u(struct shmem_s *pp, char **addr)
{
    char str[128];
    int leadn = 0;
    int folwn = 0;
    int dist;
    int idx=0, nlp=0, rsz=0, rlp=0, sta=0;

    asp_mem_barrier();
    
    folwn = pp->r->folw.run * pp->slotn + pp->r->folw.seq;
    leadn = pp->r->lead.run * pp->slotn + pp->r->lead.seq;
    dist = leadn - folwn;

    //sprintf_f(str, "cons, d: %d %d/%d - %d\n", dist, leadn, folwn,pp->lastflg);
    //print_f(mlogPool, "ring", str);

    if (dist < 1)  return -1;

    asp_mem_barrier();
    
    if ((pp->r->folw.seq + 1) < pp->slotn) {
        //*addr = pp->pp[pp->r->folw.seq + 1];
        //pp->r->folw.seq += 1;
        idx = pp->r->folw.seq + 1;
        nlp = pp->r->folw.run;
    } else {
        //*addr = pp->pp[0];
        //pp->r->folw.seq = 0;
        //pp->r->folw.run += 1;
        idx = 0;
        nlp = pp->r->folw.run + 1;
    }

    msync(pp->urun, sizeof(int) * RING_BUFF_NUM_USB, MS_SYNC);    

    sta = pp->urun[idx];
    
    //printf("[R] cons u idx %d:%d content: 0x%.8x \n", idx, nlp, sta);

    #if !USB_RECVLEN_ZERO_HANDLE
    if (!sta) {
        return -2;
    }
    #endif

    rlp = (sta >> 20) & 0xfff;
    if (rlp != nlp) {
        printf("[R] %d:%d idx: %d\n", rlp, nlp, idx);
        //return -3;
    }

    rsz = sta & 0x1ffff;
    
    #if USB_RECVLEN_ZERO_HANDLE
    
    if (rsz > pp->chksz) {
        return -4;
    }
    
    #else
    
    if ((rsz == 0) || (rsz > pp->chksz)) {
        return -4;
    }
    
    #endif

    asp_mem_barrier();
    
    pp->urun[idx] = 0;
    pp->uget[idx] = sta;

    pp->r->folw.seq = idx;
    pp->r->folw.run = nlp;

    *addr = pp->pp[idx];

    msync(pp, sizeof(struct shmem_s), MS_SYNC);

    if (sta & 0x40000) {
        rsz |= 0x40000;
    }

    return rsz;
}

static int ring_buf_prod(struct shmem_s *pp)
{
    char str[128];

    asp_mem_barrier();
    
    if ((pp->r->lead.seq + 1) < pp->slotn) {
        pp->r->lead.seq += 1;
    } else {
        pp->r->lead.seq = 0;
        pp->r->lead.run += 1;
    }

    msync(pp, sizeof(struct shmem_s), MS_SYNC);
    
    //sprintf_f(str, "prod %d %d/\n", pp->r->lead.run, pp->r->lead.seq);
    //print_f(mlogPool, "ring", str);

    return 0;
}

static int ring_buf_cons_dual(struct shmem_s *pp, char **addr, int sel)
{
    int ret=-1;
    char str[128];
    int dualn = 0;
    int leadn = 0;
    int folwn = 0;
    int dist;

    asp_mem_barrier();
    
    folwn = pp->r->folw.run * pp->slotn + pp->r->folw.seq;
    dualn = pp->r->dual.run * pp->slotn + pp->r->dual.seq;
    leadn = pp->r->lead.run * pp->slotn + pp->r->lead.seq;
    if (dualn > leadn) {
        dist = dualn - folwn;
    } else {
        dist = leadn - folwn;
    }
#if LOG_DUAL_STREAM_RING
    sprintf_f(str, "cons d: %d %d/%d/%d \n", dist, leadn, dualn, folwn);
    print_f(mlogPool, "ring", str);
#endif
    if ((pp->lastflg) && (dist < 1)) return (-1);
    if (dist < 1)  return (-2);

    asp_mem_barrier();
    
    if ((pp->r->folw.seq + 1) < pp->slotn) {
        *addr = pp->pp[pp->r->folw.seq + 1];
        pp->r->folw.seq += 1;
    } else {
        *addr = pp->pp[0];
        pp->r->folw.seq = 0;
        pp->r->folw.run += 1;
    }

    asp_mem_barrier();
    
    if ((pp->lastflg) && (dist == 1)) {
        sprintf_f(str, "[clast] f:%d %d, d:%d %d l: %d %d \n", pp->r->folw.run, pp->r->folw.seq, 
            pp->r->dual.run, pp->r->dual.seq, pp->r->lead.run, pp->r->lead.seq);
        print_f(mlogPool, "ring", str);
        if (dualn > leadn) {
            if ((pp->r->folw.run == pp->r->dual.run) &&
             (pp->r->folw.seq == pp->r->dual.seq)) {
                //return pp->dualsz;
                ret = pp->dualsz;
            }
        } else {
            if ((pp->r->folw.run == pp->r->lead.run) &&
             (pp->r->folw.seq == pp->r->lead.seq)) {
                //return pp->lastsz;
                ret = pp->lastsz;
            }
        }
    }

    if (ret < 0) {
        ret = pp->chksz;
    }
    msync(pp, sizeof(struct shmem_s), MS_SYNC);
    
    //sprintf_f(str, "cons dual len: %d \n", ret);
    //print_f(mlogPool, "ring", str);

    return ret;
}

static int ring_buf_cons_dual_psudo(struct shmem_s *pp, char **addr, int sel)
{
    int ret=-1;
    char str[128];
    int dualn = 0;
    int leadn = 0;
    int folwn = 0;
    int dist;

    asp_mem_barrier();
    
    folwn = pp->r->psudo.run * pp->slotn + pp->r->psudo.seq;
    dualn = pp->r->dual.run * pp->slotn + pp->r->dual.seq;
    leadn = pp->r->lead.run * pp->slotn + pp->r->lead.seq;
    if (dualn > leadn) {
        dist = dualn - folwn;
    } else {
        dist = leadn - folwn;
    }

    //sprintf_f(str, "[cons], d: %d %d/%d/%d \n", dist, leadn, dualn, folwn);
    //print_f(mlogPool, "ring", str);

    if ((pp->lastflg) && (dist < 1)) return (-1);
    if (dist < 1)  return (-2);

    asp_mem_barrier();
    
    if ((pp->r->psudo.seq + 1) < pp->slotn) {
        *addr = pp->pp[pp->r->psudo.seq + 1];
        pp->r->psudo.seq += 1;
    } else {
        *addr = pp->pp[0];
        pp->r->psudo.seq = 0;
        pp->r->psudo.run += 1;
    }

    asp_mem_barrier();
    
    if ((pp->lastflg) && (dist == 1)) {
        sprintf_f(str, "[psudo] f:%d %d, d:%d %d l: %d %d \n", pp->r->psudo.run, pp->r->psudo.seq, 
            pp->r->dual.run, pp->r->dual.seq, pp->r->lead.run, pp->r->lead.seq);
        print_f(mlogPool, "ring", str);
        if (dualn > leadn) {
            if ((pp->r->psudo.run == pp->r->dual.run) &&
             (pp->r->psudo.seq == pp->r->dual.seq)) {
                //return pp->dualsz;
                ret = pp->dualsz;
            }
        } else {
            if ((pp->r->psudo.run == pp->r->lead.run) &&
             (pp->r->psudo.seq == pp->r->lead.seq)) {
                //return pp->lastsz;
                ret = pp->lastsz;
            }
        }
    }

    if (ret < 0) {
        ret = pp->chksz;
    }
    msync(pp, sizeof(struct shmem_s), MS_SYNC);
    //sprintf_f(str, "psudo len %d \n", ret);
    //print_f(mlogPool, "ring", str);

    return ret;
}

static int ring_buf_cons(struct shmem_s *pp, char **addr)
{
    char str[128];
    int leadn = 0;
    int folwn = 0;
    int dist;

    asp_mem_barrier();

    folwn = pp->r->folw.run * pp->slotn + pp->r->folw.seq;
    leadn = pp->r->lead.run * pp->slotn + pp->r->lead.seq;
    dist = leadn - folwn;

    //sprintf_f(str, "cons, d: %d %d/%d - %d\n", dist, leadn, folwn,pp->lastflg);
    //print_f(mlogPool, "ring", str);

    if (dist < 1)  return -1;

    asp_mem_barrier();
    
    if ((pp->r->folw.seq + 1) < pp->slotn) {
        *addr = pp->pp[pp->r->folw.seq + 1];
        pp->r->folw.seq += 1;
    } else {
        *addr = pp->pp[0];
        pp->r->folw.seq = 0;
        pp->r->folw.run += 1;
    }

    asp_mem_barrier();
    
    if ((pp->lastflg) && (dist == 1)) {
        sprintf_f(str, "last, f: %d %d/l: %d %d\n", pp->r->folw.run, pp->r->folw.seq, pp->r->lead.run, pp->r->lead.seq);
        print_f(mlogPool, "ring", str);

        if ((pp->r->folw.run == pp->r->lead.run) &&
            (pp->r->folw.seq == pp->r->lead.seq)) {
            return pp->lastsz;
        }
    }

    msync(pp, sizeof(struct shmem_s), MS_SYNC);

    return pp->chksz;
}

static int ring_buf_cons_psudo(struct shmem_s *pp, char **addr)
{
    char str[128];
    int leadn = 0;
    int folwn = 0;
    int dist;

    asp_mem_barrier();
    
    folwn = pp->r->psudo.run * pp->slotn + pp->r->psudo.seq;
    leadn = pp->r->lead.run * pp->slotn + pp->r->lead.seq;
    dist = leadn - folwn;

    //sprintf_f(str, "psudo cons, d: %d %d/%d - %d\n", dist, leadn, folwn,pp->lastflg);
    //print_f(mlogPool, "ring", str);

    if (dist < 1)  return -1;

    asp_mem_barrier();
    
    if ((pp->r->psudo.seq + 1) < pp->slotn) {
        *addr = pp->pp[pp->r->psudo.seq + 1];
        pp->r->psudo.seq += 1;
    } else {
        *addr = pp->pp[0];
        pp->r->psudo.seq = 0;
        pp->r->psudo.run += 1;
    }

    asp_mem_barrier();
    
    if ((pp->lastflg) && (dist == 1)) {
        sprintf_f(str, "psudo last, f: %d %d/l: %d %d\n", pp->r->psudo.run, pp->r->psudo.seq, pp->r->lead.run, pp->r->lead.seq);
        print_f(mlogPool, "ring", str);

        if ((pp->r->psudo.run == pp->r->lead.run) &&
            (pp->r->psudo.seq == pp->r->lead.seq)) {
            return pp->lastsz;
        }
    }

    msync(pp, sizeof(struct shmem_s), MS_SYNC);

    return pp->chksz;
}

static int msp_spi_conf(int dev, int flag, void *bitset)
{
    int ret;
    
    if (!dev) {
        printf("spi-config, spi device id == 0\n");
        return -1;
    }
    ret = ioctl(dev, flag, bitset);

    //printf("tx/rx len: %d\n", ret);
    
    return ret;
}

static int mtx_data(int fd, uint8_t *rx_buff, uint8_t *tx_buff, int pksz, struct spi_ioc_transfer *tr)
{
    char mlog[256];
    int ret;

    memset(tr, 0, sizeof(struct spi_ioc_transfer));
    msync(tr, sizeof(struct spi_ioc_transfer), MS_SYNC);

    if (pksz > SPI_MAX_TXSZ) return (-3);

    tr->tx_buf = (unsigned long)tx_buff;
    tr->rx_buf = (unsigned long)rx_buff;
    tr->len = pksz;
    tr->delay_usecs = 0;
    tr->speed_hz = 40000000;
    tr->bits_per_word = 8;
//    tr->rx_nbits = 0;
//    tr->tx_nbits = 0;

    ret = msp_spi_conf(fd, SPI_IOC_MESSAGE(1), tr);
    if (ret < 0) {
        //printf("spi error code: %d \n", ret);
    }
    
    return ret;
}

static int mrs_ipc_get(struct mainRes_s *mrs, char *str, int size, int idx)
{
    int ret=-1;
#if 1
    int tcnt=0, ptret=0;
    char ch=0;
    struct pollfd ptfd[1];
    ptfd[0].fd = mrs->pipeup[idx].rt[0];
    ptfd[0].events = POLLIN;

    while(1) {
        tcnt++;
        ptret = poll(ptfd, 1, 10);
        //sprintf_f(mrs->log, "[%s] poll return %d evt: 0x%.2x - %d\n", mrs->nmrs, ptret, ptfd[0].revents, idx);
        //print_f(mrs->plog, "IPC", mrs->log);
        if (ptret > 0) {
            ret = read(mrs->pipeup[idx].rt[0], str, size);
            ch = *str;
            //sprintf_f(mrs->log, "[%s] get chr: %c (0x%.2x) ret: %d - %d\n", mrs->nmrs, ch, ch, ret, idx);
            //print_f(mrs->plog, "IPC", mrs->log);
            return ret;
        }

        if (((tcnt+1) % 2) == 0) {
            //sprintf_f(mrs->log, "[%s] poll wait - %d\n", mrs->nmrs, idx);
            //print_f(mrs->plog, "IPC", mrs->log);
            break;
        }
    }
#else
    ret = read(mrs->pipeup[idx].rt[0], str, size);
#endif
    return ret;
}

static int mrs_ipc_put(struct mainRes_s *mrs, char *str, int size, int idx)
{
    int ret;
    ret = write(mrs->pipedn[idx].rt[1], str, size);
    return ret;
}

static int rs_ipc_put(struct procRes_s *rs, char *str, int size)
{
    int ret;
    ret = write(rs->ppipeup->rt[1], str, size);
    return ret;
}

static int rs_ipc_get_ms(struct procRes_s *rs, char *str, int size, int wms)
{
    int ret=-1;
#if 1
    int tcnt=0, ptret=0;
    char ch=0;
    struct pollfd ptfd[1];
    ptfd[0].fd = rs->ppipedn->rt[0];
    ptfd[0].events = POLLIN;

    while(1) {
        tcnt++;
        ptret = poll(ptfd, 1, wms);
        //sprintf_f(rs->logs, "[%s] poll return %d evt: 0x%.2x sz: %d\n", rs->nrs, ptret, ptfd[0].revents, size);
        //print_f(rs->plogs, "IPC", rs->logs);
        if (ptret > 0) {
            ret = read(rs->ppipedn->rt[0], str, size);
            ch = *str;
            //sprintf_f(rs->logs, "[%s] size: %d, get chr: %c ret: %d \n", rs->nrs, size, ch, ret);
            //print_f(rs->plogs, "IPC", rs->logs);
            return ret;
        }

        if (wms) break;

        if (((tcnt+1) % 10) == 0) {
            //sprintf_f(rs->logs, "[%s] poll wait\n", rs->nrs);
            //print_f(rs->plogs, "IPC", rs->logs);
            break;
        }
    }
#else
    ret = read(rs->ppipedn->rt[0], str, size);
#endif
    return ret;
}

static int rs_ipc_get(struct procRes_s *rs, char *str, int size)
{
    int ret=-1;
#if 1
    int tcnt=0, ptret=0;
    char ch=0;
    struct pollfd ptfd[1];
    ptfd[0].fd = rs->ppipedn->rt[0];
    ptfd[0].events = POLLIN;

    while(1) {
        tcnt++;
        ptret = poll(ptfd, 1, 1000);
        //sprintf_f(rs->logs, "[%s] poll return %d evt: 0x%.2x sz: %d\n", rs->nrs, ptret, ptfd[0].revents, size);
        //print_f(rs->plogs, "IPC", rs->logs);
        if (ptret > 0) {
            ret = read(rs->ppipedn->rt[0], str, size);
            ch = *str;
            //sprintf_f(rs->logs, "[%s] size: %d, get chr: %c ret: %d \n", rs->nrs, size, ch, ret);
            //print_f(rs->plogs, "IPC", rs->logs);
            return ret;
        }

        if (((tcnt+1) % 2) == 0) {
            //sprintf_f(rs->logs, "[%s] poll wait\n", rs->nrs);
            //print_f(rs->plogs, "IPC", rs->logs);
        }
    }
#else
    ret = read(rs->ppipedn->rt[0], str, size);
#endif
    return ret;
}

static int pn_init(struct procRes_s *rs)
{
    close(rs->ppipedn->rt[1]);
    close(rs->ppipeup->rt[0]);
    return 0;
}

static int pn_end(struct procRes_s *rs)
{
    close(rs->ppipedn->rt[0]); 
    close(rs->ppipeup->rt[1]);
    return 0;
}

static int p6_init(struct procRes_s *rs)
{
    int ret;

    rs->cpyfatDirTr = aspMemalloc(sizeof(struct sdFatDir_s), 8);    /* FAT dict tree init */
    if (!rs->cpyfatDirTr) {
        sprintf_f(rs->logs, "ERROR!!! allocate memory for fat dir failed!!!\n");
        print_f(rs->plogs, "P6_INIT", rs->logs);

        return -1;
    }

    memset(rs->cpyfatDirTr, 0, sizeof(struct sdFatDir_s));

    rs->cpyfatDirTr->dirFATMax = FAT_DIRPOO_ARY_MAX;
    
    ret = pn_init(rs);
    return ret;
}

static int p6_end(struct procRes_s *rs)
{
    int ret;
    ret = pn_end(rs);
    return ret;
}

static int p7_init(struct procRes_s *rs)
{
    int ret;
    ret = pn_init(rs);
    return ret;
}

static int p7_end(struct procRes_s *rs)
{
    int ret;
    ret = pn_end(rs);
    return ret;
}

static int p8_init(struct procRes_s *rs)
{
    int ret;
    ret = pn_init(rs);
    return ret;
}

static int p8_end(struct procRes_s *rs)
{
    int ret;
    ret = pn_end(rs);
    return ret;
}

static int p9_init(struct procRes_s *rs)
{
    int ret;
    ret = pn_init(rs);
    return ret;
}

static int p9_end(struct procRes_s *rs)
{
    int ret;
    ret = pn_end(rs);
    return ret;
}

static int p10_init(struct procRes_s *rs)
{
    int ret;
    ret = pn_init(rs);
    return ret;
}

static int p10_end(struct procRes_s *rs)
{
    int ret;
    ret = pn_end(rs);
    return ret;
}

static int p11_init(struct procRes_s *rs, struct procRes_s *rsd, struct procRes_s *rcmd)
{
    int ret=0;
    ret = pn_init(rs);
    ret |= pn_init(rsd);
    ret |= pn_init(rcmd);
    return ret;
}

static int p11_end(struct procRes_s *rs, struct procRes_s *rsd, struct procRes_s *rcmd)
{
    int ret=0;
    ret = pn_end(rs);
    ret |= pn_end(rsd);
    ret |= pn_end(rcmd);
    return ret;
}

static int p12_init(struct procRes_s *rs)
{
    int ret=0;
    ret = pn_init(rs);
    return ret;
}

static int p12_end(struct procRes_s *rs)
{
    int ret=0;
    ret = pn_end(rs);
    return ret;
}

static int p13_init(struct procRes_s *rs)
{
    int ret;
    ret = pn_init(rs);
    return ret;
}

static int p13_end(struct procRes_s *rs)
{
    int ret;
    ret = pn_end(rs);
    return ret;
}

static int p14_init(struct procRes_s *rs)
{
    int ret;
    ret = pn_init(rs);
    return ret;
}

static int p14_end(struct procRes_s *rs)
{
    int ret;
    ret = pn_end(rs);
    return ret;
}

static int p15_init(struct procRes_s *rs)
{
    int ret;
    ret = pn_init(rs);
    return ret;
}

static int p15_end(struct procRes_s *rs)
{
    int ret;
    ret = pn_end(rs);
    return ret;
}

static int p16_init(struct procRes_s *rs)
{
    int ret;
    ret = pn_init(rs);
    return ret;
}

static int p16_end(struct procRes_s *rs)
{
    int ret;
    ret = pn_end(rs);
    return ret;
}

static int p17_init(struct procRes_s *rs)
{
    int ret;
    ret = pn_init(rs);
    return ret;
}

static int p17_end(struct procRes_s *rs)
{
    int ret;
    ret = pn_end(rs);
    return ret;
}

static int p18_init(struct procRes_s *rs)
{
    int ret;
    ret = pn_init(rs);
    return ret;
}

static int p18_end(struct procRes_s *rs)
{
    int ret;
    ret = pn_end(rs);
    return ret;
}

static int p5_init(struct procRes_s *rs, struct procRes_s *rcmd)
{
    int ret=0;
    ret = pn_init(rs);
    ret |= pn_init(rcmd);
    return ret;
}

static int p5_end(struct procRes_s *rs, struct procRes_s *rcmd)
{
    int ret=0;
    ret = pn_end(rs);
    ret |= pn_end(rcmd);
    return ret;
}

static int p4_init(struct procRes_s *rs)
{
    int ret;
    ret = pn_init(rs);
    return ret;
}

static int p4_end(struct procRes_s *rs)
{
    int ret;
    ret = pn_end(rs);
    return ret;
}

static int p3_init(struct procRes_s *rs)
{
    int ret;
    ret = pn_init(rs);
    return ret;
}

static int p3_end(struct procRes_s *rs)
{
    int ret;
    ret = pn_end(rs);
    return ret;
}

static int p2_init(struct procRes_s *rs)
{
    int ret;
    ret = pn_init(rs);
    return ret;
}

static int p2_end(struct procRes_s *rs)
{
    int ret;
    ret = pn_end(rs);
    return ret;
}

static int p1_init(struct procRes_s *rs, struct procRes_s *rcmd)
{
    int ret=0;
    ret = pn_init(rs);
    ret |= pn_init(rcmd);
    return ret;
}

static int p1_end(struct procRes_s *rs, struct procRes_s *rcmd)
{
    int ret=0;
    ret = pn_end(rs);
    ret |= pn_end(rcmd);
    return ret;
}

static int p0_init(struct mainRes_s *mrs) 
{
    close(mrs->pipedn[0].rt[0]);
    close(mrs->pipedn[1].rt[0]);
    close(mrs->pipedn[2].rt[0]);
    close(mrs->pipedn[3].rt[0]);
    close(mrs->pipedn[4].rt[0]);
    
    close(mrs->pipeup[0].rt[1]);
    close(mrs->pipeup[1].rt[1]);
    close(mrs->pipeup[2].rt[1]);
    close(mrs->pipeup[3].rt[1]);
    close(mrs->pipeup[4].rt[1]);

    return 0;
}

static int p0_end(struct mainRes_s *mrs)
{
    close(mrs->pipeup[0].rt[0]);
    close(mrs->pipeup[1].rt[0]);
    close(mrs->pipeup[2].rt[0]);
    close(mrs->pipeup[3].rt[0]);
    close(mrs->pipeup[4].rt[0]);

    close(mrs->pipedn[0].rt[1]);
    close(mrs->pipedn[1].rt[1]);
    close(mrs->pipedn[2].rt[1]);
    close(mrs->pipedn[3].rt[1]);
    close(mrs->pipedn[4].rt[1]);

    kill(mrs->sid[0], SIGKILL);
    kill(mrs->sid[1], SIGKILL);
    kill(mrs->sid[2], SIGKILL);
    kill(mrs->sid[3], SIGKILL);
    kill(mrs->sid[4], SIGKILL);

    fclose(mrs->fs);
    munmap(mrs->dataRx.pp[0], 1024*SPI_TRUNK_SZ);
    munmap(mrs->cmdRx.pp[0], 256*SPI_TRUNK_SZ);
    munmap(mrs->cmdTx.pp[0], 256*SPI_TRUNK_SZ);
    return 0;
}

static int aspWaitResult(struct aspWaitRlt_s *tg)
{
    struct mainRes_s *mrs;
    int n, ms, c, pr, ret=0, wcnt=0;
    char ch=0, *rlt=0, dt;

    rlt = tg->wtRlt;
    if (!rlt) return -1;
    mrs = tg->wtMrs;
    if (!mrs) return -2;
    if (tg->wtComp) dt = *rlt;
    pr = tg->wtComp;
    c = tg->wtChan;
    ms = tg->wtMs;
    if (!ms) ms = 3000;

    while (1) {
        n=0; ch=0;
        n = mrs_ipc_get(mrs, &ch, 1, c);
        if (n >0) {
            if (pr) {
                if (ch == dt) {
                    *rlt = ch;
                     goto end;
                }
            } else {
                *rlt = ch;
                 goto end;
            }
        }
/*      
        usleep(ms);
        wcnt++;
        if (wcnt > 1000) {
            return -3;
        }
*/
    }
end:

    //sprintf_f(mrs->log, "wait rlt: %c 0x%.2x\n", ch, ch); 
    //print_f(mrs->plog, "DBG", mrs->log);

    return ret;
}

#define LOG_FUNC_PROCEDURE (0)
static int cmdfunc_upd2host(struct mainRes_s *mrs, char cmd, char *rsp)
{
    char ch=0, param=0, *rlt=0;
    int ret=0, wcnt=0, n=0;
    uint16_t dt16;
    struct info16Bit_s *pkt;
    struct aspWaitRlt_s *pwt;
    if (!mrs) {ret = -1; goto end;}
    pwt = &mrs->wtg;
    pkt = &mrs->mchine.tmp;
    if ((!pwt) || (!pwt->wtRlt) || (!pwt->wtMrs)) {ret = -2; goto end;}
    if (!pkt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}
    if (!rsp) {ret = -5; goto end;}
    
#if LOG_FUNC_PROCEDURE
    sprintf_f(mrs->log, "cmdfunc_upd2host opc:0x%x, dat:0x%x\n", pkt->opcode, pkt->data); 
    print_f(mrs->plog, "DBG", mrs->log);
#endif
    dt16 = pkg_info(pkt);
    abs_info(&mrs->mchine.cur, dt16);

    ch = cmd;
    mrs_ipc_put(mrs, &ch, 1, 6);

    ch = cmd;
    pwt->wtComp = 1;
    *rlt = ch;
    n = aspWaitResult(pwt);
    if (n) {
        ret = (n * 10) -2; /* -32 */
        goto end;
    }
#if LOG_FUNC_PROCEDURE
    sprintf_f(mrs->log, "1.wt get %c\n", *rlt); 
    print_f(mrs->plog, "DBG", mrs->log);
#endif
    pwt->wtComp = 0;
    n = aspWaitResult(pwt);
    if (n) {
        ret = (n * 10) -3;
        goto end; /* -33 */
    }    
    *rsp = *rlt;

/*
    if (*rlt == 0x1) {
        sprintf_f(mrs->log, "succeed:"); 
        print_dbg(mrs->plog, mrs->log, n);
    } else {
        sprintf_f(mrs->log, "failed:"); 
        print_dbg(mrs->plog, mrs->log, n);
    }
*/
    sprintf_f(mrs->log, "result:"); 
    print_dbg(mrs->plog, mrs->log, n);

#if LOG_FUNC_PROCEDURE
    sprintf_f(mrs->log, "2.wt get 0x%x\n", *rlt); 
    print_f(mrs->plog, "DBG", mrs->log);
#endif
    n = mrs_ipc_get(mrs, mrs->log, 256, pwt->wtChan);
    while (n > 0) {
        print_dbg(mrs->plog, mrs->log, n);
        n = mrs_ipc_get(mrs, mrs->log, 256, pwt->wtChan);
    }

    dt16 = pkg_info(&mrs->mchine.get);
    abs_info(pkt, dt16);
#if LOG_FUNC_PROCEDURE
    sprintf_f(mrs->log, "3.wt get pkt op:0x%x, data:0x%x\n", pkt->opcode, pkt->data); 
    print_f(mrs->plog, "DBG", mrs->log);
#endif
end:

    return ret;
}

static int cmdfunc_wt_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, err=0, upd=0, brk=0, pass=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_wt_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = cmdfunc_upd2host(mrs, 'r', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }

    struct aspConfig_s* ctb = 0;
    for (ix = 0; ix < ASPOP_CODE_MAX; ix++) {
        ctb = &mrs->configTable[ix];
        if (!ctb) {ret = -5; goto end;}
        if (ctb->opStatus & ASPOP_STA_CON) {
            n = 0; rsp = 0;
            /* set data for update to scanner */
            pkt->opcode = ctb->opCode;
            pkt->data = ctb->opValue;
            n = cmdfunc_upd2host(mrs, 't', &rsp);
            if ((n == -32) || (n == -33)) {
                brk = 1;
                goto end;
            }
            
            if ((!n) && (rsp == 0x1) && (pkt->opcode == ctb->opCode) && (pkt->data == ctb->opValue)) {
            #if 0 /* remove for FPGA developing need */
                ctb->opStatus = ASPOP_STA_UPD; 
            #endif
                pass++;
            } else {
                /*
                sprintf_f(mrs->log, "<err++, n=%d rsp=%d opc:0x%x dat:0x%x>", n, rsp, pkt->opcode, pkt->data); 
                print_dbg(mrs->plog, mrs->log, 0);
                */
                sprintf_f(mrs->log, "err++, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
                print_f(mrs->plog, "DBG", mrs->log);

                err++;
            }
            upd++;
        }
        ctb = 0;
    }

    sprintf_f(mrs->log, "cmdfunc_wt_opcode total do:%d error:%d \n", upd, err); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    if (brk | ret | err) {
        sprintf(mrs->log, "wt_NG,error:%d,pass:%d,break:%d,ret:%d", err, pass, brk,ret);
    } else {
        sprintf(mrs->log, "wt_PASS,error:%d,pass:%d,break:%d,ret:%d", err, pass, brk,ret);
    }
/*
    if (brk) {
        n = 0; rsp = 0;
        n = cmdfunc_upd2host(mrs, 'r', &rsp);
        sprintf(mrs->log, "failed:do=%d, error=%d ret=%d brk=%d n=%d rsp=0x%x", upd, err, ret, brk, n, rsp);
    } else if ((ret) || (err)) {
        sprintf(mrs->log, "failed:do=%d, error=%d ret=%d", upd, err, ret);         
    } else {
        sprintf(mrs->log, "succeed:do=%d, error=%d ret=%d", upd, err, ret);         
    }
 */

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_lh_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_lh_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_SINGLE;
    pkt->data = SINSCAN_DUAL_STRM;
    n = cmdfunc_upd2host(mrs, 'd', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) && (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
    }

    sprintf_f(mrs->log, "cmdfunc_lh_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    if (brk | ret) {
        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }
/*
    if (brk) {
        n = 0; rsp = 0;
        n = cmdfunc_upd2host(mrs, 'r', &rsp);
        sprintf(mrs->log, "failed:do=%d, error=%d ret=%d brk=%d n=%d rsp=0x%x", upd, err, ret, brk, n, rsp);
    } else if ((ret) || (err)) {
        sprintf(mrs->log, "failed:do=%d, error=%d ret=%d", upd, err, ret);         
    } else {
        sprintf(mrs->log, "succeed:do=%d, error=%d ret=%d", upd, err, ret);         
    }
 */

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    
    printf_dbgflush(mrs->plog, mrs, argc);

    printf_flush(mrs->plog, mrs->flog);
    
    return ret;
}

static int cmdfunc_go_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_act_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_SINGLE;
    pkt->data = SINSCAN_DUAL_STRM;

    clock_gettime(CLOCK_REALTIME, &mrs->time[0]);

    sprintf(mrs->log, "=====[_DOUBLE_SCAN_] BEG=====");
    dbgShowTimeStamp(mrs->log, mrs, NULL, 2, mrs->log);
    
    n = cmdfunc_upd2host(mrs, 'n', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) && (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
    }

    sprintf_f(mrs->log, "cmdfunc_act_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    sprintf(mrs->log, "=====[_DOUBLE_SCAN_] END=====");     
    dbgShowTimeStamp(mrs->log, mrs, NULL, 2, mrs->log);

    if (brk | ret) {
        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_act_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct aspConfig_s* ctb = 0;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_go_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    ctb = &mrs->configTable[ASPOP_ACTION];
    
    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = ctb->opCode;
    pkt->data = ctb->opValue;
    
    n = cmdfunc_upd2host(mrs, 't', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) && (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
    }

    sprintf_f(mrs->log, "cmdfunc_act_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    if (brk | ret) {
        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_op1_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_go_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_ACTION;
    pkt->data = ACTION_OPTION_01;
    n = cmdfunc_upd2host(mrs, 't', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) && (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
    }

    sprintf_f(mrs->log, "cmdfunc_act_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    if (brk | ret) {
        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_op2_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_go_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_ACTION;
    pkt->data = ACTION_OPTION_02;
    n = cmdfunc_upd2host(mrs, 't', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) && (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
    }

    sprintf_f(mrs->log, "cmdfunc_act_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    if (brk | ret) {
        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_op3_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_go_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_ACTION;
    pkt->data = ACTION_OPTION_03;
    n = cmdfunc_upd2host(mrs, 't', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) && (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
    }

    sprintf_f(mrs->log, "cmdfunc_act_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    if (brk | ret) {
        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_op4_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_go_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_ACTION;
    pkt->data = ACTION_OPTION_04;
    n = cmdfunc_upd2host(mrs, 't', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) && (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
    }

    sprintf_f(mrs->log, "cmdfunc_act_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    if (brk | ret) {
        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_op5_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_go_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_ACTION;
    pkt->data = ACTION_OPTION_05;
    n = cmdfunc_upd2host(mrs, 't', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) && (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
    }

    sprintf_f(mrs->log, "cmdfunc_act_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    if (brk | ret) {
        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_sdon_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_sdon_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_SINGLE;
    pkt->data = SINSCAN_SD_ONLY;
    n = cmdfunc_upd2host(mrs, 'g', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) && (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
    }

    sprintf_f(mrs->log, "cmdfunc_sdon_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    if (brk | ret) {
        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_wfisd_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_wfisd_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_SINGLE;
    pkt->data = SINSCAN_WIFI_SD;

    clock_gettime(CLOCK_REALTIME, &mrs->time[0]);

    sprintf(mrs->log, "=====_SINGLE_SCAN_SD_ BEG=====");     
    dbgShowTimeStamp(mrs->log, mrs, NULL, 2, mrs->log);
    
    n = cmdfunc_upd2host(mrs, 'i', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) && (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
    }

    sprintf_f(mrs->log, "cmdfunc_wfisd_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    sprintf(mrs->log, "=====_SINGLE_SCAN_SD_ END=====");     
    dbgShowTimeStamp(mrs->log, mrs, NULL, 2, mrs->log);

    if (brk | ret) {
        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_dulsd_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_dulsd_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_SINGLE;
    pkt->data = SINSCAN_DUAL_SD;
    
    n = cmdfunc_upd2host(mrs, 'j', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) && (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
    }

    sprintf_f(mrs->log, "cmdfunc_dulsd_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    if (brk | ret) {
        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_tgr_opcode(int argc, char *argv[])
{
    int val=0;
    int n=0, ix=0, ret=0;
    char ch=0, opcode[5], param=0;
    uint32_t tg=0, cd=0;
    struct aspConfig_s *ctb = 0, *pct = 0;
    struct mainRes_s *mrs=0;
    
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}

    pct = mrs->configTable;
    
    sprintf_f(mrs->log, "cmdfunc_tgr_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);
    /* get opcode and parameter */
    ch = 'o';
    mrs_ipc_put(mrs, &ch, 1, 5);

    n = -1;
    while (n == -1) {
        n = mrs_ipc_get(mrs, opcode, 5, 5);
        //sprintf_f(mrs->log, "n:%d\n", n); 
        //print_f(mrs->plog, "DBG", mrs->log);
    }

    /* debug print */ 
    /*
    for (ix = 0; ix < n; ix++) {
        sprintf_f(mrs->log, "%d.%.2x\n", ix, opcode[ix]); 
        print_f(mrs->plog, "DBG", mrs->log);
    }
    */

    if (n != 5) {ret = -2; goto end;}
    if ((opcode[0] != 0xaa) && (opcode[0] != 0xad)) {ret = -3; goto end;}
    if (opcode[4] != 0xa5) {ret = -4; goto end;}
    if (opcode[2] != '/') {ret = -5; goto end;}

    tg = opcode[1];
/*
    for (ix = 0; ix < ASPOP_CODE_MAX; ix++) {
        ctb = pct[ix];
        if (tg == ctb->opCode) {
            break;
        }
        ctb = 0;
    }
*/
    switch (tg) {
        case OP_SINGLE:
        case OP_MSINGLE:
        case OP_HANDSCAN:
        case OP_NOTESCAN:
            ctb = &pct[ASPOP_SCAN_SINGLE];
            ctb->opCode = tg;
            break;
        case OP_DOUBLE:
        case OP_MDOUBLE:
            ctb = &pct[ASPOP_SCAN_DOUBLE];
            ctb->opCode = tg;
            break;
        case OP_ACTION:
            ctb = &pct[ASPOP_ACTION];
            break;
        default:
            ctb = 0;
            break;
    }

    if (!ctb) {
        sprintf_f(mrs->log, "cmdfunc_tgr_opcode - 3\n"); 
        print_f(mrs->plog, "DBG", mrs->log);
        ret = -7;
        goto end;
    }

    if (opcode[0] == 0xaa) {
        cd = opcode[3];

        if (cd == ctb->opValue) {
            ctb->opStatus |= ASPOP_STA_WR;
            param = ctb->opValue;
            goto end;
        }

        ret = cmdfunc_opchk_single(cd, ctb->opMask, ctb->opBitlen, ctb->opType);
        if (ret < 0) {
            ret = (ret * 10) -6;
        } else {            
            ctb->opValue = cd;
            ctb->opStatus |= ASPOP_STA_WR;
        }
        
        sprintf_f(mrs->log, "WT opcode 0x%.2x/0x%.2x, input value: 0x%.2x, ret:%d\n", ctb->opCode, ctb->opValue, cd, ret); 
        print_f(mrs->plog, "DBG", mrs->log);
    } else {
        sprintf_f(mrs->log, "RD opcode 0x%.2x/0x%.2x, input value: 0x%.2x, ret:%d\n", ctb->opCode, ctb->opValue, cd, ret); 
        print_f(mrs->plog, "DBG", mrs->log);
    }

    msync(pct, ASPOP_CODE_MAX * sizeof(struct aspConfig_s), MS_SYNC);
    
    param = ctb->opValue;

end:

    if (ret < 0) {
        ch = 'x';
        mrs_ipc_put(mrs, &ch, 1, 5);
        ch = 0xf0;
        mrs_ipc_put(mrs, &ch, 1, 5);

        if (!ctb) {
            sprintf(mrs->log, "failed: input 0x%x/0x%x, ret:%d", opcode[1], opcode[3], ret); 
        } else {
            sprintf(mrs->log, "failed: input 0x%x/0x%x, mask:0x%x, bitlen:%d, ret:%d", opcode[1], opcode[3], ctb->opMask, ctb->opBitlen, ret); 
        }

    } else {
        if (ret == 0) {
            ch = 'p';
            mrs_ipc_put(mrs, &ch, 1, 5);

            sprintf(mrs->log, "succeed: same result 0x%x/0x%x, ret: %d", ctb->opCode, ctb->opValue, ret);   
        } else {
            ch = 'p';
            mrs_ipc_put(mrs, &ch, 1, 5);

            sprintf(mrs->log, "succeed: result 0x%x/0x%x, ret: %d", ctb->opCode, ctb->opValue, ret);    
        } 
        mrs_ipc_put(mrs, &param, 1, 5);     
    }
    n = strlen(mrs->log);
    mrs_ipc_put(mrs, mrs->log, n, 5);
    
    sprintf_f(mrs->log, "opcode op end, log n =%d, ret=%d\n", n, ret); 
    print_f(mrs->plog, "DBG", mrs->log);
    
    return 0;
}

static int cmdfunc_mdouble_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0, ch=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct aspConfig_s* ctb = 0;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_mdouble_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_MDOUBLE;
    pkt->data = SINSCAN_DUAL_STRM;
    
    /* refresh status */
    ctb = &mrs->configTable[ASPOP_SCAN_DOUBLE];
    ctb->opStatus |= ASPOP_STA_WR;
    
    ret = cfgTableSet(mrs->configTable, ASPOP_MULTI_LOOP, 1);
    if (ret < 0) {
        sprintf_f(mrs->log, "Error!!! msingle set ASPOP_MULTI_LOOP failed !!! ret:%d\n", ret); 
        print_f(mrs->plog, "DBG", mrs->log);
    }
    
    clock_gettime(CLOCK_REALTIME, &mrs->time[0]);

    sprintf(mrs->log, "=====[_DOUBLE_SCAN_] BEG=====");
    dbgShowTimeStamp(mrs->log, mrs, NULL, 2, mrs->log);
    
    #if USB_META
    n = cmdfunc_upd2host(mrs, 'C', &rsp);
    #else
    n = cmdfunc_upd2host(mrs, 'n', &rsp);
    #endif
    
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) || (rsp != 0x1)) {
         sprintf_f(mrs->log, "break loop!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
         ret = -1;
    }

    sprintf_f(mrs->log, "cmdfunc_mdouble_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    sprintf(mrs->log, "=====[_DOUBLE_SCAN_] END=====");     
    dbgShowTimeStamp(mrs->log, mrs, NULL, 2, mrs->log);

    if (brk | ret) {
        ch = 'e';
        mrs_ipc_put(mrs, &ch, 1, 5);

        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        ch = 'd';
        mrs_ipc_put(mrs, &ch, 1, 5);

        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_msingle_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0, ch=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct aspConfig_s* ctb = 0;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_msingle_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_MSINGLE;
    pkt->data = SINSCAN_WIFI_ONLY;

    /* refresh status */
    ctb = &mrs->configTable[ASPOP_SCAN_SINGLE];
    ctb->opStatus |= ASPOP_STA_WR;
    
    ret = cfgTableSet(mrs->configTable, ASPOP_MULTI_LOOP, 1);
    if (ret < 0) {
        sprintf_f(mrs->log, "Error!!! msingle set ASPOP_MULTI_LOOP failed !!! ret:%d\n", ret); 
        print_f(mrs->plog, "DBG", mrs->log);
    }
    
    clock_gettime(CLOCK_REALTIME, &mrs->time[0]);

    sprintf(mrs->log, "=====_SINGLE_SCAN_ BEG=====");     
    dbgShowTimeStamp(mrs->log, mrs, NULL, 2, mrs->log);

    #if USB_META
    n = cmdfunc_upd2host(mrs, 'B', &rsp);
    #else
    n = cmdfunc_upd2host(mrs, 's', &rsp);
    #endif
    
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) || (rsp != 0x1)) {
         sprintf_f(mrs->log, "break loop!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
         ret = -1;
    }

    sprintf_f(mrs->log, "cmdfunc_msingle_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
    
end:

    sprintf(mrs->log, "=====_SINGLE_SCAN_ END=====");     
    dbgShowTimeStamp(mrs->log, mrs, NULL, 2, mrs->log);

    if (brk | ret) {
        ch = 'e';
        mrs_ipc_put(mrs, &ch, 1, 5);

        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        ch = 'd';
        mrs_ipc_put(mrs, &ch, 1, 5);

        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }
    
    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);

    printf_dbgflush(mrs->plog, mrs, argc);

    printf_flush(mrs->plog, mrs->flog);    
    
    return ret;
}

static int cmdfunc_mocr_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0, ch=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct aspConfig_s* ctb = 0;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_mocr_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_NOTESCAN;
    pkt->data = NOTESCAN_OPTION_01;

    /* refresh status */
    ctb = &mrs->configTable[ASPOP_SCAN_SINGLE];
    ctb->opStatus |= ASPOP_STA_WR;
    ctb->opCode = OP_NOTESCAN;

    clock_gettime(CLOCK_REALTIME, &mrs->time[0]);

    sprintf(mrs->log, "=====_SINGLE_SCAN_ BEG=====");     
    dbgShowTimeStamp(mrs->log, mrs, NULL, 2, mrs->log);
    
    n = cmdfunc_upd2host(mrs, '3', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) || (rsp != 0x1)) {
         sprintf_f(mrs->log, "break loop!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
         ret = -1;
    }

    sprintf_f(mrs->log, "cmdfunc_msingle_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
    
end:

    sprintf(mrs->log, "=====_SINGLE_SCAN_ END=====");     
    dbgShowTimeStamp(mrs->log, mrs, NULL, 2, mrs->log);

    if (brk | ret) {
        ch = 'e';
        mrs_ipc_put(mrs, &ch, 1, 5);

        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        ch = 'd';
        mrs_ipc_put(mrs, &ch, 1, 5);

        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }
    
    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);

    printf_dbgflush(mrs->plog, mrs, argc);

    printf_flush(mrs->plog, mrs->flog);    
    
    return ret;
}

static int cmdfunc_fmt128g_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_fmt128g_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_RGRD;
    pkt->data = 0;
    n = cmdfunc_upd2host(mrs, '7', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) || (rsp != 0x4)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
         ret = -5;
    }

    sprintf_f(mrs->log, "cmdfunc_fmt128g_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
    
end:

    if (brk | ret) {
        sprintf(mrs->log, "FMT128G_NG,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "FMT128G_OK,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_fmt64g_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_fmt64g_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_RGRD;
    pkt->data = 0;
    n = cmdfunc_upd2host(mrs, '6', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) || (rsp != 0x4)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
         ret = -5;
    }

    sprintf_f(mrs->log, "cmdfunc_fmt64g_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
    
end:

    if (brk | ret) {
        sprintf(mrs->log, "FMT64G_NG,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "FMT64G_OK,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_fmt16g_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_fmt16g_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_RGRD;
    pkt->data = 0;
    n = cmdfunc_upd2host(mrs, '5', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) || (rsp != 0x4)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
         ret = -5;
    }

    sprintf_f(mrs->log, "cmdfunc_fmt16g_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
    
end:

    if (brk | ret) {
        sprintf(mrs->log, "FMT16G_NG,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "FMT16G_OK,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_fmt32g_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_fmt32g_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_RGRD;
    pkt->data = 0;
    n = cmdfunc_upd2host(mrs, '4', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) || (rsp != 0x4)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
         ret = -5;
    }

    sprintf_f(mrs->log, "cmdfunc_fmt32g_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
    
end:

    if (brk | ret) {
        sprintf(mrs->log, "FMT32G_NG,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "FMT32G_OK,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_ocr_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0, ch=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct aspConfig_s* ctb = 0;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_ocr_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;

    /* set data for update to scanner */
    pkt->opcode = OP_NOTESCAN;
    pkt->data = SINSCAN_WIFI_ONLY;

    /* refresh status */
    ctb = &mrs->configTable[ASPOP_SCAN_SINGLE];
    ctb->opStatus |= ASPOP_STA_WR;

    clock_gettime(CLOCK_REALTIME, &mrs->time[0]);

    sprintf(mrs->log, "=====_SINGLE_SCAN_ BEG=====");     
    dbgShowTimeStamp(mrs->log, mrs, NULL, 2, mrs->log);
    
    n = cmdfunc_upd2host(mrs, '3', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if (rsp != 0x1) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
         ret = -1;
    }

    sprintf_f(mrs->log, "cmdfunc_ocr_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    sprintf(mrs->log, "=====_SINGLE_SCAN_ END=====");     
    dbgShowTimeStamp(mrs->log, mrs, NULL, 2, mrs->log);

    if (brk | ret) {
        sprintf(mrs->log, "OCR_NG,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "OCR_OK,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);
    printf_flush(mrs->plog, mrs->flog);    
    
    return ret;
}

static int cmdfunc_upsd_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0, ch=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_upsd_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_RAW;
    pkt->data = 0;

    clock_gettime(CLOCK_REALTIME, &mrs->time[0]);

    sprintf(mrs->log, "=====_UPLOAD_SD_ BEG=====");
    dbgShowTimeStamp(mrs->log, mrs, NULL, 2, mrs->log);
    
    n = cmdfunc_upd2host(mrs, '2', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if (rsp != 0x1) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
         ret = -1;
    }

    sprintf_f(mrs->log, "cmdfunc_upsd_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    sprintf(mrs->log, "=====_UPLOAD_SD_ END=====");
    dbgShowTimeStamp(mrs->log, mrs, NULL, 2, mrs->log);

    if (brk | ret) {
        sprintf(mrs->log, "UPSD_NG,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "UPSD_OK,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_gosd_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0, ch=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_gosd_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_RAW;
    pkt->data = 0;

    clock_gettime(CLOCK_REALTIME, &mrs->time[0]);

    sprintf(mrs->log, "=====_DOUBLE_SCAN_SD_ BEG=====");
    dbgShowTimeStamp(mrs->log, mrs, NULL, 2, mrs->log);
    
    n = cmdfunc_upd2host(mrs, 'n', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if (rsp != 0x2) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
         ret = -1;
    }

    sprintf_f(mrs->log, "cmdfunc_gosd_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    sprintf(mrs->log, "=====_DOUBLE_SCAN_SD_ END=====");
    dbgShowTimeStamp(mrs->log, mrs, NULL, 2, mrs->log);

    if (brk | ret) {
        sprintf(mrs->log, "GOSD_NG,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "GOSD_OK,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_raw_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0, ch=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_raw_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_RAW;
    pkt->data = 0;
    n = cmdfunc_upd2host(mrs, 'l', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if (rsp != 0x1) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
         ret = -1;
    }

    sprintf_f(mrs->log, "cmdfunc_raw_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    if (brk | ret) {
        sprintf(mrs->log, "RAW_NG,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "RAW_OK,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_scango_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0, ch=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_scango_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    n = cmdfunc_upd2host(mrs, 'z', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if (rsp != 0x1) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
         ret = -1;
    }

    sprintf_f(mrs->log, "cmdfunc_scango_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    if (brk | ret) {
        sprintf(mrs->log, "SCANGO_NG,%d,%d", ret, brk);
        ch = 'z';
    } else {
        sprintf(mrs->log, "SCANGO_OK,%d,%d", ret, brk);
        ch = 'Z';
    }
    
    mrs_ipc_put(mrs, &ch, 1, 5);

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_meta_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_meta_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_META_DAT;
    pkt->data = ASPMETA_POWON_INIT;

    clock_gettime(CLOCK_REALTIME, &mrs->time[0]);
    
    n = cmdfunc_upd2host(mrs, 'y', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) || (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
         ret = -5;
    }

    sprintf_f(mrs->log, "cmdfunc_meta_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    if (brk | ret) {
        sprintf(mrs->log, "META_NG,%d,%d", ret, brk);
        //print_f(mrs->plog, "DBG", mrs->log);
    } else {
        sprintf(mrs->log, "META_OK,%d,%d", ret, brk);
        //print_f(mrs->plog, "DBG", mrs->log);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_apm_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    struct aspConfig_s* ctb = 0;

    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_ap_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    ctb = &mrs->configTable[ASPOP_AP_MODE];
    
    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}


    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_SINGLE;
    pkt->data = SINSCAN_DUAL_SD;

    ctb->opValue = APM_AP;
    ctb->opStatus = ASPOP_STA_APP;
    
    n = cmdfunc_upd2host(mrs, 'r', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
    
    n = cmdfunc_upd2host(mrs, 'q', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) && (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
    }

    sprintf_f(mrs->log, "cmdfunc_ap_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    if (brk | ret) {
        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_vector_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_vector_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_SINGLE;
    pkt->data = SINSCAN_DUAL_SD;
    n = cmdfunc_upd2host(mrs, 'o', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) && (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
    }

    sprintf_f(mrs->log, "cmdfunc_vector_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    if (brk | ret) {
        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_crop_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_crop_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_SINGLE;
    pkt->data = SINSCAN_DUAL_SD;
    n = cmdfunc_upd2host(mrs, 'm', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) && (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
    }

    sprintf_f(mrs->log, "cmdfunc_dulsd_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    if (brk | ret) {
        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_regw_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_go_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_RGWT;
    pkt->data = 0;
    n = cmdfunc_upd2host(mrs, 'e', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) && (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
    }

    sprintf_f(mrs->log, "cmdfunc_act_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    if (brk | ret) {
        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_regr_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_go_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_RGRD;
    pkt->data = 0;
    n = cmdfunc_upd2host(mrs, 'f', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) && (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
    }

    sprintf_f(mrs->log, "cmdfunc_act_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
end:

    if (brk | ret) {
        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_usbbknote_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_usbbknote_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    //clock_gettime(CLOCK_REALTIME, &mrs->time[0]);

    //sprintf(mrs->log, "=====[_USB_SCAN_] BEG=====");
    //dbgShowTimeStamp(mrs->log, mrs, NULL, 2, mrs->log);

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_RGRD;
    pkt->data = 0;
    n = cmdfunc_upd2host(mrs, 'D', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) || (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
         ret = -5;
    }

    sprintf_f(mrs->log, "cmdfunc_usbbknote_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
    
end:

    //sprintf(mrs->log, "=====[_USB_SCAN_] END=====");
    //dbgShowTimeStamp(mrs->log, mrs, NULL, 2, mrs->log);
    
    if (brk | ret) {
        sprintf(mrs->log, "USBBNSCAN_NG,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "USBBNSCAN_OK,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_wusingle_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_wusingle_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_RGRD;
    pkt->data = 0;
    n = cmdfunc_upd2host(mrs, 'A', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) || (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
         ret = -5;
    }

    sprintf_f(mrs->log, "cmdfunc_wusingle_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
    
end:

    if (brk | ret) {
        sprintf(mrs->log, "WUSINGLE_NG,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "WUSINGLE_OK,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_usbscan_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_usbscan_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    //clock_gettime(CLOCK_REALTIME, &mrs->time[0]);

    //sprintf(mrs->log, "=====[_USB_SCAN_] BEG=====");
    //dbgShowTimeStamp(mrs->log, mrs, NULL, 2, mrs->log);

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_RGRD;
    pkt->data = 0;
    n = cmdfunc_upd2host(mrs, '0', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) || (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
         ret = -5;
    }

    sprintf_f(mrs->log, "cmdfunc_usbscan_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
    
end:

    //sprintf(mrs->log, "=====[_USB_SCAN_] END=====");
    //dbgShowTimeStamp(mrs->log, mrs, NULL, 2, mrs->log);
    
    if (brk | ret) {
        sprintf(mrs->log, "USBSCAN_NG,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "USBSCAN_OK,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_crtfdr_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_crtfdr_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_RGRD;
    pkt->data = 0;
    n = cmdfunc_upd2host(mrs, '9', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) || (rsp != 0x4)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
         ret = -5;
    }

    sprintf_f(mrs->log, "cmdfunc_crtfdr_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
    
end:

    if (brk | ret) {
        sprintf(mrs->log, "CRTFDR_NG,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "CRTFDR_OK,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_reboot_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_reboot_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_RGRD;
    pkt->data = 0;
    n = cmdfunc_upd2host(mrs, '8', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) || (rsp != 0x4)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
         ret = -5;
    }

    sprintf_f(mrs->log, "cmdfunc_reboot_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
    
end:

    if (brk | ret) {
        sprintf(mrs->log, "REBOOT_NG,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "REBOOT_OK,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_boot_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_boot_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_RGRD;
    pkt->data = 0;
    n = cmdfunc_upd2host(mrs, 'b', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) || (rsp != 0x4)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
         ret = -5;
    }

    sprintf_f(mrs->log, "cmdfunc_boot_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
    
end:

    if (brk | ret) {
        sprintf(mrs->log, "BOOT_NG,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "BOOT_OK,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_single_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_single_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_SINGLE;
    pkt->data = SINSCAN_WIFI_ONLY;

    ret = cfgTableSet(mrs->configTable, ASPOP_MULTI_LOOP, 0);
    if (ret < 0) {
        sprintf_f(mrs->log, "Error!!! set ASPOP_MULTI_LOOP failed !!! ret:%d\n", ret); 
        print_f(mrs->plog, "DBG", mrs->log);
    }
    
    clock_gettime(CLOCK_REALTIME, &mrs->time[0]);

    sprintf(mrs->log, "=====_SINGLE_SCAN_ BEG=====");     
    dbgShowTimeStamp(mrs->log, mrs, NULL, 2, mrs->log);
    
    n = cmdfunc_upd2host(mrs, 's', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) && (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
    }

    sprintf_f(mrs->log, "cmdfunc_single_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
    
end:

    sprintf(mrs->log, "=====_SINGLE_SCAN_ END=====");     
    dbgShowTimeStamp(mrs->log, mrs, NULL, 2, mrs->log);

    if (brk | ret) {
        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }
    
    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);

    printf_dbgflush(mrs->plog, mrs, argc);

    printf_flush(mrs->plog, mrs->flog);    
    
    return ret;
}

static int cmdfunc_dnld_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_dnld_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_SINGLE;
    pkt->data = SINSCAN_WIFI_ONLY;
    n = cmdfunc_upd2host(mrs, 'h', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) && (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
    }

    sprintf_f(mrs->log, "cmdfunc_dnld_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
    
end:

    if (brk | ret) {
        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_upld_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_upld_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_SINGLE;
    pkt->data = SINSCAN_WIFI_ONLY;

    #if 1 /* 0: test fat folder creating */
    n = cmdfunc_upd2host(mrs, 'u', &rsp);
    #else
    n = cmdfunc_upd2host(mrs, '9', &rsp);
    #endif
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) && (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
    }

    sprintf_f(mrs->log, "cmdfunc_upld_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
    
end:

    if (brk | ret) {
        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_save_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_upld_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_SINGLE;
    pkt->data = SINSCAN_WIFI_ONLY;
    n = cmdfunc_upd2host(mrs, 'v', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) && (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
    }

    sprintf_f(mrs->log, "cmdfunc_upld_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
    
end:

    if (brk | ret) {
        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_free_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_free_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_SINGLE;
    pkt->data = SINSCAN_WIFI_ONLY;
    n = cmdfunc_upd2host(mrs, 'c', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) && (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
    }

    sprintf_f(mrs->log, "cmdfunc_upld_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
    
end:

    if (brk | ret) {
        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_used_opcode(int argc, char *argv[])
{
    char *rlt=0, rsp=0;
    int ret=0, ix=0, n=0, brk=0;
    struct aspWaitRlt_s *pwt;
    struct info16Bit_s *pkt;
    struct mainRes_s *mrs=0;
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_used_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);

    pkt = &mrs->mchine.tmp;
    pwt = &mrs->wtg;
    if (!pkt) {ret = -2; goto end;}
    if (!pwt) {ret = -3; goto end;}
    rlt = pwt->wtRlt;
    if (!rlt) {ret = -4; goto end;}

    /* set wait result mechanism */
    pwt->wtChan = 6;
    pwt->wtMs = 300;

    n = 0; rsp = 0;
    /* set data for update to scanner */
    pkt->opcode = OP_SINGLE;
    pkt->data = SINSCAN_WIFI_ONLY;
    n = cmdfunc_upd2host(mrs, 'k', &rsp);
    if ((n == -32) || (n == -33)) {
        brk = 1;
        goto end;
    }
        
    if ((n) && (rsp != 0x1)) {
         sprintf_f(mrs->log, "ERROR!!, n=%d rsp=%d opc:0x%x dat:0x%x\n", n, rsp, pkt->opcode, pkt->data); 
         print_f(mrs->plog, "DBG", mrs->log);
    }

    sprintf_f(mrs->log, "cmdfunc_upld_opcode n = %d, rsp = %d\n", n, rsp); 
    print_f(mrs->plog, "DBG", mrs->log);
    
end:

    if (brk | ret) {
        sprintf(mrs->log, "E,%d,%d", ret, brk);
    } else {
        sprintf(mrs->log, "D,%d,%d", ret, brk);
    }

    n = strlen(mrs->log);
    print_dbg(mrs->plog, mrs->log, n);
    printf_dbgflush(mrs->plog, mrs, argc);

    return ret;
}

static int cmdfunc_opchk_single(uint32_t val, uint32_t mask, int len, int type)
{
    int cnt=0, s=0;
    if (val > mask) return -1;
    if (len > 32) return -2;
    if (!len) return -3;

    if (type != ASPOP_TYPE_SINGLE) {
        if (val > mask) {
            return -4;
        }
        return 1;
    }
    
    s = 0;
    while(s < len) {
        if (val & (0x1 << s)) cnt++;
        s++;
    }

    if (cnt == 0) return -5;
    if (cnt > 1) return -6;

    return 2;
}
static int cmdfunc_opcode(int argc, char *argv[])
{
    int val=0;
    int n=0, ix=0, ret=0;
    char ch=0, opcode[5], param=0;
    uint32_t tg=0, cd=0;
    struct mainRes_s *mrs=0;
    struct aspConfig_s* ctb = 0;
    
    mrs = (struct mainRes_s *)argv[0];
    if (!mrs) {ret = -1; goto end;}
    sprintf_f(mrs->log, "cmdfunc_opcode argc:%d\n", argc); 
    print_f(mrs->plog, "DBG", mrs->log);
    /* get opcode and parameter */
    ch = 'o';
    mrs_ipc_put(mrs, &ch, 1, 5);

    n = -1;
    while (n == -1) {
        n = mrs_ipc_get(mrs, opcode, 5, 5);
        //sprintf_f(mrs->log, "n:%d\n", n); 
        //print_f(mrs->plog, "DBG", mrs->log);
    }

    /* debug print */ 
    /*
    for (ix = 0; ix < n; ix++) {
        sprintf_f(mrs->log, "%d.%.2x\n", ix, opcode[ix]); 
        print_f(mrs->plog, "DBG", mrs->log);
    }
    */

    if (n != 5) {ret = -2; goto end;}
    if ((opcode[0] != 0xaa) && (opcode[0] != 0xad)) {ret = -3; goto end;}
    if (opcode[4] != 0xa5) {ret = -4; goto end;}
    if (opcode[2] != '/') {ret = -5; goto end;}

    tg = opcode[1];

    for (ix = 0; ix < ASPOP_CODE_MAX; ix++) {
        ctb = &mrs->configTable[ix];
        if (tg == ctb->opCode) {
        
            //sprintf_f(mrs->log, "found!!! [%d] [0x%x] [0x%x] [0x%x] \n", ix, ctb->opCode, ctb->opValue, ctb->opStatus); 
            //print_f(mrs->plog, "DBG", mrs->log);

            break;
        }
        ctb = 0;
    }

    if (!ctb) {
        sprintf_f(mrs->log, "Error!!! cmdfunc_opcode - 3\n"); 
        print_f(mrs->plog, "DBG", mrs->log);
        ret = -7;
        goto end;
    }

    if (opcode[0] == 0xaa) {
        cd = opcode[3];

        if (cd == ctb->opValue) {
            ctb->opStatus |= ASPOP_STA_CON;
            param = ctb->opValue;
            goto end;
        }

        ret = cmdfunc_opchk_single(cd, ctb->opMask, ctb->opBitlen, ctb->opType);
        if (ret < 0) {
            ret = (ret * 10) -6;
        } else {            
            ctb->opValue = cd;
            ctb->opStatus |= ASPOP_STA_CON;
        }
        
        sprintf_f(mrs->log, "WT opcode 0x%.2x/0x%.2x, input value: 0x%.2x, ret:%d\n", ctb->opCode, ctb->opValue, cd, ret); 
        print_f(mrs->plog, "DBG", mrs->log);
    } else {
        sprintf_f(mrs->log, "RD opcode 0x%.2x/0x%.2x, input value: 0x%.2x, ret:%d\n", ctb->opCode, ctb->opValue, cd, ret); 
        print_f(mrs->plog, "DBG", mrs->log);
    }

    param = ctb->opValue;

end:

    if (ret < 0) {
        ch = 'x';
        mrs_ipc_put(mrs, &ch, 1, 5);
        ch = 0xf0;
        mrs_ipc_put(mrs, &ch, 1, 5);

        if (!ctb) {
            sprintf(mrs->log, "failed: input 0x%x/0x%x, ret:%d", opcode[1], opcode[3], ret); 
        } else {
            sprintf(mrs->log, "failed: input 0x%x/0x%x, mask:0x%x, bitlen:%d, ret:%d", opcode[1], opcode[3], ctb->opMask, ctb->opBitlen, ret); 
        }

    } else {
        if (ret == 0) {
            ch = 'p';
            mrs_ipc_put(mrs, &ch, 1, 5);

            sprintf(mrs->log, "same: result 0x%x/0x%x, ret: %d", ctb->opCode, ctb->opValue, ret);   
        } else {
            ch = 'p';
            mrs_ipc_put(mrs, &ch, 1, 5);

            sprintf(mrs->log, "succeed: result 0x%x/0x%x, ret: %d", ctb->opCode, ctb->opValue, ret);    
        } 
        mrs_ipc_put(mrs, &param, 1, 5);     
    }
    n = strlen(mrs->log);
    mrs_ipc_put(mrs, mrs->log, n, 5);
    
    sprintf_f(mrs->log, "opcode op end, log n =%d, ret=%d\n", n, ret); 
    print_f(mrs->plog, "DBG", mrs->log);
    
    return 0;
}

static int cmdfunc_01(int argc, char *argv[])
{
    struct mainRes_s *mrs;
    char str[256], ch;
    if (!argv) return -1;

    mrs = (struct mainRes_s *)argv[0];

    ch = '=';

    if (argc == 7) {
        ch = 'd';
    }

    else if (argc == 6) {
        ch = 'r';
    }
    
    else if (argc == 0) {
        ch = 'p';
    }

    else if (argc == 5) {
        ch = 'n';
    }

    sprintf_f(str, "cmdfunc_01 argc:%d ch:%c\n", argc, ch); 
    print_f(mlogPool, "DBG", str);

    mrs_ipc_put(mrs, &ch, 1, 6);
    return 1;
}

static int dbg(struct mainRes_s *mrs)
{
#define CMD_SIZE 45

    int ci, pi, ret, idle=0, wait=-1, loglen=0, ui=0, clen=0;
    char cmd[256], *addr[3], rsp[256], ch, *plog;
    char poll[32] = "poll";

    struct cmd_s cmdtab[CMD_SIZE] = {{0, "poll", cmdfunc_01}, {1, "action", cmdfunc_act_opcode}, {2, "rgw", cmdfunc_regw_opcode}, {3, "op", cmdfunc_opcode}, 
                                {4, "wt", cmdfunc_wt_opcode}, {5, "go", cmdfunc_go_opcode}, {6, "rgr", cmdfunc_regr_opcode}, {7, "launch", cmdfunc_lh_opcode},
                                {8, "boot", cmdfunc_boot_opcode}, {9, "single", cmdfunc_single_opcode}, {10, "dnld", cmdfunc_dnld_opcode}, {11, "upld", cmdfunc_upld_opcode},
                                {12, "save", cmdfunc_save_opcode}, {13, "free", cmdfunc_free_opcode}, {14, "used", cmdfunc_used_opcode}, {15, "op1", cmdfunc_op1_opcode}
                                , {16, "op2", cmdfunc_op2_opcode}, {17, "op3", cmdfunc_op3_opcode}, {18, "op4", cmdfunc_op4_opcode}, {19, "op5", cmdfunc_op5_opcode}
                                , {20, "sdon", cmdfunc_sdon_opcode}, {21, "wfisd", cmdfunc_wfisd_opcode}, {22, "dulsd", cmdfunc_dulsd_opcode}, {23, "tgr", cmdfunc_tgr_opcode}
                                , {24, "crop", cmdfunc_crop_opcode}, {25, "vec", cmdfunc_vector_opcode}, {26, "apm", cmdfunc_apm_opcode}, {27, "meta", cmdfunc_meta_opcode}
                                , {28, "scango", cmdfunc_scango_opcode}, {29, "raw", cmdfunc_raw_opcode}, {30, "gosd", cmdfunc_gosd_opcode}, {31, "upsd", cmdfunc_upsd_opcode}
                                , {32, "ocr", cmdfunc_ocr_opcode}, {33, "msingle", cmdfunc_msingle_opcode}, {34, "mdouble", cmdfunc_mdouble_opcode}, {35, "mocr", cmdfunc_mocr_opcode}
                                , {36, "fmt32g", cmdfunc_fmt32g_opcode}, {37, "fmt16g", cmdfunc_fmt16g_opcode}, {38, "fmt64g", cmdfunc_fmt64g_opcode}, {39, "fmt128g", cmdfunc_fmt128g_opcode}
                                , {40, "reboot", cmdfunc_reboot_opcode}, {41, "crtfdr", cmdfunc_crtfdr_opcode}, {42, "usbscan", cmdfunc_usbscan_opcode}, {43, "wusingle", cmdfunc_wusingle_opcode}
                                , {44, "usbbknote", cmdfunc_usbbknote_opcode}};

    p0_init(mrs);

    prctl(PR_SET_NAME, "msp-dbg");
    //sprintf(argv[0], "msp-dbg");
    
    plog = aspMemalloc(2048, 8);
    if (!plog) {
        sprintf_f(mrs->log, "DBG plog alloc failed! \n");
        print_f(mrs->plog, "DBG", mrs->log);
        return (-1);
    }

    while (1) {
        /* command parsing */
        ci = 0;    
        ci = mrs_ipc_get(mrs, cmd, 256, 5);

        if (ci > 0) {
            cmd[ci] = '\0';
            //sprintf_f(mrs->log, "wifi get [%s] size:%d \n", cmd, ci);
            //print_f(mrs->plog, "DBG", mrs->log);
        } else {
            ui = 0;
            ui = mrs_ipc_get(mrs, cmd, 256, 14);
            if (ui > 0) {
                cmd[ui] = '\0';
                //sprintf_f(mrs->log, "p11 usb get [%s] ret:%d \n", cmd, ui);
                //print_f(mrs->plog, "DBG", mrs->log);
            } else {
                if (idle > 100) {
                    idle = 0;
                    //strcpy(cmd, poll);
                } else {
                    idle ++;
                    printf_flush(mrs->plog, mrs->flog);
                    usleep(1000);
                    continue;
                }
            }
        }

        clen = strlen(cmd);
        //sprintf_f(mrs->log, "cmd: [%s] len:%d \n", cmd, clen);
        //print_f(mrs->plog, "DBG", mrs->log);

        pi = 0;
        while (pi < CMD_SIZE) {
            //sprintf_f(mrs->log, "%d. cmd: [%s] [%s] len:%d \n", pi, cmd, cmdtab[pi].str, clen);
            //print_f(mrs->plog, "DBG", mrs->log);

            if (clen == strlen(cmdtab[pi].str)) {
                if (!strncmp(cmd, cmdtab[pi].str, strlen(cmdtab[pi].str))) {

                    //sprintf_f(mrs->log, "match!!! cmd: [%s] [%s] len:%d \n", cmd, cmdtab[pi].str, clen);
                    //print_f(mrs->plog, "DBG", mrs->log);

                    break;
                }
            }
            pi++;
        }
#if 0 /* no longer dumy log */
        /* clear previous log */
        ret = 0;
        ret = mrs_ipc_get(mrs, rsp, 256, 6);
        while (ret > 0) {
            sprintf_f(mrs->log, "ret:%d, rsp:%s\n", ret, rsp);
            print_f(mrs->plog, "DBG", mrs->log);
/*
            mrs_ipc_put(mrs, rsp, ret, 5);
*/
            ret = 0;
            ret = mrs_ipc_get(mrs, rsp, 256, 6);
        }
#endif

        /* command execution */
        if ((ci > 0) || (ui > 0)) {
            if (pi < CMD_SIZE) {
                addr[0] = (char *)mrs;
                //sprintf_f(mrs->log, "input [%d]%s\n", pi, cmdtab[pi].str);
                //print_f(mrs->plog, "DBG", mrs->log);
                ret = cmdtab[pi].pfunc(cmdtab[pi].id, addr);
                wait = 1;
                memset(plog, 0, 2048);
                loglen = 0;
                memset(cmd, 0, 256);

                aspMemDebug(aspMemAsign, asptotMalloc, totSalloc);
            } else {
                mrs_ipc_put(mrs, "?", 1, 5); 
                continue;
            }
        } else {
            if (wait < 0) continue;
        }

        //sprintf_f(mrs->log, "get ch:  \n");
        //print_f(mrs->plog, "DBG", mrs->log);

        ch = 0;
        ret = mrs_ipc_get(mrs, &ch, 1, 6);
        while (ret > 0) {
            //sprintf_f(mrs->log, "get result ret: %d ch: %c \n",ret, ch);
            //print_f(mrs->plog, "DBG", mrs->log);

            if (loglen > 0) {
                plog[loglen] = ch;
                loglen++;
                if ((ch == '>') || (loglen == 2048)) {
                
                    if (pi == 42) {
                        mrs_ipc_put(mrs, plog, loglen, 14);
                    } else {
                        mrs_ipc_put(mrs, plog, loglen, 5);
                    }
                    
                    sprintf_f(mrs->log, "\"%s\"", plog);
                    print_f(mrs->plog, "DBG", mrs->log);

                    wait = -1;
                }
            } else {
                if (ch == '<') {
                    plog[loglen] = ch;
                    loglen++;
                }
            }
            ch = 0;
            ret = mrs_ipc_get(mrs, &ch, 1, 6);
        }

        wait ++;
        if (wait > 1000000) {
            sprintf_f(mrs->log, "command time out :%d, loglen: %d\n", wait, loglen);
            print_f(mrs->plog, "DBG", mrs->log);
            if (loglen > 0) {
            
                if (pi == 42) {
                    mrs_ipc_put(mrs, plog, loglen, 14);
                } else {
                    mrs_ipc_put(mrs, plog, loglen, 5);
                }
                
            }
            wait = -1;
        }

        printf_flush(mrs->plog, mrs->flog);
    }

    p0_end(mrs);
}

static int hd00(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd01(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd02(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd03(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd04(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd05(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd06(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd07(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd08(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd09(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd10(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd11(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd12(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd13(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd14(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd15(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd16(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd17(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd18(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd19(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd20(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd21(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd22(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd23(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd24(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd25(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd26(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd27(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd28(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd29(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd30(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd31(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd32(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd33(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd34(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd35(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd36(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd37(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd38(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd39(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd40(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd41(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd42(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int ret=0, bitset;
    bitset = 0;
    ret = msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
    sprintf_f(mrs->log, "set sp0 ctl pin=%d ret=%d\n", bitset, ret);
    print_f(mrs->plog, "ERROR42", mrs->log);

    return 0;
}
static int hd43(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd44(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int ret=0, bitset;
    bitset = 0;
    ret = msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
    sprintf_f(mrs->log, "set sp0 ctl pin=%d ret=%d\n", bitset, ret);
    print_f(mrs->plog, "ERROR44", mrs->log);

    return 0;
}
static int hd45(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd46(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd47(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd48(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd49(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd50(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd51(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd52(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd53(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd54(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd55(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd56(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd57(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd58(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd59(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd60(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd61(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd62(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd63(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd64(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd65(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd66(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd67(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd68(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd69(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd70(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd71(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd72(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd73(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd74(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd75(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd76(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd77(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd78(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd79(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd80(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd81(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd82(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd83(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd84(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd85(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd86(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd87(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd88(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd89(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd90(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd91(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd92(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd93(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd94(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd95(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd96(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd97(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd98(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd99(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd100(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd101(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd102(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd103(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd104(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd105(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd106(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd107(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd108(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd109(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd110(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd111(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd112(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd113(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd114(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd115(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd116(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd117(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd118(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd119(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd120(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd121(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd122(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd123(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd124(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd125(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd126(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd127(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd128(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd129(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd130(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd131(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd132(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd133(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd134(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd135(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd136(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd137(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd138(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd139(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd140(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd141(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd142(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd143(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd144(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd145(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd146(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd147(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd148(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd149(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd150(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd151(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd152(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd153(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}
static int hd154(struct mainRes_s *mrs, struct modersp_s *modersp){return 0;}

static int fs00(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    struct info16Bit_s *p;
    p = &mrs->mchine.cur;

    sprintf_f(mrs->log, "usleep(%d) %d -> %d \n", modersp->v, modersp->m, modersp->d);
    print_f(mrs->plog, "fs00", mrs->log);

    usleep(modersp->v);
    modersp->m = modersp->d;
    modersp->d = 0;

    if (modersp->m == -1) {
        modersp->r = 1;
        return 1;
    }
    
    return 0; 
}
static int fs01(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    sprintf_f(mrs->log, "check RDY high ... \n");
    print_f(mrs->plog, "fs01", mrs->log);

    mrs_ipc_put(mrs, "b", 1, 1);
    modersp->c = 0;
    modersp->m = modersp->m + 1;
    return 0; 
}
static int fs02(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    char ch;
    int len;
    //sprintf_f(mrs->log, "check RDY high d:%d, c:%d\n", modersp->d, modersp->c);
    //print_f(mrs->plog, "fs02", mrs->log);

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if (len > 0){
        if (ch == 'B') {
        //modersp->m = modersp->m + 1;
            if (modersp->d) {
                modersp->m = modersp->d;
                modersp->d = 0;
                return 2;
            } else {
                modersp->r = 1;
                return 1;
            }
        }
        else {
            if (modersp->c < 10) { 
                mrs_ipc_put(mrs, "b", 1, 1);
                modersp->c += 1;
            } else {
                sprintf_f(mrs->log, "RDY is low break!! \n");
                print_f(mrs->plog, "fs02", mrs->log);

                modersp->c = 0;
                modersp->r = 2;
                return 1;
            }
        }
    }
    return 0; 
}
static int fs03(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    struct info16Bit_s *p;
    p = &mrs->mchine.cur;
    sprintf_f(mrs->log, "get %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
    print_f(mrs->plog, "fs03", mrs->log);

    mrs->mchine.seqcnt += 1;
    if (mrs->mchine.seqcnt >= 0x8) {
        mrs->mchine.seqcnt = 0;
    }

    p->opcode = OP_PON;
    p->inout = 0;
    p->seqnum = mrs->mchine.seqcnt;
    
    mrs_ipc_put(mrs, "c", 1, 1);
    modersp->m = modersp->m + 1;
    return 0; 
}

static int fs04(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    int len=0, bitset=0;
    char ch=0;
    struct info16Bit_s *p;

    //sprintf_f(mrs->log, "enter \n");
    //print_f(mrs->plog, "fs04", mrs->log);

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((len > 0) && (ch == 'C')) {
        msync(&mrs->mchine, sizeof(struct machineCtrl_s), MS_SYNC);

        p = &mrs->mchine.get;
        //sprintf_f(mrs->log, "get %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
        //print_f(mrs->plog, "fs04", mrs->log);

        if (p->opcode == OP_PON) {
            //modersp->m = modersp->m + 1;   
            modersp->r = 1;
            return 1;
        } else {
            modersp->m = 0;
            modersp->d = 4;
            modersp->v = 1000000;
            return 2;
        }
    }
    return 0; 
}

static int fs05(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    struct info16Bit_s *p;
    p = &mrs->mchine.cur;
    int bitset;
    sprintf_f(mrs->log, "get %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
    print_f(mrs->plog, "fs05", mrs->log);
    bitset = 1;
    msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 11, __u32), &bitset);   //SPI_IOC_WR_SLVE_READY
    sprintf_f(mrs->log, "Set spi 0 slave ready: %d\n", bitset);
    print_f(mrs->plog, "fs05", mrs->log);
    bitset = 1;
    msp_spi_conf(mrs->sfm[1], _IOW(SPI_IOC_MAGIC, 11, __u32), &bitset);   //SPI_IOC_WR_SLVE_READY
    sprintf_f(mrs->log, "Set spi 1 slave ready: %d\n", bitset);
    print_f(mrs->plog, "fs05",mrs->log);

    bitset = 0;
    msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
    sprintf_f(mrs->log, "[%d]Set RDY pin %d, cnt:%d\n",0, bitset, modersp->d);
    print_f(mrs->plog, "fs05", mrs->log);

    bitset = 0;
    msp_spi_conf(mrs->sfm[1], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
    sprintf_f(mrs->log, "[%d]Set RDY pin %d, cnt:%d\n",1, bitset, modersp->d);
    print_f(mrs->plog, "fs05", mrs->log);

    modersp->r = 1;
    return 1; 
}
static int fs06(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct info16Bit_s *p;
    p = &mrs->mchine.cur;
    sprintf_f(mrs->log, "get %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
    print_f(mrs->plog, "fs06", mrs->log);

    mrs->mchine.seqcnt += 1;
    if (mrs->mchine.seqcnt >= 0x8) {
        mrs->mchine.seqcnt = 0;
    }

    p->opcode = OP_RDY;
    p->inout = 0;
    p->seqnum = mrs->mchine.seqcnt;
    
    mrs_ipc_put(mrs, "c", 1, 1);
    modersp->m = modersp->m + 1;
    return 0; 
}

static int fs07(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    int len=0;
    char ch=0;
    struct info16Bit_s *p;

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((len > 0) && (ch == 'C')) {
        msync(&mrs->mchine, sizeof(struct machineCtrl_s), MS_SYNC);

        p = &mrs->mchine.get;
        //sprintf_f(mrs->log, "get %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
        //print_f(mrs->plog, "fs07", mrs->log);

        if (p->opcode == OP_RDY) {
            modersp->r = 1;
            return 1;
        } else {
            modersp->m = modersp->m - 1;        
            return 2;
        }
    }
    
    if ((len > 0) && (ch == 'X')) {
            sprintf_f(mrs->log, "FAIL!!send command again!\n");
            print_f(mrs->plog, "fs07", mrs->log);
            modersp->m = modersp->m - 1;        
            return 2;
    }
    return 0; 
}

static int fs08(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct info16Bit_s *p;
    p = &mrs->mchine.cur;
    sprintf_f(mrs->log, "get %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
    print_f(mrs->plog, "fs08", mrs->log);

    mrs->mchine.seqcnt += 1;
    if (mrs->mchine.seqcnt >= 0x8) {
        mrs->mchine.seqcnt = 0;
    }

    p->opcode = OP_RDY;
    p->inout = 0;
    p->seqnum = mrs->mchine.seqcnt;
    
    mrs_ipc_put(mrs, "c", 1, 1);
    modersp->m = modersp->m + 1;
    return 0; 
}

static int fs09(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    int len=0;
    char ch=0;
    struct info16Bit_s *p;

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((len > 0) && (ch == 'C')) {
        msync(&mrs->mchine, sizeof(struct machineCtrl_s), MS_SYNC);

        p = &mrs->mchine.get;
        //sprintf_f(mrs->log, "get %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
        //print_f(mrs->plog, "fs09", mrs->log);

        if (p->opcode == OP_QRY) {
            modersp->d = modersp->m - 1;        
            modersp->m = 0;
            modersp->v = 1000000;
            return 2;
        } else {
            /* must be something wrong */
            sprintf(mrs->log, "fs09: did not receive QRY but 0x%x", p->opcode);
            error_handle(mrs->log, 1967);
        }
    }

    if ((len > 0) && (ch == 'X')) {
            sprintf_f(mrs->log, "FAIL!!send command again!\n");
            print_f(mrs->plog, "fs09", mrs->log);
            modersp->m = modersp->m - 1;        
            return 2;
    }

    return 0; 
}

static int fs10(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    sprintf_f(mrs->log, "check socket status\n");
    print_f(mrs->plog, "fs10", mrs->log);
    
    mrs_ipc_put(mrs, "r", 1, 3);
    modersp->m = modersp->m + 1;
    return 0; 
}

static int fs11(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    int len=0;
    char ch=0;
    struct info16Bit_s *p;

    //sprintf_f(mrs->log, "wait socket status\n");
    //print_f(mrs->plog, "fs11", mrs->log);

    len = mrs_ipc_get(mrs, &ch, 1, 3);
    if (len > 0) {

        sprintf_f(mrs->log, "wait socket status ch: %c - end\n", ch);
        print_f(mrs->plog, "fs11", mrs->log);

        if (ch == 'R') {
            modersp->r = 1;
            return 1;
        } else if (ch == 'r') {
            error_handle("socket error", 3007);
            modersp->r = 2;
            return 1;
        } else  {
            modersp->r = 3;
         return 0;
        }
    }
    return 0; 
}

static int fs12(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct info16Bit_s *p;
    struct info16Bit_s *t;
    p = &mrs->mchine.cur;
    t = &mrs->mchine.tmp;

    p->opcode = t->opcode;
    p->data = t->data;
    
    //sprintf_f(mrs->log, "set %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
    //print_f(mrs->plog, "fs12", mrs->log);
    
    mrs_ipc_put(mrs, "c", 1, 1);
    modersp->m = modersp->m + 1;
    return 0; 
}

static int fs13(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    int len=0;
    char ch=0;
    struct info16Bit_s *p;

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((len > 0) && (ch == 'C')) {
        msync(&mrs->mchine, sizeof(struct machineCtrl_s), MS_SYNC);

        p = &mrs->mchine.get;
        //sprintf_f(mrs->log, "get %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
        //print_f(mrs->plog, "fs13", mrs->log);

        if (p->opcode == OP_QRY) {
            modersp->r = 1;
            return 1;
        } else {
            modersp->m = modersp->m - 1;        
            return 2;
        }
    }
    return 0; 
}

static int fs14(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct info16Bit_s *p;
    struct info16Bit_s *t;
    p = &mrs->mchine.cur;
    t = &mrs->mchine.tmp;

    p->opcode = t->opcode;
    p->data = t->data;

    //sprintf_f(mrs->log, "set %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
    //print_f(mrs->plog, "fs14", mrs->log);
    
    mrs_ipc_put(mrs, "c", 1, 1);
    modersp->m = modersp->m + 1;
    return 0; 
}

static int fs15(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    int len=0, val=0, ret=0;
    char ch=0;
    struct info16Bit_s *p;
    struct aspConfig_s *pct=0;
    pct = mrs->configTable;

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((len > 0) && (ch == 'C')) {
        msync(&mrs->mchine, sizeof(struct machineCtrl_s), MS_SYNC);

        p = &mrs->mchine.get;
        //sprintf_f(mrs->log, "get %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
        //print_f(mrs->plog, "fs15", mrs->log);

        if ((p->opcode == OP_SINGLE) && ((p->data == SINSCAN_DUAL_STRM) 
            ||(p->data == SINSCAN_DUAL_SD))) {
            modersp->m = modersp->m + 1;
            return 2;
        }
        #if 0 /* not a good flow */
        else if ((p->opcode == OP_SINGLE) && (p->data == SINSCAN_DUAL_SD)) {
            modersp->m = modersp->m + 1;
        
            ret = cfgTableGet(pct, ASPOP_SUP_SAVE, &val);
            if (ret) {
                sprintf_f(mrs->log, "ASPOP_SUP_SAVE not available, ret:%d\n", ret);  
                print_f(mrs->plog, "fs15", mrs->log);
            } else {
                sprintf_f(mrs->log, "ASPOP_SUP_SAVE value: 0x%x\n", val);  
                print_f(mrs->plog, "fs15", mrs->log);

                switch (val) {
                    case SUPBACK_RAW:
                        break;
                    case SUPBACK_FAT:
                        break;
                    case SUPBACK_SD:
                        modersp->d = modersp->m + 1;
                        modersp->m = 59;
                        break;
                    default:
                        sprintf_f(mrs->log, "WARNING!!! unexpected OP_SUPBACK value: 0x%x \n", val);  
                        print_f(mrs->plog, "fs15", mrs->log);
                        break;
                }
            }

            return 2;
        } 
        #endif
        else if (p->opcode == OP_SUPBACK) { // flow changed, will be removed in future
            modersp->d = modersp->m + 1;
            modersp->m = 57;
            return 2;
        } else {
            modersp->m = modersp->m - 1;        
            return 2;
        }
    }
    return 0; 
}

static int fs16(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int bitset=0, ret;
    bitset = 0;
    msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 8, __u32), &bitset);   //SPI_IOC_WR_DATA_MODE
    sprintf_f(mrs->log, "spi0 Set data mode: %d\n", bitset);
    print_f(mrs->plog, "fs16", mrs->log);
    bitset = 0;
    msp_spi_conf(mrs->sfm[1], _IOW(SPI_IOC_MAGIC, 8, __u32), &bitset);   //SPI_IOC_WR_DATA_MODE
    sprintf_f(mrs->log, "spi1 Set data mode: %d\n", bitset);
    print_f(mrs->plog, "fs16", mrs->log);

/* bullet don't need kthread mode */
#if SPI_KTHREAD_USE 
    bitset = 0;
    ret = msp_spi_conf(mrs->sfm[0], _IOR(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_START_THREAD
    sprintf_f(mrs->log, "Start spi0 spidev thread, ret: 0x%x\n", ret);
    print_f(mrs->plog, "fs16", mrs->log);

    bitset = 0;
    ret = msp_spi_conf(mrs->sfm[1], _IOR(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_START_THREAD
    sprintf_f(mrs->log, "Start spi1 spidev thread, ret: 0x%x\n", ret);
    print_f(mrs->plog, "fs16", mrs->log);
#endif

    modersp->r = 1;
    return 1;
}

static int fs17(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct sdFAT_s *pfat=0;
    pfat = &mrs->aspFat;
    //pfat->fatSupcur = pfat->fatSupdata;
    
    sprintf_f(mrs->log, "trigger spi0 spi1 \n");
    print_f(mrs->plog, "fs17", mrs->log);


    mrs_ipc_put(mrs, "d", 1, 2);
    //clock_gettime(CLOCK_REALTIME, &mrs->time[1]);
    usleep(100);
    mrs_ipc_put(mrs, "d", 1, 1);
    //clock_gettime(CLOCK_REALTIME, &mrs->time[0]);
#if CHECK_SOCKET_STATUS
    modersp->m = modersp->m + 1;
#else
    modersp->d = modersp->m + 1;
    modersp->m = 25;
#endif
    modersp->v = 0;
    modersp->c = 0;
    return 2;
}

static int fs18(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    struct sdFAT_s *pfat=0;
    struct supdataBack_s *s=0, *sc=0;

    int len=0;
    char *addr = 0, *dst=0;
    int ret, bitset;
    char ch;

    //sprintf_f(mrs->log, "%d\n", modersp->v);
    //print_f(mrs->plog, "fs18", mrs->log);
    pfat = &mrs->aspFat;
    sc = pfat->fatSupcur;

    while (1) {
    if (!(modersp->c % 2)) {
    ret = mrs_ipc_get(mrs, &ch, 1, 1);
    if (ret > 0) {
        if (ch == 'p') {
            if (sc) {
                len = ring_buf_cons_dual_psudo(&mrs->dataRx, &addr, modersp->v);
                //sprintf_f(mrs->log, "1. get psudo len:%d, cnt:%d\n", len, modersp->v);
                //print_f(mrs->plog, "fs18", mrs->log);

                if (len >= 0) {
                    dst = sc->supdataBuff;
                    memcpy(dst, addr, len);
                    sc->supdataTot = len;

                    s = aspMemalloc(sizeof(struct supdataBack_s), 10);
                    memset(s, 0, sizeof(struct supdataBack_s));
                    sc->n = s;
                    sc = sc->n;

                    modersp->v += 1;                    
                    pfat->fatSupcur = sc;
                }
            }
            
            mrs_ipc_put(mrs, "d", 1, 3);
        }

        if (ch == 'd') {
            sprintf_f(mrs->log, "0 %d end\n", modersp->v);
            print_f(mrs->plog, "fs18", mrs->log);

            mrs_ipc_put(mrs, "d", 1, 3);
            modersp->r |= 0x1;
            //mrs_ipc_put(mrs, "e", 1, 3);
        }
        //ret = mrs_ipc_get(mrs, &ch, 1, 1);
        modersp->c += 1;
    }else {
        break;
    }
    }

    if (modersp->c % 2) {    
    ret = mrs_ipc_get(mrs, &ch, 1, 2);
    if (ret > 0) {
        if (ch == 'p') {
            if (sc) {
                len = ring_buf_cons_dual_psudo(&mrs->dataRx, &addr, modersp->v);
                //sprintf_f(mrs->log, "2. get psudo len:%d, cnt:%d\n", len, modersp->v);
                //print_f(mrs->plog, "fs18", mrs->log);

                if (len >= 0) {
                    dst = sc->supdataBuff;
                    memcpy(dst, addr, len);
                    sc->supdataTot = len;

                    s = aspMemalloc(sizeof(struct supdataBack_s), 10);
                    memset(s, 0, sizeof(struct supdataBack_s));
                    sc->n = s;
                    sc = sc->n;

                    modersp->v += 1;  
                    pfat->fatSupcur = sc;
                }
            }
            mrs_ipc_put(mrs, "d", 1, 3);
        }

        if (ch == 'd') {
            sprintf_f(mrs->log, "1 %d end\n", modersp->v);
            print_f(mrs->plog, "fs18", mrs->log);
 
            mrs_ipc_put(mrs, "d", 1, 3);
            modersp->r |= 0x2;
            //mrs_ipc_put(mrs, "e", 1, 3);
        }
        //ret = mrs_ipc_get(mrs, &ch, 1, 2);
        modersp->c += 1;
    }else {
        break;
    }
    }
    }

    if (modersp->r == 0x3) {
        if (sc) {
            len = ring_buf_cons_dual_psudo(&mrs->dataRx, &addr, modersp->v);
            while (len >= 0) {
                sprintf_f(mrs->log, "3. get psudo len:%d, cnt:%d\n", len, modersp->v);
                print_f(mrs->plog, "fs18", mrs->log);

                dst = sc->supdataBuff;
                memcpy(dst, addr, len);
                sc->supdataTot = len;
                
                s = aspMemalloc(sizeof(struct supdataBack_s), 10);
                memset(s, 0, sizeof(struct supdataBack_s));
                sc->n = s;
                sc = sc->n;

                pfat->fatSupcur = sc;
                modersp->v += 1;  
                len = ring_buf_cons_dual_psudo(&mrs->dataRx, &addr, modersp->v);
            }

            len = 0;
            s = pfat->fatSupdata;
            while (s) {
                if (s->supdataTot == 0) {
                    break;
                } else {
                    len += s->supdataTot;
                }
                sc = s;
                s = s->n;
            }

            if (sc) {
                sc->n = 0;
            }

            while (s) {
                sc = s;
                s = s->n;
                
                memset(sc, 0, sizeof(struct supdataBack_s));
                aspMemFree(sc, 0);
            }
            pfat->fatSupcur = 0;
        }
        mrs_ipc_put(mrs, "D", 1, 3);
        sprintf_f(mrs->log, "%d end, len: %d, cnt:%d\n", modersp->v, len,modersp->c);
        print_f(mrs->plog, "fs18", mrs->log);

        mrs->mchine.cur.opinfo = modersp->v;
        
        modersp->m = modersp->m + 1;
        return 2;
    }

    return 0;
}

static int fs19(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int len=0;
    char ch=0;
    //sprintf_f(mrs->log, "wait socket finish \n");
    //print_f(mrs->plog, "fs19", mrs->log);

    len = mrs_ipc_get(mrs, &ch, 1, 3);
    if ((len > 0) && (ch == 'D')) {
        ring_buf_init(&mrs->dataRx);
        mrs->dataRx.r->folw.seq = 1;
        mrs->dataRx.r->psudo.seq = 1;

        modersp->r = 1;;
        return 1;
    }

    return 0;
}

static int fs20(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    int bitset, ret;

    bitset = 0;
    msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
    sprintf_f(mrs->log, "[%d]Set RDY pin %d, cnt:%d\n",0, bitset, modersp->d);
    print_f(mrs->plog, "fs20", mrs->log);

    bitset = 0;
    msp_spi_conf(mrs->sfm[1], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
    sprintf_f(mrs->log, "[%d]Set RDY pin %d, cnt:%d\n",1, bitset, modersp->d);
    print_f(mrs->plog, "fs20", mrs->log);

    usleep(100000);
            
    bitset = 0;
    msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 8, __u32), &bitset);   //SPI_IOC_WR_DATA_MODE
    sprintf_f(mrs->log, "spi0 Set data mode: %d\n", bitset);
    print_f(mrs->plog, "fs20", mrs->log);

    bitset = 0;
    msp_spi_conf(mrs->sfm[1], _IOW(SPI_IOC_MAGIC, 8, __u32), &bitset);   //SPI_IOC_WR_DATA_MODE
    sprintf_f(mrs->log, "spi1 Set data mode: %d\n", bitset);
    print_f(mrs->plog, "fs20", mrs->log);

    bitset = 1;
    msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 11, __u32), &bitset);   //SPI_IOC_WR_SLVE_READY
    sprintf_f(mrs->log, "Set spi 0 slave ready: %d\n", bitset);
    print_f(mrs->plog, "fs20", mrs->log);

    bitset = 1;
    msp_spi_conf(mrs->sfm[1], _IOW(SPI_IOC_MAGIC, 11, __u32), &bitset);   //SPI_IOC_WR_SLVE_READY
    sprintf_f(mrs->log, "Set spi 1 slave ready: %d\n", bitset);
    print_f(mrs->plog, "fs20", mrs->log);
    
#if SPI_KTHREAD_USE
    bitset = 0;
    ret = msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_STOP_THREAD
    sprintf_f(mrs->log, "Stop spi0 spidev thread, ret: 0x%x\n", ret);
    print_f(mrs->plog, "fs20", mrs->log);

    bitset = 0;
    ret = msp_spi_conf(mrs->sfm[1], _IOW(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_STOP_THREAD
    sprintf_f(mrs->log, "Stop spi1 spidev thread, ret: 0x%x\n", ret);
    print_f(mrs->plog, "fs20", mrs->log);
#endif

    modersp->r = 1;
    return 1;
}
static int fs21(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct info16Bit_s *p;

    sprintf_f(mrs->log, "get OP_FIH \n");
    print_f(mrs->plog, "fs21", mrs->log);

    p = &mrs->mchine.cur;

    mrs->mchine.seqcnt += 1;
    if (mrs->mchine.seqcnt >= 0x8) {
        mrs->mchine.seqcnt = 0;
    }

    p->opcode = OP_FIH;
    p->inout = 0;
    p->seqnum = mrs->mchine.seqcnt;
    
    mrs_ipc_put(mrs, "c", 1, 1);
    modersp->m = modersp->m + 1;
    return 0; 
}

static int fs22(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int len=0;
    char ch=0;
    struct info16Bit_s *p;

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((len > 0) && (ch == 'C')) {
        msync(&mrs->mchine, sizeof(struct machineCtrl_s), MS_SYNC);

        p = &mrs->mchine.get;
        //sprintf_f(mrs->log, "get %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
        //print_f(mrs->plog, "fs22", mrs->log);

        if (p->opcode == OP_FIH) {
            modersp->m = modersp->m + 1; 
        } else {
            error_handle("get FIH failed", 2238);
        }
    }
    
    if ((len > 0) && (ch == 'X')) {
            sprintf_f(mrs->log, "FAIL!!send command again!\n");
            print_f(mrs->plog, "fs22", mrs->log);
            modersp->m = modersp->m - 1;        
            return 2;
    }
    
    if ((len > 0) && (ch == 'R')) {
            int fd0=0, fdr=0;

            fdr = mrs->sfm[0];
            
            sprintf_f(mrs->log, "FAIL!!reset spi _0_!\n");
            print_f(mrs->plog, "fs22", mrs->log);

            close(fdr);
            
#if SPIDEV_SWITCH
            fd0 = open(spidev_1, O_RDWR);
#else
            fd0 = open(spidev_0, O_RDWR);
#endif

            if (fd0 <= 0) {
                sprintf_f(mrs->log, "can't open device[%s]\n", spidev_0); 
                print_f(mrs->plog, "fs22", mrs->log);
            } else {
                sprintf_f(mrs->log, "open device[%s] id: %d \n", spidev_0, fd0); 
                print_f(mrs->plog, "fs22", mrs->log);
            }

            mrs->sfm[0] = fd0;

            sprintf_f(mrs->log, "ERROR !! bypasss 0x07!\n");
            print_f(mrs->plog, "fs22", mrs->log);
            
            modersp->m = modersp->m + 1;        
            return 2;
    }

    return 0; 
}

static int fs23(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int bitset;
    bitset = 1;
    msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 11, __u32), &bitset);   //SPI_IOC_WR_SLVE_READY

    sprintf_f(mrs->log, "Set spi 0 slave ready: %d\n", bitset);
    print_f(mrs->plog, "fs23", mrs->log);

    bitset = 1;
    msp_spi_conf(mrs->sfm[1], _IOW(SPI_IOC_MAGIC, 11, __u32), &bitset);   //SPI_IOC_WR_SLVE_READY

    sprintf_f(mrs->log, "Set spi 1 slave ready: %d\n", bitset);
    print_f(mrs->plog, "fs23", mrs->log);

    modersp->r = 1;
    return 1;
}

static int fs24(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int bitset;
    usleep(1);

    bitset = 1;
    msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
    sprintf_f(mrs->log, "[%d]Set RDY pin %d, cnt:%d\n",0, bitset, modersp->d);
    print_f(mrs->plog, "fs24", mrs->log);

    bitset = 1;
    msp_spi_conf(mrs->sfm[1], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
    sprintf_f(mrs->log, "[%d]Set RDY pin %d, cnt:%d\n",1, bitset, modersp->d);
    print_f(mrs->plog, "fs24", mrs->log);

    usleep(1000);

    bitset = 0;
    msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
    sprintf_f(mrs->log, "[%d]Set RDY pin %d, cnt:%d\n",0, bitset, modersp->d);
    print_f(mrs->plog, "fs24", mrs->log);

    bitset = 0;
    msp_spi_conf(mrs->sfm[1], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
    sprintf_f(mrs->log, "[%d]Set RDY pin %d, cnt:%d\n",1, bitset, modersp->d);
    print_f(mrs->plog, "fs24", mrs->log);

    sleep(1);

    bitset = 1;
    msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
    sprintf_f(mrs->log, "[%d]Set RDY pin %d, cnt:%d\n",0, bitset, modersp->d);
    print_f(mrs->plog, "fs24", mrs->log);

    bitset = 1;
    msp_spi_conf(mrs->sfm[1], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
    sprintf_f(mrs->log, "[%d]Set RDY pin %d, cnt:%d\n",1, bitset, modersp->d);
    print_f(mrs->plog, "fs24", mrs->log);

    usleep(1000);

    bitset = 0;
    msp_spi_conf(mrs->sfm[0], _IOR(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_RD_CTL_PIN
    sprintf_f(mrs->log, "[%d]Get RDY pin %d, cnt:%d\n",0, bitset, modersp->d);
    print_f(mrs->plog, "fs24", mrs->log);

    bitset = 0;
    msp_spi_conf(mrs->sfm[1], _IOR(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_RD_CTL_PIN
    sprintf_f(mrs->log, "[%d]Get RDY pin %d, cnt:%d\n",1, bitset, modersp->d);
    print_f(mrs->plog, "fs24", mrs->log);

    bitset = 0;
    msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 11, __u32), &bitset);   //SPI_IOC_WR_SLVE_READY
    sprintf_f(mrs->log, "Set spi 0 slave ready: %d\n", bitset);
    print_f(mrs->plog, "fs24", mrs->log);

    bitset = 0;
    msp_spi_conf(mrs->sfm[1], _IOW(SPI_IOC_MAGIC, 11, __u32), &bitset);   //SPI_IOC_WR_SLVE_READY
    sprintf_f(mrs->log, "Set spi 1 slave ready: %d\n", bitset);
    print_f(mrs->plog, "fs24", mrs->log);

    return 1;
}

static int fs25(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct sdFAT_s *pfat=0;
    struct aspConfig_s *pct=0, *pdt=0;
    uint32_t val_s = 0, val_d = 0;
            
    sprintf_f(mrs->log, "check 01 socket status\n");
    print_f(mrs->plog, "fs25", mrs->log);

    pfat = &mrs->aspFat;
    pct = mrs->configTable;
    
    mrs_ipc_put(mrs, "r", 1, 3);

#if 0
    pdt = &pct[ASPOP_SCAN_SINGLE];
    if ((pdt->opStatus & ASPOP_STA_WR)) {
        val_s = pdt->opValue;
    }

    pdt = &pct[ASPOP_SCAN_DOUBLE];
    if ((pdt->opStatus & ASPOP_STA_WR)) {
        val_d = pdt->opValue;
    }
    
    sprintf_f(mrs->log, "ASPOP_SCAN table val_s: 0x%x, val_d: 0x%x \n", val_s, val_d);
    print_f(mrs->plog, "fs25", mrs->log);

    if (val_s) {
        switch(val_s) {
            case SINSCAN_WIFI_ONLY:
                //case SINSCAN_WHIT_BLNC:
                //case SINSCAN_USB:
                //case SINSCAN_DUAL_STRM:
                pfat->fatSupdata = 0;
                pfat->fatSupcur = 0;
                aspMemClear(aspMemAsign, asptotMalloc, 10);
                break;
            //case SINSCAN_SD_ONLY:
            case SINSCAN_WIFI_SD:
            //case SINSCAN_DUAL_SD:
                break;
            default:
                sprintf_f(mrs->log, "WARNING: unexpected ASPOP_SCAN_SINGLE table val: 0x%x \n", val_s);
                print_f(mrs->plog, "fs25", mrs->log);
                break;
        }
    }
    else if (val_d) {
        switch(val_d) {
            case DOUSCAN_WIFI_ONLY:
                pfat->fatSupdata = 0;
                pfat->fatSupcur = 0;
                pfat->fatSupdataDuo = 0;
                pfat->fatSupcurDuo = 0;
                aspMemClear(aspMemAsign, asptotMalloc, 10);
                break;
            case DOUSCAN_WIFI_SD:
                //case DOUSCAN_SD_ONLY:  
                break;       
            default:
                sprintf_f(mrs->log, "WARNING: unexpected ASPOP_SCAN_DOUBLE table val: 0x%x \n", val_d);
                print_f(mrs->plog, "fs25", mrs->log);
                break;
        }
    }
#endif

    modersp->m = modersp->m + 1;
    return 0; 
}

static int fs26(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    int len=0;
    char ch=0;
    struct info16Bit_s *p;
    
    //sprintf_f(mrs->log, "wait socket status\n");
    //print_f(mrs->plog, "fs26", mrs->log);
    
    len = mrs_ipc_get(mrs, &ch, 1, 3);
    if (len > 0) {

        //sprintf_f(mrs->log, "wait 01 socket status ch: %c - end\n", ch);
        //print_f(mrs->plog, "fs26", mrs->log);

        if (ch == 'R') {
#if CHECK_SOCKET_STATUS
            modersp->r = 1;
            //modersp->m = modersp->m + 1;
            return 1;
#else
            if (modersp->d) {
                modersp->m = modersp->d;
                modersp->d = 0;
                modersp->r = 0;
                return 0;
            } else {
                modersp->r = 1;
                return 1;
            }
#endif
        } else if (ch == 'r') {
            error_handle("socket error", 3421);
            modersp->r = 2;
            return 1;
        } else  {
            modersp->r = 3;
            return 0;
        }
    }
    return 0; 
}

static int fs27(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    struct sdFAT_s *pfat=0;
    struct aspConfig_s *pct=0;
    uint32_t val = 0;
    
    sprintf_f(mrs->log, "check 02 socket status\n");
    print_f(mrs->plog, "fs27", mrs->log);

    pfat = &mrs->aspFat;
    pct = mrs->configTable;
    
    mrs_ipc_put(mrs, "r", 1, 8);
    
#if 0
    cfgTableGet(pct, ASPOP_SCAN_DOUBLE, &val);

    sprintf_f(mrs->log, "ASPOP_SCAN_DOUBLE table val: 0x%x \n", val);
    print_f(mrs->plog, "fs27", mrs->log);

    switch(val) {
        case DOUSCAN_WIFI_ONLY:
            pfat->fatSupdata = 0;
            pfat->fatSupcur = 0;
            pfat->fatSupdataDuo = 0;
            pfat->fatSupcurDuo = 0;
            aspMemClear(aspMemAsign, asptotMalloc, 10);
            break;
        case DOUSCAN_WIFI_SD:
        //case DOUSCAN_SD_ONLY:
            break;       
        default:
            sprintf_f(mrs->log, "WARNING: unexpected ASPOP_SCAN_DOUBLE table val: 0x%x \n", val);
            print_f(mrs->plog, "fs27", mrs->log);
            break;
    }
#endif

    modersp->m = modersp->m + 1;
    return 0; 
}

static int fs28(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    int len=0;
    char ch=0;
    struct info16Bit_s *p;

    //sprintf_f(mrs->log, "wait socket status\n");
    //print_f(mrs->plog, "fs28", mrs->log);

    len = mrs_ipc_get(mrs, &ch, 1, 8);
    if (len > 0) {

        //sprintf_f(mrs->log, "wait 02 socket status ch: %c - end\n", ch);
        //print_f(mrs->plog, "fs28", mrs->log);

        if (ch == 'R') {
#if CHECK_SOCKET_STATUS
            modersp->r = 1;
            return 1;
#else
            modersp->m = 25;
            return 0;
#endif
        } else if (ch == 'r') {
            error_handle("socket error", 3463);
            modersp->r = 2;
            return 1;
        } else  {
            modersp->r = 3;
            return 0;
        }
    }
    return 0; 
}

static int fs29(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct info16Bit_s *p;
    p = &mrs->mchine.cur;

    mrs->mchine.seqcnt += 1;
    if (mrs->mchine.seqcnt >= 0x8) {
        mrs->mchine.seqcnt = 0;
    }

    p->opcode = OP_DOUBLE;
    p->data = DOUSCAN_WIFI_ONLY;
    p->inout = 0;
    p->seqnum = mrs->mchine.seqcnt;

    //sprintf_f(mrs->log, "get %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
    //print_f(mrs->plog, "fs29", mrs->log);
    
    mrs_ipc_put(mrs, "c", 1, 1);
    modersp->m = modersp->m + 1;
    return 0; 
}

static int fs30(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int len=0;
    char ch=0;
    struct info16Bit_s *p;

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((len > 0) && (ch == 'C')) {
        msync(&mrs->mchine, sizeof(struct machineCtrl_s), MS_SYNC);

        p = &mrs->mchine.get;
        //sprintf_f(mrs->log, "get %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
        //print_f(mrs->plog, "fs30", mrs->log);

        if (p->opcode == OP_QRY) {
            modersp->r = 1;
            return 1;
        } else {
            modersp->m = modersp->m - 1;        
            return 2;
        }
    }
    return 0; 
}

static int fs31(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct info16Bit_s *p;
    p = &mrs->mchine.cur;

    mrs->mchine.seqcnt += 1;
    if (mrs->mchine.seqcnt >= 0x8) {
        mrs->mchine.seqcnt = 0;
    }

    p->opcode = OP_DOUBLE;
    p->data = DOUSCAN_WIFI_ONLY;
    p->inout = 0;
    p->seqnum = mrs->mchine.seqcnt;

    //sprintf_f(mrs->log, "get %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
    //print_f(mrs->plog, "fs31", mrs->log);
    
    mrs_ipc_put(mrs, "c", 1, 1);
    modersp->m = modersp->m + 1;
    return 0; 
}

static int fs32(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    int len=0;
    char ch=0;
    struct info16Bit_s *p;

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((len > 0) && (ch == 'C')) {
        msync(&mrs->mchine, sizeof(struct machineCtrl_s), MS_SYNC);

        p = &mrs->mchine.get;
        //sprintf_f(mrs->log, "get %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
        //print_f(mrs->plog, "fs32", mrs->log);

        if ((p->opcode == OP_DOUBLE) && (p->data == DOUSCAN_WIFI_ONLY)) {
            modersp->m = modersp->m + 1;
            return 2;
        } else {
            modersp->m = modersp->m - 1;        
            return 2;
        }
    }
    return 0; 
}

static int fs33(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int bitset=0, ret;
    bitset = 0;
    msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 8, __u32), &bitset);   //SPI_IOC_WR_DATA_MODE
    sprintf_f(mrs->log, "spi0 Set data mode: %d\n", bitset);
    print_f(mrs->plog, "fs33", mrs->log);
    bitset = 0;
    msp_spi_conf(mrs->sfm[1], _IOW(SPI_IOC_MAGIC, 8, __u32), &bitset);   //SPI_IOC_WR_DATA_MODE
    sprintf_f(mrs->log, "spi1 Set data mode: %d\n", bitset);
    print_f(mrs->plog, "fs33", mrs->log);

    ring_buf_init(&mrs->cmdRx);
    ring_buf_init(&mrs->cmdTx);

    mrs_ipc_put(mrs, "n", 1, 2);
    //usleep(100000);

#if SPI_KTHREAD_USE
    bitset = 0;
    ret = msp_spi_conf(mrs->sfm[1], _IOR(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_START_THREAD
    sprintf_f(mrs->log, "Start spi1 spidev thread, ret: 0x%x\n", ret);
    print_f(mrs->plog, "fs33", mrs->log);

    bitset = 0;
    ret = msp_spi_conf(mrs->sfm[0], _IOR(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_START_THREAD
    sprintf_f(mrs->log, "Start spi0 spidev thread, ret: 0x%x\n", ret);
    print_f(mrs->plog, "fs33", mrs->log);
#endif
    
    modersp->m = modersp->m + 1;

    return 0;
}

static int fs34(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int bitset=0, ret;
    struct sdFAT_s *pfat=0;
    pfat = &mrs->aspFat;
    //pfat->fatSupcur = pfat->fatSupdata;
    //pfat->fatSupcurDuo= pfat->fatSupdataDuo;

    sprintf_f(mrs->log, "trigger spi0 spi1 \n");
    print_f(mrs->plog, "fs34", mrs->log);
    
    mrs_ipc_put(mrs, "n", 1, 1);
#if CHECK_SOCKET_STATUS
    modersp->m = modersp->m + 1;
#else
    modersp->d = modersp->m + 1;
    modersp->m = 27;
#endif
    modersp->v = 0;
    modersp->c = 0;
    return 2;
}

#define LOG_WIFI_SEQU_PLAY (0)
#define LOG_FOR_DOUBLE_SIDESCAN (0)
static int fs35(struct mainRes_s *mrs, struct modersp_s *modersp)
{
#define QSIZE 7
#define QDELAY 0
    int ret, bitset, tmc, len;
    char ch, *addr=0, *dst=0;
    struct sdFAT_s *pfat=0;
    struct supdataBack_s *s=0, *sc=0;
    struct supdataBack_s *sduo=0, *scduo=0;

    pfat = &mrs->aspFat;
    sc = pfat->fatSupcur;
    scduo= pfat->fatSupcurDuo;

    //sprintf_f(mrs->log, "v:%d, c:%d, r:0x%x\n", modersp->v, modersp->c, modersp->r);
    //print_f(mrs->plog, "fs35", mrs->log);

    if (modersp->r & 0x4) {

        if (modersp->r & 0x1) {
            modersp->r &= ~(0x04);
        } 
        else if (modersp->c) {
            ret = mrs_ipc_get(mrs, &ch, 1, 3);
            while (ret > 0) {
                if (ch == 'n') {
                    modersp->c -= 1;
#if LOG_WIFI_SEQU_PLAY
                    sprintf_f(mrs->log, "WiFi _0_ rest - %d\n", modersp->c);
                    print_f(mrs->plog, "fs35", mrs->log);
#endif
                }
                if (modersp->c == 0) {
                    break;
                }
                ret = mrs_ipc_get(mrs, &ch, 1, 3);
            }
            if (modersp->c == 0) {
                if (modersp->v < 0) {
                    modersp->r |= 0x1;
                }
                modersp->v = 0;
                modersp->r &= ~(0x04);
            }
        }
        else {
            ret = mrs_ipc_get(mrs, &ch, 1, 1);
            //sprintf_f(mrs->log, "1. get ch: %c ret=%d - 1\n", ch, ret);
            //print_f(mrs->plog, "fs35", mrs->log);

            while (ret > 0) {
                if (ch == 'p') {
                    modersp->v += 1;

                    if (sc) {
                        len = ring_buf_cons_psudo(&mrs->cmdRx, &addr);
#if LOG_FOR_DOUBLE_SIDESCAN
                        sprintf_f(mrs->log, "1. get psudo len:%d, cnt:%d\n", len, modersp->v);
                        print_f(mrs->plog, "fs35", mrs->log);
#endif
                        if (len >= 0) {
                            dst = sc->supdataBuff;
                            memcpy(dst, addr, len);
                            sc->supdataTot = len;
                            s = aspMemalloc(sizeof(struct supdataBack_s), 10);
                            memset(s, 0, sizeof(struct supdataBack_s));
                            sc->n = s;
                            sc = sc->n;

                            pfat->fatSupcur = sc;
                        }
                    }
                    //sprintf_f(mrs->log, "1. v=%d \n", modersp->v);
                    //print_f(mrs->plog, "fs35", mrs->log);

                    if (modersp->v > QSIZE) break;
                }
                if (ch == 'd') {
                    sprintf_f(mrs->log, "spi __0__ END!!!\n");
                    print_f(mrs->plog, "fs35", mrs->log);
                    modersp->v += 1;
                    modersp->v = 0 - modersp->v;
                    //mrs_ipc_put(mrs, "n", 1, 3);
                    //modersp->r |= 0x1;
                    //mrs_ipc_put(mrs, "e", 1, 3);
#if PULL_LOW_AFTER_DATA
                    bitset = 0;
                    msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
                    sprintf_f(mrs->log, "set spi0 RDY pin %d\n",bitset);
                    print_f(mrs->plog, "fs35", mrs->log);
                    usleep(210000);
#endif
                    break;
                }
                ret = mrs_ipc_get(mrs, &ch, 1, 1);
                //sprintf_f(mrs->log, "1. get ch: %c ret=%d - 2\n", ch, ret);
                //print_f(mrs->plog, "fs35", mrs->log);

            }

            if (modersp->v < 0) {
                modersp->c = 0 - modersp->v;
            } else {
                modersp->c = modersp->v;
            }
            //sprintf_f(mrs->log, "1. c=%d \n", modersp->c);
            //print_f(mrs->plog, "fs35", mrs->log);

            if (modersp->c > 0) {
                tmc = modersp->c;
                while (tmc) {
                    mrs_ipc_put(mrs, "n", 1, 3);
                    //dbgShowTimeStamp("hold", mrs, NULL, 2, NULL);
                    #if QDELAY
                    usleep(QDELAY);
                    #endif
                    //dbgShowTimeStamp("rele", mrs, NULL, 2, NULL);
                    tmc --;
                }
            } else {
                modersp->r &= ~(0x04);
            }
        }
    }

    if (!(modersp->r & 0x4)) {

        if (modersp->r & 0x2) {
            modersp->r |= 0x04;
        } 
        else if (modersp->c) {
            ret = mrs_ipc_get(mrs, &ch, 1, 8);
            while (ret > 0) {
                if (ch == 'n') {
                    modersp->c -= 1;
#if LOG_WIFI_SEQU_PLAY
                    sprintf_f(mrs->log, "WiFi _1_ rest - %d\n", modersp->c);
                    print_f(mrs->plog, "fs35", mrs->log);
#endif
                }
                if (modersp->c == 0) {
                    break;
                }
                ret = mrs_ipc_get(mrs, &ch, 1, 8);
            }
            if (modersp->c == 0) {
                if (modersp->v < 0) {
                    modersp->r |= 0x2;
                }
                modersp->v = 0;
                modersp->r |= 0x04;
            }
        }
        else {
            ret = mrs_ipc_get(mrs, &ch, 1, 2);
            //sprintf_f(mrs->log, "2. get ch: %c ret=%d - 1\n", ch, ret);
            //print_f(mrs->plog, "fs35", mrs->log);

            while (ret > 0) {
                if (ch == 'p') {
                    modersp->v += 1;

                    if (scduo) {
                        len = ring_buf_cons_psudo(&mrs->cmdTx, &addr);
#if LOG_FOR_DOUBLE_SIDESCAN
                        sprintf_f(mrs->log, "2. get psudo len:%d, cnt:%d\n", len, modersp->v);
                        print_f(mrs->plog, "fs35", mrs->log);
#endif

                        if (len >= 0) {
                            dst = scduo->supdataBuff;
                            memcpy(dst, addr, len);
                            scduo->supdataTot = len;
                            s = aspMemalloc(sizeof(struct supdataBack_s), 10);
                            memset(s, 0, sizeof(struct supdataBack_s));
                            scduo->n = s;
                            scduo= scduo->n;

                            pfat->fatSupcurDuo= scduo;
                        }
                    }
                    
                    //sprintf_f(mrs->log, "2. v=%d \n", modersp->v);
                    //print_f(mrs->plog, "fs35", mrs->log);
                    
                    if (modersp->v > QSIZE) break;
                }
                if (ch == 'd') {
                    sprintf_f(mrs->log, "spi __1__ END!!!\n");
                    print_f(mrs->plog, "fs35", mrs->log);
                    modersp->v += 1;
                    modersp->v = 0 - modersp->v;
                    //mrs_ipc_put(mrs, "n", 1, 8);
                    //modersp->r |= 0x1;
                    //mrs_ipc_put(mrs, "e", 1, 8);
#if PULL_LOW_AFTER_DATA
                    bitset = 0;
                    msp_spi_conf(mrs->sfm[1], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
                    sprintf_f(mrs->log, "set spi1 RDY pin %d\n",bitset);
                    print_f(mrs->plog, "fs35", mrs->log);
                    usleep(210000);
#endif
                    break;
                }
                ret = mrs_ipc_get(mrs, &ch, 1, 2);
                //sprintf_f(mrs->log, "2. get ch: %c ret=%d - 2\n", ch, ret);
                //print_f(mrs->plog, "fs35", mrs->log);

            }

            if (modersp->v < 0) {
                modersp->c = 0 - modersp->v;
            } else {
                modersp->c = modersp->v;
            }

            //sprintf_f(mrs->log, "2. c=%d \n", modersp->c);
            //print_f(mrs->plog, "fs35", mrs->log);

            if (modersp->c > 0) {
                tmc = modersp->c;
                while (tmc) {
                    mrs_ipc_put(mrs, "n", 1, 8);
                    //dbgShowTimeStamp("hold", mrs, NULL, 2, NULL);
                    #if QDELAY
                    usleep(QDELAY);
                    #endif
                    //dbgShowTimeStamp("rele", mrs, NULL, 2, NULL);
                    tmc --;
                }
            } else {
                modersp->r |= 0x04;
            }
        }
    }
/*
    ret = aspCalcSupLen(pfat->fatSupdata);

    sprintf_f(mrs->log, "1. calcu total: %d\n", ret);
    print_f(mrs->plog, "fs35", mrs->log);

    ret = aspCalcSupLen(pfat->fatSupdataDuo);
    sprintf_f(mrs->log, "2. calcu total: %d\n", ret);
    print_f(mrs->plog, "fs35", mrs->log);
*/
    if ((modersp->r & 0x3) == 0x3) {
        if (sc) {
            len = ring_buf_cons_psudo(&mrs->cmdRx, &addr);
            while (len >= 0) {
                sprintf_f(mrs->log, "1. get psudo len:%d, cnt:%d\n", len, modersp->v);
                print_f(mrs->plog, "fs35", mrs->log);

                dst = sc->supdataBuff;
                memcpy(dst, addr, len);
                sc->supdataTot = len;
                
                s = aspMemalloc(sizeof(struct supdataBack_s), 10);
                memset(s, 0, sizeof(struct supdataBack_s));
                sc->n = s;
                sc = sc->n;

                pfat->fatSupcur = sc;
                modersp->v += 1;  
                len = ring_buf_cons_psudo(&mrs->cmdRx, &addr);
            }

            len = 0;
            s = pfat->fatSupdata;
            while (s) {
                if (s->supdataTot == 0) {
                    break;
                } else {
                    len += s->supdataTot;
                    //sprintf_f(mrs->log, "tot/len: %d/%d\n", s->supdataTot, len);
                    //print_f(mrs->plog, "fs68", mrs->log);
                }
                sc = s;
                s = s->n;
            }

            if (sc) {
                sc->n = 0;
            }

            while (s) {
                sc = s;
                s = s->n;
                
                memset(sc, 0, sizeof(struct supdataBack_s));
                aspMemFree(sc, 0);
            }
            pfat->fatSupcur = 0;

            ret = aspCalcSupLen(pfat->fatSupdata);

            sprintf_f(mrs->log, "1. count: %d, len: %d, total: %d END\n", modersp->v, len, ret);
            print_f(mrs->plog, "fs35", mrs->log);
        }

        if (scduo) {
            len = ring_buf_cons_psudo(&mrs->cmdTx, &addr);
            while (len >= 0) {
                sprintf_f(mrs->log, "2. get psudo len:%d, cnt:%d\n", len, modersp->v);
                print_f(mrs->plog, "fs68", mrs->log);

                dst = scduo->supdataBuff;
                memcpy(dst, addr, len);
                scduo->supdataTot = len;
                
                s = aspMemalloc(sizeof(struct supdataBack_s), 10);
                memset(s, 0, sizeof(struct supdataBack_s));
                scduo->n = s;
                scduo= scduo->n;

                pfat->fatSupcurDuo= scduo;
                modersp->v += 1;  
                len = ring_buf_cons_psudo(&mrs->cmdTx, &addr);
            }

            len = 0;
            s = pfat->fatSupdataDuo;
            while (s) {
                if (s->supdataTot == 0) {
                    break;
                } else {
                    len += s->supdataTot;
                    //sprintf_f(mrs->log, "tot/len: %d/%d\n", s->supdataTot, len);
                    //print_f(mrs->plog, "fs68", mrs->log);
                }
                scduo= s;
                s = s->n;
            }

            if (scduo) {
                scduo->n = 0;
            }

            while (s) {
                scduo= s;
                s = s->n;
                
                memset(scduo, 0, sizeof(struct supdataBack_s));
                aspMemFree(scduo, 0);
            }
            pfat->fatSupcurDuo= 0;

            ret = aspCalcSupLen(pfat->fatSupdataDuo);

            sprintf_f(mrs->log, "2. count: %d, len: %d, total: %d END\n", modersp->v, len, ret);
            print_f(mrs->plog, "fs35", mrs->log);
        }

        mrs_ipc_put(mrs, "N", 1, 3);
        mrs_ipc_put(mrs, "N", 1, 8);

        sprintf_f(mrs->log, "%d end\n", modersp->v);
        print_f(mrs->plog, "fs35", mrs->log);
        //modersp->m = modersp->m + 1;
        //return 2;
        modersp->r = 1;
        return 1;
    }

    return 0; 
}

static int fs36(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int bitset;
    int len=0;
    char ch=0;
    //sprintf_f(mrs->log, "wait socket finish \n");
    //print_f(mrs->plog, "fs36", mrs->log);

    len = mrs_ipc_get(mrs, &ch, 1, 3);
    if ((len > 0) && (ch == 'N')) {            
        modersp->m = modersp->m + 1;
        return 2;
    }

    return 0;
}

static int fs37(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    int bitset, ret;
    int len=0;
    char ch=0;

    len = mrs_ipc_get(mrs, &ch, 1, 8);
    if ((len > 0) && (ch == 'N')) {
        ring_buf_init(&mrs->cmdRx);
        ring_buf_init(&mrs->cmdTx);
        
        bitset = 0;
        msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 8, __u32), &bitset);   //SPI_IOC_WR_DATA_MODE
        sprintf_f(mrs->log, "spi0 Set data mode: %d\n", bitset);
        print_f(mrs->plog, "fs37", mrs->log);

        bitset = 0;
        msp_spi_conf(mrs->sfm[1], _IOW(SPI_IOC_MAGIC, 8, __u32), &bitset);   //SPI_IOC_WR_DATA_MODE
        sprintf_f(mrs->log, "spi1 Set data mode: %d\n", bitset);
        print_f(mrs->plog, "fs37", mrs->log);

        bitset = 1;
        msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 11, __u32), &bitset);   //SPI_IOC_WR_SLVE_READY
        sprintf_f(mrs->log, "Set spi 0 slave ready: %d\n", bitset);
        print_f(mrs->plog, "fs37", mrs->log);

        bitset = 1;
        msp_spi_conf(mrs->sfm[1], _IOW(SPI_IOC_MAGIC, 11, __u32), &bitset);   //SPI_IOC_WR_SLVE_READY
        sprintf_f(mrs->log, "Set spi 1 slave ready: %d\n", bitset);
        print_f(mrs->plog, "fs37", mrs->log);

#if SPI_KTHREAD_USE
        bitset = 0;
        ret = msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_STOP_THREAD
        sprintf_f(mrs->log, "Stop spi0 spidev thread, ret: 0x%x\n", ret);
        print_f(mrs->plog, "fs37", mrs->log);
        
        bitset = 0;
        ret = msp_spi_conf(mrs->sfm[1], _IOW(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_STOP_THREAD
        sprintf_f(mrs->log, "Stop spi1 spidev thread, ret: 0x%x\n", ret);
        print_f(mrs->plog, "fs37", mrs->log);
#endif

        if (modersp->d) {
            modersp->m = modersp->d;
            modersp->d = 0;
            return 2;
        } else {
            modersp->r = 1;
            return 1;
        }

        //modersp->r = 1;
        //return 1;
    }

    return 0;
}

static int fs38(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    return 0; 
}

static int fs39(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    return 0; 
}

static int fs40(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int bitset;
    bitset = 1;
    msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 11, __u32), &bitset);   //SPI_IOC_WR_SLVE_READY

    sprintf_f(mrs->log, "Set spi 0 slave ready: %d\n", bitset);
    print_f(mrs->plog, "fs40", mrs->log);

    bitset = 1;
    msp_spi_conf(mrs->sfm[1], _IOW(SPI_IOC_MAGIC, 11, __u32), &bitset);   //SPI_IOC_WR_SLVE_READY

    sprintf_f(mrs->log, "Set spi 1 slave ready: %d\n", bitset);
    print_f(mrs->plog, "fs40", mrs->log);

    modersp->r = 1;
    return 1;
}

static int fs41(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct info16Bit_s *p;
    p = &mrs->mchine.cur;
    //sprintf_f(mrs->log, "set %d 0x%.2x 0x%.2x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
    //print_f(mrs->plog, "fs41", mrs->log);

    mrs->mchine.seqcnt += 1;
    if (mrs->mchine.seqcnt >= 0x8) {
        mrs->mchine.seqcnt = 0;
    }
    
    mrs_ipc_put(mrs, "c", 1, 1);
    modersp->m = modersp->m + 1;
    return 0; 
}

static int fs42(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    int len=0;
    char ch=0;
    struct info16Bit_s *p;

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((len > 0) && (ch == 'C')) {
        msync(&mrs->mchine, sizeof(struct machineCtrl_s), MS_SYNC);

        p = &mrs->mchine.get;
        //sprintf_f(mrs->log, "get %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
        //print_f(mrs->plog, "fs42", mrs->log);
        
        if (ch == 'X') {
            sprintf_f(mrs->log, "FAIL!!send command again!\n");
            print_f(mrs->plog, "fs42", mrs->log);
            modersp->m = modersp->m - 1;        
            return 2;
        }
        
        if (p->opcode == OP_QRY) {
            modersp->m = modersp->m + 1;
        } else {
            modersp->r = 2;
            return 1;
        }
    }
    
    return 0; 
}

static int fs43(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct info16Bit_s *p;
    p = &mrs->mchine.cur;
    //sprintf_f(mrs->log, "set %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
    //print_f(mrs->plog, "fs43", mrs->log);

    mrs->mchine.seqcnt += 1;
    if (mrs->mchine.seqcnt >= 0x8) {
        mrs->mchine.seqcnt = 0;
    }
    
    mrs_ipc_put(mrs, "c", 1, 1);
    modersp->m = modersp->m + 1;
    return 0; 
}

static int fs44(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int len=0;
    char ch=0;
    struct info16Bit_s *p, *c;

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((len > 0) && (ch == 'C')) {
        msync(&mrs->mchine, sizeof(struct machineCtrl_s), MS_SYNC);

        c = &mrs->mchine.cur;
        p = &mrs->mchine.get;
        //sprintf_f(mrs->log, "get 0x%.2x/0x%.2x 0x%.2x/0x%.2x\n", p->opcode, c->opcode, p->data, c->data);
        //print_f(mrs->plog, "fs44", mrs->log);

        if (ch == 'X') {
            sprintf_f(mrs->log, "FAIL!!send command again!\n");
            print_f(mrs->plog, "fs44", mrs->log);
            modersp->m = modersp->m - 1;        
            return 2;
        }

        if (p->opcode == c->opcode){
            modersp->r = 1;
            return 1;
        } else {
            modersp->r = 2;
            return 1;
        }
    }
    return 0; 
}

static int fs45(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct sdParseBuff_s *pabuf=0;
    int bitset=0, ret;

    bitset = 0;
    pabuf = &mrs->aspFat.parBuf;
    
    msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 8, __u32), &bitset);   //SPI_IOC_WR_DATA_MODE
    sprintf_f(mrs->log, "spi0 Set data mode: %d\n", bitset);
    print_f(mrs->plog, "fs45", mrs->log);

#if SPI_KTHREAD_USE
    bitset = 0;
    ret = msp_spi_conf(mrs->sfm[0], _IOR(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_START_THREAD
    sprintf_f(mrs->log, "Start spi0 spidev thread, ret: 0x%x\n", ret);
    print_f(mrs->plog, "fs45", mrs->log);
#endif

    ring_buf_init(&mrs->dataRx);
    //pabuf->dirBuffUsed = 0;
    modersp->v = 0;
    
    sprintf_f(mrs->log, "trigger spi0 \n");
    print_f(mrs->plog, "fs45", mrs->log);

    mrs_ipc_put(mrs, "s", 1, 1);
    //clock_gettime(CLOCK_REALTIME, &mrs->time[0]);

    modersp->m = modersp->m + 1;
    return 2;
}

static int fs46(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct sdParseBuff_s *pabuf=0;
    int ret, bitset, loop=0, len=0, bufn, dstsz=0, totsz;
    char ch;
    char *src, *dst, *pt;

    //sprintf_f(mrs->log, "%d\n", modersp->v);
    //print_f(mrs->plog, "fs46", mrs->log);
    pabuf = &mrs->aspFat.parBuf;
    
    ret = mrs_ipc_get(mrs, &ch, 1, 1);
    while (ret > 0) {
        if (ch == 's') {
            modersp->v += 1;
        }

        if (ch == 'S') {
            sprintf_f(mrs->log, "ch:%c, v:%d break\n", ch, modersp->v);
            print_f(mrs->plog, "fs46", mrs->log);

            modersp->r |= 0x1;
            break;
        }
        ret = mrs_ipc_get(mrs, &ch, 1, 1);
    }

    if (modersp->r & 0x1) {
        bufn = ring_buf_info_len(&mrs->dataRx);
        sprintf_f(mrs->log, "%d end, bufn: %d, spirecv: %d\n", modersp->v, bufn, pabuf->dirBuffUsed);
        print_f(mrs->plog, "fs46", mrs->log);

        if (!pabuf->dirParseBuff) {
            dstsz = (bufn + 1) * SPI_TRUNK_SZ;
            dst = aspMemalloc(dstsz, 10);
            if (!dst) {
                sprintf_f(mrs->log, "cnt: %d, len: %d\n", loop, len);
                print_f(mrs->plog, "fs46", mrs->log);
                modersp->r = 0xed;
                return 1;
            }
            memset(dst, 0, dstsz);
            pabuf->dirBuffMax = dstsz;
            pabuf->dirParseBuff = dst;
        } else {
            dst = pabuf->dirParseBuff + pabuf->dirBuffUsed;
        }
        
        totsz = 0;
        pt = dst;
        loop = modersp->v;
        while (loop > 0) {
            len = ring_buf_cons(&mrs->dataRx, &src);
            if (len < 0) {
                sprintf_f(mrs->log, "ERROR!!! get ring buff failed ret: %d\n", len);
                print_f(mrs->plog, "fs46", mrs->log);
                modersp->r = 0xed;
                return 1;
            }
            
            msync(src, len, MS_SYNC);

            memcpy(pt, src, len);

            totsz += len;
            pt += len;
            loop --;
            
            sprintf_f(mrs->log, "%d. len: %d, totsz:%d\n", loop, len, totsz);
            print_f(mrs->plog, "fs46", mrs->log);
        }

        pabuf->dirBuffUsed += totsz;
        //pabuf->dirParseBuff = dst;
        modersp->m = modersp->m + 1;
        return 2;
    }

    return 0;
}

static int fs47(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct sdParseBuff_s *pabuf=0;
    int ret, bitset;
    char ch;

    //sprintf_f(mrs->log, "%d\n", modersp->v++);
    //print_f(mrs->plog, "fs47", mrs->log);

    ret = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((ret > 0) && (ch == 'S')){
        clock_gettime(CLOCK_REALTIME, &mrs->time[1]);
        pabuf = &mrs->aspFat.parBuf;
        sprintf_f(mrs->log, "spi 0 end, buff used: %d\n", pabuf->dirBuffUsed);
        print_f(mrs->plog, "fs47", mrs->log);
        
        modersp->m = modersp->m + 1;

#if SPI_KTHREAD_USE
         bitset = 0;
         ret = msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_STOP_THREAD
         sprintf_f(mrs->log, "Stop spi0 spidev thread, ret: 0x%x\n", ret);
         print_f(mrs->plog, "fs47", mrs->log);
#endif
#if PULL_LOW_AFTER_DATA
        bitset = 0;
        msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
        sprintf_f(mrs->log, "set RDY pin %d\n",bitset);
        print_f(mrs->plog, "fs47", mrs->log);
        usleep(210000);
#endif


        return 2;
    }

    return 0; 
}

static int fs48(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct info16Bit_s *p;

    //sprintf_f(mrs->log, "get OP_FIH \n");
    //print_f(mrs->plog, "fs48", mrs->log);

    p = &mrs->mchine.cur;

    mrs->mchine.seqcnt += 1;
    if (mrs->mchine.seqcnt >= 0x8) {
        mrs->mchine.seqcnt = 0;
    }

    p->opcode = OP_FIH;
    p->inout = 0;
    p->seqnum = mrs->mchine.seqcnt;
    
    mrs_ipc_put(mrs, "c", 1, 1);
    modersp->m = modersp->m + 1;
    return 0; 
}

static int fs49(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int len=0;
    char ch=0;
    struct info16Bit_s *p;
    
    //sprintf_f(mrs->log, "get OP_FIH \n");
    //print_f(mrs->plog, "fs49", mrs->log);
    
    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((len > 0) && (ch == 'C')) {
        msync(&mrs->mchine, sizeof(struct machineCtrl_s), MS_SYNC);

        p = &mrs->mchine.get;
        //sprintf_f(mrs->log, "get %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
        //print_f(mrs->plog, "fs49", mrs->log);

        if (p->opcode == OP_FIH) {
            modersp->m = 6; 
            return 2;
        } else {
            modersp->r = 2;
            return 1;
        }
    }
    
    if ((len > 0) && (ch == 'X')) {
        sprintf_f(mrs->log, "FAIL!!send command again!\n");
        print_f(mrs->plog, "fs49", mrs->log);
        modersp->m = modersp->m - 1;        
        return 2;
    }

    if ((len > 0) && (ch == 'R')) {
            int fd0=0, fdr=0;

            fdr = mrs->sfm[0];
            
            sprintf_f(mrs->log, "FAIL!!reset spi _0_!\n");
            print_f(mrs->plog, "fs49", mrs->log);

            close(fdr);
            
#if SPIDEV_SWITCH
            fd0 = open(spidev_1, O_RDWR);
#else
            fd0 = open(spidev_0, O_RDWR);
#endif

            if (fd0 <= 0) {
                sprintf_f(mrs->log, "can't open device[%s]\n", spidev_0); 
                print_f(mrs->plog, "fs49", mrs->log);
            } else {
                sprintf_f(mrs->log, "open device[%s] id: %d \n", spidev_0, fd0); 
                print_f(mrs->plog, "fs49", mrs->log);
            }

            mrs->sfm[0] = fd0;

            sprintf_f(mrs->log, "ERROR !! bypasss 0x07!\n");
            print_f(mrs->plog, "fs49", mrs->log);
            
            modersp->m = modersp->m + 1;        
            return 2;
    }
    
    return 0; 
}

static int fs50(struct mainRes_s *mrs, struct modersp_s *modersp)
{
#define SF0 (8 * 0)
#define SF1 (8 * 1)
#define SF2 (8 * 2)
#define SF3 (8 * 3)

    uint32_t val=0, i=0;
    char *pr=0;
    uint32_t secStr=0, secLen=0;
    struct aspConfig_s *pct=0;
    struct sdbootsec_s   *psec=0;
    struct sdFAT_s *pfat=0;
    struct sdParseBuff_s *pParBuf=0;
    struct info16Bit_s *p=0, *c=0;
    
    sprintf_f(mrs->log, "parsing boot sector \n");
    print_f(mrs->plog, "fs50", mrs->log);

    c = &mrs->mchine.cur;
    p = &mrs->mchine.tmp;
    
    pct = mrs->configTable;
    pfat = &mrs->aspFat;
    pParBuf = &pfat->parBuf;

    if (pParBuf->dirBuffUsed) {
        sprintf_f(mrs->log, "parsing, buff  size:%d\n", pParBuf->dirBuffUsed);
        print_f(mrs->plog, "fs50", mrs->log);

        pr = pParBuf->dirParseBuff;
        
        shmem_dump(pr, 512);
        
        psec = &pfat->fatBootsec;
        //memset(psec, 0, sizeof(struct sdbootsec_s));
        //msync(psec, sizeof(struct sdbootsec_s), MS_SYNC);
        
        /* 0  Jump command */
        psec->secJpcmd = pr[0] | (pr[1] << SF1) | (pr[2] << SF2) | (pr[3] << SF3);
        /* 3  system id */
        for (i = 0; i < 8; i++) {
            psec->secSysid[i] = pr[3+i];
        }
        psec->secSysid[7] = '\0';
        /* 11 sector size */ 
        psec->secSize = aspRawCompose(&pr[11], 2);
        /* 13 sector per cluster */
        psec->secPrClst = pr[13];
        /* 14 reserved sector count*/
        psec->secResv = aspRawCompose(&pr[14], 2);
        /* 16 number of FATs */
        psec->secNfat = pr[16];
        /* 17 skip, number of root dir entries */
        /* 19 skip, total sectors */
        /* 21 medium id */
        psec->secIDm = pr[21];
        /* 22 skip, sector per FAT */
        /* 24 sector per track */
        psec->secPrtrk = aspRawCompose(&pr[24], 2);
        /* 26 number of sides */
        psec->secNsid = aspRawCompose(&pr[26], 2);
        /* 28 number of hidded sectors */
        psec->secNhid = aspRawCompose(&pr[28], 4);
        /* 32 total sectors */
        psec->secTotal = aspRawCompose(&pr[32], 4);
        /* 36 sectors per FAT */
        psec->secPrfat = aspRawCompose(&pr[36], 4);
        /* 40 extension flag */
        psec->secExtf = aspRawCompose(&pr[40], 2);
        /* 42 FS version */
        psec->secVers = aspRawCompose(&pr[42], 2); 
        /* 44 root cluster */
        psec->secRtclst = aspRawCompose(&pr[44], 4); 
        /* 48 FS info */
        psec->secFSif = aspRawCompose(&pr[48], 2); 
        /* 50 backup boot sector */
        psec->secBkbt = aspRawCompose(&pr[50], 2); 
        /* 64 physical disk number */
        psec->secPhdk = pr[64];
        /* 66 extended boot record signature */
        psec->secExtbt = pr[66];
        /* 67 volume ID number */
        psec->secVoid = aspRawCompose(&pr[67], 4); 
        /* 71 to 81 volume label */
        for (i = 0; i < 11; i++) {
            psec->secVola[i] = pr[71+i];
        }
        psec->secVola[11] = '\0';
        /* 82 to 89 file system type */
        for (i = 0; i < 8; i++) {
            psec->secFtyp[i] = pr[82+i];
        }
        psec->secFtyp[8] = '\0';
        /* 510 signature word */
        psec->secSign = aspRawCompose(&pr[510], 2); 

        /* set the boot sector status to 1 */
        psec->secSt = 1;

        psec->secWhfat = psec->secResv;
        psec->secWhroot = psec->secWhfat + psec->secPrfat * 2;

        //pParBuf->dirBuffUsed = 0;
        
#if 0 /* test reverse fat */
        /* 0  Jump command */
        memset(fatRev, 0, 512);
        
        shmem_dump(fatRev, 512);
        
        /*
        for (i=0; i < 512; i++) {
            fatRev[i] = 0;
        }
        */
        //msync(fatRev, 512, MS_SYNC);
        
        aspRawReverse(&fatRev[0], 4, psec->secJpcmd);
        
        /* 3  system id */
        for (i = 0; i < 8; i++) {
            fatRev[3+i] = psec->secSysid[i];
        }
        /* 11 sector size */ 
        aspRawReverse(&fatRev[11], 2, psec->secSize);
        
        /* 13 sector per cluster */
        fatRev[13] = psec->secPrClst;

        /* 14 reserved sector count*/
        aspRawReverse(&fatRev[14], 2, psec->secResv);
        
        /* 16 number of FATs */
        fatRev[16] = psec->secNfat;
        /* 17 skip, number of root dir entries */
        /* 19 skip, total sectors */
        /* 21 medium id */
        fatRev[21] = psec->secIDm;
        /* 22 skip, sector per FAT */
        /* 24 sector per track */
        aspRawReverse(&fatRev[24], 2, psec->secPrtrk);
        
        /* 26 number of sides */
        aspRawReverse(&fatRev[26], 2, psec->secNsid);

        /* 28 number of hidded sectors */
        aspRawReverse(&fatRev[28], 4, psec->secNhid);
        
        /* 32 total sectors */
        aspRawReverse(&fatRev[32], 4, psec->secTotal);
        /* 36 sectors per FAT */
        aspRawReverse(&fatRev[36], 4, psec->secPrfat);
        /* 40 extension flag */
        aspRawReverse(&fatRev[40], 2, psec->secExtf);
        /* 42 FS version */
        aspRawReverse(&fatRev[42], 2, psec->secVers);
        /* 44 root cluster */
        aspRawReverse(&fatRev[44], 4, psec->secRtclst);
        /* 48 FS info */
        aspRawReverse(&fatRev[48], 2, psec->secFSif);
        /* 50 backup boot sector */ 
        aspRawReverse(&fatRev[50], 2, psec->secBkbt);
        
        /* 64 physical disk number */
        fatRev[64] = psec->secPhdk;
        /* 66 extended boot record signature */
        fatRev[66] = psec->secExtbt;
        /* 67 volume ID number */
        
        aspRawReverse(&fatRev[67], 4, psec->secVoid);
        
        /* 71 to 81 volume label */
        for (i = 0; i < 11; i++) {
             fatRev[71+i] = psec->secVola[i];
        }
         
        /* 82 to 89 file system type */
        for (i = 0; i < 8; i++) {
            fatRev[82+i] = psec->secFtyp[i];
        }
        
        /* 510 signature word */
        aspRawReverse(&fatRev[510], 2, psec->secSign);

        shmem_dump(fatRev, 512);
        shmem_dump(pr, 512);
#endif

        if (psec->secSize == 512) {
            pfat->fatStatus |= ASPFAT_STATUS_BOOT_SEC;
            psec->secWhfat += psec->secBoffset;
            psec->secWhroot += psec->secBoffset;

            debugPrintBootSec(psec);
            pParBuf->dirBuffUsed = 0;
        } else {
            pfat->fatRetry += 1;
#if 0 /* test if boot failed */
            if (pfat->fatRetry == 2) {
                modersp->r = 0xed;
                return 1;
            }

            else if (pfat->fatRetry == 4) {
                modersp->r = 0xed;
                return 1;
            }

            else if (pfat->fatRetry == 6) {
                modersp->r = 0xed;
                return 1;
            }

            else if (pfat->fatRetry == 8) {
                modersp->r = 0xed;
                return 1;
            }

            else if (pfat->fatRetry == 10) {
                modersp->r = 0xed;
                return 1;
            }

            else if (pfat->fatRetry == 12) {
                modersp->r = 0xed;
                return 1;
            }

            else if (pfat->fatRetry > 14) {
                psec->secBoffset = 8192;
            }
#else
            memset(psec, 0, sizeof(struct sdbootsec_s));
            msync(psec, sizeof(struct sdbootsec_s), MS_SYNC);

            if (pfat->fatRetry > 6) {
                //psec->secBoffset = 8192;
                //pfat->fatStatus &= ~ASPFAT_STATUS_MBR;
                modersp->r = 0xed;
                return 1;
            } else {
                pParBuf->dirBuffUsed = 0;
            }
#endif
        }

        sprintf_f(mrs->log, "!!!! boot retry :%d offset: %d  !!!!\n", pfat->fatRetry, psec->secBoffset);
        print_f(mrs->plog, "fs50", mrs->log);

        modersp->r = 1;
    }else {
        secStr = c->opinfo;
        secLen = p->opinfo;

        sprintf_f(mrs->log, "buff empty, set str:%d(0x%x), len:%d \n", secStr, secStr, secLen);
        print_f(mrs->plog, "fs50", mrs->log);

        cfgTableSet(pct, ASPOP_SDFAT_RD, 1);

        val = cfgValueOffset(secStr, 24);
        cfgTableSet(pct, ASPOP_SDFAT_STR01, val);
        val = cfgValueOffset(secStr, 16);
        cfgTableSet(pct, ASPOP_SDFAT_STR02, val);
        val = cfgValueOffset(secStr, 8);
        cfgTableSet(pct, ASPOP_SDFAT_STR03, val);
        val = cfgValueOffset(secStr, 0);
        cfgTableSet(pct, ASPOP_SDFAT_STR04, val);

        val = cfgValueOffset(secLen, 24);
        cfgTableSet(pct, ASPOP_SDFAT_LEN01, val);
        val = cfgValueOffset(secLen, 16);
        cfgTableSet(pct, ASPOP_SDFAT_LEN02, val);
        val = cfgValueOffset(secLen, 8);
        cfgTableSet(pct, ASPOP_SDFAT_LEN03, val);
        val = cfgValueOffset(secLen, 0);
        cfgTableSet(pct, ASPOP_SDFAT_LEN04, val);

        cfgTableSet(pct, ASPOP_SDFAT_SDAT, 1);

        modersp->r = 2;
    }


    return 1;
}
static int fs51(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    int val=0, i=0, ret=0, err=0, clstlen=0, datlen=0;
    char *pr=0;
    uint32_t secStr=0, secLen=0;
    struct aspConfig_s *pct=0;
    struct sdbootsec_s   *psec=0;
    struct sdFAT_s *pfat=0;
    struct sdParseBuff_s *pParBuf=0;
    struct info16Bit_s *p=0, *c=0;
    struct directnFile_s *curDir=0, *ch=0, *br=0, *rootdir=0;
    struct folderQueue_s *pfhead=0, *pfdirt=0, *pfnext=0;
    struct adFATLinkList_s *pflsh=0, *pflnt=0;
    struct sdFATable_s   *pftb=0;
    
    c = &mrs->mchine.cur;
    p = &mrs->mchine.tmp;
    
    pct = mrs->configTable;
    pfat = &mrs->aspFat;
    pParBuf = &pfat->parBuf;
    psec = &pfat->fatBootsec;
    pftb = &pfat->fatTable;
    
    if (pftb->c) {
        pflnt = pftb->c;
        pftb->c = pflnt->n;
        aspMemFree(pflnt, 0);
    }

    if ((!pftb->c) && (pParBuf->dirBuffUsed)) {
        sprintf_f(mrs->log, "parsing, buff  size:%d\n", pParBuf->dirBuffUsed);
        print_f(mrs->plog, "fs51", mrs->log);

        pftb->h = 0;
        
        pr = pParBuf->dirParseBuff;

        ret = aspFS_createFATRoot(pfat);
        if (ret == 0) {
            rootdir = pfat->fatDirTr.dirRoot;
            err = aspFS_insertFATChilds(pfat, rootdir, pr, pParBuf->dirBuffUsed);
            sprintf_f(mrs->log, "parsing resut:  %d \n", err);
            print_f(mrs->plog, "fs51", mrs->log);
        }

        if (rootdir->ch) {
            sprintf_f(mrs->log, "boot dir's first ch SFN:  [%s] \n", rootdir->ch->dfSFN);
            print_f(mrs->plog, "fs51", mrs->log);
        } else {
            sprintf_f(mrs->log, "boot dir's no first ch SFN, boot SFN:  [%s] \n", rootdir->dfSFN);
            print_f(mrs->plog, "fs51", mrs->log);
        }

        //if (rootdir->ch->dftype) {
        if (!err) {
            pfat->fatStatus |= ASPFAT_STATUS_ROOT_DIR;
        }        

        curDir = rootdir;
        br= curDir->ch;

#if 0 /* do folder parsing anyway */
        if (!br) {
            pfat->fatStatus |= ASPFAT_STATUS_FOLDER;
            modersp->r = 1;
            return 1;
        }
#endif

        while (br) {
            if (br->dftype == ASPFS_TYPE_DIR) {
                if ((strcmp(br->dfSFN, "..") != 0) && (strcmp(br->dfSFN, ".") != 0)) {
                    sprintf_f(mrs->log, "ADD folder [%s] to parsing queue\n", br->dfSFN);
                    print_f(mrs->plog, "fs51", mrs->log);
                    pfdirt = aspMemalloc(sizeof(struct folderQueue_s), 10);
                    pfdirt->fdObj = br;
                    pfdirt->fdnxt = 0;
                    
                    if (!pfhead) {
                        pfhead = pfdirt;
                    } else {
                        pfnext = pfhead;
                        
                        while (pfnext->fdnxt) {
                            pfnext = pfnext->fdnxt;
                        }

                        pfnext->fdnxt = pfdirt;
                    }
                }
            }

            br = br->br;            
        }

        pParBuf->dirBuffUsed = 0;
        mrs->folder_dirt = pfhead;

        if (rootdir) {
            aspFScpDir(&pfat->fatRootdir, rootdir);
        }
        
        modersp->r = 1;

        if (err < 0) {
            modersp->r = 0xed;
        }
    }
    else {

        if (!pftb->h) {
            pflsh = 0;
            ret = mspSD_parseFAT2LinkList(&pflsh, psec->secRtclst, pftb->ftbFat1, (psec->secTotal - psec->secWhroot) / psec->secPrClst);
            if (ret) {
                sprintf_f(mrs->log, "FAT table parsing for root dictionary FAIL!!ret:%d \n", ret);
                print_f(mrs->plog, "fs51", mrs->log);
                modersp->r = 3;
                return 1;
            }
            sprintf_f(mrs->log, "show root FAT link str:\n");
            print_f(mrs->plog, "fs51", mrs->log);

            pflnt = pflsh;
            while (pflnt) {
                clstlen += pflnt->ftLen;
                sprintf_f(mrs->log, "    str:%d len:%d\n", pflnt->ftStart, pflnt->ftLen);
                print_f(mrs->plog, "fs51", mrs->log);
                pflnt = pflnt->n;
            }
            pftb->h = pflsh;
            pftb->c = pftb->h;

            sprintf_f(mrs->log, "total cluster len:%d\n", clstlen);
            print_f(mrs->plog, "fs51", mrs->log);            

            datlen = (clstlen * psec->secPrClst) * 512;
            pr = aspMemalloc(datlen, 10);
            if (!pr) {
                sprintf_f(mrs->log, "memory alloc error len: %d\n", datlen);
                print_f(mrs->plog, "fs51", mrs->log);
                modersp->r = 0xed;
                return 1;
            } else {
                sprintf_f(mrs->log, "parsing buffer memory alloc succeed len: %d(10)\n", datlen);
                print_f(mrs->plog, "fs51", mrs->log);
            }
            memset(pr, 0, datlen);
            pParBuf->dirBuffMax = datlen;
            pParBuf->dirParseBuff = pr;
            pParBuf->dirBuffUsed = 0;
        }

            
        pflnt = pftb->c;
                 
        secStr = (pflnt->ftStart - 2) * psec->secPrClst + psec->secWhroot;
        secLen = pflnt->ftLen * psec->secPrClst;

        c->opinfo = secStr;
        p->opinfo = secLen;

        if (secLen < 16) secLen = 16;

        sprintf_f(mrs->log, "buff empty, set str:%d, len:%d, pbuff used: %d \n", secStr, secLen, pParBuf->dirBuffUsed);
        print_f(mrs->plog, "fs51", mrs->log);

        cfgTableSet(pct, ASPOP_SDFAT_RD, 1);

        val = cfgValueOffset(secStr, 24);
        cfgTableSet(pct, ASPOP_SDFAT_STR01, val);
        val = cfgValueOffset(secStr, 16);
        cfgTableSet(pct, ASPOP_SDFAT_STR02, val);
        val = cfgValueOffset(secStr, 8);
        cfgTableSet(pct, ASPOP_SDFAT_STR03, val);
        val = cfgValueOffset(secStr, 0);
        cfgTableSet(pct, ASPOP_SDFAT_STR04, val);
        val = cfgValueOffset(secLen, 24);
        cfgTableSet(pct, ASPOP_SDFAT_LEN01, val);
        val = cfgValueOffset(secLen, 16);
        cfgTableSet(pct, ASPOP_SDFAT_LEN02, val);
        val = cfgValueOffset(secLen, 8);
        cfgTableSet(pct, ASPOP_SDFAT_LEN03, val);
        val = cfgValueOffset(secLen, 0);
        cfgTableSet(pct, ASPOP_SDFAT_LEN04, val);

        cfgTableSet(pct, ASPOP_SDFAT_SDAT, 1);

        modersp->r = 2;
    }

    return 1;
}
static int fs52(struct mainRes_s *mrs, struct modersp_s *modersp) 
{
    char strFullPath[544];
    char strPath[32][16];
    int val=0, i=0, ret=0, last=0, offset=0;
    char *pr=0;
    uint32_t secStr=0, secLen=0;
    struct aspConfig_s *pct=0;
    struct sdbootsec_s   *psec=0;
    struct sdFAT_s *pfat=0;
    struct sdParseBuff_s *pParBuf=0;
    struct info16Bit_s *p=0, *c=0;
    struct directnFile_s *curDir=0, *ch=0, *br=0, *pa=0;
    struct folderQueue_s *pfhead=0, *pfdirt=0, *pfnext=0;
    struct adFATLinkList_s *pflsh=0, *pflnt=0;
    struct sdFATable_s   *pftb=0;
    
    c = &mrs->mchine.cur;
    p = &mrs->mchine.tmp;
    
    pct = mrs->configTable;
    pfat = &mrs->aspFat;
    pParBuf = &pfat->parBuf;
    psec = &pfat->fatBootsec;
    pftb = &pfat->fatTable;
    
    if (mrs->folder_dirt) {
        pfhead = mrs->folder_dirt;
        curDir = pfhead->fdObj;

        if (pftb->c) {
            pflnt = pftb->c;
            pftb->c = pflnt->n;
            aspMemFree(pflnt, 0);
        }

        if ((!pftb->c) && (pParBuf->dirBuffUsed)) {
            sprintf_f(mrs->log, "parsing, buff  size:%d\n", pParBuf->dirBuffUsed);
            print_f(mrs->plog, "fs52", mrs->log);

            pftb->h = 0;

            pr = pParBuf->dirParseBuff;
            last = pParBuf->dirBuffUsed;

            mspFS_insertFATChildDir(pfat, curDir, pr, last);

            ch = curDir->ch;
            if (!ch) {
                sprintf_f(mrs->log, "ERROR!! folder [%s] should have child\n", curDir->dfSFN);
                print_f(mrs->plog, "fs52", mrs->log);

                modersp->r = 0xed;
                return 1;
            }
            
            br = ch->br;
            while (br) {
                if (br->dftype == ASPFS_TYPE_DIR) {
                    if ((strcmp(br->dfSFN, "..") != 0) && (strcmp(br->dfSFN, ".") != 0)) {
                        sprintf_f(mrs->log, "ADD folder [%s]\n", br->dfSFN);
                        print_f(mrs->plog, "fs52", mrs->log);

                        pfdirt = aspMemalloc(sizeof(struct folderQueue_s), 10);
                        pfdirt->fdObj = br;
                        pfdirt->fdnxt = 0;
                    
                        if (!pfhead) {
                            pfhead = pfdirt;
                        } else {
                            pfnext = pfhead;
                        
                            while (pfnext->fdnxt) {
                                pfnext = pfnext->fdnxt;
                            }

                            pfnext->fdnxt = pfdirt;
                        }
                    }
                }
/*
                pflsh = 0;
                ret = mspSD_parseFAT2LinkList(&pflsh, br->dfclstnum, pftb->ftbFat1, pftb->ftbLen/4);
                if (ret) {
                    sprintf_f(mrs->log, "FAT table parsing for root dictionary FAIL!!ret:%d \n", ret);
                    print_f(mrs->plog, "fs52", mrs->log);
                } else {
                    sprintf_f(mrs->log, "show FAT for /root/%s\n", br->dfSFN);
                    print_f(mrs->plog, "fs52", mrs->log);
                }
                
                pflnt = pflsh;
                while (pflnt) {
                    sprintf_f(mrs->log, "check list str:%d len:%d\n", pflnt->ftStart, pflnt->ftLen);
                    print_f(mrs->plog, "fs52", mrs->log);
                    pflnt = pflnt->n;
                }
*/
                br = br->br;
            }

            pParBuf->dirBuffUsed = 0;
            
            mrs->folder_dirt = pfhead->fdnxt;
            aspMemFree(pfhead, 0);
            
        }
    }
    
    if (mrs->folder_dirt) {
        pfhead = mrs->folder_dirt;
        curDir = pfhead->fdObj;

        if (!pftb->h) {
            pflsh = 0;

            ret = mspSD_parseFAT2LinkList(&pflsh, curDir->dfclstnum, pftb->ftbFat1, (psec->secTotal - psec->secWhroot) / psec->secPrClst);
            if (ret) {
                sprintf_f(mrs->log, "FAT table parsing for root dictionary FAIL!!ret:%d (%s)\n", ret, curDir->dfSFN);
                print_f(mrs->plog, "fs52", mrs->log);
                modersp->r = 0xed;
                return 1;
            }
            /* debug */
            sprintf_f(mrs->log, "show FAT link for [%s]:\n", curDir->dfSFN);
            print_f(mrs->plog, "fs52", mrs->log);

            pflnt = pflsh;
            while (pflnt) {
                sprintf_f(mrs->log, "    str:%d len:%d\n", pflnt->ftStart, pflnt->ftLen);
                print_f(mrs->plog, "fs52", mrs->log);
                pflnt = pflnt->n;
            }
            pftb->h = pflsh;
            pftb->c = pftb->h;
        }

        pflnt = pftb->c;

        sprintf_f(mrs->log, "[%d x %d + %d] \n",pflnt->ftStart - 2, psec->secPrClst, psec->secWhroot);
        print_f(mrs->plog, "fs52", mrs->log);
                 
        secStr = (pflnt->ftStart - 2) * (uint32_t)psec->secPrClst + (uint32_t)psec->secWhroot;
        secLen = pflnt->ftLen * (uint32_t)psec->secPrClst;
        //secStr = (curDir->dfclstnum - 2) * psec->secPrClst + psec->secWhroot;
        //secLen = psec->secPrClst;

        c->opinfo = secStr;
        p->opinfo = secLen;

        if (secLen < 16) secLen = 16;
        
        memset(strPath[0], 0, 512);

        pa = curDir;
        i = 0;
        while(pa) {

            strcpy(strPath[i], pa->dfSFN);
            pa = pa->pa;
            i++;
            if (i >= 16) break;
        }

        memset(strFullPath, 0, 544);
        
        pr = strFullPath;
        while (i) {
            i --;
            *pr = '/';
            pr += 1;
            
            ret = strnlen(strPath[i], sizeof(strPath[i]));
            strncpy(pr, strPath[i], ret);
            pr += ret;
            
        }

        sprintf_f(mrs->log, "NEXT parsing dir[%s], set str:%d, len:%d(%d) \n", strFullPath, secStr, secLen, pflnt->ftStart);
        print_f(mrs->plog, "fs52", mrs->log);

        cfgTableSet(pct, ASPOP_SDFAT_RD, 1);

        val = cfgValueOffset(secStr, 24);
        cfgTableSet(pct, ASPOP_SDFAT_STR01, val);
        val = cfgValueOffset(secStr, 16);
        cfgTableSet(pct, ASPOP_SDFAT_STR02, val);
        val = cfgValueOffset(secStr, 8);
        cfgTableSet(pct, ASPOP_SDFAT_STR03, val);
        val = cfgValueOffset(secStr, 0);
        cfgTableSet(pct, ASPOP_SDFAT_STR04, val);
        val = cfgValueOffset(secLen, 24);
        cfgTableSet(pct, ASPOP_SDFAT_LEN01, val);
        val = cfgValueOffset(secLen, 16);
        cfgTableSet(pct, ASPOP_SDFAT_LEN02, val);
        val = cfgValueOffset(secLen, 8);
        cfgTableSet(pct, ASPOP_SDFAT_LEN03, val);
        val = cfgValueOffset(secLen, 0);
        cfgTableSet(pct, ASPOP_SDFAT_LEN04, val);

        cfgTableSet(pct, ASPOP_SDFAT_SDAT, 1);

        modersp->r = 2;
    }
    else {
        pfat->fatStatus |= ASPFAT_STATUS_FOLDER;
        modersp->r = 1;
    }

    return 1;
}
static int fs53(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
#define FAT_FILE (1)

#if FAT_FILE
    FILE *f=0;
    char fatPath[128] = "/tmp/fatTab.bin";
    char fatDst[128];
#endif

    int val=0, i=0, ret = 0;
    char *pr=0;
    uint32_t secStr=0, secLen=0, freeClst=0, usedClst=0, totClst=0;
    struct aspConfig_s *pct=0;
    struct sdbootsec_s   *psec=0;
    struct sdFAT_s *pfat=0;
    struct sdParseBuff_s *pParBuf=0;
    struct info16Bit_s *p=0, *c=0;
    struct sdFATable_s   *pftb=0;
    struct adFATLinkList_s *pfatfree=0, *pflnt=0;
    
    sprintf_f(mrs->log, "read FAT  \n");
    print_f(mrs->plog, "fs53", mrs->log);

    c = &mrs->mchine.cur;
    p = &mrs->mchine.tmp;
    
    pct = mrs->configTable;
    pfat = &mrs->aspFat;
    pftb = &pfat->fatTable;
    psec = &pfat->fatBootsec;
    pParBuf = &pfat->parBuf;

    if (pftb->ftbFat1) {
        sprintf_f(mrs->log, "get FAT table, addr:0x%.8x, len:%d\n", (uint32_t)pftb->ftbFat1, pftb->ftbLen);
        print_f(mrs->plog, "fs53", mrs->log);

        shmem_dump(pftb->ftbFat1, 512);
        
#if FAT_FILE
        //ret = file_save_get(&f, fatPath);
        //f = find_save(fatDst, fatPath);
        f = fopen(fatPath, "w+");

        if (f) {
            msync(pftb->ftbFat1, pftb->ftbLen, MS_SYNC);
            fwrite(pftb->ftbFat1, 1, pftb->ftbLen, f);
            fflush(f);
            fclose(f);
            sprintf_f(mrs->log, "FAT table save to [%s] size:%d\n", fatPath, pftb->ftbLen);
            print_f(mrs->plog, "fs53", mrs->log);
        } else {
            sprintf_f(mrs->log, "FAT table find save to [%s] failed !!!\n", fatPath);
            print_f(mrs->plog, "fs53", mrs->log);
        }
/*
        aspMemFree(pftb->ftbFat1, 0);
        pftb->ftbFat1 = 0;
        pftb->ftbLen = 0;
*/
#endif
        sprintf_f(mrs->log, "total sector: %d, root sector: %d, free cluster: %d vs secPerfat: %d\n", psec->secTotal, psec->secWhroot, (psec->secTotal - psec->secWhroot) / psec->secPrClst, psec->secPrfat);
        print_f(mrs->plog, "fs53", mrs->log);

        totClst = (psec->secTotal - psec->secWhroot) / psec->secPrClst;
        ret = mspSD_getFreeFATList(&pfatfree, 0, pftb->ftbFat1, totClst);
        if (!ret) {
            sprintf_f(mrs->log, "show FAT free space \n");
            print_f(mrs->plog, "fs53", mrs->log);

            freeClst = 0;
            pflnt = pfatfree;
            while (pflnt) {
                freeClst += pflnt->ftLen;
                sprintf_f(mrs->log, "start: %d len:%d \n", pflnt->ftStart, pflnt->ftLen);
                print_f(mrs->plog, "fs53", mrs->log);
                pflnt = pflnt->n;
            }
            sprintf_f(mrs->log, "total free cluster: %d, free sector: %d (%d) \n", freeClst, freeClst * psec->secPrClst, freeClst * psec->secPrClst * psec->secSize);
            print_f(mrs->plog, "fs53", mrs->log);     
            usedClst = totClst - freeClst;
            
            pftb->ftbMng.ftfreeClst = freeClst;
            pftb->ftbMng.ftusedClst = usedClst;
            pftb->ftbMng.f = pfatfree;
            
            pfat->fatStatus |= ASPFAT_STATUS_FAT;
            msync(pftb->ftbFat1, pftb->ftbLen, MS_SYNC);
            
            modersp->r = 1;
        } else {
            sprintf_f(mrs->log, "parse FAT free space failed, ret:0x%x \n", ret);
            print_f(mrs->plog, "fs53", mrs->log);
            modersp->r = 0xed;
        }
    }else {
        secStr = c->opinfo;
        secLen = p->opinfo;

        sprintf_f(mrs->log, "buff empty, set str:%d, len:%d \n", secStr, secLen);
        print_f(mrs->plog, "fs53", mrs->log);

        cfgTableSet(pct, ASPOP_SDFAT_RD, 1);

        val = cfgValueOffset(secStr, 24);
        cfgTableSet(pct, ASPOP_SDFAT_STR01, val);
        val = cfgValueOffset(secStr, 16);
        cfgTableSet(pct, ASPOP_SDFAT_STR02, val);
        val = cfgValueOffset(secStr, 8);
        cfgTableSet(pct, ASPOP_SDFAT_STR03, val);
        val = cfgValueOffset(secStr, 0);
        cfgTableSet(pct, ASPOP_SDFAT_STR04, val);
        val = cfgValueOffset(secLen, 24);
        cfgTableSet(pct, ASPOP_SDFAT_LEN01, val);
        val = cfgValueOffset(secLen, 16);
        cfgTableSet(pct, ASPOP_SDFAT_LEN02, val);
        val = cfgValueOffset(secLen, 8);
        cfgTableSet(pct, ASPOP_SDFAT_LEN03, val);
        val = cfgValueOffset(secLen, 0);
        cfgTableSet(pct, ASPOP_SDFAT_LEN04, val);

        cfgTableSet(pct, ASPOP_SDFAT_SDAT, 1);

        modersp->r = 2;
    }

    return 1;
}

static int fs54(struct mainRes_s *mrs, struct modersp_s *modersp) 
{
    int bitset=0, ret=0;
    
    bitset = 0;
    msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 8, __u32), &bitset);   //SPI_IOC_WR_DATA_MODE
    sprintf_f(mrs->log, "spi0 Set data mode: %d\n", bitset);
    print_f(mrs->plog, "fs54", mrs->log);

#if SPI_KTHREAD_USE
    bitset = 0;
    ret = msp_spi_conf(mrs->sfm[0], _IOR(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_START_THREAD
    sprintf_f(mrs->log, "Start spi0 spidev thread, ret: 0x%x\n", ret);
    print_f(mrs->plog, "fs54", mrs->log);
#endif

    sprintf_f(mrs->log, "trigger spi0 \n");
    print_f(mrs->plog, "fs54", mrs->log);

    ring_buf_init(&mrs->cmdRx);

    mrs_ipc_put(mrs, "a", 1, 1);
    //clock_gettime(CLOCK_REALTIME, &mrs->time[0]);

    modersp->m = modersp->m + 1;
    return 0;
}
static int fs55(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int val=0, pi=0, ret=0, len=0, bitset=0;
    char *pr=0, ch=0, *addr=0, wtlen=0;
    uint32_t secStr=0, secLen=0;
    
    struct sdbootsec_s   *psec=0;
    struct sdFAT_s *pfat=0;
    struct info16Bit_s *p=0, *c=0;
    struct sdFATable_s   *pftb=0;

    //sprintf_f(mrs->log, "read FAT  \n");
    //print_f(mrs->plog, "fs55", mrs->log);

    c = &mrs->mchine.cur;
    p = &mrs->mchine.tmp;
    
    pfat = &mrs->aspFat;
    pftb = &pfat->fatTable;

    ret = mrs_ipc_get(mrs, &ch, 1, 1);
    while (ret > 0) {
        if ((ch == 'p') || (ch == 'd')){
            if (!pftb->ftbFat1) {
                secLen = p->opinfo;
                val = secLen * 512;
                pftb->ftbFat1 = aspMemalloc(val, 9); /* FAT table */
                //pftb->ftbFat1 = aspSalloc(val);
                if (!pftb->ftbFat1) {
                    sprintf_f(mrs->log, "aspMemalloc for FAT table FAIL!! \n");
                    print_f(mrs->plog, "fs55", mrs->log);

                    modersp->r = 2;
                    return 1;
                }
                sprintf_f(mrs->log, "FAT table size: %d\n", val);
                print_f(mrs->plog, "fs55", mrs->log);

                pftb->ftbLen = 0;
            }
        
            wtlen = 0;
            modersp->v += 1;
            len = ring_buf_cons(&mrs->cmdRx, &addr);
            if (len >= 0) {
                pi++;
                msync(addr, len, MS_SYNC);
                /* send data to wifi socket */
                if (len != 0) {
                    pr = pftb->ftbFat1 + pftb->ftbLen;
                    //pr = pftb->ftbFat1 + wtlen;
                    memcpy(pr, addr, len);
                    //wtlen += len;
                    pftb->ftbLen += len;
                    sprintf_f(mrs->log, "%d get fat len:%d, total:%d\n", pi, len, pftb->ftbLen);
                    print_f(mrs->plog, "fs55", mrs->log);
                }
            } else {
                sprintf_f(mrs->log, "end, len:%d\n", len);
                print_f(mrs->plog, "fs55", mrs->log);
            }

            if (ch == 'd') {
                sprintf_f(mrs->log, "spi0 %d end\n", modersp->v);
                print_f(mrs->plog, "fs55", mrs->log);
#if PULL_LOW_AFTER_DATA
                bitset = 0;
                msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
                sprintf_f(mrs->log, "set RDY pin %d\n",bitset);
                print_f(mrs->plog, "fs55", mrs->log);
                usleep(210000);
#endif
#if SPI_KTHREAD_USE
                bitset = 0;
                ret = msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_STOP_THREAD
                sprintf_f(mrs->log, "Stop spi0 spidev thread, ret: 0x%x\n", ret);
                print_f(mrs->plog, "fs55", mrs->log);
#endif

                modersp->m = 48;
                return 2;
            }
        }

        ret = mrs_ipc_get(mrs, &ch, 1, 1);
    }
    
    return 0;
}

static int fs56(struct mainRes_s *mrs, struct modersp_s *modersp) 
{ 
    struct sdFAT_s *pfat=0;
    
    pfat = &mrs->aspFat;
    
    sprintf_f(mrs->log, "show the tree!!!  \n");
    print_f(mrs->plog, "fs56", mrs->log);

    msync(pfat, sizeof(struct sdFAT_s), MS_SYNC);
    
    if (!(pfat->fatStatus & ASPFAT_STATUS_BOOT)) {
        mspFS_listDetail(&pfat->fatCurDir, 4);
        //mspFS_list(curDir, 4);
        pfat->fatStatus |= ASPFAT_STATUS_BOOT;
        
        //pfat->fatCurDir = pfat->fatRootdir;
        //aspFScpDir(&pfat->fatCurDir, &pfat->fatRootdir);
    } else {
        //aspMemClear(aspMemAsign, asptotMalloc, 10);
        /*
        if(!pfat->fatDirTr.dirCur) {
            //pfat->fatCurDir = pfat->fatRootdir;
            aspFScpDir(&pfat->fatCurDir, pfat->fatDirTr.dirRoot);            
            pfat->fatDirTr.dirCur = pfat->fatDirTr.dirRoot;
            //mspFS_folderList(pfat->fatDirTr.dirRoot, 4);            
            mspFS_list(pfat->fatDirTr.dirRoot, 4);            
        } else {
            //mspFS_folderList(pfat->fatDirTr.dirCur, 4);            
            mspFS_list(pfat->fatDirTr.dirRoot, 4);            
        }
        */
    }

    if(!pfat->fatDirTr.dirCur) {
        aspFScpDir(&pfat->fatCurDir, pfat->fatDirTr.dirRoot);            
        pfat->fatDirTr.dirCur = pfat->fatDirTr.dirRoot;
        mspFS_list(pfat->fatDirTr.dirRoot, 4);     
        //mspFS_listDetail(pfat->fatDirTr.dirRoot, 4);
    } else {          
        mspFS_list(pfat->fatDirTr.dirRoot, 4);            
        //mspFS_listDetail(pfat->fatDirTr.dirRoot, 4);
    }

    modersp->r = 4;    
    return 1;
}

static int fs57(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct info16Bit_s *p;
    p = &mrs->mchine.cur;

    p->opcode = OP_SUPBACK;
    p->data = 0;

    //sprintf_f(mrs->log, "set opcode OP_SUPBACK: 0x%.2x 0x%.2x \n", p->opcode, p->data);
    //print_f(mrs->plog, "fs57", mrs->log);
    
    mrs_ipc_put(mrs, "c", 1, 1);
    modersp->m = modersp->m + 1;
    return 0; 
}

static int fs58(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    int len=0;
    char ch=0;
    struct info16Bit_s *p;

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((len > 0) && (ch == 'C')) {
        msync(&mrs->mchine, sizeof(struct machineCtrl_s), MS_SYNC);

        p = &mrs->mchine.get;
        //sprintf_f(mrs->log, "get opcode 0x%.2x 0x%.2x \n", p->opcode, p->data);
        //print_f(mrs->plog, "fs58", mrs->log);

        if (p->opcode == OP_SUPBACK) {
            modersp->m = modersp->m + 1;
            return 2;
        } else {
            modersp->r = 2;
            return 1;
        }
    }
    return 0; 
}

static int fs59(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    int ret=0;
    uint32_t val=0, fformat=0;
    struct supdataBack_s *s=0;
    struct aspConfig_s *pct=0;
    struct sdFAT_s *pfat=0;

    pct = mrs->configTable;
    pfat = &mrs->aspFat;

    sprintf_f(mrs->log, "initial the fatSupdata !!!  \n");
    print_f(mrs->plog, "fs59", mrs->log);
    pfat->fatSupdata = 0;

    ret = cfgTableGetChk(pct, ASPOP_FILE_FORMAT, &fformat, ASPOP_STA_CON);    
    sprintf_f(mrs->log, "get user defined file format (0x%.2x) ret:%d \n", fformat, ret);
    print_f(mrs->plog, "fs59", mrs->log);
    if (ret) {
        fformat = 0;
    }
    
    //cfgTableSet(pct, ASPOP_SUP_SAVE, (uint32_t)s);
    s = 0;
    s = aspMemalloc(sizeof(struct supdataBack_s), 10);
    if (!s) {
        sprintf_f(mrs->log, "FAIL to initial the second fatSupdata !!! \n");
        print_f(mrs->plog, "fs59", mrs->log);

        modersp->r = 2;
        return 1;
    }

    //cfgTableSet(pct, ASPOP_SUP_SAVE, (uint32_t)s);
    memset(s, 0, sizeof(struct supdataBack_s));
    pfat->fatSupdata = s;   
    pfat->fatSupcur = pfat->fatSupdata;

    if ((fformat == FILE_FORMAT_PDF) || (fformat == FILE_FORMAT_TIFF_I)) {
        sprintf_f(mrs->log, "file format (%d) 2:PDF 4:tiff_i, allocate one more trunk at the begin\n", fformat);
        print_f(mrs->plog, "fs59", mrs->log);

        s = aspMemalloc(sizeof(struct supdataBack_s), 10);
        if (!s) {
            sprintf_f(mrs->log, "FAIL to initial the head fatSupdata !!! \n");
            print_f(mrs->plog, "fs59", mrs->log);

            modersp->r = 2;
            return 1;
        }

        memset(s, 0, sizeof(struct supdataBack_s));
        pfat->fatSupcur->supdataUse = SPI_TRUNK_SZ - 512;
        pfat->fatSupcur->supdataTot = SPI_TRUNK_SZ;
        pfat->fatSupcur->n = s;
        pfat->fatSupcur = s;
    }

    sprintf_f(mrs->log, "fatSupdata = 0x%.8x, fatSupcur = 0x%.8x!!!  \n", (uint32_t)pfat->fatSupdata, (uint32_t)pfat->fatSupcur);
    print_f(mrs->plog, "fs59", mrs->log);

    if (modersp->d) {
        modersp->m = modersp->d;
        modersp->d = 0;
        return 2;
    } else {
        modersp->r = 1;
        return 1;
    }
}

static int fs60(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct info16Bit_s *p;
    p = &mrs->mchine.cur;

    p->opcode = OP_SUPBACK;
    p->data = 0;

    //sprintf_f(mrs->log, "set opcode OP_SUPBACK: 0x%.2x 0x%.2x \n", p->opcode, p->data);
    //print_f(mrs->plog, "fs60", mrs->log);
    
    mrs_ipc_put(mrs, "c", 1, 1);
    modersp->m = modersp->m + 1;
    return 0; 
}

static int fs61(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    int len=0;
    char ch=0;
    struct info16Bit_s *p;

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((len > 0) && (ch == 'C')) {
        msync(&mrs->mchine, sizeof(struct machineCtrl_s), MS_SYNC);

        p = &mrs->mchine.get;
        //sprintf_f(mrs->log, "get opcode 0x%.2x 0x%.2x \n", p->opcode, p->data);
        //print_f(mrs->plog, "fs61", mrs->log);

        if (p->opcode == OP_QRY) {
            modersp->m = modersp->m + 1;            
            return 2;
        } else {
            modersp->r = 2;
            return 1;
        }
    }
    return 0; 
}

static int fs62(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct info16Bit_s *p;
    p = &mrs->mchine.cur;

    p->opcode = OP_SUPBACK;
    p->data = 0;

    //sprintf_f(mrs->log, "set opcode OP_SUPBACK: 0x%.2x 0x%.2x \n", p->opcode, p->data);
    //print_f(mrs->plog, "fs62", mrs->log);
    
    mrs_ipc_put(mrs, "c", 1, 1);
    modersp->m = modersp->m + 1;
    return 0; 
}

static int fs63(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    int len=0;
    char ch=0;
    struct info16Bit_s *p;

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((len > 0) && (ch == 'C')) {
        msync(&mrs->mchine, sizeof(struct machineCtrl_s), MS_SYNC);

        p = &mrs->mchine.get;
        //sprintf_f(mrs->log, "get opcode 0x%.2x 0x%.2x \n", p->opcode, p->data);
        //print_f(mrs->plog, "fs63", mrs->log);

        if (p->opcode == OP_SUPBACK) {
            modersp->m = modersp->m + 1;            
            return 2;
        } else {
            modersp->r = 2;
            return 1;
        }
    }
    return 0; 
}

#define SUP_FILE (0)
static int fs64(struct mainRes_s *mrs, struct modersp_s *modersp)
{

#if SUP_FILE
    FILE *f=0;
    char supPath[128] = "/mnt/mmc2/tx/supBack_%d.bin";
    char supDst[128];
#endif

    sprintf_f(mrs->log, "trigger spi0 \n");
    print_f(mrs->plog, "fs64", mrs->log);

    ring_buf_init(&mrs->dataRx);
    
#if SUP_FILE
    f = find_save(supDst, supPath);
    if (f) {
        sprintf_f(mrs->log, "save sup back to [%s] \n", supDst);
        print_f(mrs->plog, "fs64", mrs->log);

        mrs->mchine.cur.opinfo = (uint32_t)f;
    }
#else    
    mrs->mchine.cur.opinfo = 0;
#endif
    
    mrs_ipc_put(mrs, "k", 1, 1);
    //clock_gettime(CLOCK_REALTIME, &mrs->time[0]);

    modersp->m = modersp->m + 1;
    modersp->c = 0;
    modersp->v = 0;
    return 2;
}

static int fs65(struct mainRes_s *mrs, struct modersp_s *modersp) 
{ 
#if SUP_FILE
    FILE *f=0;
#endif
    struct sdFAT_s *pfat=0;
    struct supdataBack_s *s=0, *sc=0, *sh=0;

    int len=0, cnt=0;;
    char *addr = 0;

    sprintf_f(mrs->log, "start \n");
    print_f(mrs->plog, "fs65", mrs->log);
    pfat = &mrs->aspFat;
    sh = pfat->fatSupdata;
    sc = pfat->fatSupcur;
#if SUP_FILE
    f = (FILE *)mrs->mchine.cur.opinfo;
#endif        
    if (sc) {
        sprintf_f(mrs->log, "the current should not here!!! sc:0x%.8x\n", (uint32_t)sc);
        print_f(mrs->plog, "fs65", mrs->log);
    }
    
    if (!sh) {
        sprintf_f(mrs->log, "the head should not here!!! sh:0x%.8x\n", (uint32_t)sh);
        print_f(mrs->plog, "fs65", mrs->log);
    }

    while (sh) {
    
        len = ring_buf_get(&mrs->dataRx, &addr);
        if (len <= 0) {
            //sprintf_f(mrs->log, "WARNING, len:%d \n", len);
            //print_f(mrs->plog, "fs65", mrs->log);
            break;
        } else if (len != SPI_TRUNK_SZ) {
            sprintf_f(mrs->log, "WARNING, buff len not equal to %d, len:%d \n", SPI_TRUNK_SZ, len);
            print_f(mrs->plog, "fs65", mrs->log);
        } 

        //sprintf_f(mrs->log, "cnt:%d\n", modersp->c);
        //print_f(mrs->plog, "fs65", mrs->log);
        
        if (sh->supdataTot < len) {
            len = sh->supdataTot;
        }

        if (len > 0) {

#if SUP_FILE
            if (f) {
                fwrite(sh->supdataBuff, 1, len, f);
                sprintf_f(mrs->log, "sup save len:%d\n", len);
                print_f(mrs->plog, "fs65", mrs->log);
            } else {
                sprintf_f(mrs->log, "sup back save NONE \n");
                print_f(mrs->plog, "fs65", mrs->log);
            }
#endif

            memcpy(addr, sh->supdataBuff, len);
            ring_buf_prod(&mrs->dataRx);
            mrs_ipc_put(mrs, "k", 1, 1);
            modersp->c += 1;
            modersp->v += len;
        }

        s = sh;
        sh = sh->n;

        pfat->fatSupdata = sh;
        
        memset(s, 0, sizeof(struct supdataBack_s));
        aspMemFree(s, 0);
    }

    if (sh) {
        //sprintf_f(mrs->log, "not yet, cnt:%d \n", modersp->c);
        //print_f(mrs->plog, "fs65", mrs->log);

        return 0;
    } else {
        ring_buf_set_last(&mrs->dataRx, len);
        
        mrs_ipc_put(mrs, "K", 1, 1);    
        sprintf_f(mrs->log, "tx done:%d total:%d last:%d\n", modersp->c, modersp->v, len);
        print_f(mrs->plog, "fs65", mrs->log);
        modersp->m = modersp->m + 1;
#if SUP_FILE
        if (f) {
            fclose(f);
            mrs->mchine.cur.opinfo = 0;
        }
#endif        
        return 2;
    }
    
}

static int fs66(struct mainRes_s *mrs, struct modersp_s *modersp) 
{ 
    int len=0, bitset=0, ret=0;
    char ch=0;
    struct info16Bit_s *p;

    //sprintf_f(mrs->log, "wait spi0 tx end\n");
    //print_f(mrs->plog, "fs66", mrs->log);

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if (len > 0) {

        sprintf_f(mrs->log, "ch: %c - end\n", ch);
        print_f(mrs->plog, "fs66", mrs->log);

        if (ch == 'K') {

#if PULL_LOW_AFTER_DATA
            bitset = 0;
            msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
            sprintf_f(mrs->log, "set RDY pin %d\n",bitset);
            print_f(mrs->plog, "fs66", mrs->log);
            usleep(210000);
#endif
#if SPI_KTHREAD_USE
            bitset = 0;
            ret = msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_STOP_THREAD
            sprintf_f(mrs->log, "Stop spi0 spidev thread, ret: 0x%x\n", ret);
            print_f(mrs->plog, "fs66", mrs->log);
#endif

            modersp->r = 1;            
            return 1;
        } else  {
            modersp->r = 2;
            return 1;
        }
    }
    return 0; 
}
static int fs67(struct mainRes_s *mrs, struct modersp_s *modersp) 
{ 
    int bitset, ret;
    struct sdFAT_s *pfat=0;
    pfat = &mrs->aspFat;
    //pfat->fatSupcur = pfat->fatSupdata;
        
    sprintf_f(mrs->log, "trigger spi0\n");
    print_f(mrs->plog, "fs67", mrs->log);

#if SPI_KTHREAD_USE
    bitset = 0;
    ret = msp_spi_conf(mrs->sfm[0], _IOR(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_START_THREAD
    sprintf_f(mrs->log, "Start spi0 spidev thread, ret: 0x%x\n", ret);
    print_f(mrs->plog, "fs67", mrs->log);
#endif

    ring_buf_init(&mrs->cmdRx);

    mrs_ipc_put(mrs, "n", 1, 1);
    
    //clock_gettime(CLOCK_REALTIME, &mrs->time[0]);
    modersp->v = 0;
#if CHECK_SOCKET_STATUS
    modersp->m = modersp->m + 1;
#else
    modersp->d = modersp->m + 1;
    modersp->m = 25;
#endif
    return 2;
}
static int fs68(struct mainRes_s *mrs, struct modersp_s *modersp) 
{ 
    int ret, bitset, len=0;
    char ch, *addr=0, *dst=0;
    struct sdFAT_s *pfat=0;
    struct supdataBack_s *s=0, *sc=0;

    //sprintf_f(mrs->log, "v:%d r:0x%.8x\n", modersp->v, modersp->r);
    //print_f(mrs->plog, "fs68", mrs->log);
    pfat = &mrs->aspFat;
    sc = pfat->fatSupcur;

    ret = mrs_ipc_get(mrs, &ch, 1, 1);
    while (ret > 0) {
        if (ch == 'p') {
            modersp->v += 1;
            
            if (sc) {
                len = ring_buf_cons_psudo(&mrs->cmdRx, &addr);
                //sprintf_f(mrs->log, "1. get psudo len:%d, cnt:%d\n", len, modersp->v);
                //print_f(mrs->plog, "fs68", mrs->log);

                if (len >= 0) {
                    dst = sc->supdataBuff;
                    memcpy(dst, addr, len);
                    sc->supdataTot = len;

                    s = aspMemalloc(sizeof(struct supdataBack_s), 10);
                    memset(s, 0, sizeof(struct supdataBack_s));
                    sc->n = s;
                    sc = sc->n;

                    pfat->fatSupcur = sc;
                }
            }
            
            mrs_ipc_put(mrs, "n", 1, 3);
        }

        if (ch == 'd') {
            sprintf_f(mrs->log, "0 %d end\n", modersp->v);
            print_f(mrs->plog, "fs68", mrs->log);

            mrs_ipc_put(mrs, "n", 1, 3);
            modersp->r |= 0x1;
            //mrs_ipc_put(mrs, "e", 1, 3);
        }
        
        sprintf_f(mrs->log, "get ch:%c v:%d r:0x%.8x\n", ch, modersp->v, modersp->r);
        print_f(mrs->plog, "fs68", mrs->log);
        
        ret = mrs_ipc_get(mrs, &ch, 1, 1);
    }

    if (modersp->r & 0x1) {
        if (sc) {
            len = ring_buf_cons_psudo(&mrs->cmdRx, &addr);
            while (len >= 0) {
                //sprintf_f(mrs->log, "2. get psudo len:%d, cnt:%d\n", len, modersp->v);
                //print_f(mrs->plog, "fs68", mrs->log);

                dst = sc->supdataBuff;
                memcpy(dst, addr, len);
                sc->supdataTot = len;
                
                s = aspMemalloc(sizeof(struct supdataBack_s), 10);
                memset(s, 0, sizeof(struct supdataBack_s));
                sc->n = s;
                sc = sc->n;

                pfat->fatSupcur = sc;
                modersp->v += 1;  
                len = ring_buf_cons_psudo(&mrs->cmdRx, &addr);
            }

            len = 0;
            s = pfat->fatSupdata;
            while (s) {
                if (s->supdataTot == 0) {
                    break;
                } else {
                    len += s->supdataTot;
                    //sprintf_f(mrs->log, "tot/len: %d/%d\n", s->supdataTot, len);
                    //print_f(mrs->plog, "fs68", mrs->log);
                }
                sc = s;
                s = s->n;
            }

            if (sc) {
                sc->n = 0;
            }

            while (s) {
                sc = s;
                s = s->n;
                
                memset(sc, 0, sizeof(struct supdataBack_s));
                aspMemFree(sc, 0);
            }
            pfat->fatSupcur = 0;

            ret = aspCalcSupLen(pfat->fatSupdata);
        }
        
        modersp->t = modersp->v;
        modersp->c = 0;

        mrs_ipc_put(mrs, "N", 1, 3);
        sprintf_f(mrs->log, "%d end, len: %d, calcu: %d\n", modersp->v, len, ret);
        print_f(mrs->plog, "fs68", mrs->log);
        //modersp->m = modersp->m + 1;
        //return 2;

        mrs->mchine.cur.opinfo = modersp->v;

#if SPI_KTHREAD_USE
            bitset = 0;
            ret = msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_STOP_THREAD
            sprintf_f(mrs->log, "Stop spi0 spidev thread, ret: 0x%x\n", ret);
            print_f(mrs->plog, "fs68", mrs->log);
#endif

#if PULL_LOW_AFTER_DATA
            bitset = 0;
            msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
            sprintf_f(mrs->log, "set RDY pin %d\n",bitset);
            print_f(mrs->plog, "fs68", mrs->log);
            usleep(210000);
#endif

        modersp->r = 1;
        return 1;
    }

    return 0; 
}
static int fs69(struct mainRes_s *mrs, struct modersp_s *modersp) 
{ 
    int len=0, bitset=0, ret=0;
    char ch=0;
    struct info16Bit_s *p;

    //sprintf_f(mrs->log, "wait wifi tx end, t: %d \n", modersp->t);
    //print_f(mrs->plog, "fs69", mrs->log);
    
    if (modersp->t == 0) {
        sprintf_f(mrs->log, "wait wifi tx end, t: %d \n", modersp->t);
        print_f(mrs->plog, "fs69", mrs->log);

        ring_buf_init(&mrs->cmdRx);

        modersp->m = modersp->d;
        modersp->d = 0;
        return 2;
    }

    len = mrs_ipc_get(mrs, &ch, 1, 3);
    while (len > 0) {

        //sprintf_f(mrs->log, "ch: %c - end\n", ch);
        //print_f(mrs->plog, "fs69", mrs->log);
        modersp->c ++;
        
        if (ch == 'N') {
            sprintf_f(mrs->log, "ch: %c - end, count: %d\n", ch, modersp->c);
            print_f(mrs->plog, "fs69", mrs->log);

            ring_buf_init(&mrs->cmdRx);
            modersp->t = 0;
            
            if (modersp->d) {
                modersp->m = modersp->d;
                modersp->d = 0;
                return 2;
            } else {
                modersp->r = 1;
                return 1;
            }
            
            //modersp->r = 1;            
            //return 1;
        }
        len = mrs_ipc_get(mrs, &ch, 1, 3);
    }
    return 0; 
}

static int fs70(struct mainRes_s *mrs, struct modersp_s *modersp) 
{
    int val=0, i=0, ret=0;
    char *pr=0;
    uint32_t secStr=0, secLen=0;
    struct aspConfig_s *pct=0;
    struct sdbootsec_s   *psec=0;
    struct sdFAT_s *pfat=0;
    struct sdParseBuff_s *pParBuf=0;
    struct info16Bit_s *p=0, *c=0;
    struct directnFile_s *curDir=0, *ch=0, *br=0;
    struct folderQueue_s *pfhead=0, *pfdirt=0, *pfnext=0;
    struct adFATLinkList_s *pflsh=0, *pflnt=0;
    struct sdFATable_s   *pftb=0;
    
    c = &mrs->mchine.cur;
    p = &mrs->mchine.tmp;
    
    pct = mrs->configTable;
    pfat = &mrs->aspFat;
    pParBuf = &pfat->parBuf;
    psec = &pfat->fatBootsec;
    pftb = &pfat->fatTable;

    sprintf_f(mrs->log, "download file: %s \n", pfat->fatFileDnld.dfSFN);
    print_f(mrs->plog, "fs70", mrs->log);

    if (!pfat->fatFileDnld.dfindex) {
        modersp->r = 2;
        return 1;
    }
   
    //curDir = pfat->fatFileDnld;
    aspFSms2rs(&curDir, &pfat->fatFileDnld, &pfat->fatDirTr);
    //aspFScpDir(curDir, &pfat->fatFileDnld);
    if (!pftb->h) {
        pflsh = 0;

        ret = mspSD_parseFAT2LinkList(&pflsh, curDir->dfclstnum, pftb->ftbFat1, (psec->secTotal - psec->secWhroot) / psec->secPrClst);
        if (ret) {
            sprintf_f(mrs->log, "FAT table parsing for root dictionary FAIL!!ret:%d (%s)\n", ret, curDir->dfSFN);
            print_f(mrs->plog, "fs70", mrs->log);
            modersp->r = 3;
            return 1;
        }
        /* debug */
        sprintf_f(mrs->log, "show FAT link for [%s]:\n", curDir->dfSFN);
        print_f(mrs->plog, "fs70", mrs->log);

        pflnt = pflsh;
        while (pflnt) {
            sprintf_f(mrs->log, "    str:%d len:%d\n", pflnt->ftStart, pflnt->ftLen);
            print_f(mrs->plog, "fs70", mrs->log);
            pflnt = pflnt->n;
        }
        pftb->h = pflsh;
        pftb->c = pftb->h;

        pfat->fatStatus |= ASPFAT_STATUS_SDRD;
        modersp->r = 1;
    } else {
        sprintf_f(mrs->log, "FAT table parsing for root dictionary FAIL!!ret:%d \n", ret);
        print_f(mrs->plog, "fs70", mrs->log);
        modersp->r = 2;
    }

    return 1;
}

static int fs71(struct mainRes_s *mrs, struct modersp_s *modersp) 
{
    int val=0, i=0, ret=0;
    char *pr=0;
    uint32_t secStr=0, secLen=0, fstsec=0, lstsec;
    struct aspConfig_s *pct=0;
    struct sdbootsec_s   *psec=0;
    struct sdFAT_s *pfat=0;
    struct sdParseBuff_s *pParBuf=0;
    struct info16Bit_s *p=0, *c=0;
    struct directnFile_s *curDir=0, *ch=0, *br=0;
    struct folderQueue_s *pfhead=0, *pfdirt=0, *pfnext=0;
    struct adFATLinkList_s *pflsh=0, *pflnt=0;
    struct sdFATable_s   *pftb=0;


    c = &mrs->mchine.cur;
    p = &mrs->mchine.tmp;
    
    pct = mrs->configTable;
    pfat = &mrs->aspFat;
    pParBuf = &pfat->parBuf;
    psec = &pfat->fatBootsec;
    pftb = &pfat->fatTable;

    //curDir = pfat->fatFileDnld;
    aspFSms2rs(&curDir, &pfat->fatFileDnld, &pfat->fatDirTr);
    if (!curDir) {
        sprintf_f(mrs->log, "get SD cur failed\n");
        print_f(mrs->plog, "fs71", mrs->log);

        modersp->r = 0xed;
        return 1;
    }

    sprintf_f(mrs->log, "get SD cur:0x%.8x filename:[%s]length[%d]\n", (uint32_t)pftb->c, (curDir->dflen==0)?curDir->dfSFN:curDir->dfLFN, curDir->dflength);
    print_f(mrs->plog, "fs71", mrs->log);

    if (pftb->c) {
        pflnt = pftb->c;
                 
        secStr = (pflnt->ftStart - 2) * psec->secPrClst + psec->secWhroot;

        if (!pflnt->n) {
            if (!(curDir->dflength % 512)) {
                fstsec = curDir->dflength / 512;
            } else {
                fstsec = (curDir->dflength / 512) + 1;
            }
            sprintf_f(mrs->log, "fstsec: %d\n", fstsec);
            print_f(mrs->plog, "fs71", mrs->log);

            if (!(fstsec % psec->secPrClst) ) {
                lstsec = psec->secPrClst;
            } else {
                lstsec = fstsec % psec->secPrClst;
            }
            sprintf_f(mrs->log, "lstsec: %d\n", lstsec);
            print_f(mrs->plog, "fs71", mrs->log);
            
            secLen = (pflnt->ftLen - 1) * psec->secPrClst + lstsec;
        } else {
            secLen = pflnt->ftLen * psec->secPrClst;
        }

        c->opinfo = secStr;
        p->opinfo = secLen;

        if (secLen < 16) secLen = 16;

        sprintf_f(mrs->log, "set secStart:%d, secLen:%d \n", secStr, secLen);
        print_f(mrs->plog, "fs71", mrs->log);

        cfgTableSet(pct, ASPOP_SDFAT_RD, 1);

        val = cfgValueOffset(secStr, 24);
        cfgTableSet(pct, ASPOP_SDFAT_STR01, val);
        val = cfgValueOffset(secStr, 16);
        cfgTableSet(pct, ASPOP_SDFAT_STR02, val);
        val = cfgValueOffset(secStr, 8);
        cfgTableSet(pct, ASPOP_SDFAT_STR03, val);
        val = cfgValueOffset(secStr, 0);
        cfgTableSet(pct, ASPOP_SDFAT_STR04, val);
        val = cfgValueOffset(secLen, 24);
        cfgTableSet(pct, ASPOP_SDFAT_LEN01, val);
        val = cfgValueOffset(secLen, 16);
        cfgTableSet(pct, ASPOP_SDFAT_LEN02, val);
        val = cfgValueOffset(secLen, 8);
        cfgTableSet(pct, ASPOP_SDFAT_LEN03, val);
        val = cfgValueOffset(secLen, 0);
        cfgTableSet(pct, ASPOP_SDFAT_LEN04, val);

        cfgTableSet(pct, ASPOP_SDFAT_SDAT, 1);
        
        modersp->r = 2;

        pftb->c = pflnt->n;
        aspMemFree(pflnt, 0);

    }else {
        pftb->h = 0;
        pfat->fatStatus &= ~ASPFAT_STATUS_SDRD;    
        
        //pfat->fatFileDnld = 0;
        memset(&pfat->fatFileDnld, 0, sizeof(struct directnFile_s));
        
        modersp->r = 1;
    }

    return 1;
}

static int fs72(struct mainRes_s *mrs, struct modersp_s *modersp) 
{ 
    int bitset, ret;
    sprintf_f(mrs->log, "trigger spi0\n");
    print_f(mrs->plog, "fs72", mrs->log);

#if SPI_KTHREAD_USE
    bitset = 0;
    ret = msp_spi_conf(mrs->sfm[0], _IOR(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_START_THREAD
    sprintf_f(mrs->log, "Start spi0 spidev thread, ret: 0x%x\n", ret);
    print_f(mrs->plog, "fs72", mrs->log);
#endif

    ring_buf_init(&mrs->cmdRx);

    mrs_ipc_put(mrs, "z", 1, 1);
    //clock_gettime(CLOCK_REALTIME, &mrs->time[0]);

    modersp->m = modersp->m + 1;
    return 2;
}
static int fs73(struct mainRes_s *mrs, struct modersp_s *modersp) 
{ 
    int ret, bitset;
    char ch;

    //sprintf_f(mrs->log, "%d\n", modersp->v);
    //print_f(mrs->plog, "fs73", mrs->log);

    ret = mrs_ipc_get(mrs, &ch, 1, 1);
    while (ret > 0) {
        if (ch == 'p') {
            modersp->v += 1;
            mrs_ipc_put(mrs, "n", 1, 3);
        }

        if (ch == 'd') {
            sprintf_f(mrs->log, "0 %d end\n", modersp->v);
            print_f(mrs->plog, "fs73", mrs->log);

            mrs_ipc_put(mrs, "n", 1, 3);
            modersp->r |= 0x1;
            //mrs_ipc_put(mrs, "e", 1, 3);
        }
        ret = mrs_ipc_get(mrs, &ch, 1, 1);
    }

    if (modersp->r & 0x1) {
        mrs_ipc_put(mrs, "N", 1, 3);
        sprintf_f(mrs->log, "%d end\n", modersp->v);
        print_f(mrs->plog, "fs73", mrs->log);
        modersp->m = modersp->m + 1;
        return 2;
    }

    return 0; 
}
static int fs74(struct mainRes_s *mrs, struct modersp_s *modersp) 
{ 
    int len=0, bitset=0, ret=0, count=0;
    char ch=0;
    struct info16Bit_s *p;

    //sprintf_f(mrs->log, "wait spi0 tx end\n");
    //print_f(mrs->plog, "fs74", mrs->log);

    len = mrs_ipc_get(mrs, &ch, 1, 3);
    while (len > 0) {

        count++;
        if (ch == 'N') {
            sprintf_f(mrs->log, "ch: %c - end, count: %d\n", ch, count);
            print_f(mrs->plog, "fs74", mrs->log);

            ring_buf_init(&mrs->cmdRx);

#if SPI_KTHREAD_USE
            bitset = 0;
            ret = msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_STOP_THREAD
            sprintf_f(mrs->log, "Stop spi0 spidev thread, ret: 0x%x\n", ret);
            print_f(mrs->plog, "fs74", mrs->log);
#endif
#if PULL_LOW_AFTER_DATA
            bitset = 0;
            msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
            sprintf_f(mrs->log, "set RDY pin %d\n",bitset);
            print_f(mrs->plog, "fs74", mrs->log);
            usleep(210000);
#endif

            modersp->m = 48;            
            return 2;
        }

        len = mrs_ipc_get(mrs, &ch, 1, 3);
        
    }
    return 0; 
}

static int fs75(struct mainRes_s *mrs, struct modersp_s *modersp) 
{
    int val=0, i=0, ret=0, dirid=0, tpid=0;
    char *pr=0;
    uint32_t secStr=0, secLen=0, clstByte=0, clstLen=0, freeClst=0, usedClst=0, totClst=0;
    uint32_t totalsize=0;
    struct aspConfig_s *pct=0;
    struct sdbootsec_s   *psec=0;
    struct sdFAT_s *pfat=0;
    struct sdParseBuff_s *pParBuf=0;
    struct info16Bit_s *p=0, *c=0;
    struct directnFile_s *curDir=0, *ch=0, *br=0, *getDir=0;
    struct folderQueue_s *pfhead=0, *pfdirt=0, *pfnext=0;
    struct adFATLinkList_s *pflsh=0, *pflnt=0;
    struct adFATLinkList_s *pfre=0, *pnxf=0, *pclst=0;
    struct sdFATable_s   *pftb=0;
    
    c = &mrs->mchine.cur;
    p = &mrs->mchine.tmp;
    
    pct = mrs->configTable;
    pfat = &mrs->aspFat;
    pParBuf = &pfat->parBuf;
    psec = &pfat->fatBootsec;
    pftb = &pfat->fatTable;
    clstByte = psec->secSize * psec->secPrClst;
    if (!clstByte) {
        sprintf_f(mrs->log, "ERROR!! bytes number of cluster is zero \n");
        print_f(mrs->plog, "fs75", mrs->log);

        modersp->r = 3;
        return 1;
    }

    pfre = pftb->ftbMng.f;
    if (!pfre) {
        sprintf_f(mrs->log, "Error!! free space link list is empty \n");
        print_f(mrs->plog, "fs75", mrs->log);
        modersp->r = 0xed;
        return 1;
    }
    
    if (!pfat->fatFileUpld.dfindex) {
        modersp->r = 0xed;
        return 1;
    } else {
        dirid = pfat->fatFileUpld.dfindex;
    }

    sprintf_f(mrs->log, "upload file: [%s] \n", pfat->fatFileUpld.dfSFN);
    print_f(mrs->plog, "fs75", mrs->log);
   
    //curDir = &pfat->fatFileUpld;
    aspFSms2rs(&curDir, &pfat->fatFileUpld, &pfat->fatDirTr);
    if (!curDir) {
        sprintf_f(mrs->log, "get SD cur failed\n");
        print_f(mrs->plog, "fs75", mrs->log);

        modersp->r = 0xed;
        return 1;
    }

    sprintf_f(mrs->log, "print curDir and upldDir: \n");
    print_f(mrs->plog, "fs75", mrs->log);

    debugPrintDir(curDir);
    debugPrintDir(&pfat->fatFileUpld);
    
    //if (curDir->dflength != pfat->fatFileUpld.dflength) {
    if (strcmp(curDir->dfSFN, pfat->fatFileUpld.dfSFN) != 0) {
        ret = mspFS_allocDir(&pfat->fatDirTr, &getDir, 9);
        if (!getDir) {
            sprintf_f(mrs->log, "get free dir space failed, ret: %d\n", ret);
            print_f(mrs->plog, "fs75", mrs->log);

            modersp->r = 0xed;
            return 1;
        }
        
        tpid = getDir->dfindex;        
        if (tpid != dirid) {
            curDir = getDir;
            sprintf_f(mrs->log, "WARNNING!!! reset curdir(id:%d) as %d\n", dirid, tpid);
            print_f(mrs->plog, "fs75", mrs->log);
        }
        
        ret = aspFScpDirTr(curDir, &pfat->fatFileUpld, &pfat->fatDirTr);
        if (ret < 0) {
            sprintf_f(mrs->log, "cp dir into file tree failed ret: %d\n", ret);
            print_f(mrs->plog, "fs75", mrs->log);
            modersp->r = 0xed;
            return 1;
        }
        
        if (tpid != dirid) {
            sprintf_f(mrs->log, "check curdir(id:%d) not %d\n", curDir->dfindex, dirid);
            print_f(mrs->plog, "fs75", mrs->log);
            aspFScpDir(&pfat->fatFileUpld, curDir);
        }
        
        if (curDir->pa) {
            aspFS_insertFATChild(curDir->pa, curDir);
            sprintf_f(mrs->log, "insert [%s] into [%s] \n", curDir->dfSFN, curDir->pa->dfSFN);
            print_f(mrs->plog, "fs75", mrs->log);
        } else {
            sprintf_f(mrs->log, "WARNNING: [%s] didn't have parent \n", curDir->dfSFN);
            print_f(mrs->plog, "fs75", mrs->log);
        }

    } else {
        sprintf_f(mrs->log, "get upd dir succeed: [%s](0x%.8x) <== [%s](0x%.8x)\n", curDir->dfSFN, curDir->dfindex, pfat->fatFileUpld.dfSFN, pfat->fatFileUpld.dfindex);
        print_f(mrs->plog, "fs75", mrs->log);
    }

    
    if (!pftb->h) {
        pflsh = 0;

        if (curDir->dflength % clstByte) {
            clstLen = (curDir->dflength / clstByte) + 1;
        } else {
            clstLen = (curDir->dflength / clstByte);        
        }

        sprintf_f(mrs->log, "needed cluster length: %d \n", clstLen);
        print_f(mrs->plog, "fs75", mrs->log);
        
        if (clstLen) {
            ret = mspSD_allocFreeFATList(&pflsh, clstLen, pfre, &pnxf);
            if (ret) {
                sprintf_f(mrs->log, "free FAT table parsing for file upload FAIL!!ret:%d (%s)\n", ret, curDir->dfSFN);
                print_f(mrs->plog, "fs75", mrs->log);
                modersp->r = 0xed;
                return 1;
            } 
            else {
                freeClst = 0;
                if ((pfre != pnxf) && (pnxf)) {
                    totClst = (psec->secTotal - psec->secWhroot) / psec->secPrClst;

                    while (pfre != pnxf) {
                        pclst = pfre;

                        pfre = pfre->n;

                        sprintf_f(mrs->log, "free used FREE FAT linklist, 0x%.8x start: %d, length: %d \n", (uint32_t)pclst, pclst->ftStart, pclst->ftLen);
                        print_f(mrs->plog, "fs75", mrs->log);

                        aspMemFree(pclst, 0);
                        pclst = 0;
                    }
                }

                pflnt = pnxf;
                while (pflnt) {
                    freeClst += pflnt->ftLen;
                    sprintf_f(mrs->log, "cal start: %d len:%d \n", pflnt->ftStart, pflnt->ftLen);
                    print_f(mrs->plog, "fs75", mrs->log);
                    pflnt = pflnt->n;
                }

                totalsize = freeClst * psec->secPrClst * psec->secSize;
                sprintf_f(mrs->log, "re-calculate total free cluster: %d free sector: %d (size: %d) \n", 
                    freeClst, freeClst * psec->secPrClst, totalsize);
                print_f(mrs->plog, "fs75", mrs->log);     
                usedClst = totClst - freeClst;

                pftb->ftbMng.ftfreeClst = freeClst;
                pftb->ftbMng.ftusedClst = usedClst;
                pftb->ftbMng.f = pnxf;
            }

            /* debug */
            sprintf_f(mrs->log, "show allocated FAT list: \n");
            print_f(mrs->plog, "fs75", mrs->log);

            val = 0;
            pflnt = pflsh;
            while (pflnt) {
                val += pflnt->ftLen;
                sprintf_f(mrs->log, "    str:%d len:%d - %d\n", pflnt->ftStart, pflnt->ftLen, val);
                print_f(mrs->plog, "fs75", mrs->log);
                pflnt = pflnt->n;
            }
            sprintf_f(mrs->log, "total allocated cluster is %d!! \n", val);
            print_f(mrs->plog, "fs75", mrs->log);

        
            pftb->h = pflsh;
            pftb->c = pftb->h;

            pfat->fatStatus |= ASPFAT_STATUS_SDWT;
            pfat->fatStatus |= ASPFAT_STATUS_FATWT;
        }else {
            pftb->h = 0;
            pftb->c = 0;
        }

        pfat->fatStatus |= ASPFAT_STATUS_DFECHK;
        pfat->fatStatus |= ASPFAT_STATUS_DFEWT;
        modersp->r = 1;
    } else {
        sprintf_f(mrs->log, "ERROR!!! header of FAT link list is not empty!! \n");
        print_f(mrs->plog, "fs75", mrs->log);
        modersp->r = 0xed;
    }

    return 1;
}

static int fs76(struct mainRes_s *mrs, struct modersp_s *modersp) 
{
    int val=0, i=0, ret=0, tpid=0, dirid;
    char *pr=0;
    uint32_t secStr=0, secLen=0, fstsec=0, lstsec;
    struct aspConfig_s *pct=0;
    struct sdbootsec_s   *psec=0;
    struct sdFAT_s *pfat=0;
    struct sdParseBuff_s *pParBuf=0;
    struct info16Bit_s *p=0, *c=0;
    struct directnFile_s *curDir=0, *ch=0, *br=0, *getDir=0;
    struct folderQueue_s *pfhead=0, *pfdirt=0, *pfnext=0;
    struct adFATLinkList_s *pflsh=0, *pflnt=0;
    struct sdFATable_s   *pftb=0;


    c = &mrs->mchine.cur;
    p = &mrs->mchine.tmp;
    
    pct = mrs->configTable;
    pfat = &mrs->aspFat;
    pParBuf = &pfat->parBuf;
    psec = &pfat->fatBootsec;
    pftb = &pfat->fatTable;

    //curDir = &pfat->fatFileUpld;
    if (!pfat->fatFileUpld.dfindex) {
        modersp->r = 0xed;
        return 1;
    } else {
        dirid = pfat->fatFileUpld.dfindex;
    }

    aspFSms2rs(&curDir, &pfat->fatFileUpld, &pfat->fatDirTr);
    
    if (!curDir) {
        sprintf_f(mrs->log, "get SD cur failed\n");
        print_f(mrs->plog, "fs76", mrs->log);

        modersp->r = 0xed;
        return 1;
    }

    //aspFScpDir(curDir, &pfat->fatFileUpld);
    //if (curDir->dflength != pfat->fatFileUpld.dflength) {
    if (strcmp(curDir->dfSFN, pfat->fatFileUpld.dfSFN) != 0) {
        ret = aspFScpDirTr(curDir, &pfat->fatFileUpld, &pfat->fatDirTr);
        if (ret < 0) {
            sprintf_f(mrs->log, "cp dir into file tree failed ret: %d\n", ret);
            print_f(mrs->plog, "fs76", mrs->log);
            modersp->r = 0xed;
            return 1;
        }

        tpid = getDir->dfindex;        
        if (tpid != dirid) {
            curDir = getDir;
            sprintf_f(mrs->log, "WARNNING!!! reset curdir(id:%d) as %d\n", dirid, tpid);
            print_f(mrs->plog, "fs76", mrs->log);
        }

        if (curDir->pa) {
            aspFS_insertFATChild(curDir->pa, curDir);
            sprintf_f(mrs->log, "insert [%s] into [%s] \n", curDir->dfSFN, curDir->pa->dfSFN);
            print_f(mrs->plog, "fs76", mrs->log);
        } else {
            sprintf_f(mrs->log, "WARNNING: [%s] didn't have parent \n", curDir->dfSFN);
            print_f(mrs->plog, "fs76", mrs->log);
        }

        if (tpid != dirid) {
            sprintf_f(mrs->log, "check curdir(id:%d) not %d\n", curDir->dfindex, dirid);
            print_f(mrs->plog, "fs76", mrs->log);
            aspFScpDir(&pfat->fatFileUpld, curDir);
        }

    } else {
        sprintf_f(mrs->log, "get upd dir succeed: [%s] <== [%s]\n", curDir->dfSFN, pfat->fatFileUpld.dfSFN);
        print_f(mrs->plog, "fs76", mrs->log);
    }


    sprintf_f(mrs->log, "get SD cur:0x%.8x filename:[%s]length[%d]\n", (uint32_t)pftb->c, curDir->dfSFN, curDir->dflength);
    print_f(mrs->plog, "fs76", mrs->log);

    if (pftb->c) {
        pflnt = pftb->c;
                 
        secStr = (pflnt->ftStart - 2) * psec->secPrClst + psec->secWhroot;

        if (!pflnt->n) {
            if (!(curDir->dflength % 512)) {
                fstsec = curDir->dflength / 512;
            } else {
                fstsec = (curDir->dflength / 512) + 1;
            }
            sprintf_f(mrs->log, "fstsec: %d\n", fstsec);
            print_f(mrs->plog, "fs76", mrs->log);

            if (!(fstsec % psec->secPrClst) ) {
                lstsec = psec->secPrClst;
            } else {
                lstsec = fstsec % psec->secPrClst;
            }
            sprintf_f(mrs->log, "lstsec: %d\n", lstsec);
            print_f(mrs->plog, "fs76", mrs->log);
            
            secLen = (pflnt->ftLen - 1) * psec->secPrClst + lstsec;
        } else {
            secLen = pflnt->ftLen * psec->secPrClst;
        }

        c->opinfo = secStr;
        p->opinfo = secLen;

        if (secLen < 16) secLen = 16;

        sprintf_f(mrs->log, "set secStart:%d, secLen:%d \n", secStr, secLen);
        print_f(mrs->plog, "fs76", mrs->log);

        cfgTableSet(pct, ASPOP_SDFAT_WT, 1);

        val = cfgValueOffset(secStr, 24);
        cfgTableSet(pct, ASPOP_SDFAT_STR01, val);
        val = cfgValueOffset(secStr, 16);
        cfgTableSet(pct, ASPOP_SDFAT_STR02, val);
        val = cfgValueOffset(secStr, 8);
        cfgTableSet(pct, ASPOP_SDFAT_STR03, val);
        val = cfgValueOffset(secStr, 0);
        cfgTableSet(pct, ASPOP_SDFAT_STR04, val);
        val = cfgValueOffset(secLen, 24);
        cfgTableSet(pct, ASPOP_SDFAT_LEN01, val);
        val = cfgValueOffset(secLen, 16);
        cfgTableSet(pct, ASPOP_SDFAT_LEN02, val);
        val = cfgValueOffset(secLen, 8);
        cfgTableSet(pct, ASPOP_SDFAT_LEN03, val);
        val = cfgValueOffset(secLen, 0);
        cfgTableSet(pct, ASPOP_SDFAT_LEN04, val);

        cfgTableSet(pct, ASPOP_SDFAT_SDAT, 1);
        
        modersp->r = 3; /*3 is for SDWT*/

        pftb->c = pflnt->n;
        //aspMemFree(pflnt, 0);

    }else {
        pfat->fatStatus &= ~ASPFAT_STATUS_SDWT;    
        pftb->c = pftb->h;
        //pfat->fatFileUpld = 0;
        //pftb->h = 0;
        modersp->r = 1;
    }

    return 1;
}

static int fs77(struct mainRes_s *mrs, struct modersp_s *modersp) 
{
    int bitset, ret;
    sprintf_f(mrs->log, "data flow upload to SD\n");
    print_f(mrs->plog, "fs77", mrs->log);

    sprintf_f(mrs->log, "trigger spi0\n");
    print_f(mrs->plog, "fs77", mrs->log);

#if SPI_KTHREAD_USE & SPI_UPD_NO_KTHREAD
    bitset = 0;
    ret = msp_spi_conf(mrs->sfm[0], _IOR(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_START_THREAD
    sprintf_f(mrs->log, "Start spi0 spidev thread, ret: 0x%x\n", ret);
    print_f(mrs->plog, "fs77", mrs->log);
#endif

    ring_buf_init(&mrs->cmdTx);

    mrs_ipc_put(mrs, "u", 1, 3);
    //clock_gettime(CLOCK_REALTIME, &mrs->time[0]);
    mrs_ipc_put(mrs, "u", 1, 8);
            
    modersp->m = modersp->m + 1;
    return 2;
}

static int fs78(struct mainRes_s *mrs, struct modersp_s *modersp) 
{ 
    int ret, bitset;
    char ch;

    //sprintf_f(mrs->log, "%d\n", modersp->v);
    //print_f(mrs->plog, "fs78", mrs->log);

    ret = mrs_ipc_get(mrs, &ch, 1, 3);
    while (ret > 0) {
        if (ch == 'u') {
            modersp->v += 1;
            mrs_ipc_put(mrs, "u", 1, 1);
        } else if (ch == 'h'){
            mrs_ipc_put(mrs, "u", 1, 8);
        }

        if (ch == 'U') {
            sprintf_f(mrs->log, "0 %d end\n", modersp->v);
            print_f(mrs->plog, "fs78", mrs->log);

            mrs_ipc_put(mrs, "U", 1, 1);

            mrs_ipc_put(mrs, "U", 1, 8);
            
            modersp->r |= 0x1;
        }
        ret = mrs_ipc_get(mrs, &ch, 1, 3);
    }

    if (modersp->r & 0x1) {
        sprintf_f(mrs->log, "%d end\n", modersp->v);
        print_f(mrs->plog, "fs78", mrs->log);
        modersp->m = modersp->m + 1;
        return 2;
    }

    return 0; 
}

static int fs79(struct mainRes_s *mrs, struct modersp_s *modersp) 
{ 
    int len=0, bitset=0, ret=0;
    char ch=0;
    struct info16Bit_s *p;

    //sprintf_f(mrs->log, "wait spi0 tx end\n");
    //print_f(mrs->plog, "fs79", mrs->log);

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if (len > 0) {

        sprintf_f(mrs->log, "ch: %c - end\n", ch);
        print_f(mrs->plog, "fs79", mrs->log);

        if (ch == 'U') {

            ring_buf_init(&mrs->cmdTx);

#if SPI_KTHREAD_USE & SPI_UPD_NO_KTHREAD
            bitset = 0;
            ret = msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_STOP_THREAD
            sprintf_f(mrs->log, "Stop spi0 spidev thread, ret: 0x%x\n", ret);
            print_f(mrs->plog, "fs79", mrs->log);
#endif
#if PULL_LOW_AFTER_DATA
            bitset = 0;
            msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
            sprintf_f(mrs->log, "set RDY pin %d\n",bitset);
            print_f(mrs->plog, "fs79", mrs->log);
            usleep(210000);
#endif

            modersp->m = 48;            
            return 2;
        } else  {
            //modersp->r = 2;
            //modersp->c += 1;
            return 0;
        }
    }
    return 0; 
}

static int fs80(struct mainRes_s *mrs, struct modersp_s *modersp) 
{
    FILE *f=0;
    char fatPath[128] = "/tmp/fatTab.bin";

    int val=0, i=0, ret=0;
    char *pr=0;
    uint32_t secStr=0, secLen=0, fstsec=0, lstsec=0;
    struct aspConfig_s *pct=0;
    struct sdbootsec_s   *psec=0;
    struct sdFAT_s *pfat=0;
    struct sdParseBuff_s *pParBuf=0;
    struct info16Bit_s *p=0, *c=0;
    struct directnFile_s *curDir=0, *ch=0, *br=0;
    struct folderQueue_s *pfhead=0, *pfdirt=0, *pfnext=0;
    struct adFATLinkList_s *pflsh=0, *pflnt=0;
    struct sdFATable_s   *pftb=0;

    c = &mrs->mchine.cur;
    p = &mrs->mchine.tmp;
    
    pct = mrs->configTable;
    pfat = &mrs->aspFat;
    pParBuf = &pfat->parBuf;
    psec = &pfat->fatBootsec;
    pftb = &pfat->fatTable;
    sprintf_f(mrs->log, "FAT table upload to SD\n");
    print_f(mrs->plog, "fs80", mrs->log);

    //curDir = pfat->fatFileUpld;
    //aspFSms2rs(&curDir, &pfat->fatFileUpld, &pfat->fatDirTr);
    if (pftb->c) {
        pflnt = pftb->c;

        ret = mspSD_updLocalFAT(pflnt, pftb->ftbFat1, pftb->ftbLen);
        if (ret) {
            sprintf_f(mrs->log, "update local FAT failed!!! ret: %d \n", ret);
            print_f(mrs->plog, "fs80", mrs->log);
        }

        f = fopen(fatPath, "w+");

        if (f) {
            msync(pftb->ftbFat1, pftb->ftbLen, MS_SYNC);
            fwrite(pftb->ftbFat1, 1, pftb->ftbLen, f);
            fflush(f);
            fclose(f);
            sprintf_f(mrs->log, "FAT table save to [%s] size:%d\n", fatPath, pftb->ftbLen);
            print_f(mrs->plog, "fs80", mrs->log);
        } else {
            sprintf_f(mrs->log, "FAT table find save to [%s] failed !!!\n", fatPath);
            print_f(mrs->plog, "fs80", mrs->log);
        }

        secStr = 0; secLen = 0;
        ret = mspSD_rangeFATLinkList(pflnt, &fstsec, &lstsec);
        if (ret) {
            sprintf_f(mrs->log, "find range of FAT table failed ret:%d, secStr: %d, secLen: %d\n", ret, fstsec, lstsec);
            print_f(mrs->plog, "fs80", mrs->log);    
            fstsec = 2;
            lstsec = psec->secPrfat;
        }

        sprintf_f(mrs->log, "FAT table upload to SD, fstsec: %d, lstsec: %d (FAT offset)\n", fstsec, lstsec);
        print_f(mrs->plog, "fs80", mrs->log);

        fstsec = (fstsec * 4) / 512;
        lstsec = ((lstsec * 4) / 512) + 1;
        
        sprintf_f(mrs->log, "FAT table upload to SD, fstsec: %d, lstsec: %d (sector)\n", fstsec, lstsec);
        print_f(mrs->plog, "fs80", mrs->log);
/*
        val = SPI_TRUNK_SZ / 512;
        if ((lstsec % val) < 16) {
            lstsec = lstsec + (16 - (lstsec % val));
        }
        
        sprintf_f(mrs->log, "FAT table upload to SD, fstsec: %d, lstsec: %d - 3\n", fstsec, lstsec);
        print_f(mrs->plog, "fs80", mrs->log);
*/
        secStr = psec->secWhfat + fstsec;
        secLen = lstsec - fstsec;

        c->opinfo = secStr;
        p->opinfo = secLen;
        
        sprintf_f(mrs->log, "set secStart:%d, secLen:%d \n", secStr, secLen);
        print_f(mrs->plog, "fs80", mrs->log);

        if (secLen < 16) secLen = 16;

        cfgTableSet(pct, ASPOP_SDFAT_WT, 1);

        val = cfgValueOffset(secStr, 24);
        cfgTableSet(pct, ASPOP_SDFAT_STR01, val);
        val = cfgValueOffset(secStr, 16);
        cfgTableSet(pct, ASPOP_SDFAT_STR02, val);
        val = cfgValueOffset(secStr, 8);
        cfgTableSet(pct, ASPOP_SDFAT_STR03, val);
        val = cfgValueOffset(secStr, 0);
        cfgTableSet(pct, ASPOP_SDFAT_STR04, val);
        val = cfgValueOffset(secLen, 24);
        cfgTableSet(pct, ASPOP_SDFAT_LEN01, val);
        val = cfgValueOffset(secLen, 16);
        cfgTableSet(pct, ASPOP_SDFAT_LEN02, val);
        val = cfgValueOffset(secLen, 8);
        cfgTableSet(pct, ASPOP_SDFAT_LEN03, val);
        val = cfgValueOffset(secLen, 0);
        cfgTableSet(pct, ASPOP_SDFAT_LEN04, val);

        cfgTableSet(pct, ASPOP_SDFAT_SDAT, 1);
        
        modersp->r = 3; /*3 is for SDWT*/

        pftb->c = 0;
    }else {
        pfat->fatStatus &= ~ASPFAT_STATUS_FATWT;
        //curDir->dfstats = ASPFS_STATUS_EN;
        //pfat->fatFileUpld = 0;
        modersp->r = 1;
    }

    return 1;
}

static int fs81(struct mainRes_s *mrs, struct modersp_s *modersp) 
{
    FILE *f=0;
    char clstPath[128] = "/tmp/clstNew.bin";
    int val=0, i=0, ret=0, fLen=0, len=0, tpid=0, dirid;
    uint8_t *pdef=0;
    uint32_t secStr=0, secLen=0, fstsec=0, lstsec, freeClst=0, usedClst=0, totClst=0;
    struct aspConfig_s *pct=0;
    struct sdbootsec_s   *psec=0;
    struct sdFAT_s *pfat=0;
    struct sdParseBuff_s *pParBuf=0;
    struct info16Bit_s *p=0, *c=0;
    struct directnFile_s *curDir=0, *ch=0, *br=0, *pa=0, *getDir=0;
    struct folderQueue_s *pfhead=0, *pfdirt=0, *pfnext=0;
    struct adFATLinkList_s *pflsh=0, *pflnt=0;
    struct adFATLinkList_s *padd=0;
    struct sdFATable_s   *pftb=0;
    struct adFATLinkList_s *pfre=0, *pnxf=0, *pclst;    

    c = &mrs->mchine.cur;
    p = &mrs->mchine.tmp;
    
    pct = mrs->configTable;
    pfat = &mrs->aspFat;
    pParBuf = &pfat->parBuf;
    psec = &pfat->fatBootsec;
    pftb = &pfat->fatTable;
    
    sprintf_f(mrs->log, "DFE read from SD (%s)\n", pfat->fatFileUpld.dfSFN);
    print_f(mrs->plog, "fs81", mrs->log);

    if (!pfat->fatFileUpld.dfindex) {
        modersp->r = 0xed;
        return 1;
    } else {
        dirid = pfat->fatFileUpld.dfindex;
    }

    //curDir = pfat->fatFileUpld;
    aspFSms2rs(&curDir, &pfat->fatFileUpld, &pfat->fatDirTr);
    if (!curDir) {
        sprintf_f(mrs->log, "DFE read from SD\n");
        print_f(mrs->plog, "fs81", mrs->log);
        modersp->r = 0xed;
        return 1;
    }
    //aspFScpDir(curDir, &pfat->fatFileUpld);
    
    //if (curDir->dflength != pfat->fatFileUpld.dflength) {
    if (strcmp(curDir->dfSFN, pfat->fatFileUpld.dfSFN) != 0) {
        ret = aspFScpDirTr(curDir, &pfat->fatFileUpld, &pfat->fatDirTr);
        if (ret < 0) {
            sprintf_f(mrs->log, "cp dir into file tree failed ret: %d\n", ret);
            print_f(mrs->plog, "fs81", mrs->log);
            modersp->r = 0xed;
            return 1;
        }
        
        tpid = getDir->dfindex;        
        if (tpid != dirid) {
            curDir = getDir;
            sprintf_f(mrs->log, "WARNNING!!! reset curdir(id:%d) as %d\n", dirid, tpid);
            print_f(mrs->plog, "fs81", mrs->log);
        }
    
        if (curDir->pa) {
            aspFS_insertFATChild(curDir->pa, curDir);
            sprintf_f(mrs->log, "insert [%s] into [%s] \n", curDir->dfSFN, curDir->pa->dfSFN);
            print_f(mrs->plog, "fs81", mrs->log);
        } else {
            sprintf_f(mrs->log, "WARNNING: [%s] didn't have parent \n", curDir->dfSFN);
            print_f(mrs->plog, "fs81", mrs->log);
        }

        if (tpid != dirid) {
            sprintf_f(mrs->log, "check curdir(id:%d) not %d\n", curDir->dfindex, dirid);
            print_f(mrs->plog, "fs81", mrs->log);
            aspFScpDir(&pfat->fatFileUpld, curDir);
        }

    } else {
        sprintf_f(mrs->log, "get upd dir succeed: [%s] <== [%s]\n", curDir->dfSFN, pfat->fatFileUpld.dfSFN);
        print_f(mrs->plog, "fs81", mrs->log);
    }

    
    if (mrs->folder_dirt) {
        pfdirt = mrs->folder_dirt;
        pa = pfdirt->fdObj;
        
        if (pParBuf->dirBuffUsed) {
            sprintf_f(mrs->log, "get parse buffer used size: %d]\n", pParBuf->dirBuffUsed);
            print_f(mrs->plog, "fs81", mrs->log);

            //msync(pParBuf->dirParseBuff, pParBuf->dirBuffUsed, MS_SYNC);
            
            /* fill the DEF */
            
            /* find the free space, slot unit is 32 bytes */
            fLen = aspFindFreeDEF(&pdef, pParBuf->dirParseBuff, pParBuf->dirBuffUsed, 32);

            /* debug */
            if (fLen > 0) {
                //shmem_dump(pParBuf->dirParseBuff + (((pParBuf->dirBuffUsed - fLen) > 512)?(pParBuf->dirBuffUsed - fLen - 512):(pParBuf->dirBuffUsed - fLen)), fLen+512);
            }
            
            /* calculate the DEF */                 
            len = aspCompirseDEF(pdef, curDir);
            if (len > 0) {
                sprintf_f(mrs->log, "compirse DEF len:%d(free:%d)\n", len, fLen);
                print_f(mrs->plog, "fs81", mrs->log);

                //shmem_dump(pdef, len);
            } else {
                sprintf_f(mrs->log, "ERROR!!! compirse DEF failed, ret len:%d(free:%d)\n", len, fLen);
                print_f(mrs->plog, "fs81", mrs->log);
            }

            f = fopen(clstPath, "w+");
            if (f) {
                msync(pdef, len, MS_SYNC);
                fwrite(pdef, 1, len, f);
                fflush(f);
                fclose(f);
                sprintf_f(mrs->log, "DFE save to [%s] size:%d\n", clstPath, len);
                print_f(mrs->plog, "fs81", mrs->log);
                shmem_dump(pdef, len);
            } else {
                sprintf_f(mrs->log, "DFE table find save to [%s] failed !!!\n", clstPath);
                print_f(mrs->plog, "fs81", mrs->log);
            }
            
            pflsh = 0;
            ret = mspSD_parseFAT2LinkList(&pflsh, pa->dfclstnum, pftb->ftbFat1, (psec->secTotal - psec->secWhroot) / psec->secPrClst);
            if (ret) {
                sprintf_f(mrs->log, "FAT table parsing for root dictionary FAIL!!ret:%d (%s)\n", ret, curDir->dfSFN);
                print_f(mrs->plog, "fs81", mrs->log);
                modersp->r = 0xed;
                return 1;
            }

            /* debug */
            sprintf_f(mrs->log, "show FAT link for [%s]:\n", pa->dfSFN);
            print_f(mrs->plog, "fs81", mrs->log);

            pclst = pflsh;
            while (1) {
                sprintf_f(mrs->log, "    str:%d len:%d for %s\n", pclst->ftStart, pclst->ftLen, pa->dfSFN);
                print_f(mrs->plog, "fs81", mrs->log);
                if (!pclst->n) break;
                pnxf = pclst;
                pclst = pclst->n;
                aspMemFree(pnxf, 0);
            }       
                    
            if ((fLen == -1) || ((fLen > 0) && (len > fLen))) {

                sprintf_f(mrs->log, "  free:%d, need:%d\n", fLen, len);
                print_f(mrs->plog, "fs81", mrs->log);
                
                /* no space */
                /* allocate FAT to folder */
                pfre = pftb->ftbMng.f;
                if (!pfre) {
                    sprintf_f(mrs->log, "Error!! free space link list is empty \n");
                    print_f(mrs->plog, "fs81", mrs->log);
                    modersp->r = 0xed;
                    return 1;
                }

                sprintf_f(mrs->log, "folder allocate new cluster for file: [%s] \n", curDir->dfSFN);
                print_f(mrs->plog, "fs81", mrs->log);

                if (!pftb->h) {
                    padd = 0;

                    pnxf = 0;
                    ret = mspSD_allocFreeFATList(&padd, 1, pfre, &pnxf);
                    if (ret) {
                        sprintf_f(mrs->log, "ERROR!!! free FAT table parsing for file upload FAIL!!ret:%d (%s)\n", ret, curDir->dfSFN);
                        print_f(mrs->plog, "fs81", mrs->log);
                        modersp->r = 0xed;
                        return 1;
                    } 

                    else {

                        freeClst = 0;
                        if ((pfre != pnxf) && (pnxf)) {
                            totClst = (psec->secTotal - psec->secWhroot) / psec->secPrClst;

                            while (pfre != pnxf) {
                                pclst = pfre;

                                pfre = pfre->n;

                                sprintf_f(mrs->log, "free used FAT linklist, 0x%.8x start: %d, length: %d \n", (uint32_t)pclst, pclst->ftStart, pclst->ftLen);
                                print_f(mrs->plog, "fs81", mrs->log);

                                aspMemFree(pclst, 0);
                                pclst = 0;
                            }
                        }

                        pflnt = pnxf;
                        while (pflnt) {
                            freeClst += pflnt->ftLen;
                            sprintf_f(mrs->log, "cal start: %d len:%d \n", pflnt->ftStart, pflnt->ftLen);
                            print_f(mrs->plog, "fs81", mrs->log);
                            pflnt = pflnt->n;
                        }

                        sprintf_f(mrs->log, "re-calculate total free cluster: %d \n free sector: %d (size: %d) \n", freeClst, freeClst * psec->secPrClst, freeClst * psec->secPrClst * psec->secSize);
                        print_f(mrs->plog, "fs81", mrs->log);     
                        usedClst = totClst - freeClst;

                        pftb->ftbMng.ftfreeClst = freeClst;
                        pftb->ftbMng.ftusedClst = usedClst;
                        pftb->ftbMng.f = pnxf;

                    }

                    /* debug */
                    sprintf_f(mrs->log, "show allocated free FAT list: \n");
                    print_f(mrs->plog, "fs81", mrs->log);

                    val = 0;
                    pflnt = padd;
                    while (pflnt) {
                        val += pflnt->ftLen;
                        sprintf_f(mrs->log, "    str:%d len:%d - %d\n", pflnt->ftStart, pflnt->ftLen, val);
                        print_f(mrs->plog, "fs81", mrs->log);
                        pflnt = pflnt->n;
                    }
                    sprintf_f(mrs->log, "total allocated cluster is %d!! \n", val);
                    print_f(mrs->plog, "fs81", mrs->log);
                    
                    pclst->n = padd; 
                }else {
                    aspMemFree(pclst, 0);
                    sprintf_f(mrs->log, "ERROR!!! pftb->h != 0, 0x%x\n", (uint32_t)pftb->h);
                    print_f(mrs->plog, "fs81", mrs->log);
                    modersp->r = 0xed;
                    return 1;
                }
                
                /* enable FAT update flag */
                pfat->fatStatus |= ASPFAT_STATUS_FATWT;   
            }

            /* for cluster DEF update */
            pftb->h = pclst;
            pftb->c = pftb->h;

            //memset(pParBuf->dirParseBuff, 0, pParBuf->dirBuffMax);            
            pParBuf->dirBuffUsed = 0;
            pfat->fatStatus &= ~ASPFAT_STATUS_DFECHK;   
            aspMemFree(pfdirt, 0);         
            mrs->folder_dirt = 0;
            modersp->r = 1;
        } else {
            sprintf_f(mrs->log, "Size of used parse buffer should not be zero, folder[%s]\n", pa->dfSFN);
            print_f(mrs->plog, "fs81", mrs->log);
            
            aspMemFree(pfdirt, 0);            
            mrs->folder_dirt = 0;
            modersp->r = 0xed;
        }
    }
    else {

        if (pftb->h) {
            pflnt = pftb->h;
            curDir->dfclstnum = pflnt->ftStart;
            sprintf_f(mrs->log, "set upload file [%s] start cluster: %d, size:%d\n", curDir->dfSFN, curDir->dfclstnum, curDir->dflength);
            print_f(mrs->plog, "fs81", mrs->log);

            while (pflnt) {
                pflsh = pflnt;
                pflnt = pflnt->n;
                aspMemFree(pflsh, 0);
            }
            pftb->h = 0;
        }

        pa = curDir->pa;
        pfdirt = aspMemalloc(sizeof(struct folderQueue_s), 10);
        pfdirt->fdObj = pa;
        pfdirt->fdnxt = 0;

        if (!pftb->h) {
            pflsh = 0;

            ret = mspSD_parseFAT2LinkList(&pflsh, pa->dfclstnum, pftb->ftbFat1, (psec->secTotal - psec->secWhroot) / psec->secPrClst);
            if (ret) {
                sprintf_f(mrs->log, "ERROR!!! FAT table parsing for root dictionary FAIL!!ret:%d (%s)\n", ret, pa->dfSFN);
                print_f(mrs->plog, "fs81", mrs->log);
                modersp->r = 0xed;
                return 1;
            }
            /* debug */
            sprintf_f(mrs->log, "show FAT link for [%s]:\n", pa->dfSFN);
            print_f(mrs->plog, "fs81", mrs->log);

            pflnt = pflsh;
            while (pflnt) {
                sprintf_f(mrs->log, "    str:%d len:%d\n", pflnt->ftStart, pflnt->ftLen);
                print_f(mrs->plog, "fs81", mrs->log);
                pflnt = pflnt->n;
            }
            
            pftb->h = pflsh;
            pftb->c = pftb->h;
        }else {
            pflnt = pftb->h;
            sprintf_f(mrs->log, "ERROR!!! FAT link list head should be zero, str:%d len:%d\n", pflnt->ftStart, pflnt->ftLen);
            print_f(mrs->plog, "fs81", mrs->log);

            modersp->r = 0xed;
            aspMemFree(pfdirt, 0);            
            return 1;
        }

        /* goto the last cluster */
        pflnt = pftb->h;
        while (pflnt->n) {
            pflnt = pflnt->n;
            sprintf_f(mrs->log, "goto next FAT list str:%d len:%d\n", pflnt->ftStart, pflnt->ftLen);
            print_f(mrs->plog, "fs81", mrs->log);
        }

        sprintf_f(mrs->log, "last FAT list str:%d len:%d\n", pflnt->ftStart, pflnt->ftLen);
        print_f(mrs->plog, "fs81", mrs->log);

        sprintf_f(mrs->log, "[%d x %d + %d] \n",pflnt->ftStart - 2, psec->secPrClst, psec->secWhroot);
        print_f(mrs->plog, "fs81", mrs->log);
                 
        secStr = (pflnt->ftStart - 2) * (uint32_t)psec->secPrClst + (uint32_t)psec->secWhroot;
        secLen = pflnt->ftLen * (uint32_t)psec->secPrClst;
        //secStr = (curDir->dfclstnum - 2) * psec->secPrClst + psec->secWhroot;
        //secLen = psec->secPrClst;

        c->opinfo = secStr;
        p->opinfo = secLen;

        if (secLen < 16) secLen = 16;

        cfgTableSet(pct, ASPOP_SDFAT_RD, 1);

        val = cfgValueOffset(secStr, 24);
        cfgTableSet(pct, ASPOP_SDFAT_STR01, val);
        val = cfgValueOffset(secStr, 16);
        cfgTableSet(pct, ASPOP_SDFAT_STR02, val);
        val = cfgValueOffset(secStr, 8);
        cfgTableSet(pct, ASPOP_SDFAT_STR03, val);
        val = cfgValueOffset(secStr, 0);
        cfgTableSet(pct, ASPOP_SDFAT_STR04, val);
        val = cfgValueOffset(secLen, 24);
        cfgTableSet(pct, ASPOP_SDFAT_LEN01, val);
        val = cfgValueOffset(secLen, 16);
        cfgTableSet(pct, ASPOP_SDFAT_LEN02, val);
        val = cfgValueOffset(secLen, 8);
        cfgTableSet(pct, ASPOP_SDFAT_LEN03, val);
        val = cfgValueOffset(secLen, 0);
        cfgTableSet(pct, ASPOP_SDFAT_LEN04, val);

        cfgTableSet(pct, ASPOP_SDFAT_SDAT, 1);

        modersp->r = 2;

        /* goto the last cluster */
        sprintf_f(mrs->log, "free FAT link for [%s]:\n", curDir->dfSFN);
        print_f(mrs->plog, "fs81", mrs->log);

        pflnt = pftb->h;
        while (pflnt) {
            sprintf_f(mrs->log, "    str:%d len:%d\n", pflnt->ftStart, pflnt->ftLen);
            print_f(mrs->plog, "fs81", mrs->log);
            pflsh = pflnt;
            pflnt = pflnt->n;
            aspMemFree(pflsh, 0);
        }
        pftb->h = 0;
        
        mrs->folder_dirt = pfdirt;
        pParBuf->dirBuffUsed = 0;
        //memset(pParBuf->dirParseBuff, 0, pParBuf->dirBuffMax);
    }

    return 1;
}

static int fs82(struct mainRes_s *mrs, struct modersp_s *modersp) 
{ 
    int bitset, ret;
    sprintf_f(mrs->log, "trigger spi0\n");
    print_f(mrs->plog, "fs82", mrs->log);

#if SPI_KTHREAD_USE & SPI_UPD_NO_KTHREAD
    bitset = 0;
    ret = msp_spi_conf(mrs->sfm[0], _IOR(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_START_THREAD
    sprintf_f(mrs->log, "Start spi0 spidev thread, ret: 0x%x\n", ret);
    print_f(mrs->plog, "fs82", mrs->log);
#endif

    mrs_ipc_put(mrs, "f", 1, 1);

    modersp->m = modersp->m + 1;
    return 2;
}

static int fs83(struct mainRes_s *mrs, struct modersp_s *modersp) 
{ 
    int len=0, bitset=0, ret=0;
    char ch=0;
    struct info16Bit_s *p;

    //sprintf_f(mrs->log, "wait spi0 tx end\n");
    //print_f(mrs->plog, "fs83", mrs->log);

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if (len > 0) {

        sprintf_f(mrs->log, "ch: %c - end\n", ch);
        print_f(mrs->plog, "fs83", mrs->log);

        if (ch == 'F') {

#if SPI_KTHREAD_USE & SPI_UPD_NO_KTHREAD
            bitset = 0;
            ret = msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_STOP_THREAD
            sprintf_f(mrs->log, "Stop spi0 spidev thread, ret: 0x%x\n", ret);
            print_f(mrs->plog, "fs83", mrs->log);
#endif
#if PULL_LOW_AFTER_DATA
            bitset = 0;
            msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
            sprintf_f(mrs->log, "set RDY pin %d\n",bitset);
            print_f(mrs->plog, "fs83", mrs->log);
            usleep(210000);
#endif

            modersp->m = 48;            
            return 2;
        } else {
            modersp->r = 2;
            return 1;
        }
    }
    return 0; 
}

static int fs84(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct info16Bit_s *p;
    p = &mrs->mchine.cur;

    p->opcode = OP_SAVE;
    p->data = 0;

    //sprintf_f(mrs->log, "set opcode OP_SAVE: 0x%.2x 0x%.2x \n", p->opcode, p->data);
    //print_f(mrs->plog, "fs84", mrs->log);
    
    mrs_ipc_put(mrs, "c", 1, 1);
    modersp->m = modersp->m + 1;
    return 0; 
}

static int fs85(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    int len=0;
    char ch=0;
    struct info16Bit_s *p;

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((len > 0) && (ch == 'C')) {
        msync(&mrs->mchine, sizeof(struct machineCtrl_s), MS_SYNC);

        p = &mrs->mchine.get;
        //sprintf_f(mrs->log, "get opcode 0x%.2x 0x%.2x \n", p->opcode, p->data);
        //print_f(mrs->plog, "fs85", mrs->log);

        if (p->opcode == OP_QRY) {
            modersp->m = modersp->m + 1;
            return 2;
        } else {
            modersp->r = 2;
            return 1;
        }
    }
    return 0; 
}

static int fs86(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct info16Bit_s *p;
    p = &mrs->mchine.cur;

    p->opcode = OP_SAVE;
    p->data = 0;

    //sprintf_f(mrs->log, "set opcode OP_SAVE: 0x%.2x 0x%.2x \n", p->opcode, p->data);
    //print_f(mrs->plog, "fs86", mrs->log);
    
    mrs_ipc_put(mrs, "c", 1, 1);
    modersp->m = modersp->m + 1;
    return 0; 
}

static int fs87(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    int len=0;
    char ch=0;
    struct info16Bit_s *p;

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((len > 0) && (ch == 'C')) {
        msync(&mrs->mchine, sizeof(struct machineCtrl_s), MS_SYNC);

        p = &mrs->mchine.get;
        //sprintf_f(mrs->log, "get opcode 0x%.2x 0x%.2x \n", p->opcode, p->data);
        //print_f(mrs->plog, "fs87", mrs->log);

        if (p->opcode == OP_SAVE) {
            modersp->r = 1;
            return 1;
        } else {
            modersp->r = 2;
            return 1;
        }
    }
    return 0; 
}

static int fs88(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    FILE *f=0;
    char clstPath[128] = "/tmp/clstNew.bin";
    
    uint8_t *pdef=0;
    int val=0, i=0, ret=0, fLen=0, len=0, tpid=0, dirid;
    char *pr=0, *addr=0;
    uint32_t secStr=0, secLen=0, fstsec=0, lstsec;
    struct aspConfig_s *pct=0;
    struct sdbootsec_s   *psec=0;
    struct sdFAT_s *pfat=0;
    struct sdParseBuff_s *pParBuf=0;
    struct info16Bit_s *p=0, *c=0;
    struct directnFile_s *curDir=0, *ch=0, *br=0, *pa=0, *getDir=0;
    struct folderQueue_s *pfhead=0, *pfdirt=0, *pfnext=0;
    struct adFATLinkList_s *pflsh=0, *pflnt=0;
    struct sdFATable_s   *pftb=0;

    c = &mrs->mchine.cur;
    p = &mrs->mchine.tmp;
    
    pct = mrs->configTable;
    pfat = &mrs->aspFat;
    pParBuf = &pfat->parBuf;
    psec = &pfat->fatBootsec;
    pftb = &pfat->fatTable;
    
    sprintf_f(mrs->log, "DFE upload to SD\n");
    print_f(mrs->plog, "fs88", mrs->log);

    if (!pfat->fatFileUpld.dfindex) {
        modersp->r = 0xed;
        return 1;
    } else {
        dirid = pfat->fatFileUpld.dfindex;
    }

    //curDir = pfat->fatFileUpld;
    ret = aspFSms2rs(&curDir, &pfat->fatFileUpld, &pfat->fatDirTr);
    if (!curDir) {
        sprintf_f(mrs->log, "get upld dir failed ret: %d\n", ret);
        print_f(mrs->plog, "fs88", mrs->log);
        modersp->r = 0xed;
        return 1;
    }
    
    //aspFScpDir(curDir, &pfat->fatFileUpld);
    //if (curDir->dflength != pfat->fatFileUpld.dflength) {
    if (strcmp(curDir->dfSFN, pfat->fatFileUpld.dfSFN) != 0) {
        ret = aspFScpDirTr(curDir, &pfat->fatFileUpld, &pfat->fatDirTr);
        if (ret < 0) {
            sprintf_f(mrs->log, "cp dir into file tree failed ret: %d\n", ret);
            print_f(mrs->plog, "fs88", mrs->log);
            modersp->r = 0xed;
            return 1;
        }
        
        tpid = getDir->dfindex;        
        if (tpid != dirid) {
            curDir = getDir;
            sprintf_f(mrs->log, "WARNNING!!! reset curdir(id:%d) as %d\n", dirid, tpid);
            print_f(mrs->plog, "fs88", mrs->log);
        }
    
        if (curDir->pa) {
            aspFS_insertFATChild(curDir->pa, curDir);
            sprintf_f(mrs->log, "insert [%s] into [%s] \n", curDir->dfSFN, curDir->pa->dfSFN);
            print_f(mrs->plog, "fs88", mrs->log);
        } else {
            sprintf_f(mrs->log, "WARNNING: [%s] didn't have parent \n", curDir->dfSFN);
            print_f(mrs->plog, "fs88", mrs->log);
        }

        if (tpid != dirid) {
            sprintf_f(mrs->log, "check curdir(id:%d) not %d\n", curDir->dfindex, dirid);
            print_f(mrs->plog, "fs88", mrs->log);
            aspFScpDir(&pfat->fatFileUpld, curDir);
        }

    } else {
        sprintf_f(mrs->log, "get upd dir succeed: [%s] <== [%s]\n", curDir->dfSFN, pfat->fatFileUpld.dfSFN);
        print_f(mrs->plog, "fs88", mrs->log);
    }


    if (pParBuf->dirBuffUsed) {
        pfat->fatStatus &= ~ASPFAT_STATUS_DFERD;
        if (!pftb->c) {
            sprintf_f(mrs->log, "  pftb->c should not be NULL \n");
            print_f(mrs->plog, "fs88", mrs->log);

            modersp->r = 0xed;
            return 1;
        }
        pflnt = pftb->c;
        
        //msync(pParBuf->dirParseBuff, pParBuf->dirBuffUsed, MS_SYNC);
        //shmem_dump(pParBuf->dirParseBuff, pParBuf->dirBuffUsed);
        /* find the free space, slot unit is 32 bytes */
        fLen = aspFindFreeDEF(&pdef, pParBuf->dirParseBuff, pParBuf->dirBuffUsed, 32);

        /* debug */
        if (fLen > 0) {
            //shmem_dump(pParBuf->dirParseBuff + (((pParBuf->dirBuffUsed - fLen) > 512)?(pParBuf->dirBuffUsed - fLen - 512):(pParBuf->dirBuffUsed - fLen)), fLen+512);
        } else {
            sprintf_f(mrs->log, "  ERROR!!! cluster has no space! ret:%d \n", fLen);
            print_f(mrs->plog, "fs88", mrs->log);
            modersp->r = 0xed;
            return 1;
        }

        f = fopen(clstPath, "r");

        ret = fseek(f, 0, SEEK_END);
        if (ret) {
            sprintf_f(mrs->log, " file seek failed!! ret:%d \n", ret);
            print_f(mrs->plog, "fs88", mrs->log);
            modersp->r = 0xed;
            return 1;
        } 
                
        len = ftell(f);
        sprintf_f(mrs->log, " file [%s] size: %d \n", clstPath, len);
        print_f(mrs->plog, "fs88", mrs->log);

        ret = fseek(f, 0, SEEK_SET);
        if (ret) {
            sprintf_f(mrs->log, " file seek failed!! ret:%d \n", ret);
            print_f(mrs->plog, "fs88", mrs->log);
            modersp->r = 0xed;
            return 1;
        }

        pr = aspMemalloc(len, 10);
        if (!pr) {
            sprintf_f(mrs->log, " malloc failed ret: 0x%.8x \n", (uint32_t)pr);
            print_f(mrs->plog, "fs88", mrs->log);
            modersp->r = 0xed;
            return 1;
        }
        
        ret = fread(pr, 1, len, f);
        fclose(f);

        sprintf_f(mrs->log, "FAT file read size: %d/%d free:%d\n", ret, len, fLen);
        print_f(mrs->plog, "fs88", mrs->log);
        //shmem_dump(pr, len);
        
        //addr = pParBuf->dirParseBuff + (pParBuf->dirBuffUsed - fLen);

        if (len > fLen) {
            //shmem_dump(pdef, fLen);
            memcpy(pdef, pr,  fLen);
            //shmem_dump(pdef, fLen);

            pr += fLen;
            len -= fLen;
        } else {
            //shmem_dump(pdef, len);
            memcpy(pdef, pr,  len);
            //shmem_dump(pdef, len);
            len = 0;
        }

        if (len) {
            f = fopen(clstPath, "w+");
            if (f) {
                msync(pr, len, MS_SYNC);
                //shmem_dump(pr, len);
                fwrite(pr, 1, len, f);
                fflush(f);
                fclose(f);
                sprintf_f(mrs->log, "DEF save to [%s] size:%d\n", clstPath, len);
                print_f(mrs->plog, "fs88", mrs->log);
            } else {
                sprintf_f(mrs->log, "DEF find save to [%s] failed !!!\n", clstPath);
                print_f(mrs->plog, "fs88", mrs->log);
            }
        } else {
            f = fopen(clstPath, "w+");
            if (f) {
                fflush(f);
                fclose(f);
                sprintf_f(mrs->log, "DEF save to [%s] size:%d\n", clstPath, len);
                print_f(mrs->plog, "fs88", mrs->log);
            } else {
                sprintf_f(mrs->log, "DEF find save to [%s] failed !!!\n", clstPath);
                print_f(mrs->plog, "fs88", mrs->log);
            }
        }

        secStr = (pflnt->ftStart - 2) * (uint32_t)psec->secPrClst + (uint32_t)psec->secWhroot;
        secLen = pflnt->ftLen * (uint32_t)psec->secPrClst;
        
        c->opinfo = secStr;
        p->opinfo = secLen;
        
        sprintf_f(mrs->log, "set secStart:%d, secLen:%d \n", secStr, secLen);
        print_f(mrs->plog, "fs88", mrs->log);

        if (secLen < 16) secLen = 16;

        cfgTableSet(pct, ASPOP_SDFAT_WT, 1);

        val = cfgValueOffset(secStr, 24);
        cfgTableSet(pct, ASPOP_SDFAT_STR01, val);
        val = cfgValueOffset(secStr, 16);
        cfgTableSet(pct, ASPOP_SDFAT_STR02, val);
        val = cfgValueOffset(secStr, 8);
        cfgTableSet(pct, ASPOP_SDFAT_STR03, val);
        val = cfgValueOffset(secStr, 0);
        cfgTableSet(pct, ASPOP_SDFAT_STR04, val);
        val = cfgValueOffset(secLen, 24);
        cfgTableSet(pct, ASPOP_SDFAT_LEN01, val);
        val = cfgValueOffset(secLen, 16);
        cfgTableSet(pct, ASPOP_SDFAT_LEN02, val);
        val = cfgValueOffset(secLen, 8);
        cfgTableSet(pct, ASPOP_SDFAT_LEN03, val);
        val = cfgValueOffset(secLen, 0);
        cfgTableSet(pct, ASPOP_SDFAT_LEN04, val);

        cfgTableSet(pct, ASPOP_SDFAT_SDAT, 1);
        
        modersp->r = 3; /*2 is for FAT_WT*/

        pftb->c = pflnt->n;
        pftb->h = 0;
        aspMemFree(pflnt, 0);
        pParBuf->dirBuffUsed = 0;
    }
    else if (pftb->c) {
        pflnt = pftb->c;

        secStr = (pflnt->ftStart - 2) * (uint32_t)psec->secPrClst + (uint32_t)psec->secWhroot;
        secLen = pflnt->ftLen * (uint32_t)psec->secPrClst;

        if ((!pftb->h) && (!pflnt->n)) {
            pParBuf->dirBuffUsed = secLen * 512;
            //memset(pParBuf->dirParseBuff, 0, pParBuf->dirBuffUsed);    
            modersp->r = 1;
        } else {
        
            c->opinfo = secStr;
            p->opinfo = secLen;

            sprintf_f(mrs->log, "set secStart:%d, secLen:%d \n", secStr, secLen);
            print_f(mrs->plog, "fs88", mrs->log);

            if (secLen < 16) secLen = 16;

            cfgTableSet(pct, ASPOP_SDFAT_RD, 1);

            val = cfgValueOffset(secStr, 24);
            cfgTableSet(pct, ASPOP_SDFAT_STR01, val);
            val = cfgValueOffset(secStr, 16);
            cfgTableSet(pct, ASPOP_SDFAT_STR02, val);
            val = cfgValueOffset(secStr, 8);
            cfgTableSet(pct, ASPOP_SDFAT_STR03, val);
            val = cfgValueOffset(secStr, 0);
            cfgTableSet(pct, ASPOP_SDFAT_STR04, val);
            val = cfgValueOffset(secLen, 24);
            cfgTableSet(pct, ASPOP_SDFAT_LEN01, val);
            val = cfgValueOffset(secLen, 16);
            cfgTableSet(pct, ASPOP_SDFAT_LEN02, val);
            val = cfgValueOffset(secLen, 8);
            cfgTableSet(pct, ASPOP_SDFAT_LEN03, val);
            val = cfgValueOffset(secLen, 0);
            cfgTableSet(pct, ASPOP_SDFAT_LEN04, val);

            cfgTableSet(pct, ASPOP_SDFAT_SDAT, 1);
        
            modersp->r = 2; /*2 is for FAT_RD*/

            pfat->fatStatus |= ASPFAT_STATUS_DFERD;
            pParBuf->dirBuffUsed = 0;
            //memset(pParBuf->dirParseBuff, 0, secLen * 512);
        }
    }
    else {
        if (pftb->h) {
            sprintf_f(mrs->log, " BEGIN... \n");
            print_f(mrs->plog, "fs88", mrs->log);

            pftb->c = pftb->h;
        } else {
            sprintf_f(mrs->log, " END... \n");
            print_f(mrs->plog, "fs88", mrs->log);

            pfat->fatStatus &= ~ASPFAT_STATUS_DFEWT;    
            
            //pfat->fatFileUpld = 0;
            memset(&pfat->fatFileUpld, 0, sizeof(struct directnFile_s));

            curDir->dfstats = ASPFS_STATUS_EN;
            mrs->folder_dirt = 0;
            //curDir->dfstats = ASPFS_STATUS_EN;
            //pfat->fatFileUpld = 0;
        }
        modersp->r = 1;
    }

    return 1;
}
static int fs89(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct sdParseBuff_s *pabuf=0;
    char *addr=0, *src=0;
    int bitset, ret, maxsz, totsz=0, bufn=0, cpn=0, len=0;
    sprintf_f(mrs->log, "trigger spi0\n");
    print_f(mrs->plog, "fs89", mrs->log);

    pabuf = &mrs->aspFat.parBuf;
    
#if SPI_KTHREAD_USE & SPI_UPD_NO_KTHREAD
    bitset = 0;
    ret = msp_spi_conf(mrs->sfm[0], _IOR(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_START_THREAD
    sprintf_f(mrs->log, "Start spi0 spidev thread, ret: 0x%x\n", ret);
    print_f(mrs->plog, "fs89", mrs->log);
#endif

    ring_buf_init(&mrs->dataRx);

    maxsz = pabuf->dirBuffMax;
    src = pabuf->dirParseBuff;

    sprintf_f(mrs->log, "buff size: %d\n", maxsz);
    print_f(mrs->plog, "fs89", mrs->log);

    while (maxsz > 0) {
        len = ring_buf_get(&mrs->dataRx, &addr);
        if (len <= 0) {
            sprintf_f(mrs->log, "ERROR!!! get ring buffer failed ret = %d\n", len);
            print_f(mrs->plog, "fs89", mrs->log);
            modersp->r = 0xed;
            return 1;
        }
        
        if (maxsz < len) {
            len = maxsz;
        }

        memcpy(addr, src, len);

        totsz += len;
        src += len;
        maxsz -= len;
        cpn++;

        ring_buf_prod(&mrs->dataRx);

        sprintf_f(mrs->log, "%d. len:%d, totsz: %d\n", cpn, len, totsz);
        print_f(mrs->plog, "fs89", mrs->log);
    }

    ring_buf_set_last(&mrs->dataRx, len);
    bufn = ring_buf_info_len(&mrs->dataRx);
    
    sprintf_f(mrs->log, "cpn: %d, bufn: %d\n", cpn, bufn);
    print_f(mrs->plog, "fs89", mrs->log);

    mrs_ipc_put(mrs, "w", 1, 1);
    modersp->v = 0;
    
    modersp->m = modersp->m + 1;
    return 2;
}

static int fs90(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int len=0, bitset=0, ret=0;
    char ch=0;
    struct info16Bit_s *p;

    //sprintf_f(mrs->log, "wait spi0 tx end\n");
    //print_f(mrs->plog, "fs90", mrs->log);

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if (len > 0) {

        sprintf_f(mrs->log, "ch: %c - end\n", ch);
        print_f(mrs->plog, "fs90", mrs->log);

        if (ch == 'W') {

#if SPI_KTHREAD_USE & SPI_UPD_NO_KTHREAD
            bitset = 0;
            ret = msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_STOP_THREAD
            sprintf_f(mrs->log, "Stop spi0 spidev thread, ret: 0x%x\n", ret);
            print_f(mrs->plog, "fs90", mrs->log);
#endif
#if PULL_LOW_AFTER_DATA
            bitset = 0;
            msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
            sprintf_f(mrs->log, "set RDY pin %d\n",bitset);
            print_f(mrs->plog, "fs90", mrs->log);
            usleep(210000);
#endif

            modersp->m = 48;            
            return 2;
        } else {
            modersp->r = 2;
            return 1;
        }
    }
    return 0; 
}

static int fs91(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int val=0, i=0, ret=0;
    char *pr=0;
    uint32_t secStr=0, secLen=0, clstByte=0, clstLen=0, freeClst=0, usedClst=0, totClst=0;
    struct aspConfig_s *pct=0;
    struct sdbootsec_s   *psec=0;
    struct sdFAT_s *pfat=0;
    struct info16Bit_s *p=0, *c=0;
    struct directnFile_s *curDir=0, *ch=0, *br=0;
    struct adFATLinkList_s *pflsh=0, *pflnt=0;
    struct adFATLinkList_s *pfre=0, *pnxf=0, *pclst=0;
    struct sdFATable_s   *pftb=0;
    
    pct = mrs->configTable;
    pfat = &mrs->aspFat;
    psec = &pfat->fatBootsec;
    pftb = &pfat->fatTable;
    clstByte = psec->secSize * psec->secPrClst;
    if (!clstByte) {
        sprintf_f(mrs->log, "ERROR!! bytes number of cluster is zero \n");
        print_f(mrs->plog, "fs91", mrs->log);

        modersp->r = 2;
        return 1;
    }

    pfre = pftb->ftbMng.f;
    if (!pfre) {
        sprintf_f(mrs->log, "Error!! free space link list is empty \n");
        print_f(mrs->plog, "fs91", mrs->log);
        modersp->r = 0xed;
        return 1;
    }

    ret = mspSD_getLastFATList(&pflsh, pfre);
    if (ret) {
        sprintf_f(mrs->log, "Error!! get last FAT linklist failed ret: %d\n", ret);
        print_f(mrs->plog, "fs91", mrs->log);
        modersp->r = 2;
        return 1;
    }

    sprintf_f(mrs->log, "Get last FAT linklist start: %d, length: %d\n", pflsh->ftStart, pflsh->ftLen);
    print_f(mrs->plog, "fs91", mrs->log);

    pflnt = pflsh;

    secStr = (pflnt->ftStart - 2) * (uint32_t)psec->secPrClst + (uint32_t)psec->secWhroot;
    secLen = pflnt->ftLen * (uint32_t)psec->secPrClst;
        
    sprintf_f(mrs->log, "set secStart:%d, secLen:%d \n", secStr, secLen);
    print_f(mrs->plog, "fs91", mrs->log);

    cfgTableSet(pct, ASPOP_SDFREE_FREESEC, psec->secPrClst);

    val = cfgValueOffset(secStr, 24);
    cfgTableSet(pct, ASPOP_SDFREE_STR01, val);
    val = cfgValueOffset(secStr, 16);
    cfgTableSet(pct, ASPOP_SDFREE_STR02, val);
    val = cfgValueOffset(secStr, 8);
    cfgTableSet(pct, ASPOP_SDFREE_STR03, val);
    val = cfgValueOffset(secStr, 0);
    cfgTableSet(pct, ASPOP_SDFREE_STR04, val);
    val = cfgValueOffset(secLen, 24);
    cfgTableSet(pct, ASPOP_SDFREE_LEN01, val);
    val = cfgValueOffset(secLen, 16);
    cfgTableSet(pct, ASPOP_SDFREE_LEN02, val);
    val = cfgValueOffset(secLen, 8);
    cfgTableSet(pct, ASPOP_SDFREE_LEN03, val);
    val = cfgValueOffset(secLen, 0);
    cfgTableSet(pct, ASPOP_SDFREE_LEN04, val);

    modersp->r = 1;
    return 1;
}

static int fs92(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    uint32_t secStr=0, secLen=0, val=0;
    struct aspConfig_s *pct=0;
    struct sdbootsec_s   *psec=0;
    struct sdFAT_s *pfat=0;

    pfat = &mrs->aspFat;
    pct = mrs->configTable;
    psec = &pfat->fatBootsec;

    secStr = 0;
    secLen = 0;
        
    sprintf_f(mrs->log, "set secStart:%d, secLen:%d secPrClst: %d \n", secStr, secLen, psec->secPrClst);
    print_f(mrs->plog, "fs92", mrs->log);

    cfgTableSet(pct, ASPOP_SDUSED_USEDSEC, psec->secPrClst);

    val = cfgValueOffset(secStr, 24);
    cfgTableSet(pct, ASPOP_SDUSED_STR01, val);
    val = cfgValueOffset(secStr, 16);
    cfgTableSet(pct, ASPOP_SDUSED_STR02, val);
    val = cfgValueOffset(secStr, 8);
    cfgTableSet(pct, ASPOP_SDUSED_STR03, val);
    val = cfgValueOffset(secStr, 0);
    cfgTableSet(pct, ASPOP_SDUSED_STR04, val);
    val = cfgValueOffset(secLen, 24);
    cfgTableSet(pct, ASPOP_SDUSED_LEN01, val);
    val = cfgValueOffset(secLen, 16);
    cfgTableSet(pct, ASPOP_SDUSED_LEN02, val);
    val = cfgValueOffset(secLen, 8);
    cfgTableSet(pct, ASPOP_SDUSED_LEN03, val);
    val = cfgValueOffset(secLen, 0);
    cfgTableSet(pct, ASPOP_SDUSED_LEN04, val);

    modersp->r = 1;

    return 1;
}

static int fs93(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    char fnameSave[16] = "asp%.5d.jpg";
    char srhName[12];
    int ret=0, cnt=0, slen=0;
    uint32_t secStr=0, secLen=0, clstLen=0, clstStr=0;;
    uint32_t freeClst=0, usedClst=0, totClst=0, val=0, b32=0;
    struct aspConfig_s *pct=0;
    struct sdbootsec_s   *psec=0;
    struct sdFAT_s *pfat=0;
    struct adFATLinkList_s *pflsh=0, *pflnt=0;
    struct adFATLinkList_s *pfre=0, *pnxf=0, *pclst=0;
    struct sdFATable_s   *pftb=0;
    struct directnFile_s *upld=0, *fscur=0, *fssrh=0;

    uint32_t adata[3], atime[3];
    char *wday[]={"Sun","Mon","Tue","Wed","Thu","Fri","Sat"}; 
    struct tm *p=0;
    time_t timep;
                
    pct = mrs->configTable;
    pfat = &mrs->aspFat;
    psec = &pfat->fatBootsec;
    pftb = &pfat->fatTable;

    pfre = pftb->ftbMng.f;
    if (!pfre) {
        sprintf_f(mrs->log, "Error!! free space link list is empty \n");
        print_f(mrs->plog, "fs93", mrs->log);
        modersp->r = 0xed;
        return 1;
    }

    if (!pfat->fatCurDir.dfindex) {
        sprintf_f(mrs->log, "Error!! current folder is null \n");
        print_f(mrs->plog, "fs93", mrs->log);
        modersp->r = 0xed;
        return 1;
    }

    ret = aspFSms2rs(&fscur, &pfat->fatCurDir, &pfat->fatDirTr);
    if (!fscur) {
        sprintf_f(mrs->log, "Error!! get current folder failed, ret: %d \n", ret);
        print_f(mrs->plog, "fs93", mrs->log);
        modersp->r = 0xed;
        return 1;
    } else {
        sprintf_f(mrs->log, "get current folder [%s] \n", fscur->dfSFN);
        print_f(mrs->plog, "fs93", mrs->log);
    }

    secStr = 0;
    secLen = 0;
            
    cfgTableGet(pct, ASPOP_SDUSED_USEDSEC, &val);
    if (val != psec->secPrClst) {
        sprintf_f(mrs->log, "ERROR!!! get secPrClst: %d (should be:%d) \n", val, psec->secPrClst);
        print_f(mrs->plog, "fs93", mrs->log);   
    }

    ret = 0;

    b32 = 0;
    ret += cfgTableGet(pct, ASPOP_SDUSED_STR01, &val);
    b32 |= val << 24;

    ret += cfgTableGet(pct, ASPOP_SDUSED_STR02, &val);
    b32 |= val << 16;
    
    ret += cfgTableGet(pct, ASPOP_SDUSED_STR03, &val);
    b32 |= val << 8;
    
    ret += cfgTableGet(pct, ASPOP_SDUSED_STR04, &val);
    b32 |= val ;
    secStr = b32;

    b32 = 0;
    ret += cfgTableGet(pct, ASPOP_SDUSED_LEN01, &val);
    b32 |= val << 24;
    
    ret += cfgTableGet(pct, ASPOP_SDUSED_LEN02, &val);
    b32 |= val << 16;
    
    ret += cfgTableGet(pct, ASPOP_SDUSED_LEN03, &val);
    b32 |= val << 8;
    
    ret += cfgTableGet(pct, ASPOP_SDUSED_LEN04, &val);
    b32 |= val;
    secLen = b32;

    pflnt = pfre;

    while (pflnt->n) {
        pflnt = pflnt->n;
    }

    clstStr = ((secStr - (uint32_t)psec->secWhroot) / (uint32_t)psec->secPrClst) + 2;

    if ((secLen % (uint32_t)psec->secPrClst) == 0) {
        clstLen = secLen / (uint32_t)psec->secPrClst;
    } else {
        clstLen = (secLen / (uint32_t)psec->secPrClst) + 1;
    }

    sprintf_f(mrs->log, "Get secStart:%d, secLen:%d, clstStr: %d, clstLen: %d \n", secStr, secLen, clstStr, clstLen);
    print_f(mrs->plog, "fs93", mrs->log);

    if ((pflnt->ftStart != clstStr) || (clstLen > pflnt->ftLen)) {
        sprintf_f(mrs->log, "ERROR!!! get clstStart: %d(%d) clstLen: %d(%d) \n", clstStr, pflnt->ftStart, clstLen, pflnt->ftLen);
        print_f(mrs->plog, "fs93", mrs->log);   
        modersp->r = 2;
        return 1;
    } else {
        pflnt->ftLen -= clstLen;
        pflnt->ftStart += clstLen;
        modersp->r = 1;

        pflnt = pfre;
        while (pflnt) {
            freeClst += pflnt->ftLen;
            sprintf_f(mrs->log, "cal start: %d len:%d \n", pflnt->ftStart, pflnt->ftLen);
            print_f(mrs->plog, "fs93", mrs->log);
            pflnt = pflnt->n;
        }

        sprintf_f(mrs->log, "re-calculate total free cluster: %d \n free sector: %d (size: %d) \n", freeClst, freeClst * psec->secPrClst, freeClst * psec->secPrClst * psec->secSize);
        print_f(mrs->plog, "fs98", mrs->log);     
        usedClst = totClst - freeClst;

        pftb->ftbMng.ftfreeClst = freeClst;
        pftb->ftbMng.ftusedClst = usedClst;
        pftb->ftbMng.f = pfre;
    }

    ret = mspFS_allocDir(&pfat->fatDirTr, &upld, 9);
    if (ret) {
         sprintf_f(mrs->log, "Error!! get new file entry failed ret: %d \n", ret);
        print_f(mrs->plog, "fs93", mrs->log);
        modersp->r = 0xed;
        return 1;
    }

    //memset(upld, 0, sizeof(struct directnFile_s));
    upld->dftype = ASPFS_TYPE_FILE;
    upld->dfstats = ASPFS_STATUS_DIS;
    //upld->dfstats = ASPFS_STATUS_EN;
    upld->dfattrib = ASPFS_ATTR_ARCHIVE;
    upld->dfclstnum = clstStr; /* start cluster */

    time(&timep);
    p=localtime(&timep); /*oa*/ 
    sprintf_f(mrs->log, "%.4d%.2d%.2d \n", (1900+p->tm_year),( 1+p-> tm_mon), p->tm_mday); 
    print_f(mrs->plog, "fs93", mrs->log);
    sprintf_f(mrs->log, "%s,%.2d:%.2d:%.2d\n", wday[p->tm_wday],p->tm_hour, p->tm_min, p->tm_sec); 
    print_f(mrs->plog, "fs93", mrs->log);

    adata[0] = p->tm_year+1900;
    adata[1] = p->tm_mon + 1;
    adata[2] = p->tm_mday;
    
    atime[0] = p->tm_hour;
    atime[1] = p->tm_min;
    atime[2] = p->tm_sec;
    
    upld->dfcredate = ((((adata[0] - 1980) & 0xff) << 16) | ((adata[1] & 0xff) << 8) | (adata[2] & 0xff));
    upld->dfcretime = (((atime[0]&0xff) << 16) | ((atime[1]&0xff) << 8) | (atime[2]&0xff));
    upld->dflstacdate = ((((adata[0] - 1980)&0xff) << 16) | ((adata[1]&0xff) << 8) | (adata[2]&0xff));
    upld->dfrecodate = ((((adata[0] - 1980)&0xff) << 16) | ((adata[1]&0xff) << 8) | (adata[2]&0xff));
    upld->dfrecotime = (((atime[0]&0xff) << 16) | ((atime[1]&0xff) << 8) | (atime[2]&0xff));

    upld->dflength = secLen * 512; /* file length */                                                

    /* assign a name with sequence number */
    for (cnt=0; cnt < 10000; cnt++) {
        sprintf(srhName, fnameSave, cnt);
        sprintf_f(mrs->log, "search name: [%s]\n", srhName);
        print_f(mrs->plog, "fs93", mrs->log);

        ret = mspFS_SearchInFolder(&fssrh, fscur, srhName);
        if (ret) break;
    }

    slen = strnlen(srhName, sizeof(srhName));
    strncpy(upld->dfSFN, srhName, slen);
    upld->dfSFN[12] = '\0';

    upld->dflen = 0;
    upld->dfLFN[0] = '\0';

    sprintf_f(mrs->log, "SFN[%s] LFS[%s] len:%d\n", upld->dfSFN, upld->dfLFN, upld->dflen);
    print_f(mrs->plog, "fs93", mrs->log);

    ret = mspSD_createFATLinkList(&pclst);
    if (ret) {
        modersp->r = 0xed;
        return 1;
    }
    pclst->ftStart = clstStr;
    pclst->ftLen = clstLen;
    pftb->h = pclst;
    pftb->c = pftb->h;

    aspFS_insertFATChild(fscur, upld);
    
    //pfat->fatFileUpld = upld;
    aspFScpDir(&pfat->fatFileUpld, upld);
    
    debugPrintDir(upld);
    mspFS_folderList(upld->pa, 4);

    pfat->fatStatus |= ASPFAT_STATUS_FATWT;
    pfat->fatStatus |= ASPFAT_STATUS_DFECHK;
    pfat->fatStatus |= ASPFAT_STATUS_DFEWT;

    modersp->r = 1;
    return 1;
}

static int fs94(struct mainRes_s *mrs, struct modersp_s *modersp) 
{
    int val=0, i=0, ret=0, tpid=0, dirid;
    char *pr=0;
    uint32_t secStr=0, secLen=0, fstsec=0, lstsec;
    struct aspConfig_s *pct=0;
    struct sdbootsec_s   *psec=0;
    struct sdFAT_s *pfat=0;
    struct sdParseBuff_s *pParBuf=0;
    struct info16Bit_s *p=0, *c=0;
    struct directnFile_s *curDir=0, *ch=0, *br=0, *getDir=0;
    struct folderQueue_s *pfhead=0, *pfdirt=0, *pfnext=0;
    struct adFATLinkList_s *pflsh=0, *pflnt=0;
    struct sdFATable_s   *pftb=0;


    c = &mrs->mchine.cur;
    p = &mrs->mchine.tmp;
    
    pct = mrs->configTable;
    pfat = &mrs->aspFat;
    pParBuf = &pfat->parBuf;
    psec = &pfat->fatBootsec;
    pftb = &pfat->fatTable;

    if (!pfat->fatFileUpld.dfindex) {
        modersp->r = 0xed;
        return 1;
    } else {
        dirid = pfat->fatFileUpld.dfindex;
    }

    //curDir = &pfat->fatFileUpld;
    aspFSms2rs(&curDir, &pfat->fatFileUpld, &pfat->fatDirTr);
    if (!curDir) {
        sprintf_f(mrs->log, "get SD cur failed\n");
        print_f(mrs->plog, "fs94", mrs->log);

        modersp->r = 0xed;
        return 1;
    }
    
    //if (curDir->dflength != pfat->fatFileUpld.dflength) {
    if (strcmp(curDir->dfSFN, pfat->fatFileUpld.dfSFN) != 0) {
        ret = aspFScpDirTr(curDir, &pfat->fatFileUpld, &pfat->fatDirTr);
        if (ret < 0) {
            sprintf_f(mrs->log, "cp dir into file tree failed ret: %d\n", ret);
            print_f(mrs->plog, "fs94", mrs->log);
            modersp->r = 0xed;
            return 1;
        }
        
        tpid = getDir->dfindex;        
        if (tpid != dirid) {
            curDir = getDir;
            sprintf_f(mrs->log, "WARNNING!!! reset curdir(id:%d) as %d\n", dirid, tpid);
            print_f(mrs->plog, "fs94", mrs->log);
        }
    
        if (curDir->pa) {
            aspFS_insertFATChild(curDir->pa, curDir);
            sprintf_f(mrs->log, "insert [%s] into [%s] \n", curDir->dfSFN, curDir->pa->dfSFN);
            print_f(mrs->plog, "fs94", mrs->log);
        } else {
            sprintf_f(mrs->log, "WARNNING: [%s] didn't have parent \n", curDir->dfSFN);
            print_f(mrs->plog, "fs94", mrs->log);
        }

        if (tpid != dirid) {
            sprintf_f(mrs->log, "check curdir(id:%d) not %d\n", curDir->dfindex, dirid);
            print_f(mrs->plog, "fs94", mrs->log);
            aspFScpDir(&pfat->fatFileUpld, curDir);
        }

    } else {
        sprintf_f(mrs->log, "get upd dir succeed: [%s] <== [%s]\n", curDir->dfSFN, pfat->fatFileUpld.dfSFN);
        print_f(mrs->plog, "fs94", mrs->log);
    }

    
    sprintf_f(mrs->log, "get SD cur:0x%.8x filename:[%s]length[%d]\n", (uint32_t)pftb->c, curDir->dfSFN, curDir->dflength);
    print_f(mrs->plog, "fs94", mrs->log);

    if (pftb->c) {
        pflnt = pftb->c;
                 
        secStr = (pflnt->ftStart - 2) * psec->secPrClst + psec->secWhroot;

        if (!pflnt->n) {
            if (!(curDir->dflength % 512)) {
                fstsec = curDir->dflength / 512;
            } else {
                fstsec = (curDir->dflength / 512) + 1;
            }
            sprintf_f(mrs->log, "fstsec: %d\n", fstsec);
            print_f(mrs->plog, "fs94", mrs->log);

            if (!(fstsec % psec->secPrClst) ) {
                lstsec = psec->secPrClst;
            } else {
                lstsec = fstsec % psec->secPrClst;
            }
            sprintf_f(mrs->log, "lstsec: %d\n", lstsec);
            print_f(mrs->plog, "fs94", mrs->log);
            
            secLen = (pflnt->ftLen - 1) * psec->secPrClst + lstsec;
        } else {
            secLen = pflnt->ftLen * psec->secPrClst;
        }

        c->opinfo = secStr;
        p->opinfo = secLen;

        if (secLen < 16) secLen = 16;

        sprintf_f(mrs->log, "set secStart:%d, secLen:%d \n", secStr, secLen);
        print_f(mrs->plog, "fs94", mrs->log);

        cfgTableSet(pct, ASPOP_SDFAT_WT, 1);

        val = cfgValueOffset(secStr, 24);
        cfgTableSet(pct, ASPOP_SDFAT_STR01, val);
        val = cfgValueOffset(secStr, 16);
        cfgTableSet(pct, ASPOP_SDFAT_STR02, val);
        val = cfgValueOffset(secStr, 8);
        cfgTableSet(pct, ASPOP_SDFAT_STR03, val);
        val = cfgValueOffset(secStr, 0);
        cfgTableSet(pct, ASPOP_SDFAT_STR04, val);
        val = cfgValueOffset(secLen, 24);
        cfgTableSet(pct, ASPOP_SDFAT_LEN01, val);
        val = cfgValueOffset(secLen, 16);
        cfgTableSet(pct, ASPOP_SDFAT_LEN02, val);
        val = cfgValueOffset(secLen, 8);
        cfgTableSet(pct, ASPOP_SDFAT_LEN03, val);
        val = cfgValueOffset(secLen, 0);
        cfgTableSet(pct, ASPOP_SDFAT_LEN04, val);

        cfgTableSet(pct, ASPOP_SDFAT_SDAT, 1);
        
        modersp->r = 3; /*3 is for SDWT*/

        pftb->c = pflnt->n;
        //aspMemFree(pflnt, 0);

    }else {
        pfat->fatStatus &= ~ASPFAT_STATUS_SDWBK;    
        pftb->c = pftb->h;
        //pfat->fatFileUpld = 0;
        //pftb->h = 0;
        modersp->r = 1;
    }

    return 1;
}

static int fs95(struct mainRes_s *mrs, struct modersp_s *modersp) 
{
    int bitset, ret=0;

    sprintf_f(mrs->log, "trigger spi_0_\n");
    print_f(mrs->plog, "fs95", mrs->log);

#if SPI_KTHREAD_USE & SPI_UPD_NO_KTHREAD
    bitset = 0;
    ret = msp_spi_conf(mrs->sfm[0], _IOR(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_START_THREAD
    sprintf_f(mrs->log, "Start spi0 spidev thread, ret: 0x%x\n", ret);
    print_f(mrs->plog, "fs95", mrs->log);
#else
    sprintf_f(mrs->log, "NOT start spi0 spidev thread, ret: 0x%x\n", ret);
    print_f(mrs->plog, "fs95", mrs->log);
#endif

    ring_buf_init(&mrs->cmdTx);
    modersp->v = 0;
 
    modersp->m = modersp->m + 1;
    return 2;
}

static int findJpgScale(uint8_t *data, int *hi, int *wh, int max)
{
    int ret = -1, ix = 0, staf = 0;
    uint8_t marker[2] = {0, 0};
    uint32_t imgLen[2] = {0, 0};
    uint32_t imgWid[2] = {0, 0};
    uint8_t ch = 0;
    int len = 0, width = 0;
    int scale[5][3], si=0;

    memset(scale, 0, sizeof(int) * 15);

    if (!data) return -2;
    if (!max) return -3;
    if (!hi) return -4;
    if (!wh) return -5;
    
    msync(data, max, MS_SYNC);
    
    for (ix=0; ix < max; ix++) {
        ch = data[ix];
    
        if (ch == 0xff) {
            marker[0] = ch;
            staf = 1;
        } 
        else if (staf == 1) {
            if (((ch >> 4) == 0xc) && ((ch & 0xf) != 4)) {
                marker[1] = ch;
                
                imgLen[1] = data[ix + 4];
                imgLen[0] = data[ix + 5];

                imgWid[1] = data[ix + 6];
                imgWid[0] = data[ix + 7];
                                
                len = (imgLen[1] << 8) + imgLen[0];   
                width = (imgWid[1] << 8) + imgWid[0];   

                scale[si][0] = len;
                scale[si][1] = width;
                scale[si][2] = 1;
                si ++;
                
                //printf("!!!!!!!![findJpgScale] height = %d, width = %d, m[0]:0x%.2x, m[1]:0x%.2x\n", len, width, marker[0], marker[1]);
                
            }
            staf = 0;
        }
        
    }

    for (ix=0; ix < si; ix++) {
        //printf("[findJpgScale] %d. hight: %d width: %d flag: %d \n", ix, scale[ix][0], scale[ix][1], scale[ix][2]);

        if (scale[ix][2] != 0) {
            len = scale[ix][0];
            width = scale[ix][1];
            ret = 0;
        }
    }
    
    *hi = len;
    *wh = width;

    return ret;
}

static int changeJpgLen(uint8_t *data, uint32_t tlen, int max)
{
    int ret = -1, ix = 0, staf = 0;
    uint8_t marker[2] = {0, 0};
    uint32_t imgLen[2] = {0, 0};
    uint8_t ch = 0;
    uint32_t len = 0;

    if (!data) return -2;
    if (!max) return -3;
    
    msync(data, max, MS_SYNC);
    
    for (ix=0; ix < max; ix++) {
        ch = data[ix];
    
        if (ch == 0xff) {
            marker[0] = ch;
            staf = 1;
        } 
        else if (staf == 1) {
            if (((ch >> 4) == 0xc) && ((ch & 0xf) != 4)) {
                marker[1] = ch;
                
                imgLen[1] = data[ix + 4];
                imgLen[0] = data[ix + 5];
                                
                len = (imgLen[1] << 8) + imgLen[0];   

                //printf("[changeImgLen] Length = %d -> %d\n", len, tlen);
                
                data[ix + 4] = tlen >> 8;
                data[ix + 5] = tlen & 0xff;;

                ret = 0;
                break;
            }
            staf = 0;
        }
        
    }

    return ret;
}

static int fs96(struct mainRes_s *mrs, struct modersp_s *modersp) 
{ 
    char *addr=0;
    uint32_t val=0;
    int ret=-1, totsz=0, len=0, secLen, max=0, mdo=0;
    int hi = 0, wh = 0, n = 0;
    struct sdFAT_s *pfat=0;
    struct supdataBack_s *rs = 0, *s=0, *sc=0, *sh=0, *se=0;
    struct sdbootsec_s   *psec=0;
    struct info16Bit_s *p=0, *c=0;
    struct aspConfig_s *pct=0;
    
    pct = mrs->configTable;
    pfat = &mrs->aspFat;
    sh = pfat->fatSupdata;
    sc = pfat->fatSupcur;
    psec = &pfat->fatBootsec;

    //rs = aspMemalloc(sizeof(struct supdataBack_s), 10);
    //memset(rs, 0, sizeof(struct supdataBack_s));
    //s = rs;
    
    sprintf_f(mrs->log, "deal with sup back head buff!! - 1\n");
    print_f(mrs->plog, "fs96", mrs->log);

    if (!sh) {
        sprintf_f(mrs->log, "ERROR!!! sup back head buff is empty! \n");
        print_f(mrs->plog, "fs96", mrs->log);
        modersp->r = 0xed;
        //aspMemFree(rs, 10);
        return 1;
    }

    if (!sc) {
        sprintf_f(mrs->log, "WARNING!!! sup back current buff is empty! \n");
        print_f(mrs->plog, "fs96", mrs->log);
        pfat->fatSupcur = sh;
        sc = sh;
    }

    p = &mrs->mchine.tmp;
       
    /* calculate the total size */
    secLen = p->opinfo;
    totsz = secLen * psec->secSize;

    sprintf_f(mrs->log, "deal with sup back head buff!! - 2\n");
    print_f(mrs->plog, "fs96", mrs->log);

    max = aspCalcSupLen(sc);
    if (totsz > max) {
        sprintf_f(mrs->log, "WARNING!!! totsz is larger than max rest size of sup buff, %d/%d \n", totsz, max);
        print_f(mrs->plog, "fs96", mrs->log);
        totsz = max;
    }

    sprintf_f(mrs->log, "totsz/max = %d/%d \n", totsz, max);
    print_f(mrs->plog, "fs96", mrs->log);

    sprintf_f(mrs->log, "deal with sup back head buff!! - 3\n");
    print_f(mrs->plog, "fs96", mrs->log);

#if 0 // move to fs98
    ret = cfgTableGetChk(pct, ASPOP_IMG_LEN, &val, ASPOP_STA_UPD);    
    if (ret) {
        val = 0;
    }

    sprintf_f(mrs->log, "deal with sup back head buff!! - 4\n");
    
    print_f(mrs->plog, "fs96", mrs->log);

    pct[ASPOP_IMG_LEN].opStatus = ASPOP_STA_APP;
#endif

    sprintf_f(mrs->log, "deal with sup back head buff!! - 5\n");
    print_f(mrs->plog, "fs96", mrs->log);

    mdo = 1;
    while (totsz >= 0) {
    
        //sprintf_f(mrs->log, "deal with sup back head buff!! - 6\n");
        //print_f(mrs->plog, "fs96", mrs->log);

        /* pup and push data here */
        len = ring_buf_get(&mrs->cmdTx, &addr);
        while (len <= 0) {
            sleep(2);
            len = ring_buf_get(&mrs->cmdTx, &addr);
        }

        //sprintf_f(mrs->log, "deal with sup back head buff!! - 7 len:%d \n", len);
        //print_f(mrs->plog, "fs96", mrs->log);

        if (totsz > len) {
            ret = aspPopSupOut(addr, sc, len, &s);
        } else {
            ret = aspPopSupOut(addr, sc, totsz, &s);
        }

        //sprintf_f(mrs->log, "list buff pop resutl, ret: %d/%d\n", ret, totsz);
        //print_f(mrs->plog, "fs96", mrs->log);

#if 0 // move to fs98
        if ((mdo) && (val)) {
            mdo = changeJpgLen(addr, val, ret);
        }

        n = findJpgScale(addr, &hi, &wh, ret);
        if (!n) {
            sprintf_f(mrs->log, "jpg scale = (%d, %d)\n", hi, wh);
            print_f(mrs->plog, "fs96", mrs->log);
        }
#endif
        
        ring_buf_prod(&mrs->cmdTx);
        
        mrs_ipc_put(mrs, "u", 1, 1);
        totsz -= ret;

        if (totsz <= 0) break;
        
        sc = s;
    }

    ring_buf_set_last(&mrs->cmdTx, ret);
    mrs_ipc_put(mrs, "u", 1, 1);
    
    mrs_ipc_put(mrs, "U", 1, 1);

    pfat->fatSupcur = sc;
    sprintf_f(mrs->log, "END buff pop, resutl %d/%d\n", ret, totsz);
    print_f(mrs->plog, "fs96", mrs->log);

    modersp->m = modersp->m + 1;

    aspMemFree(rs, 0);
    return 2; 
}

static int fs97(struct mainRes_s *mrs, struct modersp_s *modersp) 
{ 
    int len=0, bitset=0, ret=0;
    char ch=0;
    struct info16Bit_s *p;

    //sprintf_f(mrs->log, "wait spi0 tx end\n");
    //print_f(mrs->plog, "fs97", mrs->log);

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if (len > 0) {

        sprintf_f(mrs->log, "ch: %c - end\n", ch);
        print_f(mrs->plog, "fs97", mrs->log);
        if (ch == 'u') {
            modersp->v += 1;
        }
        
        if (ch == 'U') {

            ring_buf_init(&mrs->cmdTx);

#if SPI_KTHREAD_USE & SPI_UPD_NO_KTHREAD
            bitset = 0;
            ret = msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_STOP_THREAD
            sprintf_f(mrs->log, "Stop spi0 spidev thread, ret: 0x%x\n", ret);
            print_f(mrs->plog, "fs97", mrs->log);
#endif
#if PULL_LOW_AFTER_DATA
            bitset = 0;
            msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
            sprintf_f(mrs->log, "set RDY pin %d\n",bitset);
            print_f(mrs->plog, "fs97", mrs->log);
            usleep(210000);
#endif

            modersp->m = 48;            
            return 2;
        } else  {
            //modersp->r = 2;
            //modersp->c += 1;
            return 0;
        }
    }
    return 0; 
}

static int fs98(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    char *fnameSave = 0;
    char fnameSave_jpg[16] = "asp%.5d.jpg";
    char fnameSave_pdf[16] = "asp%.5d.pdf";
    char fnameSave_bmp[16] = "asp%.5d.bmp";
    char fnameSave_tif[16] = "asp%.5d.tif";
    char srhName[16];
    int ret=0, cnt=0, hi=0, wh=0, mh=0, mw=0, slen=0;
    uint32_t secStr=0, secLen=0, clstByte, clstLen=0, clstStr=0;
    uint32_t freeClst=0, usedClst=0, totClst=0, val=0, tmp=0;
    int datLen=0, imgLen=0;
    uint32_t fformat=0;
    struct sdbootsec_s   *psec=0;
    struct sdFAT_s *pfat=0;
    struct adFATLinkList_s *pflsh=0, *pflnt=0;
    struct adFATLinkList_s *pfre=0, *pnxf=0, *pclst=0;
    struct sdFATable_s   *pftb=0;
    struct directnFile_s *upld=0, *fscur=0, *fssrh=0;
    struct supdataBack_s *s=0, *sc=0, *sh=0, *se=0, *sb=0;
    struct aspConfig_s *pct=0;
    char *ph=0, len=0;
    struct bitmapHeader_s *bheader;
    int clr=0, w=0, h=0, dpi=0, t=0;
    
    uint32_t adata[3], atime[3];
    char *wday[]={"Sun","Mon","Tue","Wed","Thu","Fri","Sat"}; 
    struct tm *p=0;
    time_t timep;
    int pdfParam[9];
                
    pct = mrs->configTable;                
    pfat = &mrs->aspFat;
    psec = &pfat->fatBootsec;
    pftb = &pfat->fatTable;
    
    clstByte = psec->secSize * psec->secPrClst;
    if (!clstByte) {
        sprintf_f(mrs->log, "WARNING!! bytes number of cluster is zero \n");
        print_f(mrs->plog, "fs98", mrs->log);

        modersp->r = 2;
        return 1;
    }

    pfre = pftb->ftbMng.f;
    if (!pfre) {
        sprintf_f(mrs->log, "Error!! free space link list is empty \n");
        print_f(mrs->plog, "fs98", mrs->log);
        modersp->r = 2;
        return 1;
    }

    if (!pfat->fatCurDir.dfindex) {
        sprintf_f(mrs->log, "Error!! current folder is null \n");
        print_f(mrs->plog, "fs98", mrs->log);
        modersp->r = 2;
        return 1;
    }
    
    //fscur = &pfat->fatCurDir;
    aspFSms2rs(&fscur, &pfat->fatCurDir, &pfat->fatDirTr);
    if (!fscur) {
        sprintf_f(mrs->log, "Error!! get current folder failed, ret: %d \n", ret);
        print_f(mrs->plog, "fs98", mrs->log);
        modersp->r = 0xed;
        return 1;
    } else {
        sprintf_f(mrs->log, "get current folder [%s] \n", fscur->dfSFN);
        print_f(mrs->plog, "fs98", mrs->log);
    }

    sh = pfat->fatSupdata;
    if (!sh) {
        sprintf_f(mrs->log, "ERROR!!! buffered link list is NULL \n");
        print_f(mrs->plog, "fs98", mrs->log);
        modersp->r = 0xed;
        return 1;
    }

    sc = pfat->fatSupcur;
    if (sc) {
        sprintf_f(mrs->log, "WARNING!!! current buffered link list is NOT NULL \n");
        print_f(mrs->plog, "fs98", mrs->log);
    }

    pfat->fatSupcur = sh;
    sc = sh;

    ret = mspFS_allocDir(&pfat->fatDirTr, &upld, 9);
    if (ret) {
         sprintf_f(mrs->log, "Error!! get new file entry failed ret: %d \n", ret);
        print_f(mrs->plog, "fs98", mrs->log);
        modersp->r = 0xed;
        return 1;
    }

    ret = cfgTableGetChk(pct, ASPOP_FILE_FORMAT, &fformat, ASPOP_STA_CON);    
    sprintf_f(mrs->log, "user defined file format: 0x%.2x, ret:%d \n", fformat, ret);
    print_f(mrs->plog, "fs98", mrs->log);
    if (ret) {
        fformat = 0;
    }

    if (fformat == FILE_FORMAT_JPG) {
        fnameSave = fnameSave_jpg;
        sprintf_f(mrs->log, "file format : JPG(%d) name type:[%s]\n", fformat, fnameSave);
        print_f(mrs->plog, "fs98", mrs->log);

    } else if (fformat == FILE_FORMAT_PDF) {
        fnameSave = fnameSave_pdf;
        sprintf_f(mrs->log, "file format : PDF(%d) name type:[%s]\n", fformat, fnameSave);
        print_f(mrs->plog, "fs98", mrs->log);

    } else if (fformat == FILE_FORMAT_RAW) {
        fnameSave = fnameSave_bmp;
        sprintf_f(mrs->log, "file format : RAW(%d) name type:[%s]\n", fformat, fnameSave);
        print_f(mrs->plog, "fs98", mrs->log);

    } else if (fformat == FILE_FORMAT_TIFF_I) {
        fnameSave = fnameSave_tif;
        sprintf_f(mrs->log, "file format : TIFF_I(%d) name type:[%s]\n", fformat, fnameSave);
        print_f(mrs->plog, "fs98", mrs->log);

    } else if (fformat == FILE_FORMAT_TIFF_M) {
        fnameSave = fnameSave_tif;
        sprintf_f(mrs->log, "file format : TIFF_M(%d) name type:[%s]\n", fformat, fnameSave);
        print_f(mrs->plog, "fs98", mrs->log);

    } else {
        fnameSave = fnameSave_jpg;    
        sprintf_f(mrs->log, "file format : others(%d) name type:[%s]\n", fformat, fnameSave);
        print_f(mrs->plog, "fs98", mrs->log);

    }

    //memset(upld, 0, sizeof(struct directnFile_s));
    upld->dftype = ASPFS_TYPE_FILE;
    upld->dfstats = ASPFS_STATUS_DIS;
    //upld->dfstats = ASPFS_STATUS_EN;
    upld->dfattrib = ASPFS_ATTR_ARCHIVE;

    time(&timep);
    p=localtime(&timep); /*oa*/ 
    sprintf_f(mrs->log, "%.4d%.2d%.2d \n", (1900+p->tm_year),( 1+p-> tm_mon), p->tm_mday); 
    print_f(mrs->plog, "fs98", mrs->log);
    sprintf_f(mrs->log, "%s,%.2d:%.2d:%.2d\n", wday[p->tm_wday],p->tm_hour, p->tm_min, p->tm_sec); 
    print_f(mrs->plog, "fs98", mrs->log);

    adata[0] = p->tm_year+1900;
    adata[1] = p->tm_mon + 1;
    adata[2] = p->tm_mday;
    
    atime[0] = p->tm_hour;
    atime[1] = p->tm_min;
    atime[2] = p->tm_sec;
    
    upld->dfcredate = ((((adata[0] - 1980) & 0xff) << 16) | ((adata[1] & 0xff) << 8) | (adata[2] & 0xff));
    upld->dfcretime = (((atime[0]&0xff) << 16) | ((atime[1]&0xff) << 8) | (atime[2]&0xff));
    upld->dflstacdate = ((((adata[0] - 1980)&0xff) << 16) | ((adata[1]&0xff) << 8) | (adata[2]&0xff));
    upld->dfrecodate = ((((adata[0] - 1980)&0xff) << 16) | ((adata[1]&0xff) << 8) | (adata[2]&0xff));
    upld->dfrecotime = (((atime[0]&0xff) << 16) | ((atime[1]&0xff) << 8) | (atime[2]&0xff));

    /* assign a name with sequence number */
    for (cnt=0; cnt < 10000; cnt++) {
        sprintf(srhName, fnameSave, cnt);
        sprintf_f(mrs->log, "search name: [%s]\n", srhName);
        print_f(mrs->plog, "fs98", mrs->log);

        ret = mspFS_SearchInFolder(&fssrh, fscur, srhName);
        if (ret) break;
    }

    slen = strnlen(srhName, sizeof(srhName));
    strncpy(upld->dfSFN, srhName, slen);
    upld->dfSFN[12] = '\0';

    upld->dflen = 0;
    upld->dfLFN[0] = '\0';

    sprintf_f(mrs->log, "SFN[%s] LFS[%s] len:%d\n", upld->dfSFN, upld->dfLFN, upld->dflen);
    print_f(mrs->plog, "fs98", mrs->log);

    if (fformat == FILE_FORMAT_JPG) {
        s = sh;
        if (!s) {
            sprintf_f(mrs->log, "Error!!! the first trunk is not exist!!!\n\n");
            print_f(mrs->plog, "fs98", mrs->log);
            modersp->r = 0xed;
            return 1;
        }
        
        ret = cfgTableGetChk(pct, ASPOP_IMG_LEN, &val, ASPOP_STA_APP);    
        sprintf_f(mrs->log, "user defined jpg length: %d, ret:%d - 1\n", val, ret);
        print_f(mrs->plog, "fs98", mrs->log);

        if (ret) {
            //val = 0;
        }
        
        //pct[ASPOP_IMG_LEN].opStatus = ASPOP_STA_APP;
        
        if (val) {
            ret = changeJpgLen(s->supdataBuff, val, s->supdataTot);
            if (ret) {
                sprintf_f(mrs->log, "Error!!! can NOT find jpg length in first trunk !!!\n\n");
                print_f(mrs->plog, "fs98", mrs->log);
                //modersp->r = 0xed;
                //return 1;
            }
        }

        datLen = aspCalcSupLen(sc);
        if (datLen < 0) {
            sprintf_f(mrs->log, "Error!!! calculate support buffer length failed !!!\n\n");
            print_f(mrs->plog, "fs98", mrs->log);
            modersp->r = 0xed;
            return 1;
        }
    }
    else if (fformat == FILE_FORMAT_PDF) {
        s = sh->n;
        if (!s) {
            sprintf_f(mrs->log, "Error!!! the first trunk is not exist!!!\n\n");
            print_f(mrs->plog, "fs98", mrs->log);
            modersp->r = 0xed;
            return 1;
        }
        
        ret = cfgTableGetChk(pct, ASPOP_IMG_LEN, &val, ASPOP_STA_APP);    
        sprintf_f(mrs->log, "user defined jpg length: %d, ret:%d - 1\n", val, ret);
        print_f(mrs->plog, "fs98", mrs->log);

        if (ret) {
            //val = 0;
        }
       
        //pct[ASPOP_IMG_LEN].opStatus = ASPOP_STA_APP;
        
        if (val) {
            ret = changeJpgLen(s->supdataBuff, val, s->supdataTot);
            if (ret) {
                sprintf_f(mrs->log, "Error!!! can NOT find jpg length in first trunk !!!\n\n");
                print_f(mrs->plog, "fs98", mrs->log);

                //shmem_dump(sh->supdataBuff, 1024);
                //shmem_dump(s->supdataBuff, 1024);
                
                modersp->r = 0xed;
                return 1;
            }
        }
        
        ret = findJpgScale(s->supdataBuff, &hi, &wh, s->supdataTot);
        if (ret) {
            sprintf_f(mrs->log, "Error!!! can NOT find height and width in first trunk !!!\n\n");
            print_f(mrs->plog, "fs98", mrs->log);
            modersp->r = 0xed;
            return 1;
        } else {
            /* caluclate the pdf parameter by height and width */
            pdfParamCalcu(hi, wh, &mh, &mw);
        }
        
        /* pdf head */
        sb = sh;
        sprintf_f(mrs->log, "PDF Head get!!! tot: %d, use:%d \n", sb->supdataTot, sb->supdataUse);
        print_f(mrs->plog, "fs98", mrs->log);
        if (sb->supdataTot != sb->supdataUse) {
            //shmem_dump(sb->supdataBuff + sb->supdataUse, sb->supdataTot - sb->supdataUse);
            sprintf_f(mrs->log, "dump - end\n");
            print_f(mrs->plog, "fs98", mrs->log);
        }

        ret = cfgTableGetChk(pct, ASPOP_COLOR_MODE, &val, ASPOP_STA_APP);    
        sprintf_f(mrs->log, "user defined color mode: %d, ret:%d\n", val, ret);
        print_f(mrs->plog, "fs98", mrs->log);

        memset(pdfParam, 0, 9*4);
        
        pdfParam[0] = hi;
        pdfParam[1] = wh;
        pdfParam[2] = mh;
        pdfParam[3] = mw;
        pdfParam[4] = val;
        ret = pdfHead(sb->supdataBuff, SPI_TRUNK_SZ, 9, pdfParam);
        
        sb->supdataUse = 0;
        sb->supdataTot = ret;

        /*
        shmem_dump(sb->supdataBuff, sb->supdataTot);
        sprintf_f(mrs->log, "dump PDF head - end\n");
        print_f(mrs->plog, "fs98", mrs->log);
        */

        /* calculate sector start and sector length of file */            
        datLen = aspCalcSupLen(sc);
        if (datLen < 0) {
            sprintf_f(mrs->log, "Error!!! calculate support buffer length failed !!!\n\n");
            print_f(mrs->plog, "fs98", mrs->log);
            modersp->r = 0xed;
            return 1;
        }

        imgLen = aspCalcSupLen(sc->n); 
        if (imgLen < 0) {
            sprintf_f(mrs->log, "Error!!! calculate support buffer length failed !!!\n\n");
            print_f(mrs->plog, "fs98", mrs->log);
            modersp->r = 0xed;
            return 1;
        }
    
        /* pdf tail */
        se = sc;
        while (se->n) {
            se = se->n;
        }
        sprintf_f(mrs->log, "PDF Tail get!!! tot: %d, use:%d, datLen:%d, imgLen:%d \n", se->supdataTot, se->supdataUse, datLen, imgLen);
        print_f(mrs->plog, "fs98", mrs->log);
        
        if (se->supdataTot != 0) {
            //shmem_dump(se->supdataBuff, se->supdataTot);
            sprintf_f(mrs->log, "dump - end\n");
            print_f(mrs->plog, "fs98", mrs->log);
        }

        pdfParam[7] = datLen;
        pdfParam[8] = imgLen;
        ret = pdfTail(se->supdataBuff + se->supdataTot, SPI_TRUNK_SZ-se->supdataTot, 9, pdfParam);
        if (ret == -3) {
            s = 0;
            s = aspMemalloc(sizeof(struct supdataBack_s), 10);
            if (!s) {
                sprintf_f(mrs->log, "FAIL to allcate memory for the pdf tail !!! \n");
                print_f(mrs->plog, "fs98", mrs->log);
                modersp->r = 0xed;
                return 1;
            }

            memset(s, 0, sizeof(struct supdataBack_s));
            se->n = s;
            se = s;
            ret = pdfTail(se->supdataBuff, SPI_TRUNK_SZ,  9, pdfParam);
        }
        
        if (ret < 0) {
            sprintf_f(mrs->log, "Error!!! can NOT append pdf tail ret: %d !!!\n\n", ret);
            print_f(mrs->plog, "fs98", mrs->log);
            modersp->r = 0xed;
            return 1;
        }
/*        
        shmem_dump(se->supdataBuff+se->supdataTot, ret);
        sprintf_f(mrs->log, "dump PDF tail - end\n");
        print_f(mrs->plog, "fs98", mrs->log);
*/        
        se->supdataTot += ret;
        datLen += ret;
    }
    else if (fformat == FILE_FORMAT_RAW) {
        s = sh;
        if (!s) {
            sprintf_f(mrs->log, "Error!!! the first trunk is not exist!!!\n\n");
            print_f(mrs->plog, "fs98", mrs->log);
            modersp->r = 0xed;
            return 1;
        }

        ph = &mrs->bmpheader.aspbmpMagic[2];
        len = sizeof(struct bitmapHeader_s) - 2;
        memcpy(ph, s->supdataBuff, len);

        bheader = &mrs->bmpheader;
        
        clr=0;
        w=0;
        h=0;
        dpi=0;
        
        dbgBitmapHeader(bheader, len);

        /* bmp header needs 1.width 2.height 3.dpi 4.raw size */
        ret = cfgTableGetChk(pct, ASPOP_COLOR_MODE, &tmp, ASPOP_STA_APP);    
        sprintf_f(mrs->log, "user defined color mode: %d, ret:%d\n", tmp, ret);
        print_f(mrs->plog, "fs98", mrs->log);
        switch (tmp) {
            case COLOR_MODE_COLOR:
                clr = 24;
                break;
            case COLOR_MODE_GRAY:
            case COLOR_MODE_GRAY_DETAIL:
            case COLOR_MODE_BLACKWHITE:
                clr = 8;
                break;
            default:
                clr = 24;
                break;
        }

        ret = cfgTableGetChk(pct, ASPOP_IMG_LEN, &h, ASPOP_STA_APP);    
        sprintf_f(mrs->log, "user defined image length: %d, ret:%d\n", h, ret);
        print_f(mrs->plog, "fs98", mrs->log);
        if (ret) {
            //val = 0;
        }
        ret = cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_H, &val, ASPOP_STA_APP);    
        sprintf_f(mrs->log, "user defined width high: %d, ret:%d\n", val, ret);
        print_f(mrs->plog, "fs98", mrs->log);

        ret = cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_L, &tmp, ASPOP_STA_APP);    
        t = val << 8 | tmp;

        val = 0;
        ret = cfgTableGetChk(pct, ASPOP_SCAN_WIDTH, &val, ASPOP_STA_UPD);
        
        w = scanWidthConvert(t, val);
        sprintf_f(mrs->log, "user defined width low: %d, ret:%d, w = %d (tag:%d)\n", tmp, ret, w, t);
        print_f(mrs->plog, "fs98", mrs->log);

        tmp = 0;
        ret = cfgTableGetChkDPI(pct, ASPOP_RESOLUTION, &tmp, ASPOP_STA_APP);    
        sprintf_f(mrs->log, "user defined resulution: %d, ret:%d\n", tmp, ret);
        print_f(mrs->plog, "fs98", mrs->log);
        dpi = tmp;
        
        //pct[ASPOP_IMG_LEN].opStatus = ASPOP_STA_APP;

        /*
        shmem_dump(sb->supdataBuff, sb->supdataTot);
        sprintf_f(mrs->log, "dump PDF head - end\n");
        print_f(mrs->plog, "fs98", mrs->log);
        */
        sb = sh;
        if (clr == 8) {
            sb->supdataUse = 1078;
        } else if (clr == 24) {
            sb->supdataUse = 54;            
        } else {
            printf("[fs98] ERROR!!! color bits is %d \n", clr);
        }

        /* calculate sector start and sector length of file */            
        sc = sh;
        imgLen = aspCalcSupLen(sc);
        if (datLen < 0) {
            sprintf_f(mrs->log, "Error!!! calculate support buffer length failed !!!\n\n");
            print_f(mrs->plog, "fs98", mrs->log);
            modersp->r = 0xed;
            return 1;
        }

        datLen = imgLen + sc->supdataUse;

        sprintf_f(mrs->log, "bitmap info color: %d, w: %d, h: %d, dpi: %d, imglen: %d, use: %d\n", clr, w, h, dpi, imgLen, sc->supdataUse);
        print_f(mrs->plog, "fs98", mrs->log);
        
#if BMP_TEST /* for test */
        if (clr == 8) {
            bitmapHeaderSetup(bheader, 8, 5184, 6524, 300, imgLen);
        } else {
            //bitmapHeaderSetup(bheader, 24, 2304, 3456, 600, imgLen);
            bitmapHeaderSetup(bheader, 24, 2160, 3456, 600, imgLen);
        }
#else
        bitmapHeaderSetup(bheader, clr, w, h, dpi, imgLen);
#endif
        ph = &mrs->bmpheader.aspbmpMagic[2];
        len = sizeof(struct bitmapHeader_s) - 2;
        memcpy(sc->supdataBuff, ph, len);

        sc->supdataUse -= len;
        if (sc->supdataUse > 0) {
            bitmapColorTableSetup(sc->supdataBuff+len);
            sc->supdataUse -= 1024;
        }
        
        if (!sc->supdataUse) {
            printf("[fs98] Error!!! the bitmap header len is wrong %d \n", sc->supdataUse);
        } 
        
        sc->supdataUse = 0;
    }
    else if (fformat == FILE_FORMAT_TIFF_I) {
        s = sh->n;
        if (!s) {
            sprintf_f(mrs->log, "Error!!! TIFF_I the first trunk is not exist!!!\n\n");
            print_f(mrs->plog, "fs98", mrs->log);
            modersp->r = 0xed;
            return 1;
        }
         
        /* tiff head */
        sb = sh;
        sprintf_f(mrs->log, "TIFF_I Head get!!! tot: %d, use:%d \n", sb->supdataTot, sb->supdataUse);
        print_f(mrs->plog, "fs98", mrs->log);
        if (sb->supdataTot != sb->supdataUse) {
            //shmem_dump(sb->supdataBuff + sb->supdataUse, sb->supdataTot - sb->supdataUse);
            sprintf_f(mrs->log, "dump - end\n");
            print_f(mrs->plog, "fs98", mrs->log);
        }
        
        ret = tiffHead(sb->supdataBuff, SPI_TRUNK_SZ);
        
        sb->supdataUse = 0;
        sb->supdataTot = ret;

        
        //shmem_dump(sb->supdataBuff, sb->supdataTot);
        sprintf_f(mrs->log, "dump TIFF_I head - end\n");
        print_f(mrs->plog, "fs98", mrs->log);
        

        /* calculate sector start and sector length of file */            
        datLen = aspCalcSupLen(sc);
        if (datLen < 0) {
            sprintf_f(mrs->log, "Error!!! calculate support buffer length failed !!!\n\n");
            print_f(mrs->plog, "fs98", mrs->log);
            modersp->r = 0xed;
            return 1;
        }
    
        /* pdf tail */
        se = sc;
        while (se->n) {
            se = se->n;
        }
        sprintf_f(mrs->log, "TIFF_I Tail get!!! tot: %d, use:%d \n", se->supdataTot, se->supdataUse);
        print_f(mrs->plog, "fs98", mrs->log);
        
        if (se->supdataTot != 0) {
            //shmem_dump(se->supdataBuff, se->supdataTot);
            sprintf_f(mrs->log, "dump - end\n");
            print_f(mrs->plog, "fs98", mrs->log);
        }
        
        
        ret = tiffTail(se->supdataBuff + se->supdataTot, SPI_TRUNK_SZ-se->supdataTot);
        if (ret == -3) {
            s = 0;
            s = aspMemalloc(sizeof(struct supdataBack_s), 10);
            if (!s) {
                sprintf_f(mrs->log, "FAIL to allcate memory for the TIFF_I tail !!! \n");
                print_f(mrs->plog, "fs98", mrs->log);
                modersp->r = 0xed;
                return 1;
            }

            memset(s, 0, sizeof(struct supdataBack_s));
            se->n = s;
            se = s;
            ret = tiffTail(se->supdataBuff, SPI_TRUNK_SZ);
        }
        
        if (ret < 0) {
            sprintf_f(mrs->log, "Error!!! can NOT append TIFF_I tail ret: %d !!!\n\n", ret);
            print_f(mrs->plog, "fs98", mrs->log);
            modersp->r = 0xed;
            return 1;
        }

        
        //shmem_dump(se->supdataBuff+se->supdataTot, ret);
        sprintf_f(mrs->log, "dump TIFF_I tail - end\n");
        print_f(mrs->plog, "fs98", mrs->log);
        
        se->supdataTot += ret;
        datLen += ret;
    }
    else {
        /* calculate sector start and sector length of file */            
        datLen = aspCalcSupLen(sc);
        if (datLen < 0) {
            sprintf_f(mrs->log, "Error!!! calculate support buffer length failed !!!\n\n");
            print_f(mrs->plog, "fs98", mrs->log);
            modersp->r = 0xed;
            return 1;
        }
    }

    if (datLen % clstByte) {
        clstLen = (datLen / clstByte) + 1;
    } else {
        clstLen = (datLen / clstByte);        
    }

    sprintf_f(mrs->log, "Calculate sup back data len: %d\n", datLen);
    print_f(mrs->plog, "fs98", mrs->log);
    
    if (clstLen) {
        ret = mspSD_allocFreeFATList(&pflsh, clstLen, pfre, &pnxf);
        if (ret) {
            sprintf_f(mrs->log, "free FAT table parsing for file upload FAIL!!ret:%d (%s)\n", ret, upld->dfSFN);
            print_f(mrs->plog, "fs98", mrs->log);
            modersp->r = 0xed;
            return 1;
        } 
        else {
            freeClst = 0;
            if ((pfre != pnxf) && (pnxf)) {
                totClst = (psec->secTotal - psec->secWhroot) / psec->secPrClst;

                while (pfre != pnxf) {
                    pclst = pfre;

                    pfre = pfre->n;

                    sprintf_f(mrs->log, "free used FREE FAT linklist, 0x%.8x start: %d, length: %d \n", (uint32_t)pclst, pclst->ftStart, pclst->ftLen);
                    print_f(mrs->plog, "fs98", mrs->log);

                    aspMemFree(pclst, 0);
                    pclst = 0;
                }
            }

            pflnt = pnxf;
            while (pflnt) {
                freeClst += pflnt->ftLen;
                sprintf_f(mrs->log, "cal start: %d len:%d \n", pflnt->ftStart, pflnt->ftLen);
                print_f(mrs->plog, "fs98", mrs->log);
                pflnt = pflnt->n;
            }

            sprintf_f(mrs->log, "re-calculate total free cluster: %d free sector: %d (size: %d) \n", freeClst, freeClst * psec->secPrClst, freeClst * psec->secPrClst * psec->secSize);
            print_f(mrs->plog, "fs98", mrs->log);     
            usedClst = totClst - freeClst;

            pftb->ftbMng.ftfreeClst = freeClst;
            pftb->ftbMng.ftusedClst = usedClst;
            pftb->ftbMng.f = pnxf;
        }

        /* debug */
        sprintf_f(mrs->log, "show allocated FAT list: \n");
        print_f(mrs->plog, "fs98", mrs->log);

        val = 0;
        pflnt = pflsh;
        while (pflnt) {
            val += pflnt->ftLen;
            sprintf_f(mrs->log, "    str:%d len:%d - %d\n", pflnt->ftStart, pflnt->ftLen, val);
            print_f(mrs->plog, "fs98", mrs->log);
            pflnt = pflnt->n;
        }
        sprintf_f(mrs->log, "total allocated cluster is %d!! \n", val);
        print_f(mrs->plog, "fs98", mrs->log);
    
        pftb->h = pflsh;
        pftb->c = pftb->h;

        pfat->fatStatus |= ASPFAT_STATUS_SDWBK;
        pfat->fatStatus |= ASPFAT_STATUS_FATWT;
    }else {
        pftb->h = 0;
        pftb->c = 0;
    }

    upld->dfclstnum = pflsh->ftStart; /* start cluster */
    upld->dflength = datLen;

    aspFS_insertFATChild(fscur, upld);
    
    //pfat->fatFileUpld = upld;
    aspFScpDir(&pfat->fatFileUpld, upld);

    debugPrintDir(upld);
    mspFS_folderList(upld->pa, 4);

    pfat->fatStatus |= ASPFAT_STATUS_DFECHK;
    pfat->fatStatus |= ASPFAT_STATUS_DFEWT;

    modersp->r = 1;
    return 1;
}

static int fs99(struct mainRes_s *mrs, struct modersp_s *modersp) 
{ 
    int bitset, ret;
    struct sdFAT_s *pfat=0;
    pfat = &mrs->aspFat;
    //pfat->fatSupcur = pfat->fatSupdata;

    sprintf_f(mrs->log, "trigger spi0\n");
    print_f(mrs->plog, "fs99", mrs->log);

#if SPI_KTHREAD_USE
    bitset = 0;
    ret = msp_spi_conf(mrs->sfm[0], _IOR(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_START_THREAD
    sprintf_f(mrs->log, "Start spi0 spidev thread, ret: 0x%x\n", ret);
    print_f(mrs->plog, "fs99", mrs->log);
#endif

    ring_buf_init(&mrs->cmdRx);

    mrs_ipc_put(mrs, "x", 1, 1);

    modersp->v = 0;
    modersp->m = modersp->m + 1;
    return 2;
}

static int fs100(struct mainRes_s *mrs, struct modersp_s *modersp) 
{ 
    int ret, bitset, len;
    char ch, *addr=0, *dst=0;
    struct sdFAT_s *pfat=0;
    struct supdataBack_s *s=0, *sc=0;

    pfat = &mrs->aspFat;
    sc = pfat->fatSupcur;
    //sprintf_f(mrs->log, "%d\n", modersp->v);
    //print_f(mrs->plog, "fs100", mrs->log);

    ret = mrs_ipc_get(mrs, &ch, 1, 1);
    while (ret > 0) {
        if (ch == 'x') {
            if (sc) {
                len = ring_buf_cons(&mrs->cmdRx, &addr);
                sprintf_f(mrs->log, "1. get psudo len:%d\n", len);
                print_f(mrs->plog, "fs100", mrs->log);

                if (len >= 0) {
                    dst = sc->supdataBuff;
                    memcpy(dst, addr, len);
                    sc->supdataTot = len;

                    s = aspMemalloc(sizeof(struct supdataBack_s), 10);
                    memset(s, 0, sizeof(struct supdataBack_s));
                    sc->n = s;
                    sc = sc->n;

                    pfat->fatSupcur = sc;
                }
            } else {
                len = ring_buf_cons(&mrs->cmdRx, &addr);
                sprintf_f(mrs->log, "1. cons len:%d\n", len);
                print_f(mrs->plog, "fs100", mrs->log);
            }
            
        }
    
        if (ch == 'X') {
            sprintf_f(mrs->log, "get %c \n", ch);
            print_f(mrs->plog, "fs100", mrs->log);

            modersp->v |= 0x1;
        }
        ret = mrs_ipc_get(mrs, &ch, 1, 1);
    }

    if (modersp->v & 0x1) {
        if (sc) {
            len = ring_buf_cons(&mrs->cmdRx, &addr);
            while (len >= 0) {
                sprintf_f(mrs->log, "2. get psudo len:%d END\n", len);
                print_f(mrs->plog, "fs100", mrs->log);

                dst = sc->supdataBuff;
                memcpy(dst, addr, len);
                sc->supdataTot = len;
                
                s = aspMemalloc(sizeof(struct supdataBack_s), 10);
                memset(s, 0, sizeof(struct supdataBack_s));
                sc->n = s;
                sc = sc->n;

                pfat->fatSupcur = sc;
                modersp->v += 1;  
                len = ring_buf_cons(&mrs->cmdRx, &addr);
            }

            s = pfat->fatSupdata;
            while (s) {
                if (s->supdataTot == 0) {
                    break;
                }
                sc = s;
                s = s->n;
            }

            if (sc) {
                sc->n = 0;
            }

            while (s) {
                sc = s;
                s = s->n;

                memset(sc, 0, sizeof(struct supdataBack_s));
                aspMemFree(sc, 0);
            }
            pfat->fatSupcur = 0;
        }
        sprintf_f(mrs->log, "SD only end\n");
        print_f(mrs->plog, "fs100", mrs->log);

        ring_buf_init(&mrs->cmdRx);

#if SPI_KTHREAD_USE
        bitset = 0;
        ret = msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_STOP_THREAD
        sprintf_f(mrs->log, "Stop spi0 spidev thread, ret: 0x%x\n", ret);
        print_f(mrs->plog, "fs100", mrs->log);
#endif
#if PULL_LOW_AFTER_DATA
        bitset = 0;
        msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
        sprintf_f(mrs->log, "set RDY pin %d\n",bitset);
        print_f(mrs->plog, "fs100", mrs->log);
        usleep(210000);
#endif

        modersp->r = 1;            
        return 1;
    }

    return 0; 
}

static int fs101(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct info16Bit_s *p;
    p = &mrs->mchine.cur;
    //sprintf_f(mrs->log, "set %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
    //print_f(mrs->plog, "fs101", mrs->log);

    //printf("[fs101] \n");
    
    mrs_ipc_put(mrs, "c", 1, 1);
    modersp->m = modersp->m + 1;
    return 0; 
}

static int fs102(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    int len=0;
    char ch=0;
    struct info16Bit_s *p;

    p = &mrs->mchine.get;

    //printf("[fs102] \n");
    
    //sprintf_f(mrs->log, "get %d 0x%.1x 0x%.1x 0x%.2x - 1\n", p->inout, p->seqnum, p->opcode, p->data);
    //print_f(mrs->plog, "fs102", mrs->log);

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((len > 0) && (ch == 'C')) {
        msync(&mrs->mchine, sizeof(struct machineCtrl_s), MS_SYNC);

        //sprintf_f(mrs->log, "get %d 0x%.1x 0x%.1x 0x%.2x - 2\n", p->inout, p->seqnum, p->opcode, p->data);
        //print_f(mrs->plog, "fs102", mrs->log);

        if (p->opcode == OP_QRY) {
            modersp->m = modersp->m + 1;
        } else {
            modersp->r = 2;
            return 1;
        }
    }
    return 0; 
}

static int fs103(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct info16Bit_s *p;
    p = &mrs->mchine.cur;

    //printf("[fs103] \n");
    
    //sprintf_f(mrs->log, "set %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
    //print_f(mrs->plog, "fs103", mrs->log);
    
    mrs_ipc_put(mrs, "c", 1, 1);
    modersp->m = modersp->m + 1;
    return 0; 
}

static int fs104(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int len=0;
    char ch=0;
    struct info16Bit_s *p, *c;
    c = &mrs->mchine.cur;
    p = &mrs->mchine.get;

    //printf("[fs104] \n");

    //sprintf_f(mrs->log, "get 0x%.2x/0x%.2x 0x%.2x/0x%.2x - 1\n", p->opcode, c->opcode, p->data, c->data);
    //print_f(mrs->plog, "fs104", mrs->log);
        
    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((len > 0) && (ch == 'C')) {
        msync(&mrs->mchine, sizeof(struct machineCtrl_s), MS_SYNC);

        c = &mrs->mchine.cur;
        p = &mrs->mchine.get;
        //sprintf_f(mrs->log, "get 0x%.2x/0x%.2x 0x%.2x/0x%.2x - 2\n", p->opcode, c->opcode, p->data, c->data);
        //print_f(mrs->plog, "fs104", mrs->log);

        if (p->opcode == c->opcode) {
            if (p->data == c->data) {
                modersp->r = 1;
            } else {
                modersp->r = 2;
            }
            return 1;
        } else {
            modersp->r = 2;
            return 1;
        }
    }
    return 0; 
}

#define CROP_SCALE 10

#define CROP_COOD_01 {20  * CROP_SCALE, 80  * CROP_SCALE}
#define CROP_COOD_02 {75  * CROP_SCALE, 135 * CROP_SCALE}
#define CROP_COOD_03 {85  * CROP_SCALE, 135 * CROP_SCALE}
#define CROP_COOD_04 {140 * CROP_SCALE, 80  * CROP_SCALE}
#define CROP_COOD_05 {85   * CROP_SCALE, 25  * CROP_SCALE}
#define CROP_COOD_06 {75   * CROP_SCALE, 25  * CROP_SCALE}

static int getVector_x(CFLOAT *vec, CFLOAT *p1, CFLOAT *p2)
{
    CFLOAT a1, b, a2;
    CFLOAT x1, y1, x2, y2;

    if (!vec) return -1;
    if (!p1) return -2;
    if (!p2) return -3;

    x1 = p1[0];
    y1 = p1[1];

    x2 = p2[0];
    y2 = p2[1];

    printf("getVector_x() input - p1 = (%lf, %lf), p2 = (%lf, %lf)\n", x1, y1, x2, y2);
    
    b = ((x2 * y1) - (x1 * y2)) / (x2 - x1);

    a1 = ((x1 * y2) - (x1 * y1)) / ((x1 * x2) - (x1 * x1));
    a2 = ((x2 * y2) - (x2 * y1)) / ((x2 * x2) - (x2 * x1));

    printf("getVector_x() output - a = %lf/%lf, b = %lf\n", a1, a2, b);

    vec[0] = a1;
    vec[1] = b;

    return 0;
}

static int getCross_x(CFLOAT *v1, CFLOAT *v2, CFLOAT *pt)
{
    CFLOAT a1, a2, b1, b2;
    CFLOAT x, y;

    if (!v1) return -1;
    if (!v2) return -2;
    if (!pt) return -3;

    a1 = v1[0];
    b1 = v1[1];

    a2 = v2[0];
    b2 = v2[1];

    y = ((a1 * b2) - (a2 * b1)) / (a1 - a2);
    x = (b2 - b1) / (a1 - a2);

    printf("getCross_x() output - pt = (%lf, %lf)\n", x, y);

    pt[0] = x;
    pt[1] = y;
    
    return 0;
}

static int calcuDistance_x(CFLOAT *dist, CFLOAT *p1, CFLOAT *p2) 
{
    CFLOAT x1, y1, x2, y2;
    CFLOAT dx, dy, ds;

    if (!dist) return -1;
    if (!p1) return -2;
    if (!p2) return -3;

    x1 = p1[0];
    y1 = p1[1];

    x2 = p2[0];
    y2 = p2[1];

    dx = x1 - x2;
    dy = y1 - y2;

    ds = dx * dx + dy * dy;
    
    printf("calcuDistance_x() output - ds = %lf \n", ds);    

    *dist = ds;
    return 0;
}

static int fs105(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int ret=0, id=0, id1=0, id2=0;
    CFLOAT c01[2] = CROP_COOD_01;
    CFLOAT c02[2] = CROP_COOD_02;
    CFLOAT c03[2] = CROP_COOD_03;
    CFLOAT c04[2] = CROP_COOD_04;
    CFLOAT c05[2] = CROP_COOD_05;
    CFLOAT c06[2] = CROP_COOD_06;

    CFLOAT vect01[2] = {0, 0};
    CFLOAT vect02[2] = {0, 0};
    CFLOAT vect03[2] = {0, 0};
    CFLOAT vect04[2] = {0, 0};
    CFLOAT vect05[2] = {0, 0};
    CFLOAT vect06[2] = {0, 0};

    CFLOAT cross[6][2];
    
    CFLOAT cros01[2] = {0, 0};
    CFLOAT cros02[2] = {0, 0};
    CFLOAT cros03[2] = {0, 0};
    CFLOAT cros04[2] = {0, 0};
    CFLOAT cros05[2] = {0, 0};
    CFLOAT cros06[2] = {0, 0};

    CFLOAT ds, dt1, dt2, dmin[6][2];
    int idm[6][2];
    
    sprintf_f(mrs->log, "calculate ...\n");
    print_f(mrs->plog, "fs105", mrs->log);

    ret = getVector_x(vect01, c01, c02);
    ret = getVector_x(vect02, c02, c03);
    ret = getVector_x(vect03, c03, c04);
    ret = getVector_x(vect04, c04, c05);
    ret = getVector_x(vect05, c05, c06);
    ret = getVector_x(vect06, c06, c01);

    ret = getCross_x(vect01, vect03, cross[0]);
    ret = getCross_x(vect02, vect04, cross[1]);
    ret = getCross_x(vect03, vect05, cross[2]);
    ret = getCross_x(vect04, vect06, cross[3]);
    ret = getCross_x(vect05, vect01, cross[4]);
    ret = getCross_x(vect06, vect02, cross[5]);

    for (id = 0; id < 6; id++) {
        id1 = -1;
        id2 = -1;
        ret = calcuDistance_x(&ds, cross[id], c01);
        id1 = 1;
        dt1 = ds;
        ret = calcuDistance_x(&ds, cross[id], c02);
        id2 = 2;
        dt2 = ds;
        ret = calcuDistance_x(&ds, cross[id], c03);
        if ((dt1 > ds) || (dt2 > ds)) {
            if (dt1 > dt2) {
                dt1 = ds;     
                id1 = 3;
            } else {
                dt2 = ds;
                id2 = 3;
            }
        }
        ret = calcuDistance_x(&ds, cross[id], c04);
        if ((dt1 > ds) || (dt2 > ds)) {
            if (dt1 > dt2) {
                dt1 = ds;     
                id1 = 4;
            } else {
                dt2 = ds;
                id2 = 4;
            }
        }
        ret = calcuDistance_x(&ds, cross[id], c05);
        if ((dt1 > ds) || (dt2 > ds)) {
            if (dt1 > dt2) {
                dt1 = ds;     
                id1 = 5;
            } else {
                dt2 = ds;
                id2 = 5;
            }
        }
        ret = calcuDistance_x(&ds, cross[id], c06);
        if ((dt1 > ds) || (dt2 > ds)) {
            if (dt1 > dt2) {
                dt1 = ds;     
                id1 = 6;
            } else {
                dt2 = ds;
                id2 = 6;
            }
        }
        dmin[id][0] = dt1;
        dmin[id][1] = dt2;
        idm[id][0] = id1;
        idm[id][1] = id2;
    }

    dt1 = -1;
    dt2 = -1;
    
    for (id = 0; id < 6; id++) {
        if ((dt1 < 0) || (dt2 < 0)) {
            if (dt1 < 0) {
                dt1 = dmin[id][0] + dmin[id][1];
                id1 = id;
            } else {
                dt2 = dmin[id][0] + dmin[id][1];
                id2 = id;
            }
        } else {
            ds = dmin[id][0] + dmin[id][1];
            if ((dt1 > ds) || (dt2 > ds)) {
                if (dt1 > dt2) {
                    dt1 = ds;
                    id1 = id;
                } else {
                    dt2 = ds;
                    id2 = id;
                }
            }
        }
        printf("pt: (%lf, %lf) dmin: (%lf)(%lf)/(%d)(%d)\n", cross[id][0], cross[id][1], dmin[id][0], dmin[id][1], idm[id][0], idm[id][1]);
    }

    printf("replace (%d, %d) with %d, and (%d, %d) with %d, distance: (%lf, %lf)(%lf, %lf)\n", idm[id1][0], idm[id1][1], id1, idm[id2][0], idm[id2][1], id2, dmin[id1][0], dmin[id1][1], dmin[id2][0], dmin[id2][1]);
    
    modersp->r = 1; 
    return 1;
}

static int fs106(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int ret;
    char syscmd[256] = "ls -al";
    
    sprintf_f(mrs->log, "clear status ...\n");
    print_f(mrs->plog, "fs106", mrs->log);

// launchAP or directAccess
    /* clear status */
    #if 0 /* not to kill directAccess mode */
    sprintf(syscmd, "kill -9 $(ps aux | grep 'uap0' | awk '{print $1}')");
    ret = doSystemCmd(syscmd);

    sprintf_f(mrs->log, "exec [%s]...\n", syscmd);
    print_f(mrs->plog, "fs106", mrs->log);

    //sprintf(syscmd, "kill -9 $(ps aux | grep 'mothership' | awk '{print $1}')");
    //ret = doSystemCmd(syscmd);

    sprintf(syscmd, "kill -9 $(ps aux | grep 'hostapd' | awk '{print $1}')");
    ret = doSystemCmd(syscmd);

    sprintf_f(mrs->log, "exec [%s]...\n", syscmd);
    print_f(mrs->plog, "fs106", mrs->log);

    sprintf(syscmd, "ifconfig uap0 down");
    ret = doSystemCmd(syscmd);

    sprintf_f(mrs->log, "exec [%s]...\n", syscmd);
    print_f(mrs->plog, "fs106", mrs->log);

    sprintf(syscmd, "kill -9 $(ps aux | grep '%s' | awk '{print $1}')", mrs->netIntfs);
    ret = doSystemCmd(syscmd);

    sprintf_f(mrs->log, "exec [%s]...\n", syscmd);
    print_f(mrs->plog, "fs106", mrs->log);

    sprintf(syscmd, "ifconfig %s down", mrs->netIntfs);
    ret = doSystemCmd(syscmd);

    sprintf_f(mrs->log, "exec [%s]...\n", syscmd);
    print_f(mrs->plog, "fs106", mrs->log);
    
    sprintf(syscmd, "kill -9 $(ps aux | grep '%s' | awk '{print $1}')", mrs->netIntwpa);
    ret = doSystemCmd(syscmd);

    sprintf_f(mrs->log, "exec [%s]...\n", syscmd);
    print_f(mrs->plog, "fs106", mrs->log);
    #endif

    sprintf(syscmd, "kill -9 $(ps aux | grep 'wpa_supplicant' | awk '{print $1}')");
    ret = doSystemCmd(syscmd);

    sprintf_f(mrs->log, "exec [%s]...\n", syscmd);
    print_f(mrs->plog, "fs106", mrs->log);

    sprintf(syscmd, "ifconfig %s down", mrs->netIntwpa);
    ret = doSystemCmd(syscmd);

    sprintf_f(mrs->log, "exec [%s]...\n", syscmd);
    print_f(mrs->plog, "fs106", mrs->log);

    #if 0
    memset(mrs->netIntfs, 0, 16);
    sprintf(mrs->netIntfs, "%s", WIRELESS_INT);
    msync(mrs->netIntfs, 16, MS_SYNC);
    
    memset(mrs->netIntwpa, 0, 16);
    sprintf(mrs->netIntwpa, "%s", WIRELESS_INT_WPA);
    msync(mrs->netIntwpa, 16, MS_SYNC);
    #endif

    modersp->r = 1; 
    return 1;
}

static int fs107(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int ret;
    char syscmd[256] = "ls -al";
    
    FILE *faptpe=0;
    char aptypestr[32] = WIRELESS_INT;
    int itypelen=0;
    
    faptpe = fopen("/root/config/aptype", "r");
    if (faptpe) {
        itypelen = fread(aptypestr, 1, 32, faptpe);
        if ((itypelen > 0) && (itypelen < 32)) {
            aptypestr[itypelen] = '\0';
            if (aptypestr[itypelen-1] == '\n') {
                aptypestr[itypelen-1] = '\0';
            }
            if (aptypestr[itypelen-1] == '\r') {
                aptypestr[itypelen-1] = '\0';
            }
            sprintf(mrs->netIntfs, "%s", aptypestr);
        } else {
            memset(mrs->netIntfs, 0, 16);
            sprintf(mrs->netIntfs, WIRELESS_INT);
        }

        fclose(faptpe);
    } else {
        memset(mrs->netIntfs, 0, 16);
        sprintf(mrs->netIntfs, WIRELESS_INT);
    }
    
    sprintf_f(mrs->log, "launch Direct mode ...\n");
    print_f(mrs->plog, "fs107", mrs->log);

    sprintf(syscmd, "/root/script/launchAP_now.sh");
    ret = doSystemCmd(syscmd);

    sprintf_f(mrs->log, "exec [%s]...\n", syscmd);
    print_f(mrs->plog, "fs107", mrs->log);
    
    msync(mrs->netIntfs, 16, MS_SYNC);
    sprintf_f(mrs->log, "AP interface = [%s] \n", mrs->netIntfs);
    print_f(mrs->plog, "fs107", mrs->log);
    
    modersp->r = 1; 
    return 1;
}

static int fs108(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int ret;
    char syscmd[256] = "ls -al";
    struct apWifiConfig_s *pwfc=0;
    FILE *faptpe=0;
    char aptypestr[32] = WIRELESS_INT;
    int itypelen=0;

    memset(aptypestr, 0, 32);

    pwfc = &mrs->wifconf;
    if ((pwfc->wfpskLen > 0) && (pwfc->wfsidLen > 0)) {
        sprintf_f(mrs->log, "launch AP mode ... ssid: \"%s\", psk: \"%s\"\n", pwfc ->wfssid, pwfc->wfpsk);
        print_f(mrs->plog, "fs108", mrs->log);
    } else {
        sprintf_f(mrs->log, "failed to launch AP mode, no ssid and psk ...\n");
        print_f(mrs->plog, "fs108", mrs->log);
        modersp->r = 2; 
        return 1;
    }

    memset(mrs->netIntwpa, 0, 16);
    faptpe = fopen("/root/config/wpatype", "r");
    if (faptpe) {
        itypelen = fread(aptypestr, 1, 32, faptpe);
        if ((itypelen > 0) && (itypelen < 32)) {
            aptypestr[itypelen] = '\0';
            if (aptypestr[itypelen-1] == '\n') {
                aptypestr[itypelen-1] = '\0';
            }
            if (aptypestr[itypelen-1] == '\r') {
                aptypestr[itypelen-1] = '\0';
            }
            sprintf(mrs->netIntwpa, "%s", aptypestr);
        } else {
            memset(mrs->netIntwpa, 0, 16);
            sprintf(mrs->netIntwpa, WIRELESS_INT_WPA);
        }

        fclose(faptpe);
    } else {
        memset(mrs->netIntwpa, 0, 16);
        sprintf(mrs->netIntwpa, WIRELESS_INT_WPA);
    }
    /* launch wpa connect */
    //sprintf(syscmd, "/root/script/iw_con.sh");
    sprintf(syscmd, "/root/script/wpa_conf.sh \\\"%s\\\" \\\"%s\\\" /etc/wpa_supplicant.conf ", pwfc ->wfssid, pwfc->wfpsk);
    ret = doSystemCmd(syscmd);

    //sprintf(syscmd, "cp /root/script/interfaces_8723bu_wpa /etc/network/interfaces");
    //ret = doSystemCmd(syscmd);

    sprintf(syscmd, "wpa_supplicant -B -c /etc/wpa_supplicant.conf -i%s -Dnl80211 -dd", mrs->netIntwpa);
    ret = doSystemCmd(syscmd);

    sleep(1);

    sprintf(syscmd, "udhcpc -i %s -t 5 -n", mrs->netIntwpa);
    ret = doSystemCmd(syscmd);

    //sprintf(syscmd, "ping 192.168.1.255 -w 3");
    //ret = doSystemCmd(syscmd);

    sprintf(syscmd, "ifconfig");
    ret = doSystemCmd(syscmd);

    sprintf_f(mrs->log, "exec [%s]...\n", syscmd);
    print_f(mrs->plog, "fs108", mrs->log);

    sprintf_f(mrs->log, "wpa interface: [%s]\n", mrs->netIntwpa);
    print_f(mrs->plog, "fs108", mrs->log);

    sync();
    
    modersp->r = 1; 
    return 1;
}

static int fs109rs(struct procRes_s *rs)
{
    int ret=0, len=0;
    char paramFilePath[128] = "/root/scaner/scannerParam.bin";
    FILE *f;
    struct aspConfig_s *pct=0;

    sprintf_f(rs->logs, "update scanner pamameters !!!\n");
    print_f(rs->plogs, "fs109rs", rs->logs);
                        
    pct = rs->pcfgTable;
    len = ASPOP_CODE_MAX*sizeof(struct aspConfig_s);

    msync(pct, len, MS_SYNC);

    sprintf_f(rs->logs, "ASPOP_AP_MODE opc: 0x%x, status: 0x%x, value: %d\n", pct[ASPOP_AP_MODE].opCode, pct[ASPOP_AP_MODE].opStatus, pct[ASPOP_AP_MODE].opValue);
    print_f(rs->plogs, "fs109rs", rs->logs);
    
    f = fopen(paramFilePath, "w");
    if (f) {
        fwrite(pct, 1, len, f);
        fflush(f);
        fclose(f);
        sprintf_f(rs->logs, "Scanner parameter table save to [%s] size:%d\n", paramFilePath, len);
        print_f(rs->plogs, "fs109rs", rs->logs);
    } else {
        sprintf_f(rs->logs, "Scanner parameter table save to [%s] failed !!!\n", paramFilePath);
        print_f(rs->plogs, "fs109rs", rs->logs);
    }

    sync();
    
    return 1;
}

static int fs109(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int ret=0, len=0;
    char paramFilePath[128] = "/root/scaner/scannerParam.bin";
    FILE *f;
    struct aspConfig_s *pct=0;

    sprintf_f(mrs->log, "update scanner pamameters !!!\n");
    print_f(mrs->plog, "fs109", mrs->log);

    pct = mrs->configTable;
    len = ASPOP_CODE_MAX*sizeof(struct aspConfig_s);

    msync(pct, len, MS_SYNC);

    sprintf_f(mrs->log, "ASPOP_AP_MODE opc: 0x%x, status: 0x%x, value: %d\n", pct[ASPOP_AP_MODE].opCode, pct[ASPOP_AP_MODE].opStatus, pct[ASPOP_AP_MODE].opValue);
    print_f(mrs->plog, "fs109", mrs->log);
    
    f = fopen(paramFilePath, "w");
    if (f) {
        fwrite(pct, 1, len, f);
        fflush(f);
        fclose(f);
        sprintf_f(mrs->log, "Scanner parameter table save to [%s] size:%d\n", paramFilePath, len);
        print_f(mrs->plog, "fs109", mrs->log);
    } else {
        sprintf_f(mrs->log, "Scanner parameter table save to [%s] failed !!!\n", paramFilePath);
        print_f(mrs->plog, "fs109", mrs->log);
    }

    sync();
    
    modersp->r = 1; 
    return 1;
}

static int fs110(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    sprintf_f(mrs->log, "trigger spi0 \n");
    print_f(mrs->plog, "fs110", mrs->log);

    mrs_ipc_put(mrs, "y", 1, 1);
    //clock_gettime(CLOCK_REALTIME, &mrs->time[0]);

    modersp->m = modersp->m + 1;
    return 2;
}

static int fs111(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int ret, bitset;
    char ch;

    //sprintf_f(mrs->log, "%d\n", modersp->v++);
    //print_f(mrs->plog, "fs111", mrs->log);

    //sleep(5);

    ret = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((ret > 0) && (ch == 'Y')){

        sprintf_f(mrs->log, "spi 0 end, metaout get!\n");
        print_f(mrs->plog, "fs111", mrs->log);
        
        modersp->m = 48;

#if PULL_LOW_AFTER_DATA
        bitset = 0;
        msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
        sprintf_f(mrs->log, "set RDY pin %d\n",bitset);
        print_f(mrs->plog, "fs111", mrs->log);
        usleep(210000);
#endif

        return 2;
    }

    return 0; 
}

static int fs112(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    sprintf_f(mrs->log, "send notice to P6 for meta mass ready\n");
    print_f(mrs->plog, "fs112", mrs->log);

    //modersp->r = 1;
    //return 1;
    
    mrs_ipc_put(mrs, "c", 1, 7);
    //modersp->m = modersp->m + 1;
    modersp->d = modersp->m + 1;
    modersp->m = 69;
    return 2;
}

static int fs113(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int len=0;
    char ch=0;
    struct sdFAT_s *pfat=0;

    pfat = &mrs->aspFat;

    //sprintf_f(mrs->log, "check P6 getting the notice\n");
    //print_f(mrs->plog, "fs113", mrs->log);
    
    len = mrs_ipc_get(mrs, &ch, 1, 7);

    if (len > 0) {
        sprintf_f(mrs->log, "check P6 getting the notice, len = %d, ch = 0x%.2x\n", len, ch);
        print_f(mrs->plog, "fs113", mrs->log);
  
        len = 0;
        len = mrs_ipc_get(mrs, &ch, 1, 7);
        while (len > 0) {
            sprintf_f(mrs->log, "check P6 getting the notice, len = %d, ch = 0x%.2x\n", len, ch);
            print_f(mrs->plog, "fs113", mrs->log);

            len = mrs_ipc_get(mrs, &ch, 1, 7);        
        }
        
        //modersp->m = 69;
        //return 2;
        if (ch == 'C') {
            modersp->r = 1;
            return 1;
        } else {
            pfat->fatSupdata = 0;
            pfat->fatSupcur = 0;

            //sprintf_f(mrs->log, "FAIL!!send notice to P6 again!\n");
            sprintf_f(mrs->log, "P6 response BREAK loop ch = %c \n", ch);
            print_f(mrs->plog, "fs113", mrs->log);
            //modersp->m = modersp->m - 1;        
            //return 2;
            modersp->r = 2;
            return 1;
        }
    }
    
    return 0; 
}

static int fs114(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct sdParseBuff_s *pabuf=0;
    int bitset=0, ret;
    bitset = 0;

    msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 8, __u32), &bitset);   //SPI_IOC_WR_DATA_MODE
    sprintf_f(mrs->log, "spi0 Set data mode: %d\n", bitset);
    print_f(mrs->plog, "fs114", mrs->log);

#if SPI_KTHREAD_USE
    bitset = 0;
    ret = msp_spi_conf(mrs->sfm[0], _IOR(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_START_THREAD
    sprintf_f(mrs->log, "Start spi0 spidev thread, ret: 0x%x\n", ret);
    print_f(mrs->plog, "fs114", mrs->log);
#endif

    pabuf = &mrs->aspFat.parBuf;
    sprintf_f(mrs->log, "buff used: %d/%d, reset !!\n", pabuf->dirBuffUsed, pabuf->dirBuffMax);
    print_f(mrs->plog, "fs114", mrs->log);

    pabuf->dirBuffUsed = 0;
    ring_buf_init(&mrs->dataRx);
    modersp->v = 0;

    sprintf_f(mrs->log, "trigger spi0 \n");
    print_f(mrs->plog, "fs114", mrs->log);

    mrs_ipc_put(mrs, "l", 1, 1);

    modersp->m = modersp->m + 1;
    return 2;
}

static int fs115(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct sdParseBuff_s *pabuf=0;
    int ret, bitset, loop=0, len=0, bufn, dstsz=0, totsz;
    char ch;
    char *src, *dst, *pt;

    //sprintf_f(mrs->log, "%d\n", modersp->v);
    //print_f(mrs->plog, "fs115", mrs->log);
    pabuf = &mrs->aspFat.parBuf;
    
    ret = mrs_ipc_get(mrs, &ch, 1, 1);
    while (ret > 0) {
        if (ch == 'l') {
            modersp->v += 1;
        }

        if (ch == 'L') {
            sprintf_f(mrs->log, "ch:%c, v:%d break\n", ch, modersp->v);
            print_f(mrs->plog, "fs115", mrs->log);

            modersp->r |= 0x1;
            break;
        }
        ret = mrs_ipc_get(mrs, &ch, 1, 1);
    }

    if (modersp->r & 0x1) {
        bufn = ring_buf_info_len(&mrs->dataRx);
        sprintf_f(mrs->log, "%d end, bufn: %d, spirecv: %d\n", modersp->v, bufn, pabuf->dirBuffUsed);
        print_f(mrs->plog, "fs115", mrs->log);

        dstsz = bufn * SPI_TRUNK_SZ;
        dst = aspMemalloc(dstsz, 10);
        if (!dst) {
            sprintf_f(mrs->log, "%d. len: %d\n", loop, len);
            print_f(mrs->plog, "fs115", mrs->log);
            modersp->r = 0xed;
            return 1;
        }

        totsz = 0;
        pt = dst;
        loop = modersp->v;
        while (loop > 0) {
            len = ring_buf_cons(&mrs->dataRx, &src);

            memcpy(pt, src, len);

            totsz += len;
            pt += len;
            loop --;
            
            sprintf_f(mrs->log, "%d. len: %d, totsz:%d\n", loop, len, totsz);
            print_f(mrs->plog, "fs115", mrs->log);
        }

        //pabuf->dirBuffUsed = totsz;
        pabuf->dirParseBuff = dst;
        modersp->m = modersp->m + 1;
        return 2;
    }

    return 0;    
}

static int fs116(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct sdParseBuff_s *pabuf=0;
    char *addr=0, *srcbuf=0, *ph, *rawCpy, *rawSrc, *rawTmp;
    int ret, bitset, len=0, totsz=0, lstsz=0, cnt=0, acusz=0;
    int rawsz=0, oldWidth=0, oldHeight=0, oldRowsz=0, oldTot=0;
    char ch;
    struct bitmapHeader_s *bheader;
    CFLOAT LU[2], RU[2], LD[2], RD[2];
    CFLOAT LUn[2], RUn[2], LDn[2], RDn[2];
    int LUt[2], RUt[2], LDt[2], RDt[2], drawCord[4], bmpScale[4], oldScale[4];
    int sdot[2], ddot[2];
    CFLOAT rangle[2], thacos=0, thasin=0, theta, piAngle = 180.0;
    CFLOAT minH=0, minV=0, offsetH=0, offsetV=0;
    int maxhint=0, maxvint=0, minhint=0, minvint=0, rowsize=0, rawszNew=0;
    int bpp=0, ix=0, iy=0, dx=0, dy=0, outi[2], id=0, ixd=0, iyn=0, ixn=0, offsetCal=0;
    CFLOAT ind[4], outd[2], fx=0, fy=0, tx=0, ty=0;
    CFLOAT *tars, *tarc;
    char gdat[3];
    char *dst=0;

    int *crsAry, crsASize, expCAsize;
    CFLOAT linLU[3], linRU[3], linLD[3], linRD[3], linPal[3], linCrs[3];
    CFLOAT pLU[2], pRU[2], pLD[2], pRD[2], pal[2], par[2], pt[2];
    CFLOAT plm[2], prm[2], plc[2], prc[2], pn[2];
    CFLOAT maxhf=0, maxvf=0, minhf=0, minvf=0;
    //sprintf_f(mrs->log, "%d\n", modersp->v++);
    //print_f(mrs->plog, "fs116", mrs->log);

    ret = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((ret > 0) && (ch == 'L')){
        
        pabuf = &mrs->aspFat.parBuf;
        totsz = pabuf->dirBuffUsed;
        srcbuf = pabuf->dirParseBuff;
        
        sprintf_f(mrs->log, "spi 0 end, buff used: %d\n", totsz);
        print_f(mrs->plog, "fs116", mrs->log);

        /* check header */
        //shmem_dump(srcbuf, 128);

        /* rotate */
        ph = &mrs->bmpheader.aspbmpMagic[2];
        len = sizeof(struct bitmapHeader_s) - 2;
        memcpy(ph, srcbuf, len);

        bheader = &mrs->bmpheader;

        dbgBitmapHeader(bheader, len);

        rawsz = bheader->aspbiRawSize;
        rawSrc = srcbuf + bheader->aspbhRawoffset;
        oldWidth = bheader->aspbiWidth;
        oldHeight = bheader->aspbiHeight;
        bpp = bheader->aspbiCPP >> 16;
        oldRowsz = ((bpp * oldWidth + 31) / 32) * 4;

        //rawCpy = mrs->bmpRotate.aspRotCpyBuff;
        //len = mrs->bmpRotate.aspRotBuffSize;
        rawCpy = aspMemalloc(rawsz, 10);
        len = rawsz;
        if (len < rawsz) {
            sprintf_f(mrs->log, "ERROR!!! copy buffer is not enough!!! size %d, need %d !!!\n", len, rawsz);
            print_f(mrs->plog, "fs116", mrs->log);
            modersp->r = 0xed;
            return 1;
        }
        
        memcpy(rawCpy, rawSrc, rawsz);
        
        //shmem_dump(rawCpy, 128);
        //shmem_dump(rawSrc, 128);

        LU[0] = 0;
        LU[1] = bheader->aspbiHeight;

        RU[0] = bheader->aspbiWidth;
        RU[1] = bheader->aspbiHeight;        

        LD[0] = 0;
        LD[1] = 0;

        RD[0] = bheader->aspbiWidth;
        RD[1] = 0;

        modersp->v = (modersp->v + 1) % (360*5);

        theta = (CFLOAT)modersp->v;
        theta = theta / 5.0;
        
        sprintf_f(mrs->log, "rotate angle = %f \n", theta);
        print_f(mrs->plog, "fs116", mrs->log);

        theta = theta * M_PI / piAngle;

        thacos = cos(theta);
        thasin = sin(theta);
        
        rangle[0] = thacos;
        rangle[1] = thasin;
        
        calcuRotateCoordinates(LUt, LUn, LU, rangle);
        calcuRotateCoordinates(RUt, RUn, RU, rangle);
        calcuRotateCoordinates(LDt, LDn, LD, rangle);
        calcuRotateCoordinates(RDt, RDn, RD, rangle);
#if 0
        sprintf_f(mrs->log, "LUn: %lf, %lf / %3d, %3d\n", LUn[0], LUn[1], LUt[0], LUt[1]);
        print_f(mrs->plog, "fs116", mrs->log);
        sprintf_f(mrs->log, "RUn: %lf, %lf / %3d, %3d \n", RUn[0], RUn[1], RUt[0], RUt[1]);
        print_f(mrs->plog, "fs116", mrs->log);
        sprintf_f(mrs->log, "LDn: %lf, %lf / %3d, %3d \n", LDn[0], LDn[1], LDt[0], LDt[1]);
        print_f(mrs->plog, "fs116", mrs->log);
        sprintf_f(mrs->log, "RDn: %lf, %lf / %3d, %3d \n", RDn[0], RDn[1], RDt[0], RDt[1]);
        print_f(mrs->plog, "fs116", mrs->log);
#endif
        minH = aspMin(LUn[0], RUn[0]);
        minH = aspMin(minH, LDn[0]);
        minH = aspMin(minH, RDn[0]);

        minV = aspMin(LUn[1], RUn[1]);
        minV = aspMin(minV, LDn[1]);
        minV = aspMin(minV, RDn[1]);

        sprintf_f(mrs->log, "minH: %lf, minV: %lf \n", minH, minV);
        print_f(mrs->plog, "fs116", mrs->log);

        offsetH = 0 - minH;
        offsetV = 0 - minV;

        LUn[0] += offsetH;
        LUn[1] += offsetV;

        RUn[0] += offsetH;
        RUn[1] += offsetV;

        LDn[0] += offsetH;
        LDn[1] += offsetV;

        RDn[0] += offsetH;
        RDn[1] += offsetV;

        LUt[0] = (int)round(LUn[0]);
        LUt[1] = (int)round(LUn[1]);

        RUt[0] = (int)round(RUn[0]);
        RUt[1] = (int)round(RUn[1]);

        LDt[0] = (int)round(LDn[0]);
        LDt[1] = (int)round(LDn[1]);

        RDt[0] = (int)round(RDn[0]);
        RDt[1] = (int)round(RDn[1]);
#if 0
        sprintf_f(mrs->log, "LUn: %lf, %lf / %d, %d\n", LUn[0], LUn[1], LUt[0], LUt[1]);
        print_f(mrs->plog, "fs116", mrs->log);
        sprintf_f(mrs->log, "RUn: %lf, %lf / %d, %d \n", RUn[0], RUn[1], RUt[0], RUt[1]);
        print_f(mrs->plog, "fs116", mrs->log);
        sprintf_f(mrs->log, "LDn: %lf, %lf / %d, %d \n", LDn[0], LDn[1], LDt[0], LDt[1]);
        print_f(mrs->plog, "fs116", mrs->log);
        sprintf_f(mrs->log, "RDn: %lf, %lf / %d, %d \n", RDn[0], RDn[1], RDt[0], RDt[1]);
        print_f(mrs->plog, "fs116", mrs->log);
#endif
        maxhint= aspMaxInt(LUt[0], RUt[0]);
        maxhint = aspMaxInt(maxhint, LDt[0]);
        maxhint = aspMaxInt(maxhint, RDt[0]);

        maxvint = aspMaxInt(LUt[1], RUt[1]);
        maxvint = aspMaxInt(maxvint, LDt[1]);
        maxvint = aspMaxInt(maxvint, RDt[1]);

        minhint= aspMinInt(LUt[0], RUt[0]);
        minhint = aspMinInt(minhint, LDt[0]);
        minhint = aspMinInt(minhint, RDt[0]);

        minvint = aspMinInt(LUt[1], RUt[1]);
        minvint = aspMinInt(minvint, LDt[1]);
        minvint = aspMinInt(minvint, RDt[1]);
        
        rowsize = ((bpp * maxhint + 31) / 32) * 4;
        rawszNew = rowsize * maxvint;

        sprintf_f(mrs->log, "maxh: %d, minh: %d, maxv: %d, minv: %d \n", maxhint, minhint, maxvint, minvint);
        print_f(mrs->plog, "fs116", mrs->log);

        pLU[0] = -1;
        pLU[1] = -1;
        pRU[0] = -1;
        pRU[1] = -1;
        pLD[0] = -1;
        pLD[1] = -1;
        pRD[0] = -1;
        pRD[1] = -1;

        if (minhint == LUt[0]) {
            sprintf_f(mrs->log, "LU =  %d, %d match minhint: %d !!!left - 0\n", LUt[0], LUt[1], minhint);
            print_f(mrs->plog, "fs116", mrs->log);

            if (minvint == LUt[1]) {
                sprintf_f(mrs->log, "LU =  %d, %d match minvint: %d !!!left - 0\n", LUt[0], LUt[1], minvint);
                print_f(mrs->plog, "fs116", mrs->log);
            
                pLD[0] = LUn[0];
                pLD[1] = LUn[1];
                
                sprintf_f(mrs->log, "PLD = %lf, %lf\n", pLD[0], pLD[1]);
                print_f(mrs->plog, "fs116", mrs->log);

            } else {
                if (maxvint == LUt[1]) {
                    sprintf_f(mrs->log, "LU =  %d, %d match maxvint: %d !!!left - 0\n", LUt[0], LUt[1], maxvint);
                    print_f(mrs->plog, "fs116", mrs->log);

                    pLU[0] = LUn[0];
                    pLU[1] = LUn[1];

                    sprintf_f(mrs->log, "PLU = %lf, %lf\n", pLU[0], pLU[1]);
                    print_f(mrs->plog, "fs116", mrs->log);

                } else {
                    if (maxvint == RUt[1]) {
                        if (minvint == LDt[1]) {
                            if (RUt[0] >= LDt[0]) {
                                pLU[0] = LUn[0];
                                pLU[1] = LUn[1];

                                pLD[0] = LDn[0];
                                pLD[1] = LDn[1];
                            } else if (RUt[0] < LDt[0]) {
                                pLU[0] = RUn[0];
                                pLU[1] = RUn[1];

                                pLD[0] = LUn[0];
                                pLD[1] = LUn[1];
                            } else {
                                sprintf_f(mrs->log, "WARNING!! LU =  %d, %d not match!!!left - 1\n", LUt[0], LUt[1]);
                                print_f(mrs->plog, "fs116", mrs->log);
                            }
                        } else {
                            sprintf_f(mrs->log, "WARNING!! LU =  %d, %d not match!!! left - 2\n", LUt[0], LUt[1]);
                            print_f(mrs->plog, "fs116", mrs->log);
                        }
                    } else {
                        sprintf_f(mrs->log, "WARNING!! LU =  %d, %d not match!!!left - 3\n", LUt[0], LUt[1]);
                        print_f(mrs->plog, "fs116", mrs->log);
                    }
                }
            }
        }
        
        if (minhint == RUt[0]) {
            sprintf_f(mrs->log, "RU =  %d, %d match minhint: %d !!!left - 0\n", RUt[0], RUt[1], minhint);
            print_f(mrs->plog, "fs116", mrs->log);

            if (minvint == RUt[1]) {
                sprintf_f(mrs->log, "RU =  %d, %d match minvint: %d !!!left - 0\n", RUt[0], RUt[1], minvint);
                print_f(mrs->plog, "fs116", mrs->log);
                
                pLD[0] = RUn[0];
                pLD[1] = RUn[1];

                sprintf_f(mrs->log, "PLD = %lf, %lf\n", pLD[0], pLD[1]);
                print_f(mrs->plog, "fs116", mrs->log);
            } else {
                if (maxvint == RUt[1]) {
                    sprintf_f(mrs->log, "RU =  %d, %d match maxvint: %d !!!left - 0\n", RUt[0], RUt[1], maxvint);
                    print_f(mrs->plog, "fs116", mrs->log);
                    
                    pLU[0] = RUn[0];
                    pLU[1] = RUn[1];

                    sprintf_f(mrs->log, "PLU = %lf, %lf\n", pLU[0], pLU[1]);
                    print_f(mrs->plog, "fs116", mrs->log);
                } else {
                    if (maxvint == RDt[1]) {
                        if (minvint == LUt[1]) {
                            if (RDt[0] > LUt[0]) {
                                pLU[0] = RUn[0];
                                pLU[1] = RUn[1];
                    
                                pLD[0] = LUn[0];
                                pLD[1] = LUn[1];
                            } else if (RDt[0] < LUt[0]) {
                                pLU[0] = RDn[0];
                                pLU[1] = RDn[1];
                    
                                pLD[0] = RUn[0];
                                pLD[1] = RUn[1];
                            } else {
                                sprintf_f(mrs->log, "WARNING!! RU =  %d, %d not match!!!left - 1\n", RUt[0], RUt[1]);
                                print_f(mrs->plog, "fs116", mrs->log);
                            }
                        } else {
                            sprintf_f(mrs->log, "WARNING!! RU =  %d, %d not match!!!left - 2\n", RUt[0], RUt[1]);
                            print_f(mrs->plog, "fs116", mrs->log);
                        }
                    } else {
                        sprintf_f(mrs->log, "WARNING!! RU =  %d, %d not match!!!left - 3\n", RUt[0], RUt[1]);
                        print_f(mrs->plog, "fs116", mrs->log);
                    }                    
                }
            }
        }
            
        if (minhint == LDt[0]) {
            sprintf_f(mrs->log, "LD =  %d, %d match minhint: %d !!!left - 0\n", LDt[0], LDt[1], minhint);
            print_f(mrs->plog, "fs116", mrs->log);
            
            if (minvint == LDt[1]) {
                sprintf_f(mrs->log, "LD =  %d, %d match minvint: %d !!!left - 0\n", LDt[0], LDt[1], minvint);
                print_f(mrs->plog, "fs116", mrs->log);

                pLD[0] = LDn[0];
                pLD[1] = LDn[1];

                sprintf_f(mrs->log, "PLD = %lf, %lf\n", pLD[0], pLD[1]);
                print_f(mrs->plog, "fs116", mrs->log);
            } else {
                if (maxvint == LDt[1]) {
                    sprintf_f(mrs->log, "LD =  %d, %d match maxvint: %d !!!left - 0\n", LDt[0], LDt[1], maxvint);
                    print_f(mrs->plog, "fs116", mrs->log);

                    pLU[0] = LDn[0];
                    pLU[1] = LDn[1];

                    sprintf_f(mrs->log, "PLU = %lf, %lf\n", pLU[0], pLU[1]);
                    print_f(mrs->plog, "fs116", mrs->log);

                } else {
                    if (maxvint == LUt[1]) {
                        if (minvint == RDt[1]) {
                            if (LUt[0] > RDt[0]) {
                                pLU[0] = LDn[0];
                                pLU[1] = LDn[1];
                    
                                pLD[0] = RDn[0];
                                pLD[1] = RDn[1];
                            } else if (LUt[0] < RDt[0]) {
                                pLU[0] = LUn[0];
                                pLU[1] = LUn[1];
                    
                                pLD[0] = LDn[0];
                                pLD[1] = LDn[1];
                            } else {
                                sprintf_f(mrs->log, "WARNING!! LD =  %d, %d not match!!!left - 1\n", LDt[0], LDt[1]);
                                print_f(mrs->plog, "fs116", mrs->log);
                            }
                        } else {
                            sprintf_f(mrs->log, "WARNING!! LD =  %d, %d not match!!!left - 2\n", LDt[0], LDt[1]);
                            print_f(mrs->plog, "fs116", mrs->log);
                        }
                    } else {
                        sprintf_f(mrs->log, "WARNING!! LD =  %d, %d not match!!!left - 3\n", LDt[0], LDt[1]);
                        print_f(mrs->plog, "fs116", mrs->log);
                    }                                   
                }
            }
        }
            
        if (minhint == RDt[0]) {
            sprintf_f(mrs->log, "RD =  %d, %d match minhint: %d !!!left - 0\n", RDt[0], RDt[1], minhint);
            print_f(mrs->plog, "fs116", mrs->log);

            if (minvint == RDt[1]) {
                sprintf_f(mrs->log, "RD =  %d, %d match minvint: %d !!!left - 0\n", RDt[0], RDt[1], minvint);
                print_f(mrs->plog, "fs116", mrs->log);

                pLD[0] = RDn[0];
                pLD[1] = RDn[1];                    

                sprintf_f(mrs->log, "PLD = %lf, %lf\n", pLD[0], pLD[1]);
                print_f(mrs->plog, "fs116", mrs->log);
            } else {
                if (maxvint == RDt[1]) {
                    sprintf_f(mrs->log, "RD =  %d, %d match maxvint: %d !!!left - 0\n", RDt[0], RDt[1], maxvint);
                    print_f(mrs->plog, "fs116", mrs->log);

                    pLU[0] = RDn[0];
                    pLU[1] = RDn[1];

                    sprintf_f(mrs->log, "PLU = %lf, %lf\n", pLU[0], pLU[1]);
                    print_f(mrs->plog, "fs116", mrs->log);
                } else {
                    if (maxvint == LDt[1]) {
                        if (minvint == RUt[1]) {
                            if (LDt[0] > RUt[0]) {
                                pLU[0] = RDn[0];
                                pLU[1] = RDn[1];
                    
                                pLD[0] = RUn[0];
                                pLD[1] = RUn[1];
                            } else if (LDt[0] < RUt[0]) {
                                pLU[0] = LDn[0];
                                pLU[1] = LDn[1];
                    
                                pLD[0] = RDn[0];
                                pLD[1] = RDn[1];
                            } else {
                                sprintf_f(mrs->log, "WARNING!! RD =  %d, %d not match!!!left - 1\n", RDt[0], RDt[1]);
                                print_f(mrs->plog, "fs116", mrs->log);
                            }
                        } else {
                            sprintf_f(mrs->log, "WARNING!! RD =  %d, %d not match!!!left - 2\n", RDt[0], RDt[1]);
                            print_f(mrs->plog, "fs116", mrs->log);
                        }
                    } else {
                        sprintf_f(mrs->log, "WARNING!! RD =  %d, %d not match!!!left - 3\n", RDt[0], RDt[1]);
                        print_f(mrs->plog, "fs116", mrs->log);
                    }                                
                }
            }
        }

        if (maxhint == LUt[0]) {
            sprintf_f(mrs->log, "LU =  %d, %d match maxhint: %d !!!right - 0\n", LUt[0], LUt[1], maxhint);
            print_f(mrs->plog, "fs116", mrs->log);

            if (minvint == LUt[1]) {
                sprintf_f(mrs->log, "LU =  %d, %d match minvint: %d !!!right - 0\n", LUt[0], LUt[1], minvint);
                print_f(mrs->plog, "fs116", mrs->log);

                pRD[0] = LUn[0];
                pRD[1] = LUn[1];

                sprintf_f(mrs->log, "PLD = %lf, %lf\n", pRD[0], pRD[1]);
                print_f(mrs->plog, "fs116", mrs->log);

            } else {
                if (maxvint == LUt[1]) {
                    sprintf_f(mrs->log, "LU =  %d, %d match maxvint: %d !!!right - 0\n", LUt[0], LUt[1], maxvint);
                    print_f(mrs->plog, "fs116", mrs->log);

                    pRU[0] = LUn[0];
                    pRU[1] = LUn[1];

                    sprintf_f(mrs->log, "PRU = %lf, %lf\n", pRU[0], pRU[1]);
                    print_f(mrs->plog, "fs116", mrs->log);

                } else {
                    if (maxvint == LDt[1]) {
                        if (minvint == RUt[1]) {
                            if (RUt[0] <= LDt[0]) {
                                pRU[0] = LDn[0];
                                pRU[1] = LDn[1];

                                pRD[0] = LUn[0];
                                pRD[1] = LUn[1];
                            } else if (RUt[0] > LDt[0]) {
                                pRU[0] = LUn[0];
                                pRU[1] = LUn[1];

                                pRD[0] = RUn[0];
                                pRD[1] = RUn[1];
                            } else {
                                sprintf_f(mrs->log, "WARNING!! LU =  %d, %d not match!!!right - 1\n", LUt[0], LUt[1]);
                                print_f(mrs->plog, "fs116", mrs->log);
                            }
                        } else {
                            sprintf_f(mrs->log, "WARNING!! LU =  %d, %d not match!!!right - 2\n", LUt[0], LUt[1]);
                            print_f(mrs->plog, "fs116", mrs->log);
                        }
                    } else {
                        sprintf_f(mrs->log, "WARNING!! LU =  %d, %d not match!!!right - 3\n", LUt[0], LUt[1]);
                        print_f(mrs->plog, "fs116", mrs->log);
                    }
                }
            }
        }
        
        if (maxhint == RUt[0]) {
            sprintf_f(mrs->log, "RU =  %d, %d match maxhint: %d !!!right - 0\n", RUt[0], RUt[1], maxhint);
            print_f(mrs->plog, "fs116", mrs->log);

            if (minvint == RUt[1]) {
                sprintf_f(mrs->log, "RU =  %d, %d match minvint: %d !!!right - 0\n", RUt[0], RUt[1], minvint);
                print_f(mrs->plog, "fs116", mrs->log);

                pRD[0] = RUn[0];
                pRD[1] = RUn[1];

                sprintf_f(mrs->log, "PLD = %lf, %lf\n", pRD[0], pRD[1]);
                print_f(mrs->plog, "fs116", mrs->log);

            } else {
                if (maxvint == RUt[1]) {
                    sprintf_f(mrs->log, "RU =  %d, %d match maxvint: %d !!!right - 0\n", RUt[0], RUt[1], maxvint);
                    print_f(mrs->plog, "fs116", mrs->log);

                    pRU[0] = RUn[0];
                    pRU[1] = RUn[1];

                    sprintf_f(mrs->log, "PRU = %lf, %lf\n", pRU[0], pRU[1]);
                    print_f(mrs->plog, "fs116", mrs->log);

                } else {
                    if (maxvint == LUt[1]) {
                        if (minvint == RDt[1]) {
                            if (RDt[0] < LUt[0]) {
                                pRU[0] = LUn[0];
                                pRU[1] = LUn[1];
                    
                                pRD[0] = RUn[0];
                                pRD[1] = RUn[1];
                            } else if (RDt[0] > LUt[0]) {
                                pRU[0] = RUn[0];
                                pRU[1] = RUn[1];
                    
                                pRD[0] = RDn[0];
                                pRD[1] = RDn[1];
                            } else {
                                sprintf_f(mrs->log, "WARNING!! RU =  %d, %d not match!!!right - 1\n", RUt[0], RUt[1]);
                                print_f(mrs->plog, "fs116", mrs->log);
                            }
                        } else {
                            sprintf_f(mrs->log, "WARNING!! RU =  %d, %d not match!!!right - 2\n", RUt[0], RUt[1]);
                            print_f(mrs->plog, "fs116", mrs->log);
                        }
                    } else {
                        sprintf_f(mrs->log, "WARNING!! RU =  %d, %d not match!!!right - 3\n", RUt[0], RUt[1]);
                        print_f(mrs->plog, "fs116", mrs->log);
                    }                    
                }
            }
        }
            
        if (maxhint == LDt[0]) {
            sprintf_f(mrs->log, "LD =  %d, %d match maxhint: %d !!!right - 0\n", LDt[0], LDt[1], maxhint);
            print_f(mrs->plog, "fs116", mrs->log);

            if (minvint == LDt[1]) {
                sprintf_f(mrs->log, "LD =  %d, %d match minvint: %d !!!right - 0\n", LDt[0], LDt[1], minvint);
                print_f(mrs->plog, "fs116", mrs->log);

                pRD[0] = LDn[0];
                pRD[1] = LDn[1];                  

                sprintf_f(mrs->log, "PLD = %lf, %lf\n", pRD[0], pRD[1]);
                print_f(mrs->plog, "fs116", mrs->log);

            } else {
                if (maxvint == LDt[1]) {
                    sprintf_f(mrs->log, "LD =  %d, %d match maxvint: %d !!!right - 0\n", LDt[0], LDt[1], maxvint);
                    print_f(mrs->plog, "fs116", mrs->log);

                    pRU[0] = LDn[0];
                    pRU[1] = LDn[1];

                    sprintf_f(mrs->log, "PRU = %lf, %lf\n", pRU[0], pRU[1]);
                    print_f(mrs->plog, "fs116", mrs->log);

                } else {
                    if (maxvint == RDt[1]) {
                        if (minvint == LUt[1]) {
                            if (LUt[0] < RDt[0]) {
                                pRU[0] = RDn[0];
                                pRU[1] = RDn[1];
                    
                                pRD[0] = LDn[0];
                                pRD[1] = LDn[1];
                            } else if (LUt[0] > RDt[0]) {
                                pRU[0] = LDn[0];
                                pRU[1] = LDn[1];
                    
                                pRD[0] = LUn[0];
                                pRD[1] = LUn[1];
                            } else {
                                sprintf_f(mrs->log, "WARNING!! LD =  %d, %d not match!!!right - 1\n", LDt[0], LDt[1]);
                                print_f(mrs->plog, "fs116", mrs->log);
                            }
                        } else {
                            sprintf_f(mrs->log, "WARNING!! LD =  %d, %d not match!!!right - 2\n", LDt[0], LDt[1]);
                            print_f(mrs->plog, "fs116", mrs->log);
                        }
                    } else {
                        sprintf_f(mrs->log, "WARNING!! LD =  %d, %d not match!!!right - 3\n", LDt[0], LDt[1]);
                        print_f(mrs->plog, "fs116", mrs->log);
                    }                                   
                }
            }
        }
                
        if (maxhint == RDt[0]) {
            sprintf_f(mrs->log, "RD =  %d, %d match maxhint: %d !!!right - 0\n", RDt[0], RDt[1], maxhint);
            print_f(mrs->plog, "fs116", mrs->log);

            if (minvint == RDt[1]) {
                sprintf_f(mrs->log, "RD =  %d, %d match minvint: %d !!!right - 0\n", RDt[0], RDt[1], minvint);
                print_f(mrs->plog, "fs116", mrs->log);

                pRD[0] = RDn[0];
                pRD[1] = RDn[1];                    

                sprintf_f(mrs->log, "PLD = %lf, %lf\n", pRD[0], pRD[1]);
                print_f(mrs->plog, "fs116", mrs->log);

            } else {
                if (maxvint == RDt[1]) {
                    sprintf_f(mrs->log, "RD =  %d, %d match maxvint: %d !!!right - 0\n", RDt[0], RDt[1], maxvint);
                    print_f(mrs->plog, "fs116", mrs->log);

                    pRU[0] = RDn[0];
                    pRU[1] = RDn[1];

                    sprintf_f(mrs->log, "PRU = %lf, %lf\n", pRU[0], pRU[1]);
                    print_f(mrs->plog, "fs116", mrs->log);

                } else {
                    if (maxvint == RUt[1]) {
                        if (minvint == LDt[1]) {
                            if (LDt[0] < RUt[0]) {
                                pRU[0] = RUn[0];
                                pRU[1] = RUn[1];
                    
                                pRD[0] = RDn[0];
                                pRD[1] = RDn[1];
                            } else if (LDt[0] > RUt[0]) {
                                pRU[0] = RDn[0];
                                pRU[1] = RDn[1];
                    
                                pRD[0] = LDn[0];
                                pRD[1] = LDn[1];
                            } else {
                                sprintf_f(mrs->log, "WARNING!! RD =  %d, %d not match!!!right - 1\n", RDt[0], RDt[1]);
                                print_f(mrs->plog, "fs116", mrs->log);
                            }
                        } else {
                            sprintf_f(mrs->log, "WARNING!! RD =  %d, %d not match!!!right - 2\n", RDt[0], RDt[1]);
                            print_f(mrs->plog, "fs116", mrs->log);
                        }
                    } else {
                        sprintf_f(mrs->log, "WARNING!! RD =  %d, %d not match!!!right - 3\n", RDt[0], RDt[1]);
                        print_f(mrs->plog, "fs116", mrs->log);
                    }                                
                }
            }
        }

#if 0
        sprintf_f(mrs->log, "PLU: %lf, %lf \n", pLU[0], pLU[1]);
        print_f(mrs->plog, "fs116", mrs->log);
        sprintf_f(mrs->log, "PRU: %lf, %lf \n", pRU[0], pRU[1]);
        print_f(mrs->plog, "fs116", mrs->log);
        sprintf_f(mrs->log, "PLD: %lf, %lf \n", pLD[0], pLD[1]);
        print_f(mrs->plog, "fs116", mrs->log);
        sprintf_f(mrs->log, "PRD: %lf, %lf \n", pRD[0], pRD[1]);
        print_f(mrs->plog, "fs116", mrs->log);
#endif

        if (pLU[1] > pRU[1]) {
            getVectorFromP(linLU, pLU, pLD);
            getVectorFromP(linLD, pLD, pRD);
            getVectorFromP(linRD, pRD, pRU);
            getVectorFromP(linRU, pRU, pLU);

            plm[0] = pLD[0];
            plm[1] = pLD[1];
            
            prm[0] = pRU[0];
            prm[1] = pRU[1];
        } else {
            getVectorFromP(linLU, pRU, pLU);
            getVectorFromP(linLD, pLU, pLD);
            getVectorFromP(linRD, pLD, pRD);
            getVectorFromP(linRU, pRD, pRU);

            plm[0] = pLU[0];
            plm[1] = pLU[1];
            
            prm[0] = pRD[0];
            prm[1] = pRD[1];
        }
        
#if 0
        ret = getCross(linLD, linLU, plc);
        sprintf_f(mrs->log, "test cross left %lf, %lf ret: %d \n", plc[0], plc[1], ret);
        print_f(mrs->plog, "fs116", mrs->log);
                
        ret = getCross(linRD, linRU, prc);
        sprintf_f(mrs->log, "test cross right %lf, %lf ret: %d \n", prc[0], prc[1], ret);
        print_f(mrs->plog, "fs116", mrs->log);

        ret = getCross(linRU, linLU, pt);
        sprintf_f(mrs->log, "test cross top %lf, %lf ret: %d \n", pt[0], pt[1], ret);
        print_f(mrs->plog, "fs116", mrs->log);

        ret= getCross(linRD, linLD, pn);
        sprintf_f(mrs->log, "test cross down %lf, %lf ret: %d \n", pn[0], pn[1], ret);
        print_f(mrs->plog, "fs116", mrs->log);
#endif

        pal[0] = 100;
        pal[1] = 100;

        par[0] = 100;
        par[1] = 1000;
        getVectorFromP(linPal, par, pal);        

        expCAsize = maxvint-minvint+1;
        len = 3*sizeof(int);
        crsAry = aspMemalloc(expCAsize*len, 10);
        #if 0
        crsAry = (int *)mrs->bmpRotate.aspRotCrossAry;
        crsASize = mrs->bmpRotate.aspRotCASize /len;
        if (expCAsize > crsASize) {
            expCAsize = crsASize;
        }
        #endif

        pt[0] = 200.0;
        for (iy=minvint, ix=0; ix < expCAsize; iy++, ix++) {
            pt[1] = (CFLOAT)iy;
            getRectVectorFromV(linCrs, pt, linPal);

            //getCross(linCrs, linPal, pn);
            //sprintf_f(mrs->log, "pn: %.4lf, %.4lf \n", pn[0], pn[1]);
            //print_f(mrs->plog, "fs116", mrs->log);

            if (pt[1] > plm[1]) {
                getCross(linCrs, linLU, plc);
            } else {
                getCross(linCrs, linLD, plc);
            }

            //sprintf_f(mrs->log, "%.4lf %.4lf, left cross (%.4lf, %.4lf) \n", pt[1], plm[1], plc[0], plc[1]);
            //print_f(mrs->plog, "fs116", mrs->log);

            if (pt[1] > prm[1]) {
                getCross(linCrs, linRU, prc);
            } else {
                getCross(linCrs, linRD, prc);
            }

            //sprintf_f(mrs->log, "%.4lf %.4lf, right cross (%.4lf, %.4lf) \n", pt[1], prm[1], prc[0], prc[1]);
            //print_f(mrs->plog, "fs116", mrs->log);
            
            crsAry[ix*3+0] = iy;
            crsAry[ix*3+1] = (int)round(plc[0]);
            crsAry[ix*3+2] = (int)round(prc[0]);
        }

/*
        for (ix=0; ix < (maxvint-minvint+1); ix++) {
            sprintf_f(mrs->log, "%d. %d, %d, %d (%d)\n", ix, crsAry[ix*3+0], crsAry[ix*3+1], crsAry[ix*3+2], crsAry[ix*3+2] - crsAry[ix*3+1]);
            print_f(mrs->plog, "fs116", mrs->log);
        }
*/
        sprintf_f(mrs->log, "new bitmap H/V = %d /%d, rowsize: %d, rawsize: %d, buffused: %d, sizeof crsArry: %d\n", maxhint, maxvint, rowsize, rawszNew, totsz, expCAsize);
        print_f(mrs->plog, "fs116", mrs->log);

        //memset(rawSrc, 0, rawszNew);

        bheader->aspbhSize = bheader->aspbhRawoffset + rawszNew;
        bheader->aspbiWidth = maxhint;
        bheader->aspbiHeight = maxvint;
        bheader->aspbiRawSize = rawszNew;

        memcpy(srcbuf, ph, 54);
        
        /* retate raw data */
        //memset(rawSrc, 0xff, rawszNew);
        oldScale[0] = oldRowsz;
        oldScale[1] = oldHeight;
        oldScale[2] = rawsz;
        oldScale[3] = bpp;        

        bmpScale[0] = rowsize;
        bmpScale[1] = maxvint;        
        bmpScale[2] = rawszNew;
        bmpScale[3] = bpp;

        rawTmp = rawSrc;
        memset(rawTmp, 0xff, rawszNew);
        
        /* reverse to fill the rotate image */
        
        theta = (CFLOAT) (360*5 - modersp->v);
        theta = theta / 5;
        
        sprintf_f(mrs->log, "reverse rotate angle = %lf \n", theta);
        print_f(mrs->plog, "fs116", mrs->log);

        theta = theta * M_PI / piAngle;

        thacos = cos(theta);
        thasin = sin(theta);

        ix = (int)round(0 - offsetH);
        iy = (int)round(0 - offsetV);
        
        if (maxhint > maxvint) {
            oldTot = (int)round(maxhint - offsetH + 1);
        } else {
            oldTot = (int)round(maxvint - offsetV + 1);
        }

        if (ix < iy) {
            id = ix - 1;
        } else {
            id = iy - 1;
        }

        offsetCal = 0 - id;
        len = oldTot - id;
#if 0 
        tars = aspMemalloc(sizeof(CFLOAT) * len);
        tarc = aspMemalloc(sizeof(CFLOAT) * len);

        sprintf_f(mrs->log, "pre-calculating buffer size: %d, max: %d, min: %d, offset: %d, tars: 0x%.8x, tarc: 0x%.8x\n", len, oldTot, id, offsetCal, tars, tarc);
        print_f(mrs->plog, "fs116", mrs->log);
        
       
        for (ix = id, iy = 0; iy < len; ix++, iy++) {

            fx = (CFLOAT)ix;
            tars[iy] = fx * thasin;
            tarc[iy] = fx * thacos;

            sprintf_f(mrs->log, "pre-calculate fx: %lf, sin: %lf, cos: %lf \n", fx, tars[iy], tarc[iy]);
            print_f(mrs->plog, "fs116", mrs->log);

        }
#endif

#if 0
        fx = LUn[0] - offsetH;
        fy = LUn[1] - offsetV;
        dx = (int) round(fx*thacos - fy*thasin);
        dy = (int) round(fx*thasin + fy*thacos);
        sprintf_f(mrs->log, "LU back %d(%f), %d(%f) => %d, %d offset(%f, %f)\n", LUt[0], fx, LUt[1], fy,  dx, dy, offsetH, offsetV);
        print_f(mrs->plog, "fs116", mrs->log);
        
        fx = RUn[0] - offsetH;
        fy = RUn[1] - offsetV;
        dx = (int) round(fx*thacos - fy*thasin);
        dy = (int) round(fx*thasin + fy*thacos);
        sprintf_f(mrs->log, "RU back %d(%f), %d(%f) => %d, %d offset(%f, %f)\n", RUt[0], fx, RUt[1], fy,  dx, dy, offsetH, offsetV);
        print_f(mrs->plog, "fs116", mrs->log);

        fx = RDn[0] - offsetH;
        fy = RDn[1] - offsetV;
        dx = (int) round(fx*thacos - fy*thasin);
        dy = (int) round(fx*thasin + fy*thacos);
        sprintf_f(mrs->log, "RD back %d(%f), %d(%f) => %d, %d offset(%f, %f)\n", RDt[0], fx, RDt[1], fy,  dx, dy, offsetH, offsetV);
        print_f(mrs->plog, "fs116", mrs->log);

        fx = LDn[0] - offsetH;
        fy = LDn[1] - offsetV;
        dx = (int) round(fx*thacos - fy*thasin);
        dy = (int) round(fx*thasin + fy*thacos);
        sprintf_f(mrs->log, "LD back %d(%f), %d(%f) => %d, %d offset(%f, %f)\n", LDt[0], fx, LDt[1], fy,  dx, dy, offsetH, offsetV);
        print_f(mrs->plog, "fs116", mrs->log);
#endif

        lstsz = 0;
        totsz = bheader->aspbhSize;
        ring_buf_init(&mrs->cmdRx);

        msync(crsAry, expCAsize*3*4, MS_SYNC);
        
        cnt = 0;
        for (id=0; id < expCAsize; id++) {
            iy = crsAry[id*3+0];
            ix = crsAry[id*3+1];
            ixd = crsAry[id*3+2]; 

            //fx = (CFLOAT)ix;
            fy = (CFLOAT)iy;
            
            //fx -= offsetH;
            fy -= offsetV;

            //dx = (int) round(fx*thacos - fy*thasin);
            dy = (int) round(fx*thasin + fy*thacos);

            //sprintf_f(mrs->log, "back %d(%f), %d(%f) => %d, %d offset(%f, %f)\n", ix, fx, iy, fy,  dx, dy, offsetH, offsetV);
            //print_f(mrs->plog, "fs116", mrs->log);

            iyn = (int)round(fy);
            iyn += offsetCal;
            
            for (;ix <= ixd; ix++) {       

                fx = (CFLOAT)ix;

                fx -= offsetH;

                ixn = (int)round(fx);
                ixn += offsetCal;

                //dx = (int) round(tarc[ixn] - tars[iyn]);
                //dy = (int) round(tars[ixn] + tarc[iyn]);

                dx = (int) round(fx*thacos - fy*thasin);
                dy = (int) round(fx*thasin + fy*thacos);

                cnt++;

                if ((dx < 0) || (dy < 0) || (dx >= oldWidth) || (dy >= oldHeight)) {
                    //sprintf(mrs->log, "%d. %d, %d => %d, %d (%d, %d)\n",id, ix, iy,  dx, dy, oldWidth, oldHeight);
                    //print_f(mrs->plog, "fs116", mrs->log);
                    continue;
                }

                bitset = bpp / 8;
                dst = rawCpy + (dx*bitset + dy*oldRowsz);

                cnt = 0;
                while (bitset > 0) {
                    gdat[cnt] = *dst;

                    bitset --;
                    cnt++;
                    dst++;

                    if (cnt > 2) break;
                }

                bitset = bpp / 8;
                dst = rawTmp + (ix*bitset + iy*rowsize);

                cnt = 0;
                while (bitset > 0) {
                    *dst = gdat[cnt];

                    bitset --;
                    cnt++;
                    dst++;
                    
                    if (cnt > 2) break;
                }

                lstsz = bheader->aspbhRawoffset + iy*rowsize;  
                
                while ((lstsz - acusz) > SPI_TRUNK_SZ) {
                    len = 0;
                    len = ring_buf_get(&mrs->cmdRx, &addr);
                    if (len < 0) {
                        break;
                    }

                    msync(srcbuf, len, MS_SYNC);
                    memcpy(addr, srcbuf, len);
                    ring_buf_prod(&mrs->cmdRx);    

                    acusz= acusz + len;
                    srcbuf = srcbuf + len;
                    mrs_ipc_put(mrs, "n", 1, 3); 
                }                
                
            }

        }

        lstsz = totsz - acusz;

        sprintf_f(mrs->log, "last size: %d\n", lstsz);
        print_f(mrs->plog, "fs116", mrs->log);

        while (lstsz > 0) {
            len = 0;
            len = ring_buf_get(&mrs->cmdRx, &addr);
            if (len > 0) {
                if (len < lstsz) { 
                    msync(srcbuf, len, MS_SYNC);
                    memcpy(addr, srcbuf, len);
                    ring_buf_prod(&mrs->cmdRx);    

                    lstsz = lstsz - len;
                    srcbuf = srcbuf + len;
                    mrs_ipc_put(mrs, "n", 1, 3); 
                } else {
                    msync(srcbuf, lstsz, MS_SYNC);
                    memcpy(addr, srcbuf, lstsz);
                    ring_buf_prod(&mrs->cmdRx);    
                    ring_buf_set_last(&mrs->cmdRx, lstsz);
                
                    lstsz = 0;
                    mrs_ipc_put(mrs, "n", 1, 3);        
                }
            } else {
                usleep(800000);
            }
        }                

        mrs_ipc_put(mrs, "N", 1, 3);       

        sprintf_f(mrs->log, "ring buff count: %d\n", cnt);
        print_f(mrs->plog, "fs116", mrs->log);

        dbgBitmapHeader(bheader, len);
        
#if 0
        aspMemFree(rawCpy, 0);
        aspMemFree(crsAry, 0);
        aspMemFree(tars, 0);
        aspMemFree(tarc, 0);
#endif

#if 0
        /* send BMP back */
        totsz = bheader->aspbhSize;
        ring_buf_init(&mrs->cmdRx);

        lstsz = totsz;
        cnt = 0;
        while (lstsz > 0) {
            len = 0;
            len = ring_buf_get(&mrs->cmdRx, &addr);
            if (len < 0) {
                usleep(800000);
                continue;
            }
            
            if (lstsz > len) {
                memcpy(addr, srcbuf, len);
                ring_buf_prod(&mrs->cmdRx);    

                lstsz = lstsz - len;
                srcbuf = srcbuf + len;

                mrs_ipc_put(mrs, "n", 1, 3);
            } else {
                memcpy(addr, srcbuf, lstsz);
                ring_buf_prod(&mrs->cmdRx);    
                ring_buf_set_last(&mrs->cmdRx, lstsz);
                
                lstsz = 0;
                mrs_ipc_put(mrs, "n", 1, 3);                
            }

            msync(addr, len, MS_SYNC);

            cnt++;

            //sprintf_f(mrs->log, "last size: %d - %d, get len: %d\n", lstsz, cnt, len);
            //print_f(mrs->plog, "fs116", mrs->log);
        }

        mrs_ipc_put(mrs, "N", 1, 3);       

        sprintf_f(mrs->log, "ring buff count: %d\n", cnt);
        print_f(mrs->plog, "fs116", mrs->log);
#endif

        modersp->m = modersp->m + 1;

        return 2;
    }

    return 0; 
}

static int fs117(struct mainRes_s *mrs, struct modersp_s *modersp) 
{ 
    int len=0, bitset=0, ret=0, count=0;
    char ch=0;
    struct info16Bit_s *p;
    struct sdFAT_s *pfat=0;

    pfat = &mrs->aspFat;
    
    //sprintf_f(mrs->log, "wait spi0 tx end\n");
    //print_f(mrs->plog, "fs117", mrs->log);

    len = mrs_ipc_get(mrs, &ch, 1, 3);
    while (len > 0) {

        count++;
        if (ch == 'N') {
            sprintf_f(mrs->log, "ch: %c - end, count: %d\n", ch, count);
            print_f(mrs->plog, "fs117", mrs->log);

            ring_buf_init(&mrs->cmdRx);

#if SPI_KTHREAD_USE
            bitset = 0;
            ret = msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_STOP_THREAD
            sprintf_f(mrs->log, "Stop spi0 spidev thread, ret: 0x%x\n", ret);
            print_f(mrs->plog, "fs74", mrs->log);
#endif
#if PULL_LOW_AFTER_DATA
            bitset = 0;
            msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
            sprintf_f(mrs->log, "set RDY pin %d\n",bitset);
            print_f(mrs->plog, "fs74", mrs->log);
            usleep(210000);
#endif

            pfat->parBuf.dirParseBuff = 0;
            pfat->parBuf.dirBuffUsed = 0;
            pfat->parBuf.dirBuffMax = 0;
    
            aspMemClear(aspMemAsign, asptotMalloc, 10);
            modersp->m = 48;            
            return 2;
        }

        len = mrs_ipc_get(mrs, &ch, 1, 3);
        
    }
    return 0; 
}

static int fs118(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    sprintf_f(mrs->log, "trigger spi0 and spi1 \n");
    print_f(mrs->plog, "fs118", mrs->log);

    mrs_ipc_put(mrs, "y", 1, 1);
    mrs_ipc_put(mrs, "y", 1, 2);

    modersp->v = 0;
    
    modersp->m = modersp->m + 1;
    return 2;
}

static int fs119(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int ret, bitset;
    char ch;

    //sprintf_f(mrs->log, "%d\n", modersp->v++);
    //print_f(mrs->plog, "fs111", mrs->log);

    //sleep(5);

    ret = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((ret > 0) && (ch == 'Y')){

        sprintf_f(mrs->log, "spi 0 end, metaout get!\n");
        print_f(mrs->plog, "fs119", mrs->log);
        
#if PULL_LOW_AFTER_DATA
        bitset = 0;
        msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
        sprintf_f(mrs->log, "set RDY pin %d\n",bitset);
        print_f(mrs->plog, "fs119", mrs->log);
        usleep(210000);
#endif

        modersp->v |= 0x01;
    }

    ret = mrs_ipc_get(mrs, &ch, 1, 2);
    if ((ret > 0) && (ch == 'Y')){

        sprintf_f(mrs->log, "spi 1 end, metaout get!\n");
        print_f(mrs->plog, "fs119", mrs->log);
        
#if PULL_LOW_AFTER_DATA
        bitset = 0;
        msp_spi_conf(mrs->sfm[1], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
        sprintf_f(mrs->log, "set RDY pin %d\n",bitset);
        print_f(mrs->plog, "fs119", mrs->log);
        usleep(210000);
#endif

        modersp->v |= 0x10;
    }

    if (modersp->v == 0x11) {
        modersp->m = 48;
        return 2;
    }
    
    return 0; 
}

static int fs120(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    sprintf_f(mrs->log, "send notice to P6 for meta mass ready\n");
    print_f(mrs->plog, "fs120", mrs->log);

    mrs_ipc_put(mrs, "d", 1, 7);
    mrs_ipc_put(mrs, "d", 1, 7);

    //modersp->m = modersp->m + 1;
    modersp->d = modersp->m + 1;
    modersp->m = 36;
    
    return 2;
}

static int fs121(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int len=0;
    char ch=0;
    //sprintf_f(mrs->log, "check P6 getting the notice\n");
    //print_f(mrs->plog, "fs121", mrs->log);

    len = mrs_ipc_get(mrs, &ch, 1, 7);
    if (len > 0) {
        sprintf_f(mrs->log, "check P6 getting the notice, len = %d, ch = 0x%.2x\n", len, ch);
        print_f(mrs->plog, "fs121", mrs->log);

        len = 0;
        len = mrs_ipc_get(mrs, &ch, 1, 7);
        while (len > 0) {
            sprintf_f(mrs->log, "check P6 getting the notice, len = %d, ch = 0x%.2x\n", len, ch);
            print_f(mrs->plog, "fs121", mrs->log);

            len = mrs_ipc_get(mrs, &ch, 1, 7);        
        }

        if (ch == 'D') {
            modersp->r = 1;
            return 1;
        } else {
            sprintf_f(mrs->log, "P6 response BREAK loop ch = %c \n", ch);
            print_f(mrs->plog, "fs121", mrs->log);

            modersp->r = 2;
            return 1;
        }
    }
    
    return 0; 
}

static int fs122(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    int ret=0;
    uint32_t val=0, fformat=0;
    struct supdataBack_s *s=0;
    struct aspConfig_s *pct=0;
    struct sdFAT_s *pfat=0;

    pct = mrs->configTable;
    pfat = &mrs->aspFat;

    sprintf_f(mrs->log, "initial the fatSupdata for CFLOAT side scan !!!  \n");
    print_f(mrs->plog, "fs122", mrs->log);
    pfat->fatSupdataDuo= 0;

    ret = cfgTableGetChk(pct, ASPOP_FILE_FORMAT, &fformat, ASPOP_STA_CON);    
    if (ret) {
        fformat = 0;
    }
    
    //cfgTableSet(pct, ASPOP_SUP_SAVE, (uint32_t)s);
    s = 0;
    s = aspMemalloc(sizeof(struct supdataBack_s), 10);
    if (!s) {
        sprintf_f(mrs->log, "FAIL to initial the second fatSupdata !!! \n");
        print_f(mrs->plog, "fs122", mrs->log);

        modersp->r = 2;
        return 1;
    }

    //cfgTableSet(pct, ASPOP_SUP_SAVE, (uint32_t)s);
    memset(s, 0, sizeof(struct supdataBack_s));
    pfat->fatSupdataDuo = s;   
    pfat->fatSupcurDuo = pfat->fatSupdataDuo;

    if ((fformat == FILE_FORMAT_PDF) || (fformat == FILE_FORMAT_TIFF_I)) {
        sprintf_f(mrs->log, "file format (%d) 2:PDF 4:tiff_i, allocate one more trunk at the begin\n", fformat);
        print_f(mrs->plog, "fs122", mrs->log);

        s = aspMemalloc(sizeof(struct supdataBack_s), 10);
        if (!s) {
            sprintf_f(mrs->log, "FAIL to initial the head fatSupdataDuo !!! \n");
            print_f(mrs->plog, "fs122", mrs->log);

            modersp->r = 2;
            return 1;
        }

        memset(s, 0, sizeof(struct supdataBack_s));
        pfat->fatSupcurDuo->supdataUse = SPI_TRUNK_SZ - 512;
        pfat->fatSupcurDuo->supdataTot = SPI_TRUNK_SZ;
        pfat->fatSupcurDuo->n = s;
        pfat->fatSupcurDuo = s;
    }

    sprintf_f(mrs->log, "fatSupdataDuo = 0x%.8x, fatSupcurDuo = 0x%.8x!!!  \n", (uint32_t)pfat->fatSupdataDuo, (uint32_t)pfat->fatSupcurDuo);
    print_f(mrs->plog, "fs122", mrs->log);

    modersp->d = 59;

    if (modersp->d) {
        modersp->m = modersp->d;
        modersp->d = 0;
        return 2;
    } else {
        modersp->r = 1;
        return 1;
    }
}

static int fs123(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct supdataBack_s *sh=0, *shduo=0;
    struct sdFAT_s *pfat=0;
    struct aspConfig_s *pct=0;
    struct aspConfig_s *pdt, *pdtduo=0;
    
    pct = mrs->configTable;                

    pfat = &mrs->aspFat;

    sh = pfat->fatSupdata;
    shduo = pfat->fatSupdataDuo;

    if ((sh) && (shduo)) {
        pfat->fatSupdata = shduo;
        pfat->fatSupdataDuo = 0;

        pdt = &pct[ASPOP_IMG_LEN];
        pdtduo = &pct[ASPOP_IMG_LEN_DUO];

        pdt->opValue = pdtduo->opValue;
        
        sprintf_f(mrs->log, "procede for secord page SD writing back \n");
        print_f(mrs->plog, "fs123", mrs->log);

        modersp->r = 1;
    } else if ((sh) && (!shduo)) {
        pfat->fatSupdata = 0;
        pfat->fatSupcur = 0;
        pfat->fatSupdataDuo = 0;    
        pfat->fatSupcurDuo = 0;

        pfat->parBuf.dirParseBuff = 0;
        pfat->parBuf.dirBuffUsed = 0;
        pfat->parBuf.dirBuffMax = 0;
        
        aspMemClear(aspMemAsign, asptotMalloc, 10);

        modersp->r = 2;
        
        sprintf_f(mrs->log, "release resource for CFLOAT side SD write back\n");
        print_f(mrs->plog, "fs123", mrs->log);
    } else {
        sprintf_f(mrs->log, "ERROR!!! backup buffer is not correct sh: 0x%x, shduo: 0x%x\n", (uint32_t)sh, (uint32_t)shduo);
        print_f(mrs->plog, "fs123", mrs->log);
        modersp->r = 0xed;
        return 1;
    }
    
    return 1;
}

static int fs124(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct sdFAT_s *pfat=0;
    
    sprintf_f(mrs->log, "release resource for single side SD write back\n");
    print_f(mrs->plog, "fs124", mrs->log);

    pfat = &mrs->aspFat;

    pfat->fatSupdata = 0;
    pfat->fatSupcur = 0;
    pfat->parBuf.dirParseBuff = 0;
    pfat->parBuf.dirBuffUsed = 0;
    pfat->parBuf.dirBuffMax = 0;

    aspMemClear(aspMemAsign, asptotMalloc, 10);

    modersp->r = 1;
    
    return 1;
}

static int fs125(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct sdFatDir_s *pfatdir=0;
    struct sdDirPool_s *pdirpool=0;
    int dirused=0, idd=0, maxsz=0, len=0, usedsz=0, totsz=0, txsz=0;
    int cpn=0, bufn=0, in=0;
    char *src=0, *addrd=0;
    char ch=0;
    struct directnFile_s* dir, *dpa, *dbr, *dch; 
    
    pfatdir = &mrs->aspFat.fatDirTr;
    msync(pfatdir, sizeof(struct sdFatDir_s), MS_SYNC);

#if 1
    if (!pfatdir->dirFATDirty) {
        modersp->r = 1;
        return 1;
    }
#endif

#if 1 /* set to 1 to notice fat update */
    pfatdir->dirFATDirty |= 0x2;
    msync(pfatdir, sizeof(struct sdFatDir_s), MS_SYNC);
#endif

    dirused = pfatdir->dirFATUsed;
    if (dirused > pfatdir->dirFATMax) {
        dirused = pfatdir->dirFATMax;
    }

   
    for (idd = 0; idd < dirused; idd++) {
        pdirpool = pfatdir->fatDirPool[idd];
        if (!pdirpool) {
            sprintf_f(mrs->log, "ERROR!!! dir pool == NULL !!!\n");
            print_f(mrs->plog, "fs125", mrs->log);
            modersp->r = 0xed;
            return 1;
        }
        ring_buf_init(&mrs->dataRx);    

        cpn = 0;
        totsz = 0;
        src = (char *)pdirpool->dirPool;
        usedsz = pdirpool->dirUsed;
        maxsz = pdirpool->dirMax;
        if (usedsz > maxsz) {
            sprintf_f(mrs->log, "WARNING!!! plan to send data, size: %d > max: %d\n", usedsz, maxsz);
            print_f(mrs->plog, "fs125", mrs->log);
            usedsz = maxsz;
        }

        txsz = usedsz * sizeof(struct directnFile_s);
        sprintf_f(mrs->log, "plan to send data, size: %d (%d x %d) \n", txsz, usedsz, sizeof(struct directnFile_s));
        print_f(mrs->plog, "fs125", mrs->log);
        
#if 0//LOG_FS_EN
        /* debug print */
        for (in = 0; in < usedsz; in++) {
            dir = &pdirpool->dirPool[in];
            if (dir->dflen > 0) {
                sprintf_f(mrs->log, "dir %d. addr:0x%.8x, status: 0x%x <0x%.8x,0x%.8x,0x%.8x,0x%.8x> SFN[%s] LFN[%s](%d)\n", in, dir, 
                    dir->dfstats, dir->dfindex, dir->dfpaid, dir->dfbrid, dir->dfchid, dir->dfSFN, dir->dfLFN, dir->dflen);
                print_f(mrs->plog, "fs125", mrs->log);
            } else {
                sprintf_f(mrs->log, "dir %d. addr:0x%.8x, status: 0x%x <0x%.8x,0x%.8x,0x%.8x,0x%.8x> SFN[%s]\n", in, dir, 
                    dir->dfstats, dir->dfindex, dir->dfpaid, dir->dfbrid, dir->dfchid, dir->dfSFN);
                print_f(mrs->plog, "fs125", mrs->log);
            }

            /* pa info */
            sprintf_f(mrs->log, "    pa addr: 0x%.8x \n", dir->pa);
            print_f(mrs->plog, "fs125", mrs->log);
            
            if (dir->pa) {
                dpa = dir->pa;
                sprintf_f(mrs->log, "    pa status: 0x%x <0x%.8x,0x%.8x,0x%.8x,0x%.8x> SFN[%s]\n",
                    dpa->dfstats, dpa->dfindex, dpa->dfpaid, dpa->dfbrid, dpa->dfchid, dpa->dfSFN);
                print_f(mrs->plog, "fs125", mrs->log);
            }
            /* br info */
            sprintf_f(mrs->log, "    br addr: 0x%.8x \n", dir->br);
            print_f(mrs->plog, "fs125", mrs->log);
            
            if (dir->br) {
                dbr = dir->br;
                sprintf_f(mrs->log, "    br status: 0x%x <0x%.8x,0x%.8x,0x%.8x,0x%.8x> SFN[%s]\n",
                    dbr->dfstats, dbr->dfindex, dbr->dfpaid, dbr->dfbrid, dbr->dfchid, dbr->dfSFN);
                print_f(mrs->plog, "fs125", mrs->log);
            }
            /* ch info */
            sprintf_f(mrs->log, "    ch addr: 0x%.8x \n", dir->ch);
            print_f(mrs->plog, "fs125", mrs->log);
            
            if (dir->ch) {
                dch = dir->ch;
                sprintf_f(mrs->log, "    ch status: 0x%x <0x%.8x,0x%.8x,0x%.8x,0x%.8x> SFN[%s]\n",
                    dch->dfstats, dch->dfindex, dch->dfpaid, dch->dfbrid, dch->dfchid, dch->dfSFN);
                print_f(mrs->plog, "fs125", mrs->log);
            }

        }
#endif

        while (txsz > 0) {
            len = ring_buf_get(&mrs->dataRx, &addrd);
            if (len <= 0) {
                sprintf_f(mrs->log, "ERROR!!! get ring buffer failed ret = %d\n", len);
                print_f(mrs->plog, "fs125", mrs->log);
                modersp->r = 0xed;
                return 1;
            }
        
            if (txsz < len) {
                len = txsz;
            }

            memcpy(addrd, src, len);

            totsz += len;
            src += len;
            txsz -= len;
            cpn++;

            ring_buf_prod(&mrs->dataRx);

            sprintf_f(mrs->log, "%d. len:%d, totsz: %d\n", cpn, len, totsz);
            print_f(mrs->plog, "fs125", mrs->log);
        }

        ring_buf_set_last_actual(&mrs->dataRx, len);
        bufn = ring_buf_info_len(&mrs->dataRx);

        sprintf_f(mrs->log, "cpn: %d, bufn: %d\n", cpn, bufn);
        print_f(mrs->plog, "fs125", mrs->log);

        mrs_ipc_put(mrs, "d", 1, 7);

        len = mrs_ipc_get(mrs, &ch, 1, 7);
        while (len <= 0) {
            usleep(1000);
            len = mrs_ipc_get(mrs, &ch, 1, 7);    
        }

        if (ch != 'D') {
            sprintf_f(mrs->log, "WARNING!!! get reponse from p7 is %c, not D\n", ch);
            print_f(mrs->plog, "fs125", mrs->log);
        }

    }
    
    modersp->r = 1;
    return 1;
}

static int fs126(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int ret=0;
    struct sdFAT_s *pFat=0;
    struct sdFatFormat_s *pfatFmt=0;
    struct sdbootsec_s *pfBootsec=0;
    struct sdFSinfo_s    *pfInfosec=0;
    sprintf_f(mrs->log, "building the fat boot sector!!!\n");
    print_f(mrs->plog, "fs126", mrs->log);

    pFat = &mrs->aspFat;
    pfatFmt = &pFat->fatFormat;
    pfBootsec = &pfatFmt->fmtBootsec;
    pfInfosec = &pfatFmt->fmtInfosec;
    
    //pfatFmt->fmtTotSector = 62325760;
    //pfatFmt->fmtHidnSector = 8192;
    //pfatFmt->fmtSectorPerCls = 64;
    
    ret = aspFatFormat(pfatFmt);

    sprintf_f(mrs->log, "print fat boot sector result, ret = %d \n", ret);
    print_f(mrs->plog, "fs126", mrs->log);
    
    debugPrintBootSec(pfBootsec);
    debugPrintInfoSec(pfInfosec);

    pFat->fatStatus |= ASPFAT_STATUS_FMTBSEC | ASPFAT_STATUS_FMTFAT;
    
    modersp->r = 1;
    return 1;
}

static int fs127(struct mainRes_s *mrs, struct modersp_s *modersp) 
{
    uint32_t secStr=0, secLen=0, fstsec=0, lstsec, val=0;
    struct info16Bit_s *p=0, *c=0;
    struct aspConfig_s *pct=0;
    struct sdFAT_s *pFat=0;
    struct sdFatFormat_s *pfatFmt=0;
    struct sdbootsec_s *pfBootsec=0;

    pFat = &mrs->aspFat;
    pfatFmt = &pFat->fatFormat;
    pfBootsec = &pfatFmt->fmtBootsec;

    pct = mrs->configTable;
    c = &mrs->mchine.cur;
    p = &mrs->mchine.tmp;    

    sprintf_f(mrs->log, "prepare address to format FAT\n");
    print_f(mrs->plog, "fs127", mrs->log);

    //curDir = pfat->fatFileUpld;
    //aspFSms2rs(&curDir, &pfat->fatFileUpld, &pfat->fatDirTr);

    if (pfBootsec->secSt == 0) {
    secStr = 0;
    secLen = pfBootsec->secWhroot + pfBootsec->secPrClst;

    c->opinfo = secStr;
    p->opinfo = secLen;

    sprintf_f(mrs->log, "set secStart:%d, secLen:%d \n", secStr, secLen);
    print_f(mrs->plog, "fs127", mrs->log);

    if (secLen < 16) secLen = 16;

    cfgTableSet(pct, ASPOP_SDFAT_WT, 1);

    val = cfgValueOffset(secStr, 24);
    cfgTableSet(pct, ASPOP_SDFAT_STR01, val);
    val = cfgValueOffset(secStr, 16);
    cfgTableSet(pct, ASPOP_SDFAT_STR02, val);
    val = cfgValueOffset(secStr, 8);
    cfgTableSet(pct, ASPOP_SDFAT_STR03, val);
    val = cfgValueOffset(secStr, 0);
    cfgTableSet(pct, ASPOP_SDFAT_STR04, val);
    val = cfgValueOffset(secLen, 24);
    cfgTableSet(pct, ASPOP_SDFAT_LEN01, val);
    val = cfgValueOffset(secLen, 16);
    cfgTableSet(pct, ASPOP_SDFAT_LEN02, val);
    val = cfgValueOffset(secLen, 8);
    cfgTableSet(pct, ASPOP_SDFAT_LEN03, val);
    val = cfgValueOffset(secLen, 0);
    cfgTableSet(pct, ASPOP_SDFAT_LEN04, val);

    cfgTableSet(pct, ASPOP_SDFAT_SDAT, 1);

    modersp->r = 3; /*3 is for SDWT*/            
    }else {
        pFat->fatStatus &= ~ASPFAT_STATUS_FMTBSEC;
        modersp->r = 1; /*3 is for SDWT*/            
    }

    return 1;
}

static int fs128(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int ret=0, clrsz=0, i=0, len=0, totsz=0, cpn=0, bufn=0;
    char *fatRev=0, *bsector2=0, *ftable1=0, *ftable2=0, *rootsec=0, *infoSec=0;
    char fatinit[12] = {0xf8, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f};
    char diskstr[32] = {0x41, 0x53, 0x50, 0x44, 0x49, 0x53, 0x4b, 0x20, 0x20, 0x20, 0x20, 0x28, 0x00, 0x00, 0x00, 0x00,
                                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    char *addr=0;
    struct sdFAT_s *pFat=0;
    struct sdFatFormat_s *pfatFmt=0;
    struct sdbootsec_s *pfBootsec=0;
    struct sdFSinfo_s   *pfInfotsec=0;
    sprintf_f(mrs->log, "clear and write the FAT!!!\n");
    print_f(mrs->plog, "fs128", mrs->log);

    pFat = &mrs->aspFat;
    pfatFmt = &pFat->fatFormat;
    pfBootsec = &pfatFmt->fmtBootsec;
    pfInfotsec = &pfatFmt->fmtInfosec;
    
    clrsz = (pfBootsec->secWhroot + pfBootsec->secPrClst + 1) * 512;

    fatRev = aspMemalloc(clrsz, 10);
    
    memset(fatRev, 0, clrsz);

    bsector2 = fatRev + 512*6;
    ftable1 = fatRev + pfBootsec->secResv * 512;
    ftable2 = ftable1 + pfBootsec->secPrfat * 512;
    rootsec = fatRev + pfBootsec->secWhroot *512;
    infoSec = fatRev + 512;
    
    /* 0  Jump command */        
    aspRawReverse(&fatRev[0], 4, pfBootsec->secJpcmd);
        
    /* 3  system id */
    for (i = 0; i < 8; i++) {
        fatRev[3+i] = pfBootsec->secSysid[i];
    }
    /* 11 sector size */ 
    aspRawReverse(&fatRev[11], 2, pfBootsec->secSize);
    
    /* 13 sector per cluster */
    fatRev[13] = pfBootsec->secPrClst;

    /* 14 reserved sector count*/
    aspRawReverse(&fatRev[14], 2, pfBootsec->secResv);
    
    /* 16 number of FATs */
    fatRev[16] = pfBootsec->secNfat;
    /* 17 skip, number of root dir entries */
    /* 19 skip, total sectors */
    /* 21 medium id */
    fatRev[21] = pfBootsec->secIDm;
    /* 22 skip, sector per FAT */
    /* 24 sector per track */
    aspRawReverse(&fatRev[24], 2, pfBootsec->secPrtrk);
    
    /* 26 number of sides */
    aspRawReverse(&fatRev[26], 2, pfBootsec->secNsid);

    /* 28 number of hidded sectors */
    aspRawReverse(&fatRev[28], 4, pfBootsec->secNhid);
    
    /* 32 total sectors */
    aspRawReverse(&fatRev[32], 4, pfBootsec->secTotal);
    /* 36 sectors per FAT */
    aspRawReverse(&fatRev[36], 4, pfBootsec->secPrfat);
    /* 40 extension flag */
    aspRawReverse(&fatRev[40], 2, pfBootsec->secExtf);
    /* 42 FS version */
    aspRawReverse(&fatRev[42], 2, pfBootsec->secVers);
    /* 44 root cluster */
    aspRawReverse(&fatRev[44], 4, pfBootsec->secRtclst);
    /* 48 FS info */
    aspRawReverse(&fatRev[48], 2, pfBootsec->secFSif);
    /* 50 backup boot sector */ 
    aspRawReverse(&fatRev[50], 2, pfBootsec->secBkbt);
    
    /* 64 physical disk number */
    fatRev[64] = pfBootsec->secPhdk;
    /* 66 extended boot record signature */
    fatRev[66] = pfBootsec->secExtbt;
    /* 67 volume ID number */
    
    aspRawReverse(&fatRev[67], 4, pfBootsec->secVoid);
    
    /* 71 to 81 volume label */
    for (i = 0; i < 11; i++) {
         fatRev[71+i] = pfBootsec->secVola[i];
    }
     
    /* 82 to 89 file system type */
    for (i = 0; i < 8; i++) {
        fatRev[82+i] = pfBootsec->secFtyp[i];
    }
    
    /* 510 signature word */
    aspRawReverse(&fatRev[510], 2, pfBootsec->secSign);

    aspRawReverse(&infoSec[0], 4, pfInfotsec->finLdsn);
    aspRawReverse(&infoSec[484], 4, pfInfotsec->finStsn);
    aspRawReverse(&infoSec[488], 4, pfInfotsec->finFreClst);
    aspRawReverse(&infoSec[492], 4, pfInfotsec->finNxtFreClst);
    aspRawReverse(&infoSec[508], 4, pfInfotsec->finTrsn);
    
    memcpy(bsector2, fatRev, 1024);
    memcpy(ftable1, fatinit, 12);
    memcpy(ftable2, fatinit, 12);
    memcpy(rootsec, diskstr, 32);
    
    shmem_dump(fatRev, 32);
    shmem_dump(infoSec, 32);
    shmem_dump(infoSec+(512-32), 32);
    shmem_dump(bsector2, 32);
    shmem_dump(ftable1, 32);
    shmem_dump(ftable2, 32);
    shmem_dump(rootsec, 32);
    
    ring_buf_init(&mrs->dataRx);

    sprintf_f(mrs->log, "clear area size: %d, trigger spi0 !!\n", clrsz);
    print_f(mrs->plog, "fs128", mrs->log);
    
    while (clrsz > 0) {
    
        len = ring_buf_get(&mrs->dataRx, &addr);
        if (len <= 0) {
            //sprintf_f(mrs->log, "WARNNING!!! get ring buffer pendding ret = %d\n", len);
            //print_f(mrs->plog, "fs128", mrs->log);
            usleep(1000);
            continue;
        }
        
        if (clrsz < len) {
            len = clrsz;
        }

        memcpy(addr, fatRev, len);

        totsz += len;
        fatRev += len;
        clrsz -= len;
        cpn++;
        
        if (cpn == 10) {
            mrs_ipc_put(mrs, "w", 1, 1);
        }

        ring_buf_prod(&mrs->dataRx);

        sprintf_f(mrs->log, "%d. len:%d, totsz: %d\n", cpn, len, totsz);
        print_f(mrs->plog, "fs128", mrs->log);
    }

    ring_buf_set_last(&mrs->dataRx, len);
    bufn = ring_buf_info_len(&mrs->dataRx);
    
    sprintf_f(mrs->log, "cpn: %d, bufn: %d\n", cpn, bufn);
    print_f(mrs->plog, "fs128", mrs->log);

    modersp->v = 0;
    
    modersp->m = modersp->m + 1;

    pfBootsec->secSt = 1; /* flag */
    return 2;
}

static int fs129(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int len=0, bitset=0, ret=0;
    char ch=0;
    struct info16Bit_s *p;

    //sprintf_f(mrs->log, "wait spi0 tx end\n");
    //print_f(mrs->plog, "fs90", mrs->log);

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if (len > 0) {

        sprintf_f(mrs->log, "ch: %c - end\n", ch);
        print_f(mrs->plog, "fs129", mrs->log);

        if (ch == 'W') {

#if SPI_KTHREAD_USE & SPI_UPD_NO_KTHREAD
            bitset = 0;
            ret = msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_STOP_THREAD
            sprintf_f(mrs->log, "Stop spi0 spidev thread, ret: 0x%x\n", ret);
            print_f(mrs->plog, "fs129", mrs->log);
#endif
#if PULL_LOW_AFTER_DATA
            bitset = 0;
            msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
            sprintf_f(mrs->log, "set RDY pin %d\n",bitset);
            print_f(mrs->plog, "fs129", mrs->log);
            usleep(210000);
#endif

            modersp->m = 48;            
            return 2;
        } else {
            modersp->r = 2;
            return 1;
        }
    }
    return 0; 
}

static int fs130(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct sdFAT_s *pFat=0;
    pFat = &mrs->aspFat;

    sprintf_f(mrs->log, "reset FAT start!!!\n");
    print_f(mrs->plog, "fs130", mrs->log);

    memset(pFat, 0, sizeof(struct sdFAT_s));

    pFat->fatDirTr.dirFATMax = FAT_DIRPOO_ARY_MAX;
    pFat->parBuf.dirParseBuff = 0;
    pFat->parBuf.dirBuffUsed = 0;
    pFat->parBuf.dirBuffMax = 0;
    
    pFat->fatStatus = ASPFAT_STATUS_INIT;

    aspMemClear(aspMemAsign, asptotMalloc, 9);

    sprintf_f(mrs->log, "reset FAT  done!!!\n");
    print_f(mrs->plog, "fs130", mrs->log);

    modersp->r = 1;
    return 1;
}

static int fs131(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    sprintf_f(mrs->log, "polling ...\n");
    print_f(mrs->plog, "fs131", mrs->log);

    modersp->d = modersp->m + 1;
    modersp->m = 1;
    return 2;
}

static int fs132(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct info16Bit_s *p;
    p = &mrs->mchine.cur;
    //sprintf_f(mrs->log, "set %d 0x%.2x 0x%.2x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
    //print_f(mrs->plog, "fs132", mrs->log);
    
    mrs_ipc_put(mrs, "h", 1, 1);
    modersp->m = modersp->m + 1;
    return 0; 
}

static int fs133(struct mainRes_s *mrs, struct modersp_s *modersp)
{ 
    int len=0;
    char ch=0;
    struct info16Bit_s *g;

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((len > 0) && (ch == 'H')) {
        msync(&mrs->mchine, sizeof(struct machineCtrl_s), MS_SYNC);

        g = &mrs->mchine.get;
        //sprintf_f(mrs->log, "get %d 0x%.1x 0x%.1x 0x%.2x \n", g->inout, g->seqnum, g->opcode, g->data);
        //print_f(mrs->plog, "fs133", mrs->log);
        
        if (ch == 'X') {
            sprintf_f(mrs->log, "FAIL!!send command again!\n");
            print_f(mrs->plog, "fs133", mrs->log);
            modersp->m = modersp->m - 1;        
            return 2;
        }
        
        if (g->opcode == OP_QRY) {
            modersp->m = modersp->m + 1;
        } else {
            modersp->r = 2;
            return 1;
        }
    }
    
    return 0; 
}

static int fs134(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct info16Bit_s *p;
    p = &mrs->mchine.poll;
    //sprintf_f(mrs->log, "set %d 0x%.1x 0x%.1x 0x%.2x \n", p->inout, p->seqnum, p->opcode, p->data);
    //print_f(mrs->plog, "fs134", mrs->log);
    
    mrs_ipc_put(mrs, "h", 1, 1);
    modersp->m = modersp->m + 1;
    return 0; 
}

static int fs135(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int len=0;
    char ch=0;
    struct info16Bit_s *p, *g;

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if ((len > 0) && (ch == 'H')) {
        msync(&mrs->mchine, sizeof(struct machineCtrl_s), MS_SYNC);

        p = &mrs->mchine.poll;
        g = &mrs->mchine.get;
        //sprintf_f(mrs->log, "get 0x%.2x/0x%.2x 0x%.2x/0x%.2x\n", p->opcode, c->opcode, p->data, c->data);
        //print_f(mrs->plog, "fs135", mrs->log);

        if (ch == 'X') {
            sprintf_f(mrs->log, "FAIL!!send command again!\n");
            print_f(mrs->plog, "fs135", mrs->log);
            modersp->m = modersp->m - 1;        
            return 2;
        }

        if (p->opcode == g->opcode){
            modersp->r = 1;
            return 1;
        } else {
            modersp->r = 2;
            return 1;
        }
    }
    return 0; 
}

static int fs136(struct mainRes_s *mrs, struct modersp_s *modersp)
{
#define SF0 (8 * 0)
#define SF1 (8 * 1)
#define SF2 (8 * 2)
#define SF3 (8 * 3)

    uint32_t val=0, i=0;
    char *pr=0, *ppart=0;
    char system_id=0, end55=0, endaa=0;
    uint32_t secStr=0, secLen=0, secRel=0;
    struct aspConfig_s *pct=0;
    struct sdbootsec_s   *psec=0;
    struct sdFAT_s *pfat=0;
    struct sdParseBuff_s *pParBuf=0;
    struct info16Bit_s *p=0, *c=0;
    
    sprintf_f(mrs->log, "parsing MBR sector \n");
    print_f(mrs->plog, "fs136", mrs->log);

    c = &mrs->mchine.cur;
    p = &mrs->mchine.tmp;
    
    pct = mrs->configTable;
    pfat = &mrs->aspFat;
    pParBuf = &pfat->parBuf;

    if (pParBuf->dirBuffUsed) {
        sprintf_f(mrs->log, "parsing, buff  size:%d\n", pParBuf->dirBuffUsed);
        print_f(mrs->plog, "fs136", mrs->log);

        pParBuf->dirBuffUsed = 0;
        
        psec = &pfat->fatBootsec;
        
        //memset(psec, 0, sizeof(struct sdbootsec_s));
        //msync(psec, sizeof(struct sdbootsec_s), MS_SYNC);
        
        pr = pParBuf->dirParseBuff;
        
        shmem_dump(pr, 512);   
        ppart = &pr[446];
        end55 = pr[510];
        endaa = pr[511];
        shmem_dump(ppart, 16);   
        system_id = ppart[4];
        secRel = ppart[8] | (ppart[9] << 8) | (ppart[10] << 16) | (ppart[11] << 24);

        sprintf_f(mrs->log, "end: 0x%.2x 0x%.2x ,sys id: 0x%.2x, sector relative: %d \n", end55, endaa, system_id, secRel);
        print_f(mrs->plog, "fs136", mrs->log);
        
        //if ((secRel % 32) == 0) {
            if ((secRel * 512) <= (0x4000000)) {
                psec->secBoffset = secRel;
            }
        //}
        
        if ((psec->secBoffset) && (end55 == 0x55) && (endaa == 0xaa) 
            && ((system_id == 0x0c) || (system_id == 0x0b))) {
            pfat->fatStatus |= ASPFAT_STATUS_MBR;
            pfat->fatRetry = 0;
        } else {
            pfat->fatRetry += 1;
            if (pfat->fatRetry > 2) {
                sprintf_f(mrs->log, "!!!! MBR retry times == %d  break!!!!\n", pfat->fatRetry);
                print_f(mrs->plog, "fs136", mrs->log);
                pfat->fatStatus |= ASPFAT_STATUS_MBR;
                psec->secBoffset = 0;                
            }
        }

        sprintf_f(mrs->log, "!!!! offset: %d  !!!!\n", psec->secBoffset);
        print_f(mrs->plog, "fs136", mrs->log);

        modersp->r = 1;
    }else {
        secStr = c->opinfo;
        secLen = p->opinfo;

        sprintf_f(mrs->log, "buff empty, set str:%d(0x%x), len:%d \n", secStr, secStr, secLen);
        print_f(mrs->plog, "fs136", mrs->log);

        cfgTableSet(pct, ASPOP_SDFAT_RD, 1);

        val = cfgValueOffset(secStr, 24);
        cfgTableSet(pct, ASPOP_SDFAT_STR01, val);
        val = cfgValueOffset(secStr, 16);
        cfgTableSet(pct, ASPOP_SDFAT_STR02, val);
        val = cfgValueOffset(secStr, 8);
        cfgTableSet(pct, ASPOP_SDFAT_STR03, val);
        val = cfgValueOffset(secStr, 0);
        cfgTableSet(pct, ASPOP_SDFAT_STR04, val);

        val = cfgValueOffset(secLen, 24);
        cfgTableSet(pct, ASPOP_SDFAT_LEN01, val);
        val = cfgValueOffset(secLen, 16);
        cfgTableSet(pct, ASPOP_SDFAT_LEN02, val);
        val = cfgValueOffset(secLen, 8);
        cfgTableSet(pct, ASPOP_SDFAT_LEN03, val);
        val = cfgValueOffset(secLen, 0);
        cfgTableSet(pct, ASPOP_SDFAT_LEN04, val);

        cfgTableSet(pct, ASPOP_SDFAT_SDAT, 1);

        modersp->r = 2;
    }


    return 1;
}

static int fs137(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct aspConfig_s *pct=0;

    pct = mrs->configTable;

    cfgTableUpd(pct, ASPOP_IMG_LEN, 0);

    cfgTableUpd(pct, ASPOP_CROP_01, 0);
    cfgTableUpd(pct, ASPOP_CROP_02, 0);
    cfgTableUpd(pct, ASPOP_CROP_03, 0);
    cfgTableUpd(pct, ASPOP_CROP_04, 0);
    cfgTableUpd(pct, ASPOP_CROP_05, 0);
    cfgTableUpd(pct, ASPOP_CROP_06, 0);
    cfgTableUpd(pct, ASPOP_CROP_07, 0);
    cfgTableUpd(pct, ASPOP_CROP_08, 0);
    cfgTableUpd(pct, ASPOP_CROP_09, 0);
    cfgTableUpd(pct, ASPOP_CROP_10, 0);
    cfgTableUpd(pct, ASPOP_CROP_11, 0);
    cfgTableUpd(pct, ASPOP_CROP_12, 0);
    cfgTableUpd(pct, ASPOP_CROP_13, 0);
    cfgTableUpd(pct, ASPOP_CROP_14, 0);
    cfgTableUpd(pct, ASPOP_CROP_15, 0);
    cfgTableUpd(pct, ASPOP_CROP_16, 0);
    cfgTableUpd(pct, ASPOP_CROP_17, 0);
    cfgTableUpd(pct, ASPOP_CROP_18, 0);
    
    sprintf_f(mrs->log, "send notice to P6 for stoping meta\n");
    print_f(mrs->plog, "fs137", mrs->log);

    
    mrs_ipc_put(mrs, "c", 1, 7);
    modersp->m = modersp->m + 1;
    
    return 0;
}

static int fs138(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int len=0;
    char ch=0;
    //sprintf_f(mrs->log, "check P6 getting the notice\n");
    //print_f(mrs->plog, "fs138", mrs->log);

    len = mrs_ipc_get(mrs, &ch, 1, 7);

    if (len > 0) {
        sprintf_f(mrs->log, "check P6 getting the stopping notice, len = %d, ch = 0x%.2x\n", len, ch);
        print_f(mrs->plog, "fs138", mrs->log);
  
        len = 0;
        len = mrs_ipc_get(mrs, &ch, 1, 7);
        while (len > 0) {
            sprintf_f(mrs->log, "check P6 getting the stopping notice, len = %d, ch = 0x%.2x\n", len, ch);
            print_f(mrs->plog, "fs138", mrs->log);

            len = mrs_ipc_get(mrs, &ch, 1, 7);        
        }
        
        if (ch == 'E') {
            modersp->r = 0xed;
            return 1;
        }
    }
    
    return 0; 
}

static int fs139(struct mainRes_s *mrs, struct modersp_s *modersp) 
{
    int val=0, i=0, ret=0, dirid=0, tpid=0, chlid=0;
    char *pr=0;
    uint32_t secStr=0, secLen=0, clstByte=0, clstLen=0, freeClst=0, usedClst=0, totClst=0;
    uint64_t totalsize=0;
    struct aspConfig_s *pct=0;
    struct sdbootsec_s   *psec=0;
    struct sdFAT_s *pfat=0;
    struct sdParseBuff_s *pParBuf=0;
    struct info16Bit_s *p=0, *c=0;
    struct directnFile_s *curDir=0, *chlDir=0, *br=0, *getDir1=0, *pa=0, *getDir2;
    struct directnFile_s *tmpDir;
    struct folderQueue_s *pfhead=0, *pfdirt=0, *pfnext=0;
    struct adFATLinkList_s *pflsh=0, *pflnt=0;
    struct adFATLinkList_s *pfre=0, *pnxf=0, *pclst=0;
    struct sdFATable_s   *pftb=0;
    
    c = &mrs->mchine.cur;
    p = &mrs->mchine.tmp;
    
    pct = mrs->configTable;
    pfat = &mrs->aspFat;
    pParBuf = &pfat->parBuf;
    psec = &pfat->fatBootsec;
    pftb = &pfat->fatTable;
    clstByte = psec->secSize * psec->secPrClst;

    tmpDir = aspMemalloc(sizeof(struct directnFile_s), 10);
    memset(tmpDir, 0, sizeof(struct directnFile_s));

    if (!pParBuf->dirParseBuff) {
        pParBuf->dirParseBuff = aspMemalloc(32768, 10);    
        pParBuf->dirBuffMax = 32768;
        sprintf_f(mrs->log, "WARNNING!! buffer is null!! allocate %d bytes, addr: 0x%.8x \n", 32768, (uint32_t)pParBuf->dirParseBuff);
        print_f(mrs->plog, "fs139", mrs->log);
    }
    else {
        sprintf_f(mrs->log, "WARNNING!! buffer is NOT null!! addr: 0x%.8x, used: %d, max: %d \n", 
                       (uint32_t)pParBuf->dirParseBuff, pParBuf->dirBuffUsed, pParBuf->dirBuffMax);
        print_f(mrs->plog, "fs139", mrs->log);
    }
    
    if (!clstByte) {
        sprintf_f(mrs->log, "ERROR!! bytes number of cluster is zero \n");
        print_f(mrs->plog, "fs139", mrs->log);

        modersp->r = 3;
        return 1;
    }

    pfre = pftb->ftbMng.f;
    if (!pfre) {
        sprintf_f(mrs->log, "Error!! free space link list is empty \n");
        print_f(mrs->plog, "fs139", mrs->log);
        modersp->r = 0xed;
        return 1;
    }
    
    if (!pfat->fatFileUpld.dfindex) {
        modersp->r = 0xed;
        return 1;
    } else {
        dirid = pfat->fatFileUpld.dfindex;
        
        chlid = pfat->fatFolderCrt.dfindex;
        
        sprintf_f(mrs->log, "cur folder: [%x] ch [%x], chid:[%x] \n", pfat->fatFileUpld.dfindex, pfat->fatFileUpld.dfchid, chlid);
        print_f(mrs->plog, "fs139", mrs->log);
    }

    sprintf_f(mrs->log, "create folder: [%s] with [%s] inside\n", pfat->fatFileUpld.dfSFN, pfat->fatFolderCrt.dfSFN);
    print_f(mrs->plog, "fs139", mrs->log);
   
    aspFSms2rs(&curDir, &pfat->fatFileUpld, &pfat->fatDirTr);
    if (!curDir) {
        sprintf_f(mrs->log, "get SD cur failed\n");
        print_f(mrs->plog, "fs139", mrs->log);

        modersp->r = 0xed;
        return 1;
    }
    aspFSms2rs(&chlDir, &pfat->fatFolderCrt, &pfat->fatDirTr);
    if (!chlDir) {
        sprintf_f(mrs->log, "get SD chld failed\n");
        print_f(mrs->plog, "fs139", mrs->log);

        modersp->r = 0xed;
        return 1;
    }

    sprintf_f(mrs->log, "print curDir and upldDir: \n");
    print_f(mrs->plog, "fs139", mrs->log);

    debugPrintDir(curDir);
    //debugPrintDir(&pfat->fatFileUpld);
    debugPrintDir(chlDir);
    //debugPrintDir(&pfat->fatFolderCrt);
    
    if (strcmp(curDir->dfSFN, pfat->fatFileUpld.dfSFN) != 0) {
        ret = mspFS_allocDir(&pfat->fatDirTr, &getDir1, 9);
        if (!getDir1) {
            sprintf_f(mrs->log, "get free cur dir space failed, ret: %d\n", ret);
            print_f(mrs->plog, "fs139", mrs->log);

            modersp->r = 0xed;
            return 1;
        }

        ret = mspFS_allocDir(&pfat->fatDirTr, &getDir2, 9);
        if (!getDir2) {
            sprintf_f(mrs->log, "get free chld dir space failed, ret: %d\n", ret);
            print_f(mrs->plog, "fs139", mrs->log);

            modersp->r = 0xed;
            return 1;
        }
        
        tpid = getDir1->dfindex;        
        if (tpid != dirid) {
            curDir = getDir1;
            sprintf_f(mrs->log, "WARNNING!!! reset curdir(id:%d) as %d\n", dirid, tpid);
            print_f(mrs->plog, "fs139", mrs->log);
        }

        sprintf_f(mrs->log, "print cur dir before cp: \n");
        print_f(mrs->plog, "fs139", mrs->log);

        //debugPrintDir(curDir);
        ret = aspFScpDirTr(curDir, &pfat->fatFileUpld, &pfat->fatDirTr);
        if (ret < 0) {
            sprintf_f(mrs->log, "cp dir into file tree failed ret: %d\n", ret);
            print_f(mrs->plog, "fs139", mrs->log);
            modersp->r = 0xed;
            return 1;
        }
        //debugPrintDir(curDir);
        
        if (tpid != dirid) {
            sprintf_f(mrs->log, "WARNNING check curdir(id:%d) not %d\n", curDir->dfindex, dirid);
            print_f(mrs->plog, "fs139", mrs->log);
            aspFScpDir(&pfat->fatFileUpld, curDir);
        }
        
        
        tpid = getDir2->dfindex;        
        if (tpid != chlid) {
            chlDir = getDir2;
            sprintf_f(mrs->log, "WARNNING!!! reset chldir(id:%d) as %d\n", chlid, tpid);
            print_f(mrs->plog, "fs139", mrs->log);
        }        

        sprintf_f(mrs->log, "print chld dir before cp: \n");
        print_f(mrs->plog, "fs139", mrs->log);

        //debugPrintDir(chlDir);
        ret = aspFScpDirTr(chlDir, &pfat->fatFolderCrt, &pfat->fatDirTr);
        if (ret < 0) {
            sprintf_f(mrs->log, "cp dir into file tree failed ret: %d\n", ret);
            print_f(mrs->plog, "fs139", mrs->log);
            modersp->r = 0xed;
            return 1;
        }
        //debugPrintDir(chlDir);
        
        if (tpid != chlid) {
            sprintf_f(mrs->log, "WARNNING check curdir(id:%d) not %d\n", chlDir->dfindex, chlid);
            print_f(mrs->plog, "fs139", mrs->log);
            aspFScpDir(&pfat->fatFolderCrt, chlDir);
        }

        sprintf_f(mrs->log, "print chld and cur dir before insert: \n");
        print_f(mrs->plog, "fs139", mrs->log);

        //debugPrintDir(curDir->pa);
        //debugPrintDir(curDir);

        if (curDir->pa) {
            aspFS_insertFATChild(curDir->pa, curDir);
            sprintf_f(mrs->log, "insert [%s] into [%s] \n", curDir->dfSFN, curDir->pa->dfSFN);
            print_f(mrs->plog, "fs139", mrs->log);
        } else {
            sprintf_f(mrs->log, "WARNNING: [%s] didn't have parent \n", curDir->dfSFN);
            print_f(mrs->plog, "fs139", mrs->log);
        }

        //debugPrintDir(curDir->pa);
        //debugPrintDir(curDir);
        //debugPrintDir(chlDir);
        
        aspFS_insertFATChild(curDir, chlDir);
        sprintf_f(mrs->log, "insert [%s] into [%s] \n", chlDir->dfSFN, chlDir->pa->dfSFN);
        print_f(mrs->plog, "fs139", mrs->log);

        sprintf_f(mrs->log, "[%s] has ch [%s] \n", curDir->dfSFN, curDir->ch->dfSFN);
        print_f(mrs->plog, "fs139", mrs->log);

        //debugPrintDir(curDir);
        //debugPrintDir(chlDir);

        mspFS_list(curDir->pa, 4);
        
    }
    else {
        sprintf_f(mrs->log, "WARNNING get upd dir succeed: [%s](0x%.8x) <== [%s](0x%.8x)\n", curDir->dfSFN, curDir->dfindex, pfat->fatFolderCrt.dfSFN, pfat->fatFolderCrt.dfindex);
        print_f(mrs->plog, "fs139", mrs->log);
    }

    
    if (!pftb->h) {
        pflsh = 0;
        clstLen = 1;
        
        sprintf_f(mrs->log, "needed cluster length: %d \n", clstLen);
        print_f(mrs->plog, "fs139", mrs->log);
        
        ret = mspSD_allocFreeFATList(&pflsh, clstLen, pfre, &pnxf);
        if (ret) {
            sprintf_f(mrs->log, "free FAT table parsing for file upload FAIL!!ret:%d (%s)\n", ret, curDir->dfSFN);
            print_f(mrs->plog, "fs139", mrs->log);
            modersp->r = 0xed;
            return 1;
        } 
        else {
            freeClst = 0;
            if ((pfre != pnxf) && (pnxf)) {
                totClst = (psec->secTotal - psec->secWhroot) / psec->secPrClst;
    
                while (pfre != pnxf) {
                    pclst = pfre;
    
                    pfre = pfre->n;
    
                    sprintf_f(mrs->log, "free used FREE FAT linklist, 0x%.8x start: %d, length: %d \n", (uint32_t)pclst, pclst->ftStart, pclst->ftLen);
                    print_f(mrs->plog, "fs139", mrs->log);
    
                    aspMemFree(pclst, 0);
                    pclst = 0;
                }
            }
    
            pflnt = pnxf;
            while (pflnt) {
                freeClst += pflnt->ftLen;
                sprintf_f(mrs->log, "cal start: %d len:%d \n", pflnt->ftStart, pflnt->ftLen);
                print_f(mrs->plog, "fs139", mrs->log);
                pflnt = pflnt->n;
            }
    
            totalsize = freeClst * psec->secPrClst * psec->secSize;
            sprintf_f(mrs->log, "re-calculate total free cluster: %d free sector: %d (size: %llu) \n", 
                freeClst, freeClst * psec->secPrClst, totalsize);
            print_f(mrs->plog, "fs139", mrs->log);     
            usedClst = totClst - freeClst;
    
            pftb->ftbMng.ftfreeClst = freeClst;
            pftb->ftbMng.ftusedClst = usedClst;
            pftb->ftbMng.f = pnxf;
        }
    
        /* debug */
        sprintf_f(mrs->log, "show allocated FAT list: \n");
        print_f(mrs->plog, "fs139", mrs->log);
    
        val = 0;
        pflnt = pflsh;
        while (pflnt) {
            val += pflnt->ftLen;
            sprintf_f(mrs->log, "    str:%d len:%d - %d\n", pflnt->ftStart, pflnt->ftLen, val);
            print_f(mrs->plog, "fs139", mrs->log);
            pflnt = pflnt->n;
        }
        sprintf_f(mrs->log, "total allocated cluster is %d!! \n", val);
        print_f(mrs->plog, "fs139", mrs->log);

        pftb->h = pflsh;
        pftb->c = pftb->h;

        curDir->dfclstnum = pflsh->ftStart;

        if (pParBuf->dirBuffUsed) {
            sprintf_f(mrs->log, "WARNNING buff used is %d!! \n", pParBuf->dirBuffUsed);
            print_f(mrs->plog, "fs139", mrs->log);
        }
        
        pParBuf->dirBuffUsed = 0;
        pr = pParBuf->dirParseBuff;
        sprintf_f(mrs->log, "dump parsing buffer addr: 0x%.8x\n", (uint32_t)pr);
        print_f(mrs->plog, "fs139", mrs->log);
        shmem_dump(pr, 64);
        
        memset(pr, 0x0, pParBuf->dirBuffMax);

        memcpy(tmpDir, curDir, sizeof(struct directnFile_s));
        tmpDir->dflen = 0;

        //memset(&tmpDir.dfSFN[0], 0x20, 16);
        //tmpDir.dfSFN[0] = 0x2e;
        
        strcpy(tmpDir->dfSFN, ".");
        aspCompirseDEF(pr, tmpDir);
        
        pa = curDir->pa;
        if (!pa) {
            sprintf_f(mrs->log, "WARNNING curDir has no pa !!! \n");
            print_f(mrs->plog, "fs139", mrs->log);
        } else {
            sprintf_f(mrs->log, "curDir's pa = [%s] !!! \n", pa->dfSFN);
            print_f(mrs->plog, "fs139", mrs->log);
        }
        tmpDir->dfclstnum = pa->dfclstnum;
        //tmpDir.dfSFN[1] = 0x2e;
        pr += 32;

        strcpy(tmpDir->dfSFN, "..");
        aspCompirseDEF(pr, tmpDir);
        
        shmem_dump(pParBuf->dirParseBuff, 64);
        pParBuf->dirBuffUsed = 64;
        
        pfat->fatStatus |= ASPFAT_STATUS_FOLDRWT;
        pfat->fatStatus |= ASPFAT_STATUS_FATWT;
        pfat->fatStatus |= ASPFAT_STATUS_DFECHK;
        pfat->fatStatus |= ASPFAT_STATUS_DFEWT;
        modersp->r = 1;
    }
    else {
        sprintf_f(mrs->log, "ERROR!!! header of FAT link list is not empty!! \n");
        print_f(mrs->plog, "fs139", mrs->log);
        modersp->r = 0xed;
    }

    return 1;
}

static int fs140(struct mainRes_s *mrs, struct modersp_s *modersp) 
{
    int val=0, i=0, ret=0, tpid=0, dirid;
    char *pr=0;
    uint32_t secStr=0, secLen=0, fstsec=0, lstsec;
    struct aspConfig_s *pct=0;
    struct sdbootsec_s   *psec=0;
    struct sdFAT_s *pfat=0;
    struct sdParseBuff_s *pParBuf=0;
    struct info16Bit_s *p=0, *c=0;
    struct directnFile_s *curDir=0, *ch=0, *br=0, *getDir=0;
    struct folderQueue_s *pfhead=0, *pfdirt=0, *pfnext=0;
    struct adFATLinkList_s *pflsh=0, *pflnt=0;
    struct sdFATable_s   *pftb=0;


    c = &mrs->mchine.cur;
    p = &mrs->mchine.tmp;
    
    pct = mrs->configTable;
    pfat = &mrs->aspFat;
    pParBuf = &pfat->parBuf;
    psec = &pfat->fatBootsec;
    pftb = &pfat->fatTable;

    //curDir = &pfat->fatFileUpld;
    if (!pfat->fatFileUpld.dfindex) {
        modersp->r = 0xed;
        return 1;
    } else {
        dirid = pfat->fatFileUpld.dfindex;
    }

    aspFSms2rs(&curDir, &pfat->fatFileUpld, &pfat->fatDirTr);
    
    if (!curDir) {
        sprintf_f(mrs->log, "get SD cur failed\n");
        print_f(mrs->plog, "fs140", mrs->log);

        modersp->r = 0xed;
        return 1;
    }

    //aspFScpDir(curDir, &pfat->fatFileUpld);
    //if (curDir->dflength != pfat->fatFileUpld.dflength) {
    if (strcmp(curDir->dfSFN, pfat->fatFileUpld.dfSFN) != 0) {
        ret = aspFScpDirTr(curDir, &pfat->fatFileUpld, &pfat->fatDirTr);
        if (ret < 0) {
            sprintf_f(mrs->log, "cp dir into file tree failed ret: %d\n", ret);
            print_f(mrs->plog, "fs140", mrs->log);
            modersp->r = 0xed;
            return 1;
        }

        tpid = getDir->dfindex;        
        if (tpid != dirid) {
            curDir = getDir;
            sprintf_f(mrs->log, "WARNNING!!! reset curdir(id:%d) as %d\n", dirid, tpid);
            print_f(mrs->plog, "fs140", mrs->log);
        }

        if (curDir->pa) {
            aspFS_insertFATChild(curDir->pa, curDir);
            sprintf_f(mrs->log, "insert [%s] into [%s] \n", curDir->dfSFN, curDir->pa->dfSFN);
            print_f(mrs->plog, "fs140", mrs->log);
        } else {
            sprintf_f(mrs->log, "WARNNING: [%s] didn't have parent \n", curDir->dfSFN);
            print_f(mrs->plog, "fs140", mrs->log);
        }

        if (tpid != dirid) {
            sprintf_f(mrs->log, "check curdir(id:%d) not %d\n", curDir->dfindex, dirid);
            print_f(mrs->plog, "fs140", mrs->log);
            aspFScpDir(&pfat->fatFolderCrt, curDir);
        }

    } else {
        sprintf_f(mrs->log, "get upd dir succeed: [%s] <== [%s]\n", curDir->dfSFN, pfat->fatFileUpld.dfSFN);
        print_f(mrs->plog, "fs140", mrs->log);
    }


    sprintf_f(mrs->log, "get SD cur:0x%.8x filename:[%s]length[%d]\n", (uint32_t)pftb->c, curDir->dfSFN, curDir->dflength);
    print_f(mrs->plog, "fs140", mrs->log);

    if (pftb->c) {
        pflnt = pftb->c;
                 
        secStr = (pflnt->ftStart - 2) * psec->secPrClst + psec->secWhroot;
        secLen = 16; //pflnt->ftLen * psec->secPrClst;

        c->opinfo = secStr;
        p->opinfo = secLen;

        //if (secLen < 16) secLen = 16;

        sprintf_f(mrs->log, "set secStart:%d, secLen:%d \n", secStr, secLen);
        print_f(mrs->plog, "fs140", mrs->log);

        cfgTableSet(pct, ASPOP_SDFAT_WT, 1);

        val = cfgValueOffset(secStr, 24);
        cfgTableSet(pct, ASPOP_SDFAT_STR01, val);
        val = cfgValueOffset(secStr, 16);
        cfgTableSet(pct, ASPOP_SDFAT_STR02, val);
        val = cfgValueOffset(secStr, 8);
        cfgTableSet(pct, ASPOP_SDFAT_STR03, val);
        val = cfgValueOffset(secStr, 0);
        cfgTableSet(pct, ASPOP_SDFAT_STR04, val);
        val = cfgValueOffset(secLen, 24);
        cfgTableSet(pct, ASPOP_SDFAT_LEN01, val);
        val = cfgValueOffset(secLen, 16);
        cfgTableSet(pct, ASPOP_SDFAT_LEN02, val);
        val = cfgValueOffset(secLen, 8);
        cfgTableSet(pct, ASPOP_SDFAT_LEN03, val);
        val = cfgValueOffset(secLen, 0);
        cfgTableSet(pct, ASPOP_SDFAT_LEN04, val);

        cfgTableSet(pct, ASPOP_SDFAT_SDAT, 1);
        
        modersp->r = 3; /*3 is for SDWT*/

        pftb->c = pflnt->n;
        //aspMemFree(pflnt, 0);

    }else {
        pfat->fatStatus &= ~ASPFAT_STATUS_FOLDRWT;    
        pftb->c = pftb->h;
        //pfat->fatFileUpld = 0;
        //pftb->h = 0;
        modersp->r = 1;
    }

    return 1;
}

static int fs141(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    struct sdParseBuff_s *pabuf=0;
    char *addr=0, *src=0;
    int bitset, ret, maxsz, totsz=0, bufn=0, cpn=0, len=0;
    sprintf_f(mrs->log, "trigger spi0\n");
    print_f(mrs->plog, "fs141", mrs->log);

    pabuf = &mrs->aspFat.parBuf;
    
#if SPI_KTHREAD_USE & SPI_UPD_NO_KTHREAD
    bitset = 0;
    ret = msp_spi_conf(mrs->sfm[0], _IOR(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_START_THREAD
    sprintf_f(mrs->log, "Start spi0 spidev thread, ret: 0x%x\n", ret);
    print_f(mrs->plog, "fs141", mrs->log);
#endif

    ring_buf_init(&mrs->dataRx);

    maxsz = pabuf->dirBuffMax;
    src = pabuf->dirParseBuff;

    sprintf_f(mrs->log, "buff size: %d\n", maxsz);
    print_f(mrs->plog, "fs141", mrs->log);

    while (maxsz > 0) {
        len = ring_buf_get(&mrs->dataRx, &addr);
        if (len <= 0) {
            sprintf_f(mrs->log, "ERROR!!! get ring buffer failed ret = %d\n", len);
            print_f(mrs->plog, "fs141", mrs->log);
            modersp->r = 0xed;
            return 1;
        }
        
        if (maxsz < len) {
            len = maxsz;
        }

        memcpy(addr, src, len);

        totsz += len;
        src += len;
        maxsz -= len;
        cpn++;

        ring_buf_prod(&mrs->dataRx);

        sprintf_f(mrs->log, "%d. len:%d, totsz: %d\n", cpn, len, totsz);
        print_f(mrs->plog, "fs141", mrs->log);
    }

    ring_buf_set_last(&mrs->dataRx, len);
    bufn = ring_buf_info_len(&mrs->dataRx);
    
    sprintf_f(mrs->log, "cpn: %d, bufn: %d\n", cpn, bufn);
    print_f(mrs->plog, "fs141", mrs->log);

    mrs_ipc_put(mrs, "w", 1, 1);
    modersp->v = 0;
    
    modersp->m = modersp->m + 1;
    return 2;
}

static int fs142(struct mainRes_s *mrs, struct modersp_s *modersp) 
{
    int bitset, ret;
    sprintf_f(mrs->log, "data flow upload to SD\n");
    print_f(mrs->plog, "fs142", mrs->log);

    sprintf_f(mrs->log, "trigger spi0\n");
    print_f(mrs->plog, "fs142", mrs->log);

#if SPI_KTHREAD_USE & SPI_UPD_NO_KTHREAD
    bitset = 0;
    ret = msp_spi_conf(mrs->sfm[0], _IOR(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_START_THREAD
    sprintf_f(mrs->log, "Start spi0 spidev thread, ret: 0x%x\n", ret);
    print_f(mrs->plog, "fs142", mrs->log);
#endif

    ring_buf_init(&mrs->cmdTx);

    //mrs_ipc_put(mrs, "u", 1, 3);
    //clock_gettime(CLOCK_REALTIME, &mrs->time[0]);
    //mrs_ipc_put(mrs, "u", 1, 8);
            
    modersp->m = modersp->m + 2;
    return 2;
}

static int fs143(struct mainRes_s *mrs, struct modersp_s *modersp) 
{ 
    int ret, bitset;
    char ch;

    //sprintf_f(mrs->log, "%d\n", modersp->v);
    //print_f(mrs->plog, "fs143", mrs->log);

    ret = mrs_ipc_get(mrs, &ch, 1, 3);
    while (ret > 0) {
        if (ch == 'u') {
            modersp->v += 1;
            //mrs_ipc_put(mrs, "u", 1, 1);
        } else if (ch == 'h'){
            mrs_ipc_put(mrs, "u", 1, 8);
        }

        if (ch == 'U') {
            sprintf_f(mrs->log, "0 %d end\n", modersp->v);
            print_f(mrs->plog, "fs143", mrs->log);

            //mrs_ipc_put(mrs, "U", 1, 1);

            mrs_ipc_put(mrs, "U", 1, 8);
            
            modersp->r |= 0x1;
        }
        ret = mrs_ipc_get(mrs, &ch, 1, 3);
    }

    if (modersp->r & 0x1) {
        sprintf_f(mrs->log, "%d end\n", modersp->v);
        print_f(mrs->plog, "fs143", mrs->log);
        modersp->m = modersp->m + 1;
        return 2;
    }

    return 0; 
}

static int fs144(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    int len=0, bitset=0, ret=0;
    char ch=0;
    struct info16Bit_s *p;

    //sprintf_f(mrs->log, "wait spi0 tx end\n");
    //print_f(mrs->plog, "fs142", mrs->log);

    len = mrs_ipc_get(mrs, &ch, 1, 1);
    if (len > 0) {

        sprintf_f(mrs->log, "ch: %c - end\n", ch);
        print_f(mrs->plog, "fs144", mrs->log);

        if (ch == 'W') {

#if SPI_KTHREAD_USE & SPI_UPD_NO_KTHREAD
            bitset = 0;
            ret = msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 14, __u32), &bitset);  //SPI_IOC_STOP_THREAD
            sprintf_f(mrs->log, "Stop spi0 spidev thread, ret: 0x%x\n", ret);
            print_f(mrs->plog, "fs144", mrs->log);
#endif
#if PULL_LOW_AFTER_DATA
            bitset = 0;
            msp_spi_conf(mrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
            sprintf_f(mrs->log, "set RDY pin %d\n",bitset);
            print_f(mrs->plog, "fs144", mrs->log);
            usleep(210000);
#endif

            modersp->m = 48;            
            return 2;
        } else {
            modersp->r = 2;
            return 1;
        }
    }
    return 0; 
}

#define DBG_USB_GATE (0)
#define MAX_145_EVENT (11)
static int fs145(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    sprintf_f(mrs->log, "usb gate !!!\n");
    print_f(mrs->plog, "fs145", mrs->log);

    char filenames[] = "/root/scaner/id_%.5d.bin";
    char idfile[128];
    FILE *filefd=0;
    struct usbhost_s *ppup, *ppdn;
    struct pollfd pllfd[MAX_145_EVENT];
    int *dvtx=0, *dvrx=0;
    int *uphstx=0, *uphsrx=0;
    int *updvtx=0, *updvrx=0;
    int *dnhstx=0, *dnhsrx=0;
    int *dndvtx=0, *dndvrx=0;
    
    int ptret=0, ins=0, evcnt=0, ons=0, gerr=0;
    char chp=0, chq=0, cswinf=0, pllinf=0, chv=0;
    char pllcmd[MAX_145_EVENT];
    char latcmd[MAX_145_EVENT];
    char matcmd[MAX_145_EVENT];
    char minfo[12];
    char cordbuf[16];
    char indexfo[2];
    char midxfo[2];
    char chindex[2];
    char pollfo[2];
    int outfd[MAX_145_EVENT];
    int infd[MAX_145_EVENT];
    char chu=0, chs=0, cmdex=0;
    int uidx=12, sidx=13, lenrt=0;

    struct shmem_s *ringbf[4];
    char *addrd, *addrs, *addrc;
    uint32_t *add32d, *add32s;
    int lens=-1, szup=0, szdn=0, lastlen=0, ret=0, lasflag=0, val=0, csws=0, mlen=0, cswd=0, dlen=0, len=0;
    int wfileid=0, acusz=0, maxsz=0, fileidcnt=0;
    int totsz[MAX_145_EVENT];
    int cycCnt[MAX_145_EVENT];
    int idxInit=0;
    int memsz=0, pageidx=0, trunkidx=0, memallocsz=0;
    int mindex=0, scnt=0, smax=0;
    uint32_t wfiaddr=0, gval=0, resltion=0;

    struct usbBuffLink_s *pubffh=0, *pubffcd[4], *pubfft=0, *pubffm=0, *pubffo=0, *pubffedt=0;
    struct usbBuff_s *curbf=0, *headbf=0, *tmpbf=0, *outbf=0;

    int prisec=0;
    struct sdFAT_s *pfat=0;
    struct aspConfig_s *pct=0;
    struct aspMetaDataviaUSB_s *ptscaninfo=0, *ptscaninfoduo=0;
    struct aspMetaDataviaUSB_s *ptinfomod=0;
    int ix=0, iv=0;
    char *exptbuff=0;

    //exptbuff = aspMemalloc(32768, 10);
    
    pct = mrs->configTable;

    ptscaninfo = &mrs->metaUsbfs145;
    ptscaninfoduo =&mrs->metaUsbDuofs145;
    
    pfat = &mrs->aspFat;

    ppup = mrs->usbhost[0];
    ppdn = mrs->usbhost[1];

    idxInit = 1;

    cycCnt[0] = 0;
    cycCnt[1] = 0;
    cycCnt[2] = 0;
    cycCnt[3] = 0;
    
    pubffcd[0] = 0;
    pubffcd[1] = 0;
    pubffcd[2] = 0;
    pubffcd[3] = 0;
    
    ringbf[0] = ppup->pushring;
    ringbf[1] = ppup->pgatring;
    ringbf[2] = ppdn->pushring;
    ringbf[3] = ppdn->pgatring;

    ins += 1;
    uphstx = ppup->pushtx;
    
    #if DBG_USB_GATE
    sprintf_f(mrs->log, "[GW] uphstx 0:%d 1:%d (%d)\n", uphstx[0], uphstx[1], ins);
    print_f(mrs->plog, "fs145", mrs->log);
    #endif

    ins += 1;    
    uphsrx = ppup->pushrx;
    
    #if DBG_USB_GATE
    sprintf_f(mrs->log, "[GW] uphsrx 0:%d 1:%d (%d)\n", uphsrx[0], uphsrx[1], ins);
    print_f(mrs->plog, "fs145", mrs->log);
    #endif

    ins += 1;
    updvtx = ppup->pgattx;

    #if DBG_USB_GATE
    sprintf_f(mrs->log, "[GW] updvtx 0:%d 1:%d (%d)\n", updvtx[0], updvtx[1], ins);
    print_f(mrs->plog, "fs145", mrs->log);
    #endif

    ins += 1;
    updvrx = ppup->pgatrx;
    
    #if DBG_USB_GATE
    sprintf_f(mrs->log, "[GW] updvrx 0:%d 1:%d (%d)\n", updvrx[0], updvrx[1], ins);
    print_f(mrs->plog, "fs145", mrs->log);
    #endif

    ins += 1;
    dnhstx = ppdn->pushtx;

    #if DBG_USB_GATE
    sprintf_f(mrs->log, "[GW] dnhstx 0:%d 1:%d (%d)\n", dnhstx[0], dnhstx[1], ins);
    print_f(mrs->plog, "fs145", mrs->log);
    #endif
    
    ins += 1;
    dnhsrx = ppdn->pushrx;

    #if DBG_USB_GATE
    sprintf_f(mrs->log, "[GW] dnhsrx 0:%d 1:%d (%d)\n", dnhsrx[0], dnhsrx[1], ins);
    print_f(mrs->plog, "fs145", mrs->log);
    #endif
    
    ins += 1;
    dndvtx = ppdn->pgattx;

    #if DBG_USB_GATE
    sprintf_f(mrs->log, "[GW] dndvtx 0:%d 1:%d (%d)\n", dndvtx[0], dndvtx[1], ins);
    print_f(mrs->plog, "fs145", mrs->log);
    #endif
    
    ins += 1;
    dndvrx = ppdn->pgatrx;

    #if DBG_USB_GATE
    sprintf_f(mrs->log, "[GW] dndvrx 0:%d 1:%d (%d)\n", dndvrx[0], dndvrx[1], ins);
    print_f(mrs->plog, "fs145", mrs->log);
    #endif
    
    pllfd[0].fd = uphstx[0];
    pllfd[0].events = POLLIN;
    outfd[0] = updvtx[1];
    infd[0] = uphsrx[1];

    pllfd[1].fd = updvrx[0];
    pllfd[1].events = POLLIN;
    outfd[1] = uphsrx[1];
    infd[1] = updvtx[1];
    
    pllfd[2].fd = dnhstx[0];
    pllfd[2].events = POLLIN;
    outfd[2] = dndvtx[1];
    infd[2] = dnhsrx[1];
    
    pllfd[3].fd = dndvrx[0];
    pllfd[3].events = POLLIN;
    outfd[3] = dnhsrx[1];
    infd[3] = dndvtx[1];

    //mrs_ipc_get(struct mainRes_s * mrs, char * str, int size, int idx)

    pllfd[4].fd = mrs->pipeup[12].rt[0];
    pllfd[4].events = POLLIN;

    pllfd[5].fd = mrs->pipeup[13].rt[0];
    pllfd[5].events = POLLIN;

    pllfd[6].fd = mrs->pipeup[7].rt[0];
    pllfd[6].events = POLLIN;

    pllfd[7].fd = mrs->pipeup[3].rt[0];
    pllfd[7].events = POLLIN;

    pllfd[8].fd = mrs->pipeup[8].rt[0];
    pllfd[8].events = POLLIN;

    pllfd[9].fd = mrs->pipeup[1].rt[0];
    pllfd[9].events = POLLIN;

    pllfd[10].fd = mrs->pipeup[2].rt[0];
    pllfd[10].events = POLLIN;
    
    while (1) {
        ret = read(pllfd[1].fd, &chv, 1);
        while (ret > 0) {
            ret = read(pllfd[1].fd, &chv, 1);
        }

        ret = read(pllfd[3].fd, &chv, 1);
        while (ret > 0) {
            ret = read(pllfd[3].fd, &chv, 1);
        }
        
        ret = read(pllfd[0].fd, &chv, 1);
        if ((ret > 0) && (chv == 'n')) {
            latcmd[0] = 0;
            latcmd[1] = 0;
            latcmd[2] = 0;
            latcmd[3] = 0;

            matcmd[0] = 0;
            matcmd[1] = 0;
            matcmd[2] = 0;
            matcmd[3] = 0;

            idxInit = 1;

            //cswinf = 0;

            totsz[0] = 0;
            totsz[1] = 0;
            totsz[2] = 0;
            totsz[3] = 0;

            break;
        }
    }
    
    while(1) {
        ptret = poll(pllfd, MAX_145_EVENT, 100);
        //sprintf_f(mrs->log, "[GW] ===== poll return %d =====\n", ptret);
        //print_f(mrs->plog, "fs145", mrs->log);
        if (ptret < 0) {
            perror("poll");
            sprintf_f(mrs->log, "poll failed, errno: %d\n", errno);
            print_f(mrs->plog, "fs145", mrs->log);
        }
        
        if (ptret > 0) {
            evcnt = 0;
            memset(pllcmd, 0, MAX_145_EVENT);
            for (ins=0; ins < MAX_145_EVENT; ins++) {
                if ((pllfd[ins].revents & POLLIN) == POLLIN) {
                
                    read(pllfd[ins].fd, &pllcmd[ins], 1);
                    
                    #if DBG_USB_GATE
                    sprintf_f(mrs->log, "[GW] id:%d pipe%d get chr: %c(0x%.2x) total:%d\n", ins, pllfd[ins].fd, pllcmd[ins], pllcmd[ins], ptret);
                    print_f(mrs->plog, "fs145", mrs->log);
                    #endif
                    
                    evcnt++;
                    if (ptret == evcnt) {
                        break;
                    }
                }
            }
            
            evcnt = 0;
            for (ins=0; ins < MAX_145_EVENT; ins++) {
            
                if (pllcmd[ins]) {
                    evcnt++;
                    switch(ins) {

                    case 9:
                    case 10:
                        //sprintf_f(mrs->log, "[GW] get ch from p3: %c (0x%.2x) \n", pllcmd[ins], pllcmd[ins]);
                        //print_f(mrs->plog, "fs145", mrs->log);
                        
                        mrs_ipc_get(mrs, minfo, 2, 2);
                        
                        //sprintf_f(mrs->log, "[GW] get info: 0x%.2x + 0x%.2x org: 0x%.2x + 0x%.2x  \n", minfo[0], minfo[1], indexfo[0], indexfo[1]);
                        //print_f(mrs->plog, "fs145", mrs->log);

                        mindex = ((minfo[0] & 0x3f) << 5) | (minfo[1] & 0x1f);
                        mindex = mindex & 0x3ff;

                        pubffedt = pubffh;
                        while (pubffedt) {
                            
                            #if DBG_USB_GATE
                            sprintf_f(mrs->log, "    [CROP]  check 0x%.3x  get index: 0x%.3x \n", pubffedt->ubindex & 0x3ff, mindex);
                            print_f(mrs->plog, "fs145", mrs->log);
                            #endif
                            
                            if ((pubffedt->ubindex & 0x3ff) == mindex) {
                                break;
                            }
                            pubffedt = pubffedt->ubnxt;
                        }
                        
                        if (pubffedt) {
                            ptinfomod = (struct aspMetaDataviaUSB_s *)pubffedt->ubinfoaddr;
                        }

                        if (ptinfomod) {
                            addrc = (char *)&ptinfomod->CROP_POS_F1;
                            
                            ret = mrs_ipc_get(mrs, addrc, 16, 2);
                            if (ret != 16) {
                                sprintf_f(mrs->log, "Error !!! get crop ch result ret: %d != 16 \n", ret);
                                print_f(mrs->plog, "fs145", mrs->log);
                            }

                            //sprintf_f(mrs->log, "10 dump crop ch result ret: %d \n", ret);
                            //print_f(mrs->plog, "fs145", mrs->log);

                            //shmem_dump(addrc, 16);

                            //dbgMetaUsb(ptinfomod);
                        } else {
                            ret = mrs_ipc_get(mrs, cordbuf, 16, 2);
                            if (ret != 16) {
                                sprintf_f(mrs->log, "Error !!! get crop ch result ret: %d != 16 \n", ret);
                                print_f(mrs->plog, "fs145", mrs->log);
                            }

                            sprintf_f(mrs->log, "[GW] Error!!! can't find scan info address, get cord ret: %d\n", ret);
                            print_f(mrs->plog, "fs145", mrs->log);

                            shmem_dump(cordbuf, 16);
                        }

                        //sprintf_f(mrs->log, "[GW] pri or sec: %d\n", ptinfomod->PRI_O_SEC);
                        //print_f(mrs->plog, "fs145", mrs->log);

                        if (ptinfomod->PRI_O_SEC == 0) {
                            write(outfd[1], minfo, 2);
                        } else {
                            write(outfd[3], minfo, 2);
                        }

                        break;
                    case 7:
                        modersp->c ++;
                        if (pllcmd[ins] == 'N') {
                            sprintf_f(mrs->log, "[GW] WiFi end transmit count: %d / %d!!! \n", modersp->c, modersp->v);
                            print_f(mrs->plog, "fs145", mrs->log);
                            
                            val = 0;
                            ret = cfgTableGetChk(mrs->configTable, ASPOP_MULTI_LOOP, &val, ASPOP_STA_WR);    
                            if (ret < 0) {
                                sprintf_f(mrs->log, "get pll%d ASPOP_MULTI_LOOP !!! ret: %d val: %d \n", ins, ret, val);
                                print_f(mrs->plog, "fs145", mrs->log);
                            }

                            csws = 0;
                            cfgTableGetChk(mrs->configTable, ASPOP_SCAN_STATUS, &csws, ASPOP_STA_UPD);
                            if (ret < 0) {
                                sprintf_f(mrs->log, "get pll%d ASPOP_SCAN_STATUS !!! ret: %d csws: 0x%.2x \n", ins, ret, csws);
                                print_f(mrs->plog, "fs145", mrs->log);
                            }

                            sprintf_f(mrs->log, "pll%d get ASPOP_SCAN_STATUS(0x%.2x) ASPOP_MULTI_LOOP(%d) \n", ins, csws, val);
                            print_f(mrs->plog, "fs145", mrs->log);

                            #if 1 /* test stopping multiple scan */
                            if ((csws) && (val)) {
                                cfgTableUpd(mrs->configTable, ASPOP_IMG_LEN, 0);
                            }
                            #endif
                                
                            if (modersp->t) {
                                mrs_ipc_put(mrs, "d", 1, 7);
                            } else {
                                mrs_ipc_put(mrs, "c", 1, 7);
                            }
                        }
                        break;
                    case 8:
                        modersp->c ++;
                        if (pllcmd[ins] == 'N') {
                            sprintf_f(mrs->log, "[GW] WiFi end duo transmit count: %d / %d!!! \n", modersp->c, modersp->v);
                            print_f(mrs->plog, "fs145", mrs->log);
                            
                            val = 0;
                            ret = cfgTableGetChk(mrs->configTable, ASPOP_MULTI_LOOP, &val, ASPOP_STA_WR);    
                            if (ret < 0) {
                                sprintf_f(mrs->log, "get pll%d ASPOP_MULTI_LOOP !!! ret: %d val: %d \n", ins, ret, val);
                                print_f(mrs->plog, "fs145", mrs->log);
                            }

                            csws = 0;
                            ret = cfgTableGetChk(mrs->configTable, ASPOP_SCAN_STATUS_DUO, &csws, ASPOP_STA_UPD);
                            if (ret < 0) {
                                sprintf_f(mrs->log, "get pll%d ASPOP_SCAN_STATUS_DUO !!! ret: %d csws: 0x%.2x \n", ins, ret, csws);
                                print_f(mrs->plog, "fs145", mrs->log);
                            }

                            sprintf_f(mrs->log, "pll%d get ASPOP_SCAN_STATUS_DUO(0x%.2x) ASPOP_MULTI_LOOP(%d) \n", ins, csws, val);
                            print_f(mrs->plog, "fs145", mrs->log);

                            #if 1 /* test stopping multiple scan */
                            if ((csws) && (val)) {
                                cfgTableUpd(mrs->configTable, ASPOP_IMG_LEN_DUO, 0);
                            }
                            #endif
                            
                            if (modersp->t) {
                                mrs_ipc_put(mrs, "d", 1, 7);
                            } else {
                                mrs_ipc_put(mrs, "c", 1, 7);
                            }

                        }
                        break;
                    case 6:
                        chu = pllcmd[ins];
                        
                        val = 0;
                        ret = cfgTableGetChk(mrs->configTable, ASPOP_MULTI_LOOP, &val, ASPOP_STA_WR);    
                        if (ret < 0) {
                            sprintf_f(mrs->log, "Error get pll%d ASPOP_MULTI_LOOP failed!!! ret: %d val: %d\n", ins, ret, val);
                            print_f(mrs->plog, "fs145", mrs->log);
                        }
                        
                        sprintf_f(mrs->log, "get pll%d ASPOP_MULTI_LOOP val: %d!!! ret: %d signal: %c \n", ins, val, ret, chu);
                        print_f(mrs->plog, "fs145", mrs->log);

                        if (chu == 'C') {
                            if (val) {
                                mrs_ipc_put(mrs, "t", 1, 12);
                                continue;
                            } else {
                                mrs_ipc_put(mrs, "b", 1, 13);
                            }
                        } else if (chu == 'D') {
                            if (val) {
                                mrs_ipc_put(mrs, "o", 1, 12);
                                mrs_ipc_put(mrs, "o", 1, 13);
                                continue;
                            } else {
                                mrs_ipc_put(mrs, "b", 1, 13);
                            }
                        } else {
                            csws = 0;
                            cfgTableGetChk(mrs->configTable, ASPOP_SCAN_STATUS, &csws, ASPOP_STA_UPD);
                            if (ret < 0) {
                                sprintf_f(mrs->log, "get pll%d ASPOP_SCAN_STATUS !!! ret: %d csws: 0x%.2x \n", ins, ret, csws);
                                print_f(mrs->plog, "fs145", mrs->log);
                            }
                        
                            mlen = 0;
                            ret = cfgTableGetChk(mrs->configTable, ASPOP_IMG_LEN, &mlen, ASPOP_STA_APP);    
                            if (ret < 0) {
                                sprintf_f(mrs->log, "Error get pll%d ASPOP_IMG_LEN failed!!! ret: %d mlen: %d\n", ins, ret, mlen);
                                print_f(mrs->plog, "fs145", mrs->log);
                            }

                            cswd = 0;
                            cfgTableGetChk(mrs->configTable, ASPOP_SCAN_STATUS_DUO, &cswd, ASPOP_STA_UPD);
                            if (ret < 0) {
                                sprintf_f(mrs->log, "get pll%d ASPOP_SCAN_STATUS_DUO !!! ret: %d csws: 0x%.2x \n", ins, ret, cswd);
                                print_f(mrs->plog, "fs145", mrs->log);
                            }
                        
                            dlen = 0;
                            ret = cfgTableGetChk(mrs->configTable, ASPOP_IMG_LEN_DUO, &dlen, ASPOP_STA_APP);    
                            if (ret < 0) {
                                sprintf_f(mrs->log, "Error get pll%d ASPOP_IMG_LEN_DUO failed!!! ret: %d mlen: %d\n", ins, ret, dlen);
                                print_f(mrs->plog, "fs145", mrs->log);
                            }

                            sprintf_f(mrs->log, "chu: [%c] csws: 0x%.2x mlen: %d cswd: 0x%.2x dlen: %d \n", chu, csws, mlen, cswd, dlen);
                            print_f(mrs->plog, "fs145", mrs->log);
                            
                            if (chu == 'E') {
                                if ((mlen == 0) || (csws != 0)) {
                                    pfat->fatSupdata = 0;
                                    pfat->fatSupcur = 0;

                                    mrs_ipc_put(mrs, "b", 1, 13);
                                
                                    sprintf_f(mrs->log, "P6 response BREAK loop chu = %c \n", chu);
                                    print_f(mrs->plog, "fs145", mrs->log);                                    
                                } else {
                                    mrs_ipc_put(mrs, "e", 1, 12);
                                    
                                    mrs_ipc_put(mrs, "t", 1, 12);
                                    
                                    sprintf_f(mrs->log, "P6 response CONTINUE loop chu = %c \n", chu);
                                    print_f(mrs->plog, "fs145", mrs->log);                                    

                                    continue;
                                }                        
                            }
                            else {
                                if ((mlen == 0) || (csws != 0) || (dlen == 0) || (cswd != 0)) {
                                    pfat->fatSupdata = 0;
                                    pfat->fatSupcur = 0;

                                    mrs_ipc_put(mrs, "b", 1, 13);
                            
                                    sprintf_f(mrs->log, "P6 response BREAK loop chu = %c \n", chu);
                                    print_f(mrs->plog, "fs145", mrs->log);                                    
                                } else {
                                    mrs_ipc_put(mrs, "e", 1, 12);
                                    
                                    mrs_ipc_put(mrs, "o", 1, 12);
                                    mrs_ipc_put(mrs, "o", 1, 13);
                                    
                                    sprintf_f(mrs->log, "P6 response CONTINUE loop chu = %c \n", chu);
                                    print_f(mrs->plog, "fs145", mrs->log);                                    

                                    continue;
                                }
                            }
                        }

                        break;
                    case 4:
                        
                        if (pllcmd[ins] == 's') {
                            modersp->v = 0;
                            modersp->c = 0;
                            modersp->t = 0;
                        }
                        else if (pllcmd[ins] == 'p') {
                            modersp->v += 1;
                            mrs_ipc_put(mrs, "n", 1, 3);
                        }
                        else if (pllcmd[ins] == 'd') {
                            modersp->v += 1;

                            mrs_ipc_put(mrs, "N", 1, 3);

                            sprintf_f(mrs->log, "[GW] end transmit count: %d !!! \n", modersp->v);
                            print_f(mrs->plog, "fs145", mrs->log);
                        } else {

                            switch(pllcmd[ins]) {
                            case 'e':
                                ret = mrs_ipc_get(mrs, minfo, 2, 12);
                                if (ret == 2) {
                                    acusz = 0;
                                    filefd = 0;
                                    
                                    wfileid = (minfo[0] << 8) | minfo[1];

                                    #if 0 /* debug */
                                    if (wfileid == 0) {
                                        wfileid = fileidcnt;
                                        fileidcnt ++;
                                    }
                                    #endif

                                    sprintf(idfile, filenames, wfileid);
                                    filefd = find_write(idfile);
                                    
                                    sprintf_f(mrs->log, "[GW] wget file id: %d filename[%s] filefd: %d !!! \n", wfileid, idfile, (uint32_t)filefd);
                                    print_f(mrs->plog, "fs145", mrs->log);
                                } else {
                                    sprintf_f(mrs->log, "[GW] wget file id failed ret: %d !!! \n", ret);
                                    print_f(mrs->plog, "fs145", mrs->log);
                                }
                                break;
                            case 'f':
                                len = 0;
                                len = ring_buf_cons(&mrs->cmdRx, &addrs);
                                while (len <= 0) {
                                    sprintf_f(mrs->log, "[GW] wget cons len: %d \n",len);
                                    print_f(mrs->plog, "fs145", mrs->log);

                                    usleep(100000);

                                    len = ring_buf_cons(&mrs->cmdRx, &addrs);
                                }

                                if (filefd) {
                                    ret = fwrite(addrs, 1, len, filefd);
                                    acusz += len;
                                    
                                    //sprintf_f(mrs->log, "[GW] wget write: %d(%d) acusz: %d \n",ret, len, acusz);
                                    //print_f(mrs->plog, "fs145", mrs->log);

                                    if (ret != len) {
                                        sprintf_f(mrs->log, "[GW] warnning!!! wget write size %d but ret %d \n",len, ret);
                                        print_f(mrs->plog, "fs145", mrs->log);
                                    }
                                } else {
                                    sprintf_f(mrs->log, "[GW] error!! wget filefd: %d len: %d \n", (uint32_t)filefd, len);
                                    print_f(mrs->plog, "fs145", mrs->log);
                                }
                                
                                break;
                            case 'g':
                                //sprintf_f(mrs->log, "[GW] wget write end last: %d acusz: %d \n", len, acusz);
                                //print_f(mrs->plog, "fs145", mrs->log);

                                fflush(filefd);
                                fclose(filefd);
                                sync();

                                filefd = 0;
                                
                                filefd = find_read(idfile);

                                ret = fseek(filefd, 0, SEEK_END);
                                if (ret) {
                                    sprintf_f(mrs->log, "[GW] wget file seek failed!! ret:%d \n", ret);
                                    print_f(mrs->plog, "fs145", mrs->log);
                                } 

                                maxsz = ftell(filefd);
                                fclose(filefd);
                                filefd = 0;
                                
                                sprintf_f(mrs->log, "[GW] wget file [%s] size: %d \n", idfile, maxsz);
                                print_f(mrs->plog, "fs145", mrs->log);

                                minfo[0] = 'w';
                                minfo[1] = (maxsz >> 24) & 0xff;
                                minfo[2] = (maxsz >> 16) & 0xff;
                                minfo[3] = (maxsz >> 8) & 0xff;
                                minfo[4] = (maxsz >> 0) & 0xff;

                                mrs_ipc_put(mrs, minfo, 5, 12);
                                
                                break;
                            case 'h':
                                ret = mrs_ipc_get(mrs, minfo, 2, 12);
                                if (ret == 2) {
                                    acusz = 0;
                                    filefd = 0;
                                    
                                    wfileid = (minfo[0] << 8) | minfo[1];
                                    
                                    #if 0 /* debug */
                                    if (wfileid == 0) {
                                        wfileid = fileidcnt;
                                        fileidcnt --;
                                        if (fileidcnt < 0) fileidcnt = 0;
                                    }
                                    #endif
                                    
                                    sprintf(idfile, filenames, wfileid);
                                    filefd = find_read(idfile);
                                    
                                    sprintf_f(mrs->log, "[GW] rget file id: %d filename[%s] filefd: %d !!! \n", wfileid, idfile, (uint32_t)filefd);
                                    print_f(mrs->plog, "fs145", mrs->log);
                                }
                                else {
                                    sprintf_f(mrs->log, "[GW] rget file id failed ret: %d !!! \n", ret);
                                    print_f(mrs->plog, "fs145", mrs->log);
                                }
                                break;
                            case 'i':
                                if (!filefd) {
                                    maxsz = 0;
                                    
                                    minfo[0] = 'r';
                                    minfo[1] = (maxsz >> 24) & 0xff;
                                    minfo[2] = (maxsz >> 16) & 0xff;
                                    minfo[3] = (maxsz >> 8) & 0xff;
                                    minfo[4] = (maxsz >> 0) & 0xff;

                                    mrs_ipc_put(mrs, minfo, 5, 12);

                                    sprintf_f(mrs->log, "[GW] rget file failed, not existed  !!! \n");
                                    print_f(mrs->plog, "fs145", mrs->log);

                                    break;
                                }

                                ret = fseek(filefd, 0, SEEK_END);
                                if (ret) {
                                    sprintf_f(mrs->log, "[GW] rget file seek failed!! ret:%d \n", ret);
                                    print_f(mrs->plog, "fs145", mrs->log);
                                } 
                                maxsz = ftell(filefd);

                                minfo[0] = 'r';
                                minfo[1] = (maxsz >> 24) & 0xff;
                                minfo[2] = (maxsz >> 16) & 0xff;
                                minfo[3] = (maxsz >> 8) & 0xff;
                                minfo[4] = (maxsz >> 0) & 0xff;
                                
                                mrs_ipc_put(mrs, minfo, 5, 12);
                                    
                                sprintf_f(mrs->log, "[GW] rget file maxsz: %d !!! \n", maxsz);
                                print_f(mrs->plog, "fs145", mrs->log);

                                ret = fseek(filefd, 0, SEEK_SET);
                                if (ret) {
                                    sprintf_f(mrs->log, "[GW] rget file seek failed!! ret:%d \n", ret);
                                    print_f(mrs->plog, "fs145", mrs->log);
                                } 

                                while (maxsz) {
                                    len = ring_buf_get(&mrs->cmdRx, &addrs);
                                    while (len <= 0) {
                                        sprintf_f(mrs->log, "[GW] rget buff len: %d \n",len);
                                        print_f(mrs->plog, "fs145", mrs->log);

                                        usleep(100000);

                                        len = ring_buf_get(&mrs->cmdRx, &addrs);
                                    }

                                    if (len > maxsz) {
                                        len = maxsz;
                                    }
                                    
                                    maxsz -= len;
                                    
                                    //sprintf_f(mrs->log, "[GW] read rfile len: %d last: %d\n",len, maxsz);
                                    //print_f(mrs->plog, "fs145", mrs->log);

                                    ret = fread(addrs, 1, len, filefd);
                                    if (ret != len) {
                                        sprintf_f(mrs->log, "[GW] read rfile failed ret: %d (%d) \n",ret, len);
                                        print_f(mrs->plog, "fs145", mrs->log);

                                        ring_buf_prod(&mrs->cmdRx);    
                                        break;
                                    }                                    

                                    ring_buf_prod(&mrs->cmdRx);    
                                    
                                }

                                ring_buf_set_last(&mrs->cmdRx, len);

                                fclose(filefd);
                                filefd = 0;

                                break;
                            case 'j':
                                break;
                            case 'k':
                                break;
                            default:
                                break;
                            }
                        }

                        break;
                    case 5:
                                            
                        //chs = pllcmd[ins];
                        if (pllcmd[ins] == 's') {
                            modersp->v = 0;
                            modersp->c = 0;
                            modersp->t = 1;
                        }
                        else if (pllcmd[ins] == 'p') {
                            modersp->v += 1;
                            mrs_ipc_put(mrs, "n", 1, 8);
                        }
                        else if (pllcmd[ins] == 'd') {
                            modersp->v += 1;

                            mrs_ipc_put(mrs, "N", 1, 8);

                            sprintf_f(mrs->log, "[GW] end duo transmit count: %d !!! \n", modersp->t);
                            print_f(mrs->plog, "fs145", mrs->log);
                        }

                        break;
                    case 0:
                    case 2:
                        if (latcmd[ins] == 'b') {
                            if (((pllcmd[ins] & 0xc0) == 0xc0) || ((pllcmd[ins] & 0xc0) == 0x40)) {
                                sprintf_f(mrs->log, "[GW] id:%d pipe%d get chr: %c(0x%.2x) skip !!! \n", ins, outfd[ins], pllcmd[ins], pllcmd[ins]);
                                print_f(mrs->plog, "fs145", mrs->log);
                                break;
                            } 
                        }
                        
                        if ((pllcmd[ins] & 0xc0) == 0xc0) {
                            if (!pubffh) {
                                pllcmd[ins] = 0xff;
                                write(infd[ins], &pllcmd[ins], 1);
                                sprintf_f(mrs->log, "[GW] in%d id:%d put chr: %c(0x%.2x) total:%d\n", ins, infd[ins], pllcmd[ins], pllcmd[ins], evcnt);            
                                print_f(mrs->plog, "fs145", mrs->log);
                            } else {
                                chindex[0] = pllcmd[ins];

                                ptret = read(pllfd[ins].fd, &pllcmd[ins], 1);
                                while (ptret < 0) {
                                    ptret = read(pllfd[ins].fd, &pllcmd[ins], 1);
                                }
                                
                                if ((pllcmd[ins] & 0xc0) == 0x40) {
                                    chindex[1] = pllcmd[ins];
                                } else {
                                    sprintf_f(mrs->log, "[GW] WARNNING!!! unknow ch: 0x%.2x \n", pllcmd[ins]);
                                    print_f(mrs->plog, "fs145", mrs->log);
                                    break;
                                }

                                mindex = ((chindex[0] & 0x3f) << 5) | (chindex[1] & 0x1f);
                                mindex = mindex & 0x3ff;
                                
                                sprintf_f(mrs->log, "[GW] pll%d get midx: %d(0x%.2x:0x%.2x) \n", ins, mindex, chindex[0], chindex[1]);
                                print_f(mrs->plog, "fs145", mrs->log);
                                
                                if (!pubffo) {
                                    //sprintf_f(mrs->log, "[GW] find outbuf in pubffo \n");
                                    //print_f(mrs->plog, "fs145", mrs->log);
                                    pubffo = pubffh;
                                    while (pubffo) {
                                        sprintf_f(mrs->log, "    [GW] 0x%.3x:0x%.3x \n", pubffo->ubindex, mindex);
                                        print_f(mrs->plog, "fs145", mrs->log);
                                        if ((pubffo->ubindex & 0x3ff) == mindex) {
                                            break;
                                        }
                                        pubffo = pubffo->ubnxt;
                                    }

                                    if (pubffo) {
                                        outbf = pubffo->ubbufh;
                                    }
                                }
                                
                                #if 0 /* memory used debug */
                                if (pubffh) {
                                    memsz = 0;
                                    pageidx = 0;
                                    pubffm = pubffh;
                                    while (pubffm) {
                                        pageidx += 1;
                                        #if 0
                                        tmpbf = pubffm->ubbufh;
                                        trunkidx = 0;
                                        while (tmpbf) {
                                            memsz += USB_BUF_SIZE;
                                            trunkidx += 1;
                                            tmpbf = tmpbf->bn;
                                            //sprintf_f(mrs->log, "    [GW] %d - %d\n", trunkidx, memsz);
                                            //print_f(mrs->plog, "fs145", mrs->log);
                                        }
                                        sprintf_f(mrs->log, "[GW] memory used: %d - %d idx: %d \n", memsz, pageidx, pubffm->ubindex);
                                        print_f(mrs->plog, "fs145", mrs->log);
                                        #else
                                        sprintf_f(mrs->log, "[GW] mem(%d) idx: %d \n", pageidx, pubffm->ubindex);
                                        print_f(mrs->plog, "fs145", mrs->log);
                                        #endif
                                        
                                        pubffm = pubffm->ubnxt;

                                    }
                                }
                                #endif
                                
                                if (!outbf) {
                                    pllcmd[ins] = 0xff;
                                    write(infd[ins], &pllcmd[ins], 1);
                                    sprintf_f(mrs->log, "[GW] in%d id:%d put chr: %c(0x%.2x) no outbf\n", ins, infd[ins], pllcmd[ins], pllcmd[ins]);
                                    print_f(mrs->plog, "fs145", mrs->log);
                                } else if (mindex == (pubffo->ubindex & 0x3ff)) { 
                                
                                    midxfo[0] = ((pubffo->ubindex >> 5) & 0x3f) | 0x80;
                                    midxfo[1] = (pubffo->ubindex & 0x1f) | 0x40;
                                    prisec = pubffo->ubindex & 0x400;
                                    
                                    if ((pubffo->ubmetasize) && (pubffo->ublastsize)) {
                                        smax = pubffo->ubcylcnt - cycCnt[ins] + 2;
                                        #if 0
                                        if (smax > 0xff) {
                                            smax = CYCLE_LEN;
                                        }
                                        #else
                                        if (smax > 0xfff) {
                                            smax = 0xfff;
                                        }
                                        #endif
                                    } else {
                                        smax = CYCLE_LEN;
                                    }

                                    scnt = 0;
                                    while (scnt < smax) {
                                        ret = ring_buf_get(ringbf[ins], &addrd);
                                        if (ret <= 0) {
                                            sprintf_f(mrs->log, "[GW] get ring buffer failed !! ret: %d \n", ret);
                                            print_f(mrs->plog, "fs145", mrs->log);
                                            continue;
                                        }

                                        memallocsz -= 1;
                                        
                                        add32s = (uint32_t *) outbf->bpt;                                        
                                        addrs = (char *) *add32s;
                                        lens = outbf->bsz;

                                        if (lens & 0x40000) {
                                            lasflag = 0x40000;
                                        } else {
                                            lasflag = 0;
                                        }
                                        lens = lens & 0x1ffff;

                                        tmpbf = outbf->bn;
                                        
                                        if ((!tmpbf) && (pubffo->ubmetasize)) {
                                            lens = pubffo->ubmetasize;
                                            lastlen = pubffo->ublastsize;
                                            if ((lens == 0) || (lastlen == 0)) {
                                                sprintf_f(mrs->log, "\n[GW] get the last trunk size error!!! lens: %d lastlen: %d\n", lens, lastlen);
                                                print_f(mrs->plog, "fs145", mrs->log);
                                            }
                                            #if DBG_USB_GATE
                                            else {
                                                sprintf_f(mrs->log, "\n[GW] get the last trunk size, lens: %d lastlen: %d\n\n", lens, lastlen);
                                                print_f(mrs->plog, "fs145", mrs->log);
                                            }
                                            #endif
                                        }
                                        
                                        msync(addrs, lens, MS_SYNC);
                                        
                                        #if DBG_DUMP_DAT32
                                        sprintf_f(mrs->log, "[GW] dump 32 - 2 - 1\n");
                                        print_f(mrs->plog, "fs145", mrs->log);
                                        shmem_dump(addrs, 32);
                                        #endif
                                        
                                        if (addrs == addrd) {
                                            
                                            #if DBG_DUMP_DAT32
                                            sprintf_f(mrs->log, "[GW] compare addr passed !! addr: 0x%.8x \n", (uint32_t)addrs);
                                            print_f(mrs->plog, "fs145", mrs->log);
                                            #endif
                                            
                                        } else {
                                            sprintf_f(mrs->log, "[GW] compare addr failed !! addrs: 0x%.8x addrd: 0x%.8x\n", (uint32_t)addrs, (uint32_t)addrd);
                                            print_f(mrs->plog, "fs145", mrs->log);
                                        }
                                        
                                        msync(addrd, lens, MS_SYNC);
                                        
                                        #if DBG_DUMP_DAT32
                                        sprintf_f(mrs->log, "[GW] dump 32 - 2 - 2\n");
                                        print_f(mrs->plog, "fs145", mrs->log);
                                        shmem_dump(addrd, 32);
                                        #endif
                                            
                                        if ((lens < USB_BUF_SIZE) && (lasflag)) {
                                            ret = ring_buf_prod_u(ringbf[ins], lens);
                                            ring_buf_set_last(ringbf[ins], lens);
                                            
                                            pllcmd[ins] = 0x7f;
                                            cswinf = pubffo->ubcswerr;
                                            
                                            outbf = 0;
                                        
                                            headbf = pubffo->ubbufh;
                                            while (headbf) {
                                                tmpbf = headbf;                                            
                                                headbf = tmpbf->bn;
                                                free(tmpbf->bpt);
                                                free(tmpbf);
                                            }
                                            tmpbf = 0;
                                        
                                            if(pubffh == pubffo) {
                                                pubffh = pubffo->ubnxt;
                                            } else {
                                                pubffm = pubffh;
                                                while (pubffm) {
                                                    if (pubffm->ubnxt == pubffo) {
                                                        pubffm->ubnxt = pubffo->ubnxt;
                                                        break;
                                                    }
                                                    pubffm = pubffm->ubnxt;
                                                }
                                            }
                                            
                                            free(pubffo);
                                            
                                            pubffo = 0;
                                            
                                            //sprintf_f(mrs->log, "[GW] the last trunk reach, set outbf == 0, pubffh: 0x%.8x \n", (uint32_t)pubffh);
                                            //print_f(mrs->plog, "fs145", mrs->log);
                                            
                                            scnt = scnt + 1;
                                            cycCnt[ins] = 0;
                                        
                                            break;
                                        }
                                        else if (tmpbf) {
                                            ret = ring_buf_prod_u(ringbf[ins], lens);
                                            outbf = tmpbf;
                                        }
                                        else {
                                            //pllcmd[ins] = 0x80;                                    
                                            sprintf_f(mrs->log, "[GW] Error!!! idle %d \n", cycCnt[ins]);
                                            print_f(mrs->plog, "fs145", mrs->log);
                                            break;
                                        }

                                        scnt = scnt + 1;
                                        cycCnt[ins] = cycCnt[ins] + 1;

                                    }
                                    
                                    if (tmpbf) {
                                        headbf = pubffo->ubbufh;
                                        while (headbf) {
                                            if  (headbf != outbf) {
                                                tmpbf = headbf;
                                                headbf = tmpbf->bn;
                                                //sprintf_f(mrs->log, "[GW] free used buf addr: 0x%.8x \n", tmpbf);
                                                //print_f(mrs->plog, "fs145", mrs->log);
                                                free(tmpbf->bpt);
                                                free(tmpbf);
                                            } else {
                                                break;
                                            }
                                        }
                                        pubffo->ubbufh = headbf;
                                    }

                                    if (pllcmd[ins] == 0x7f) {
                                        minfo[0] = 0x7f;
                                        
                                        minfo[1] = (scnt & 0x7f) | 0x80; // 0  // 0
                                        minfo[2] = ((scnt >> 7) & 0x7f) | 0x80;  // 1
                                        
                                        minfo[3] = (prisec == 0) ? 1:2; //latcmd[ins]; // 1  // 2
                                        
                                        minfo[4] = (char)(lastlen & 0xff); // 2  // 3
                                        minfo[5] = (char)((lastlen >> 8) & 0xff); // 3  // 4
                                        minfo[6] = (char)((lastlen >> 16) & 0xff); // 4  // 5
                                        minfo[7] = (char)((lastlen >> 24) & 0xff); // 5  // 6 

                                        minfo[8] = cswinf; // 6  // 7
                                        
                                        #if 1 /* memory used debug */
                                        pageidx = 0;
                                        if (pubffh) {
                                            pubffm = pubffh;
                                            while (pubffm) {
                                                if ((pubffm->ubindex & 0x800) == 0) {
                                                    pageidx += 1;
                                                }
                                                pubffm = pubffm->ubnxt;
                                            }
                                        }
                                        #endif
                                        
                                        minfo[9] = (char)(pageidx | 0x80); // 7  // 8
                                        
                                        write(infd[ins], &minfo, 10);
                                    }
                                    else {
                                        write(infd[ins], midxfo, 2);
                                    }
                                }      
                                else {                                   
                                    sprintf_f(mrs->log, "[GW] WARNNING!!! in%d id:%d cur index: %d get index: %d NOT handle buffer\n", ins, infd[ins], pubffo->ubindex, mindex);
                                    print_f(mrs->plog, "fs145", mrs->log);
                                }
                            }
                        }
                        else if (pllcmd[ins] == 'd') {
                            latcmd[ins] = 'd';
                            latcmd[ins+1] = 'd';
                            matcmd[ins] = 'h';
                            matcmd[ins+1] = 'h';
                            write(outfd[ins], &pllcmd[ins], 1);
                        }
                        else if (pllcmd[ins] == 's') {
                            if (ins == 2) {
                                latcmd[ins] = 's';
                                latcmd[ins+1] = 's';
                                matcmd[ins] = 'h';
                                matcmd[ins+1] = 'h';
                            } else {
                                latcmd[ins] = 's';
                                latcmd[ins+1] = 's';
                                matcmd[ins] = 'h';
                                matcmd[ins+1] = 'h';
                            }
                        }
                        else if (pllcmd[ins] == 'q') {
                            if (latcmd[ins] == 'q') {
                                sprintf_f(mrs->log, "[GW] already in multiple id:%d lat:%c pll:%c\n", ins, latcmd[ins], pllcmd[ins]);
                                print_f(mrs->plog, "fs145", mrs->log);
                            } else if (latcmd[ins] == 'e') {
                                //sprintf_f(mrs->log, "[GW] already stop multiple id:%d lat:%c pll:%c\n", ins, latcmd[ins], pllcmd[ins]);
                                //print_f(mrs->plog, "fs145", mrs->log);

                                write(outfd[ins], &latcmd[ins], 1);
                            } else if (latcmd[ins] == 'R') {
                                sprintf_f(mrs->log, "[GW] already stop multiple id:%d lat:%c pll:%c waiting \n", ins, latcmd[ins], pllcmd[ins]);
                                print_f(mrs->plog, "fs145", mrs->log);
                            } else if (latcmd[ins] == 0) {
                                if (ins == 2) {
                                    //write(outfd[ins], &pllcmd[ins], 1);
                                    
                                    #if DBG_USB_GATE
                                    sprintf_f(mrs->log, "[GW] id:%d lat:0x%.2x pll:0x%.2x \n", ins, latcmd[ins], pllcmd[ins]);
                                    print_f(mrs->plog, "fs145", mrs->log);
                                    #endif
                                    
                                    latcmd[ins] = 'q';
                                    latcmd[ins+1] = 'q';
                                    matcmd[ins] = 'f';
                                    matcmd[ins+1] = 'f';
                                } else {
                                    latcmd[ins] = 'q';
                                    latcmd[ins+1] = 'q';
                                    matcmd[ins] = 'f';
                                    matcmd[ins+1] = 'f';
                                }
                            }
                            else {
                                sprintf_f(mrs->log, "[GW] unknown!! id:%d lat:%c(0x%.2x) pll:%c(0x%.2x) - q \n", ins, latcmd[ins], latcmd[ins], pllcmd[ins], pllcmd[ins]);
                                print_f(mrs->plog, "fs145", mrs->log);
                            }
                        }
                        else if (pllcmd[ins] == 'c') {
                            if (latcmd[ins] == 'c') {
                                sprintf_f(mrs->log, "[GW] already in multiple single id:%d lat:%c pll:%c\n", ins, latcmd[ins], pllcmd[ins]);
                                print_f(mrs->plog, "fs145", mrs->log);
                            } else if (latcmd[ins] == 'e') {
                                sprintf_f(mrs->log, "[GW] already stop multiple single id:%d lat:%c pll:%c\n", ins, latcmd[ins], pllcmd[ins]);
                                print_f(mrs->plog, "fs145", mrs->log);

                                write(outfd[ins], &latcmd[ins], 1);
                            } else if (latcmd[ins] == 'R') {
                                sprintf_f(mrs->log, "[GW] already stop multiple id:%d lat:%c pll:%c waiting \n", ins, latcmd[ins], pllcmd[ins]);
                                print_f(mrs->plog, "fs145", mrs->log);
                            } else if (latcmd[ins] == 0) {
                                latcmd[ins] = 'c';
                                latcmd[ins+1] = 'c';
                                matcmd[ins] = 'o';
                                matcmd[ins+1] = 'o';
                                write(outfd[ins], &pllcmd[ins], 1);
                            }
                            else {
                                sprintf_f(mrs->log, "[GW] unknown!! id:%d lat:%c(0x%.2x) pll:%c(0x%.2x) - c\n", ins, latcmd[ins], latcmd[ins], pllcmd[ins], pllcmd[ins]);
                                print_f(mrs->plog, "fs145", mrs->log);
                            }
                        }
                        else if ((pllcmd[ins] == 'p') || (pllcmd[ins] == 'r') || (pllcmd[ins] == 'a') || (pllcmd[ins] == 'k')) {
                            if ((latcmd[ins] == 'q') || (latcmd[ins] == 'c')) {
                            } else if ((latcmd[ins] == 'e') || (latcmd[ins] == 'R')) {
                            } else if (pllcmd[ins] == 'a') {
                                write(outfd[ins], &pllcmd[ins], 1);
                            } else if (pllcmd[ins] == 'k') {
                                write(outfd[ins], &pllcmd[ins], 1);
                            } else if (latcmd[ins] == 0) {
                                //sprintf_f(mrs->log, "[GW] id:%d lat:0x%.2x pll:0x%.2x \n", ins, latcmd[ins], pllcmd[ins]);
                                //print_f(mrs->plog, "fs145", mrs->log);
                                if (ins == 2) {
                                    write(outfd[ins], &pllcmd[ins], 1);
                                }
                                
                                totsz[ins] =0;
                                totsz[ins+1] = 0;
                            } else if (latcmd[ins] == 's') {
                                sprintf_f(mrs->log, "[GW] id:%d lat:0x%.2x pll:0x%.2x \n", ins, latcmd[ins], pllcmd[ins]);
                                print_f(mrs->plog, "fs145", mrs->log);
                                if (ins == 2) {
                                    write(outfd[ins], &pllcmd[ins], 1);
                                }
                            }
                            else {
                                sprintf_f(mrs->log, "[GW] unknown!! id:%d lat:%c(0x%.2x) pll:%c(0x%.2x) - qrak \n", ins, latcmd[ins], latcmd[ins], pllcmd[ins], pllcmd[ins]);
                                print_f(mrs->plog, "fs145", mrs->log);
                            }
                        }
                        else if ((pllcmd[ins] == 'm') || (pllcmd[ins] == 'n')) {
                            gval = 0;
                            ret = cfgTableGetChkDPI(pct, ASPOP_RESOLUTION, &gval, ASPOP_STA_APP);
                            resltion = gval;
                                
                            /* clean msg queue MAX_145_EVENT */
                            //for (ix=0; ix<4; ix++) {
                            for (ix=0; ix<MAX_145_EVENT; ix++) {
                                ret = read(pllfd[ix].fd, &chv, 1);
                                while (ret > 0) {
                                    sprintf_f(mrs->log, "[GW] id:%d pll:0x%.2x (clr)\n", ix, chv);
                                    print_f(mrs->plog, "fs145", mrs->log);
                                    ret = read(pllfd[ix].fd, &chv, 1);
                                }
                            }
                        
                            write(outfd[ins], &pllcmd[ins], 1);

                            latcmd[0] = 0;
                            latcmd[1] = 0;
                            latcmd[2] = 0;
                            latcmd[3] = 0;

                            matcmd[0] = 0;
                            matcmd[1] = 0;
                            matcmd[2] = 0;
                            matcmd[3] = 0;

                            pubffcd[0] = 0;
                            pubffcd[1] = 0;
                            pubffcd[2] = 0;
                            pubffcd[3] = 0;
                            
                            idxInit = 1;
                            
                            //cswinf = 0;

                            cmdex = 0;

                            if (pubffh) {
                                memsz = 0;
                                pageidx = 0;
                                
                                pubffm = pubffh;
                                while (pubffm) {
                                    pageidx += 1;

                                    headbf = pubffm->ubbufh;
                                    while (headbf) {
                                        memsz += USB_BUF_SIZE;
                                        tmpbf = headbf;                                            
                                        headbf = tmpbf->bn;
                                        //sprintf_f(mrs->log, "[GW] clean mem addr: 0x%.8x\n", tmpbf);
                                        //print_f(mrs->plog, "fs145", mrs->log);
                                        free(tmpbf->bpt);
                                        free(tmpbf);
                                    }
                                    
                                    tmpbf = 0;
                                            
                                    sprintf_f(mrs->log, "[GW] clean memory used: %d - %d idx: 0x%.2x \n", memsz, pageidx, pubffm->ubindex);
                                    print_f(mrs->plog, "fs145", mrs->log);

                                    pubfft = pubffm;
                                    pubffm = pubfft->ubnxt;

                                    free(pubfft);
                                }

                                pubffh = 0;
                            }
                            
                            totsz[ins] =0;
                            totsz[ins+1] = 0;
                            ring_buf_init(ringbf[ins]);
                            ring_buf_init(ringbf[ins+1]);
                            //ring_buf_init(&mrs->cmdTx);
                            ring_buf_init(&mrs->dataRx);
                            #if GHP_EN
                            aspBMPdecodeBuffInit(&mrs->bmpDecMfour[0]);
                            aspBMPdecodeBuffInit(&mrs->bmpDecMfour[1]);
                            aspBMPdecodeBuffInit(&mrs->bmpDecMfour[2]);
                            aspBMPdecodeBuffInit(&mrs->bmpDecMfour[3]);
                            #endif
                        }
                        else if (pllcmd[ins] == 'b') {
                            write(outfd[ins], &pllcmd[ins], 1);
                        }
                        else if (pllcmd[ins] == 'x') {
                            //sprintf_f(mrs->log, "[GW] id%d pipe%d get ch: %c(0x%.2x) return stm\n", ins, outfd[ins], pllcmd[ins], pllcmd[ins]);
                            //print_f(mrs->plog, "fs145", mrs->log);

                            pllinf = 0;
                            gerr = read(pllfd[ins].fd, &pllinf, 1);
                            while (gerr < 0) {
                                pllinf = 0;
                                gerr = read(pllfd[ins].fd, &pllinf, 1);
                            }

                            modersp->r = pllinf;
                            return 1;  
                        }
                        else if (pllcmd[ins] == 'x') {
                            //sprintf_f(mrs->log, "[GW] id%d pipe%d get ch: %c(0x%.2x) return stm\n", ins, outfd[ins], pllcmd[ins], pllcmd[ins]);
                            //print_f(mrs->plog, "fs145", mrs->log);
                            modersp->r = 1;
                            return 1;  
                        }
                        else if (pllcmd[ins] == 'i') {
                            write(outfd[ins], &pllcmd[ins], 1);
                        }
                        else if (pllcmd[ins] == 'w') {
                            write(outfd[ins], &pllcmd[ins], 1);
                        }
                        else if (pllcmd[ins] == 'y') {
                            write(outfd[ins], &pllcmd[ins], 1);
                        }
                        else if (pllcmd[ins] == 'z') {
                            write(outfd[ins], &pllcmd[ins], 1);
                        }
                        else if (pllcmd[ins] == 't') {
                            write(outfd[0], &pllcmd[ins], 1);
                            write(outfd[2], &pllcmd[ins], 1);
                        }
                        #if USB_AUTO_RESUME
                        else if (pllcmd[ins] == 'v') {
                            write(outfd[2], &pllcmd[ins], 1);
                            //write(outfd[0], &pllcmd[ins], 1);
                            
                            sprintf_f(mrs->log, "[GW] resume id%d pipe%d get ch: %c \n", ins, outfd[ins], pllcmd[ins]);
                            print_f(mrs->plog, "fs145", mrs->log);
                        }
                        #endif
                        else if (pllcmd[ins] == 'j') {
                        
                            gerr = read(pllfd[ins].fd, minfo, 6);
                            while (gerr <= 0) {
                                gerr = read(pllfd[ins].fd, minfo, 6);
                            }

                            if (gerr != 6) {
                                sprintf_f(mrs->log, "[GW] fileacc id%d get minfo failed!! ret: %d\n", ins, gerr);
                                print_f(mrs->plog, "fs145", mrs->log);
                            }

                            wfileid = (minfo[0] << 8) | minfo[1];
                            wfiaddr = minfo[2];
                            wfiaddr |= minfo[3] << 8;
                            wfiaddr |= minfo[4] << 16;
                            wfiaddr |= minfo[5] << 24;

                            sprintf(idfile, filenames, wfileid);
                            filefd = find_read(idfile);

                            if (filefd) {
                                sprintf_f(mrs->log, "[GW] fileacc id%d get read filename:[%s] \n", ins, idfile);
                                print_f(mrs->plog, "fs145", mrs->log);

                                ret = fseek(filefd, 0, SEEK_END);
                                if (ret) {
                                    sprintf_f(mrs->log, "[GW] fileacc seek failed!! ret:%d \n", ret);
                                    print_f(mrs->plog, "fs145", mrs->log);
                                } 

                                maxsz = ftell(filefd);
                                fclose(filefd);
                                filefd = 0;

                                sprintf_f(mrs->log, "[GW] fileacc id%d get read filename:[%s] size: %d waddr: 0x%.8x\n", ins, idfile, maxsz, wfiaddr);
                                print_f(mrs->plog, "fs145", mrs->log);

                                minfo[0] = pllcmd[ins];
                                minfo[1] = (maxsz >> 24) & 0xff;
                                minfo[2] = (maxsz >> 16) & 0xff;
                                minfo[3] = (maxsz >> 8) & 0xff;
                                minfo[4] = (maxsz >> 0) & 0xff;

                                minfo[5] = wfiaddr & 0xff;
                                minfo[6] = (wfiaddr >> 8) & 0xff;
                                minfo[7] = (wfiaddr >> 16) & 0xff;
                                minfo[8] = (wfiaddr >> 24) & 0xff;

                                write(outfd[ins], minfo, 9);

                                minfo[0] = 'H';                                
                                write(infd[ins], minfo, 5);
                                
                            }
                            else {
                                sprintf_f(mrs->log, "[GW] fileacc id%d get read fileid failed!! ret: %d filename:[%s]\n", ins, (uint32_t)filefd, idfile);
                                print_f(mrs->plog, "fs145", mrs->log);
                            }
                        }
                        else if (pllcmd[ins] == 'u') {
                            write(outfd[ins], &pllcmd[ins], 1);
                        }
                        else if (pllcmd[ins] == '0') {
                            write(outfd[ins], &pllcmd[ins], 1);
                        }
                        else {
                            sprintf_f(mrs->log, "\n[GW] inpo%d Error !!! pipe(%d) get unknown chr:%c(0x%.2x) Error!! \n\n", ins, pllfd[ins].fd, pllcmd[ins], pllcmd[ins]);
                            print_f(mrs->plog, "fs145", mrs->log);
                        }

                        break;
                    case 1:
                    case 3:
                    
                        if ((pllcmd[ins] == 'D') || (pllcmd[ins] == 'E')) {

                            lens = ring_buf_cons_u(ringbf[ins], &addrs);                
                            while (lens < 0) {
                                sprintf_f(mrs->log, "[GW] cons ring buff ret: %d \n", lens);
                                print_f(mrs->plog, "fs145", mrs->log);
                                usleep(1000);
                                lens = ring_buf_cons_u(ringbf[ins], &addrs);
                            }
                            
                            if (lens & 0x40000) {
                                lasflag = 0x40000;
                            } else {
                                lasflag = 0;
                            }
                            lens = lens & 0x1ffff;

                            #if 0//DBG_USB_GATE
                            sprintf_f(mrs->log, "[GW] cons u len: %d \n", lens);
                            print_f(mrs->plog, "fs145", mrs->log);
                            #endif

                            memallocsz += 1;

                            if (!pubffh) {
                                pubffh = malloc(sizeof(struct usbBuffLink_s));
                                
                                if (pubffh) {

                                    memset(pubffh, 0, sizeof(struct usbBuffLink_s));
                                    
                                    pubffh->ubindex = idxInit;
                                    idxInit += 1;

                                    if (!cmdex) {
                                        cmdex = latcmd[ins];
                                    }
                                    #if DBG_USB_GATE
                                    sprintf_f(mrs->log, "[GW] ch%d new index: %d the next is %d latcmd: %c - 1\n", ins, pubffh->ubindex, idxInit, latcmd[ins]);
                                    print_f(mrs->plog, "fs145", mrs->log);
                                    #endif
                                } else {
                                    sprintf_f(mrs->log, "[GW] ring%d allocate memory failed!! size: %d\n", ins, sizeof(struct usbBuffLink_s)); 
                                    print_f(mrs->plog, "fs145", mrs->log);
                                }

                                pubffcd[ins] = pubffh;
                            }

                            if (!pubffh) {
                                break;
                            }

                            if (!pubffcd[ins]) {
                            
                                if (((cmdex) && (latcmd[ins] != cmdex))) {

                                    #if DBG_USB_GATE
                                    sprintf_f(mrs->log, "[GW] warnning !! latcmd[%d] != cmdex  %c(0x%.2x) : %c(0x%.2x) \n", ins, latcmd[ins], latcmd[ins], cmdex, cmdex); 
                                    print_f(mrs->plog, "fs145", mrs->log);  
                                    #endif
                                    
                                    break;
                                }

                                pubffcd[ins] = malloc(sizeof(struct usbBuffLink_s));
                                if (pubffcd[ins]) {
                                    memset(pubffcd[ins], 0, sizeof(struct usbBuffLink_s));
                                    
                                    pubffcd[ins]->ubindex = idxInit;
                                    idxInit += 1;
                                    
                                    #if DBG_USB_GATE
                                    sprintf_f(mrs->log, "[GW] ch%d new index: %d the next is %d latcmd: %c - 2\n", ins, pubffcd[ins]->ubindex, idxInit, latcmd[ins]);
                                    print_f(mrs->plog, "fs145", mrs->log);
                                    #endif
                                    
                                    pubffm = pubffh;
                                    pubfft = pubffm->ubnxt;
                                    while (pubfft) {
                                        pubffm = pubfft;
                                        pubfft = pubffm->ubnxt;
                                    }

                                    pubffm->ubnxt = pubffcd[ins];
                                }
                                else {
                                    sprintf_f(mrs->log, "[GW] ring%d allocate memory failed!! size: %d\n", ins, sizeof(struct usbBuffLink_s)); 
                                    print_f(mrs->plog, "fs145", mrs->log);
                                }
                            }

                            if (!pubffcd[ins]) {
                                break;
                            }
                            
                            if (!pubffcd[ins]->ubbufh) {
                                pubffcd[ins]->ubbufh= malloc(sizeof(struct usbBuff_s));
                                if (pubffcd[ins]->ubbufh) {
                                    
                                    pubffcd[ins]->ubbufh->bpt = malloc(sizeof(uint32_t));
                                    
                                    if (!pubffcd[ins]->ubbufh->bpt) {
                                        sprintf_f(mrs->log, "[GW] ring%d ubbufh allocate memory failed!! size: %d\n", ins, USB_BUF_SIZE); 
                                        print_f(mrs->plog, "fs145", mrs->log);
                                        break;
                                    }
                                    pubffcd[ins]->ubbufh->bn = 0;
                                } else {
                                    sprintf_f(mrs->log, "[GW] ring%d allocate memory failed!! size: %d\n", ins, sizeof(struct usbBuff_s)); 
                                    print_f(mrs->plog, "fs145", mrs->log);
                                    break;
                                }
                                
                                curbf = pubffcd[ins]->ubbufh;
                                pubffcd[ins]->ubbufc = curbf;
                            }
                            else {

                                curbf = pubffcd[ins]->ubbufc;
                                tmpbf = malloc(sizeof(struct usbBuff_s));
                                if (tmpbf) {
                                    
                                    tmpbf->bpt = malloc(sizeof(uint32_t));
                                    
                                    if (!tmpbf->bpt) {
                                        sprintf_f(mrs->log, "[GW] ring%d tmpbf allocate memory failed!! size: %d\n", ins, USB_BUF_SIZE); 
                                        print_f(mrs->plog, "fs145", mrs->log);
                                        break;
                                    }
                                    tmpbf->bn = 0;
                                    curbf->bn = tmpbf;
                                    pubffcd[ins]->ubbufc = tmpbf;
                                }
                            }
                            
                            curbf = pubffcd[ins]->ubbufc;

                            if ((!curbf) || (!pubffh->ubbufh)) {
                                break;
                            }
                            
                            add32d = (uint32_t *) curbf->bpt;
                            
                            msync(addrs, lens, MS_SYNC);
                            
                            #if DBG_DUMP_DAT32
                            sprintf_f(mrs->log, "[GW] dump 32 - 1\n");
                            print_f(mrs->plog, "fs145", mrs->log);
                            shmem_dump(addrs, 32);
                            #endif
                            
                            *add32d = (uint32_t)addrs;
                            curbf->bsz = lens;

                            totsz[ins] += lens;
                            
                            if (pllcmd[ins] == 'E') {
                                if ((matcmd[ins] == 'Q') ||(matcmd[ins] == 'D')) {
                                    if (pubffcd[ins]->ublastsize == 0) {
                                        pubffcd[ins]->ublastsize = lens;
                                        //sprintf_f(mrs->log, "[GW] ring%d the last trunk size: %d total: %d - 1\n", ins, lens, totsz[ins]);                                    
                                        //print_f(mrs->plog, "fs145", mrs->log);

                                        write(infd[ins], &matcmd[ins-1], 1);
                                                                            
                                        lens = -1;                                    
                                    } else {
                                        //sprintf_f(mrs->log, "[GW] ring%d meta size: %d \n", ins, lens);
                                        //print_f(mrs->plog, "fs145", mrs->log);
                                        pubffcd[ins]->ubmetasize = lens;
                                    }
                                } else {
                                    pubffcd[ins]->ublastsize = lens;
                                }
                            }
                            
                            if (lens < 0) {
                                len = pubffcd[ins]->ublastsize;
                                
                                //sprintf_f(mrs->log, "[GW] the last trunk size: %d \n", len);
                                //print_f(mrs->plog, "fs145", mrs->log);
                                dlen = &ptscaninfo->EPOINT_RESERVE1[0] - &ptscaninfo->ASP_MAGIC_ASPC[0];
                                
                                mlen = len % 512;
                                if (dlen < mlen) {
                                    sprintf_f(mrs->log, "Error!!! usb scaninfo size less than expected len: %d expect: %d \n", mlen, dlen);
                                    print_f(mrs->plog, "fs145", mrs->log);
                                }

                                //sprintf_f(mrs->log, "dump scaninfo size: %d tot: %d \n", mlen, len);
                                //print_f(mrs->plog, "fs145", mrs->log);

                                addrd = addrs + (len - mlen);

                                pubffcd[ins]->ubinfoaddr = addrd;
                                
                                if (ins == 1) {
                                    memset(ptscaninfo, 0, sizeof(struct aspMetaDataviaUSB_s));
                                    memcpy(ptscaninfo, addrd, mlen);    
                                } else {
                                    memset(ptscaninfoduo, 0, sizeof(struct aspMetaDataviaUSB_s));
                                    memcpy(ptscaninfoduo, addrd, mlen);    
                                }

                            }
                            else if ((lens < USB_BUF_SIZE) && (lasflag)) {
                                #if DBG_USB_GATE
                                sprintf_f(mrs->log, "[GW] ring%d scaninfo size: %d total: %d - 2\n", ins, lens, totsz[ins]);
                                print_f(mrs->plog, "fs145", mrs->log);
                                #endif

                                maxsz = 0;

                                #if 0 /* disable the skip short image mechanism */
                                gval = 0;
                                ret = cfgTableGetChkDPI(pct, ASPOP_RESOLUTION, &gval, ASPOP_STA_APP);
                                maxsz = gval;
                                #endif
            
                                if (ins == 1) {
                                    //sprintf_f(mrs->log, "get usb scaninfo lastlen: %d infolen: %d\n", pubffcd[ins]->ublastsize, pubffcd[ins]->ubmetasize); 
                                    //print_f(mrs->plog, "fs145", mrs->log);

                                    ret = aspMetafs145GetlenviaUsb(mrs);
                                    if (ret >= 0) {
                                        dlen = ret;
                                        //sprintf_f(mrs->log, "get scanlength: %d!!\n", dlen); 
                                        //print_f(mrs->plog, "fs145", mrs->log);
                                    }
                                    else {
                                        sprintf_f(mrs->log, "get scaninfo failed!!! ret: %d!!\n", ret); 
                                        print_f(mrs->plog, "fs145", mrs->log);                   
                                    }
                                }
                                else {          
                                    //sprintf_f(mrs->log, "duo get usb scaninfo lastlen: %d infolen: %d\n", pubffcd[ins]->ublastsize, pubffcd[ins]->ubmetasize); 
                                    //print_f(mrs->plog, "fs145", mrs->log);
                                    
                                    ret = aspMetafs145GetlenviaUsbDuo(mrs);
                                    if (ret >= 0) {                                    
                                        dlen = ret;
                                        //sprintf_f(mrs->log, "duo get scanlength: %d!!\n", dlen); 
                                        //print_f(mrs->plog, "fs145", mrs->log);                                    
                                    }
                                    else {
                                        sprintf_f(mrs->log, "duo get scaninfo failed!!! ret: %d!!\n", ret); 
                                        print_f(mrs->plog, "fs145", mrs->log);
                                    }
                                }
                                
                                #if DBG_USB_GATE
                                sprintf_f(mrs->log, "[GW] get image length: %d max: %d \n", dlen, maxsz);
                                print_f(mrs->plog, "fs145", mrs->log);
                                #endif
                                
                                if (((dlen > 0) && (dlen > maxsz)) || (dlen == 0)) {
                                    //pllcmd[ins] = (pubffcd[ins]->ubindex & 0x7f) | 0x80;
                                    if (ins == 3) {
                                        pubffcd[ins]->ubindex |= 0x400;
                                    }
                                
                                    indexfo[0] = ((pubffcd[ins]->ubindex >> 5) & 0x3f) | 0xc0;
                                    indexfo[1] = (pubffcd[ins]->ubindex & 0x1f) | 0x40;

                                    if ((pubffcd[ins]->ubindex >> 12) > 0) {
                                        sprintf_f(mrs->log, "\n[GW] WARNNING!!! pubffcd[ins]->ubindex: %d \n", pubffcd[ins]->ubindex);                                
                                        print_f(mrs->plog, "fs145", mrs->log);
                                    }

                                    totsz[ins] = 0;
                                
                                    curbf->bsz |= lasflag;

                                    #if 0
                                    write(outfd[ins], indexfo, 2);
                                    #else

                                    //memcpy(exptbuff, addrs, lens);    

                                    len = ring_buf_get(&mrs->dataRx, &addrc);
                                    while (len <= 0) {
                                        usleep(100000);
                                        len = ring_buf_get(&mrs->dataRx, &addrc);
                                    }
                                    memset(addrc, 0, len);    
                                    
                                    if (ins == 3) {
                                        ptscaninfoduo->ASP_MAGIC_ASPC[0] = indexfo[0];
                                        ptscaninfoduo->ASP_MAGIC_ASPC[1] = indexfo[1];
                                        ptscaninfoduo->MPIONT_LEN = lens;

                                        val = ptscaninfoduo->EXTRA_POINT - ptscaninfoduo->ASP_MAGIC_ASPC;
                                        
                                        //sprintf_f(mrs->log, "[GW] usb meta copy size: %d duo\n", val);                                
                                        //print_f(mrs->plog, "fs145", mrs->log);
                                        
                                        memcpy(addrc, ptscaninfoduo, val);
                                        //shmem_dump(addrc, val);
                                        //addrc += val;

                                        memcpy(addrc + val, addrs, lens);
                                        //shmem_dump(addrc + val, 32);

                                        //shmem_dump(addrc, val+lens);
                                        
                                        if ((val + lens) > len) {
                                            sprintf_f(mrs->log, "[GW] WARNNING!!! meta + extro point = %d + %d > %d !!! - 2\n", val, lens, len);                                
                                            print_f(mrs->plog, "fs145", mrs->log);
                                        }
                                        
                                    }
                                    else {
                                        ptscaninfo->ASP_MAGIC_ASPC[0] = indexfo[0];
                                        ptscaninfo->ASP_MAGIC_ASPC[1] = indexfo[1];
                                        ptscaninfo->MPIONT_LEN = lens;


                                        val = ptscaninfo->EXTRA_POINT - ptscaninfo->ASP_MAGIC_ASPC;

                                        //sprintf_f(mrs->log, "[GW] usb meta copy size: %d \n", val);                                
                                        //print_f(mrs->plog, "fs145", mrs->log);

                                        memcpy(addrc, ptscaninfo, val);
                                        //shmem_dump(addrc, val);
                                        //addrc += val;

                                        memcpy(addrc+val, addrs, lens);
                                        //shmem_dump(addrc+val, 32);
                                        
                                        //shmem_dump(addrc, val+lens);

                                        if ((val + lens) > len) {
                                            sprintf_f(mrs->log, "[GW] WARNNING!!! meta + extro point = %d + %d > %d !!! - 1\n", val, lens, len);                                
                                            print_f(mrs->plog, "fs145", mrs->log);
                                        }

                                    }
                                    #endif

                                    ring_buf_prod(&mrs->dataRx);

                                    //sprintf_f(mrs->log, "[GW] meta + extro point = %d + %d max:%d info: 0x%.2x + 0x%.2x \n", val, lens, len, indexfo[0], indexfo[1]);
                                    //print_f(mrs->plog, "fs145", mrs->log);

                                    mrs_ipc_put(mrs, "o", 1, 2);
                                    mrs_ipc_put(mrs, indexfo, 2, 2);
                                    
                                    sprintf_f(mrs->log, "[GW] out%d id:%d put info: 0x%.2x + 0x%.2x remain: %d total count: %d index: 0x%.3x- end of transmission \n", 
                                                                  ins, outfd[ins], indexfo[0], indexfo[1], cycCnt[ins], pubffcd[ins]->ubcylcnt, pubffcd[ins]->ubindex);
                                    print_f(mrs->plog, "fs145", mrs->log);                            
                                }
                                else {
                                    pubffcd[ins]->ubindex |= 0x800;
                                    sprintf_f(mrs->log, "[GW] WARNNING!!! image too short skip this page!!! scanlen: %d min: %d\n", dlen, maxsz);                                
                                    print_f(mrs->plog, "fs145", mrs->log);
                                }
                                
                                cycCnt[ins] = 0;
                                pubffcd[ins] = 0;
                            }
                            else {
                                cycCnt[ins] += 1;                            
                                pubffcd[ins]->ubcylcnt += 1;

                                if ((cycCnt[ins] > CYCLE_LEN) && (pubffcd[ins]->ubcylcnt > CYCLE_LEN)) {
                                    /* send back index */
                                    //pllcmd[ins] = (pubffcd[ins]->ubindex & 0x7f) | 0x80;
                                    if (ins == 3) {
                                        pubffcd[ins]->ubindex |= 0x400;
                                    }
                                    
                                    indexfo[0] = ((pubffcd[ins]->ubindex >> 5) & 0x3f) | 0xc0;
                                    indexfo[1] = (pubffcd[ins]->ubindex & 0x1f) | 0x40;

                                    //if (resltion >= 600) {
                                    //    write(outfd[ins], indexfo, 2);
                                    //}

                                    #if DBG_USB_GATE
                                    sprintf_f(mrs->log, "[GW] out%d id:%d put info: 0x%.2x + 0x%.2x - middle of transmission count: %d:%d \n", ins, outfd[ins], indexfo[0], indexfo[1], cycCnt[ins], pubffcd[ins]->ubcylcnt);
                                    print_f(mrs->plog, "fs145", mrs->log);
                                    #endif
                                    
                                    cycCnt[ins] -= CYCLE_LEN;
                                }
                            }
                        }
                        else if (pllcmd[ins] == 'S') {
                            if (ins == 3) {
                                ons = 0;
                                if (latcmd[ons] == 's') {
                                    chq = 'p';
                                    write(outfd[ons], &chq, 1);

                                    write(outfd[ons], &latcmd[ons], 1);

                                } else if (latcmd[ons] == 'q') {
                                    chq = 'r';
                                    write(outfd[ons], &chq, 1);

                                    write(outfd[ons], &latcmd[ons], 1);

                                } else {

                                    chq = 'r';
                                    write(outfd[ons], &chq, 1);
                                    sprintf_f(mrs->log, "[GW] out%d id:%d put chr: %c(0x%.2x) \n", ons, outfd[ons], chq, chq);
                                    print_f(mrs->plog, "fs145", mrs->log);
                                    chq = 'q';
                                    write(outfd[ons], &chq, 1);
                                    sprintf_f(mrs->log, "[GW] out%d id:%d put chr: %c(0x%.2x) \n", ons, outfd[ons], chq, chq);
                                    print_f(mrs->plog, "fs145", mrs->log);
                                }

                                ons = 2;
                                if (latcmd[ons] == 's') {
                                    write(outfd[ons], &latcmd[ons], 1);

                                } else if (latcmd[ons] == 'q') {
                                    write(outfd[ons], &latcmd[ons], 1);

                                } else {

                                    chq = 'q';
                                    write(outfd[ons], &chq, 1);
                                    sprintf_f(mrs->log, "[GW] out%d id:%d put chr: %c(0x%.2x) \n", ons, outfd[ons], chq, chq);
                                    print_f(mrs->plog, "fs145", mrs->log);
                                }
                            }
                        }
                        else if (pllcmd[ins] == 'Q') {

                            matcmd[ins] = pllcmd[ins];
                        }
                        else if (pllcmd[ins] == 'O') {

                            matcmd[ins] = 'o';
                            
                            write(infd[ins], &latcmd[ins], 1);
                            sprintf_f(mrs->log, "[GW] out%d id:%d put chr: %c(0x%.2x) \n", ins, infd[ins], latcmd[ins], latcmd[ins]);
                            print_f(mrs->plog, "fs145", mrs->log);
                        }
                        else if (pllcmd[ins] == 'F') {
                            matcmd[ins] = pllcmd[ins];
                            if (ins == 3) {
                                #if 1
                                latcmd[2] = 'q';
                                write(outfd[2], &latcmd[2], 1);
                                #else
                                if (latcmd[0] == 'Q') {
                                    latcmd[0] = 'q';
                                    latcmd[2] = 'q';
                                    write(outfd[2], &latcmd[2], 1);

                                    write(outfd[0], &latcmd[0], 1);

                                }
                                else if (latcmd[0] == 'R') {
                                    latcmd[3] = 's';
                                    chq = 'q';
                                    write(outfd[2], &chq, 1);
                                    latcmd[2] = 'Q';
                                } else {
                                    latcmd[2] = 'Q';
                                }
                                #endif
                            }
                            else {
                                #if 1
                                latcmd[0] = 'q';
                                write(outfd[0], &latcmd[0], 1);
                                #else
                                if (latcmd[2] == 'Q') {
                                    latcmd[0] = 'q';
                                    latcmd[2] = 'q';
                                    write(outfd[2], &latcmd[2], 1);

                                    write(outfd[0], &latcmd[0], 1);

                                }
                                else if (latcmd[2] == 'R') {
                                    latcmd[1] = 's';
                                    chq = 'q';
                                    write(outfd[0], &chq, 1);
                                    latcmd[0] = 'Q';
                                }
                                else {
                                    latcmd[0] = 'Q';
                                }
                                #endif
                            }
                        }
                        else if (pllcmd[ins] == 'R') {
                            if (ins == 3) {
                                if (latcmd[0] == 'R') {
                                    latcmd[0] = 'e';
                                    latcmd[2] = 'e';
                                    chq = 'g';
                                    write(outfd[0], &chq, 1);

                                    write(outfd[2], &chq, 1);

                                }
                                else if (latcmd[0] == 'Q') {
                                    latcmd[1] = 's';
                                    chq = 'q';
                                    write(outfd[0], &chq, 1);
                                    latcmd[2] = 'R';
                                }
                                else {
                                    latcmd[2] = 'R';
                                }                                
                            }
                            else {
                                if (latcmd[2] == 'R') {
                                    latcmd[0] = 'e';
                                    latcmd[2] = 'e';
                                    chq = 'g';
                                    write(outfd[0], &chq, 1);

                                    write(outfd[2], &chq, 1);

                                }
                                else if (latcmd[2] == 'Q') {
                                    latcmd[3] = 's';
                                    chq = 'q';
                                    write(outfd[2], &chq, 1);
                                    latcmd[0] = 'R';                                    
                                }
                                else {
                                    latcmd[0] = 'R';
                                }                                
                            }
                        }
                        else if (pllcmd[ins] == 'G') {
                            //pllcmd[ins] = 0xbf;;
                            //write(outfd[ins], &pllcmd[ins], 1);
                            //sprintf_f(mrs->log, "[GW] out%d id:%d put chr: %c(0x%.2x) - stall of transmission !!! \n", ins, outfd[ins], pllcmd[ins], pllcmd[ins]);
                            //print_f(mrs->plog, "fs145", mrs->log);
                        }
                        else if (pllcmd[ins] == 'B') {
                            sprintf_f(mrs->log, "[GW] id:%d conti read stop !!!\n", ins);
                            print_f(mrs->plog, "fs145", mrs->log);
                        }
                        else if (pllcmd[ins] == 'I') {
                            cswinf = 0;                        
                            gerr = read(pllfd[ins].fd, &cswinf, 1);
                            while (gerr < 0) {
                                cswinf = 0;
                                gerr = read(pllfd[ins].fd, &cswinf, 1);
                            }
                            
                            sprintf_f(mrs->log, "[GW] id:%d conti read get csw status: %c + 0x%.2x !!!\n", ins, pllcmd[ins], cswinf);
                            print_f(mrs->plog, "fs145", mrs->log);

                            if (pubffcd[ins]) {
                                if (pubffcd[ins]->ubcswerr == 0) {
                                    pubffcd[ins]->ubcswerr = cswinf;

                                    //pubffcd[ins] = 0;
                                } else {
                                    sprintf_f(mrs->log, "[GW] Error!!! id:%d conti read set error status failed alread been set val: 0x%.2x !!!\n", ins, pubffcd[ins]->ubcswerr);
                                    print_f(mrs->plog, "fs145", mrs->log);
                                }
                            } else {
                                sprintf_f(mrs->log, "[GW] Error!!! id:%d conti read set error status failed contenter is null !!!\n", ins);
                                print_f(mrs->plog, "fs145", mrs->log);
                            }
                            
                        }
                        else if (pllcmd[ins] == 'J') {
                            pllinf = 0;                        
                            gerr = read(pllfd[ins].fd, &pllinf, 1);
                            while (gerr < 0) {
                                pllinf = 0;
                                gerr = read(pllfd[ins].fd, &pllinf, 1);
                            }

                            pollfo[0] = 'J';
                            pollfo[1] = pllinf;
                            write(outfd[ins], pollfo, 2);
                        }
                        else if (pllcmd[ins] == 'T') {
                            chq = 't';
                            write(outfd[0], &chq, 1);
                            write(outfd[2], &chq, 1);                            
                        }
                        #if USB_AUTO_RESUME
                        else if (pllcmd[ins] == 'V') {
                            sprintf_f(mrs->log, "[GW] id:%d conti resume get ch: %c \n", ins, pllcmd[ins]);
                            print_f(mrs->plog, "fs145", mrs->log);

                            //usleep(5000000);

                            if (ins == 3) {
                                chq = 'v';
                                write(outfd[0], &chq, 1);                            
                            }
                        }
                        #endif
                        else if (pllcmd[ins] == 'X') {
                            pllinf = 0;                        
                            gerr = read(pllfd[ins].fd, &pllinf, 1);
                            while (gerr < 0) {
                                pllinf = 0;
                                gerr = read(pllfd[ins].fd, &pllinf, 1);
                            }
                            
                            sprintf_f(mrs->log, "[GW] id:%d write file erase get ch: %c pllinf: 0x%.2x \n", ins, pllcmd[ins], pllinf);
                            print_f(mrs->plog, "fs145", mrs->log);
                            
                            
                            
                            if (!pllinf) {
                                ring_buf_init(&mrs->cmdRx);
                                
                                sprintf(idfile, filenames, wfileid);
                                filefd = find_read(idfile);

                                if (filefd) {
                                    write(infd[ins], "u", 1);    

                                    ret = fseek(filefd, 0, SEEK_END);
                                    if (ret) {
                                        sprintf_f(mrs->log, "[GW] fileacc seek failed!! ret:%d \n", ret);
                                        print_f(mrs->plog, "fs145", mrs->log);
                                    } 

                                    maxsz = ftell(filefd);

                                    sprintf_f(mrs->log, "[GW] fileacc id%d get read filename:[%s] size: %d \n", ins, idfile, maxsz);
                                    print_f(mrs->plog, "fs145", mrs->log);                                

                                    ret = fseek(filefd, 0, SEEK_SET);
                                    if (ret) {
                                        sprintf_f(mrs->log, "[GW] fileacc seek failed!! ret:%d \n", ret);
                                        print_f(mrs->plog, "fs145", mrs->log);
                                    } 
                                    
                                    while(maxsz) {

                                        lens = ring_buf_get(&mrs->cmdRx, &addrs);
                                        while (lens <= 0) {
                                            usleep(100000);
                                            lens = ring_buf_get(&mrs->cmdRx, &addrs);
                                        }

                                        if (lens > maxsz) {
                                            lens = maxsz;
                                        }
                                        maxsz -= lens;

                                        ret = fread(addrs, 1, lens, filefd);
                                        if (ret != lens) {
                                            sprintf_f(mrs->log, "[GW] fileacc read file failed!! ret:%d (%d) \n", ret, lens);
                                            print_f(mrs->plog, "fs145", mrs->log);

                                            break;
                                        }
                                        
                                        //sprintf_f(mrs->log, "[GW] dump memory %d bytes: \n", lens);
                                        //print_f(mrs->plog, "fs145", mrs->log);
                                        //shmem_dump(addrs, lens);

                                        ring_buf_prod(&mrs->cmdRx);
                                    }

                                    if (maxsz) {
                                        sprintf_f(mrs->log, "[GW] fileacc error!!! read file failed!! remain size: %d \n", maxsz);
                                        print_f(mrs->plog, "fs145", mrs->log);                                
                                    }

                                    ring_buf_set_last(&mrs->cmdRx, lens);
                                    
                                    fclose(filefd);
                                    filefd = 0;
                                }
                            } else {
                                pollfo[0] = 'X';
                                pollfo[1] = pllinf;
                                write(outfd[ins], pollfo, 2);
                            }
                        }
                        else if (pllcmd[ins] == 'U') {
                            pllinf = 0;                        
                            gerr = read(pllfd[ins].fd, &pllinf, 1);
                            while (gerr < 0) {
                                pllinf = 0;
                                gerr = read(pllfd[ins].fd, &pllinf, 1);
                            }
                            
                            sprintf_f(mrs->log, "[GW] id:%d write file get ch: %c pllinf: 0x%.2x \n", ins, pllcmd[ins], pllinf);
                            print_f(mrs->plog, "fs145", mrs->log);

                            pollfo[0] = 'U';
                            pollfo[1] = pllinf;
                            write(outfd[ins], pollfo, 2);
                        }
                        else {
                            sprintf_f(mrs->log, "\n[GW] inpo%d Error !!! pipe(%d) get unknown chr:%c(0x%.2x) \n\n", ins, pllfd[ins].fd, pllcmd[ins], pllcmd[ins]);
                            print_f(mrs->plog, "fs145", mrs->log);
                        }
                        
                        break;
                    default:
                        write(outfd[ins], &pllcmd[ins], 1);
                        sprintf_f(mrs->log, "[GW] out%d put chr: %c(0x%.2x) total:%d\n", ins, pllcmd[ins], pllcmd[ins], evcnt);
                        print_f(mrs->plog, "fs145", mrs->log);
                        break;
                    }
                }
            }
        }
        
    }
    return 1;
}

static int fs146(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    sprintf_f(mrs->log, "usb meta  !!!\n");
    print_f(mrs->plog, "fs146", mrs->log);

    mrs_ipc_put(mrs, "m", 1, 12);

    modersp->m = 145;
    
    return 0;
}

static int fs147(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    sprintf_f(mrs->log, "wifi usb single side scan  !!!\n");
    print_f(mrs->plog, "fs147", mrs->log);

    mrs_ipc_put(mrs, "s", 1, 12);

    modersp->m = 145;

    return 0;
}

static int fs148(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    sprintf_f(mrs->log, "check usb status  !!!\n");
    print_f(mrs->plog, "fs148", mrs->log);

    mrs_ipc_put(mrs, "p", 1, 12);

    modersp->m = 145;

    return 0;
}

static int fs149(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    sprintf_f(mrs->log, "wifi usb CFLOAT side scan  !!!\n");
    print_f(mrs->plog, "fs149", mrs->log);

    mrs_ipc_put(mrs, "n", 1, 12);
    mrs_ipc_put(mrs, "n", 1, 13);

    modersp->m = 145;

    return 0;
}

static int fs150(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    sprintf_f(mrs->log, "wifi usb multiple simplex scan  !!!\n");
    print_f(mrs->plog, "fs150", mrs->log);

    mrs_ipc_put(mrs, "r", 1, 12);

    modersp->m = 145;

    return 0;
}

static int fs151(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    sprintf_f(mrs->log, "wifi usb multiple duplex scan  !!!\n");
    print_f(mrs->plog, "fs151", mrs->log);

    mrs_ipc_put(mrs, "q", 1, 12);
    mrs_ipc_put(mrs, "q", 1, 13);

    modersp->m = 145;

    return 0;
}

#define DBG_BKN_GATE (0)
#define MAX_152_EVENT (19)
#define PRI_O_SEC_SELECT (-1)   // 0: select pri, 1: seclect sec, -1: disable
static int fs152(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    sprintf_f(mrs->log, "usb gate !!!\n");
    print_f(mrs->plog, "fs152", mrs->log);

    char filenames[] = "/root/scaner/id_%.5d.bin";
    char idfile[128];
    FILE *filefd=0;
    struct usbhost_s *ppup, *ppdn;
    struct pollfd pllfd[MAX_152_EVENT];
    int *dvtx=0, *dvrx=0;
    int *uphstx=0, *uphsrx=0;
    int *updvtx=0, *updvrx=0;
    int *dnhstx=0, *dnhsrx=0;
    int *dndvtx=0, *dndvrx=0;
    int *upjpgtx=0, *upjpgrx=0;
    int *dnjpgtx=0, *dnjpgrx=0;
    
    int ptret=0, ins=0, evcnt=0, ons=0, gerr=0, inold=0;
    char chp=0, chq=0, cswinf=0, pllinf=0, chv=0, chm=0;
    char pllcmd[MAX_152_EVENT];
    char latcmd[MAX_152_EVENT];
    char matcmd[MAX_152_EVENT];
    char minfo[12];
    char cordbuf[16];
    char indexfo[2];
    char midxfo[2];
    char chindex[2];
    char pollfo[2];
    int outfd[MAX_152_EVENT];
    int infd[MAX_152_EVENT];
    char chu=0, chs=0, cmdex=0;
    int uidx=12, sidx=13, lenrt=0;

    struct shmem_s *ringbf[MAX_152_EVENT];
    char *addrd, *addrs, *addrc;
    uint32_t *add32d, *add32s;
    int lens=-1, szup=0, szdn=0, lastlen=0, ret=0, lasflag=0, val=0, csws=0, mlen=0, cswd=0, dlen=0, len=0;
    int wfileid=0, acusz=0, maxsz=0, fileidcnt=0;
    int totsz[MAX_152_EVENT];
    int cycCnt[MAX_152_EVENT];
    int idxInit=0;
    int memsz=0, pageidx=0, trunkidx=0, memallocsz=0;
    int mindex=0, scnt=0, smax=0;
    uint32_t wfiaddr=0, gval=0, resltion=0;

    struct usbBuffLink_s *pubffh=0, *pubffcd[4], *pubfft=0, *pubffm=0, *pubffo=0, *pubffedt=0;
    struct usbBuff_s *curbf=0, *headbf=0, *tmpbf=0, *outbf=0;

    int prisec=0;
    struct sdFAT_s *pfat=0;
    struct aspConfig_s *pct=0;
    struct aspMetaDataviaUSB_s *ptscaninfo=0, *ptscaninfoduo=0, *ptusbmeta=0;
    struct aspMetaDataviaUSB_s *ptinfomod=0;
    int ix=0, iv=0;
    char *exptbuff=0;
    int bidx=0, mfidx=0, mstatus=0;
    
    //exptbuff = aspMemalloc(32768, 10);
    
    pct = mrs->configTable;

    ptscaninfo = &mrs->metaUsbfs145;
    ptscaninfoduo =&mrs->metaUsbDuofs145;
    
    pfat = &mrs->aspFat;

    ppup = mrs->usbhost[0];
    ppdn = mrs->usbhost[1];

    idxInit = 1;

    cycCnt[0] = 0;
    cycCnt[1] = 0;
    cycCnt[2] = 0;
    cycCnt[3] = 0;
    
    pubffcd[0] = 0;
    pubffcd[1] = 0;
    pubffcd[2] = 0;
    pubffcd[3] = 0;
    
    ringbf[0] = ppup->pushring;
    ringbf[1] = ppup->pgatring;
    ringbf[2] = ppdn->pushring;
    ringbf[3] = ppdn->pgatring;
    
    ringbf[15] = ppup->pushring;
    ringbf[16] = ppdn->pushring;
    
    ins += 1;
    uphstx = ppup->pushtx;
    
    #if DBG_BKN_GATE
    sprintf_f(mrs->log, "[GW] uphstx 0:%d 1:%d (%d)\n", uphstx[0], uphstx[1], ins);
    print_f(mrs->plog, "fs152", mrs->log);
    #endif

    ins += 1;    
    uphsrx = ppup->pushrx;
    
    #if DBG_BKN_GATE
    sprintf_f(mrs->log, "[GW] uphsrx 0:%d 1:%d (%d)\n", uphsrx[0], uphsrx[1], ins);
    print_f(mrs->plog, "fs152", mrs->log);
    #endif

    ins += 1;
    updvtx = ppup->pgattx;

    #if DBG_BKN_GATE
    sprintf_f(mrs->log, "[GW] updvtx 0:%d 1:%d (%d)\n", updvtx[0], updvtx[1], ins);
    print_f(mrs->plog, "fs152", mrs->log);
    #endif

    ins += 1;
    updvrx = ppup->pgatrx;
    
    #if DBG_BKN_GATE
    sprintf_f(mrs->log, "[GW] updvrx 0:%d 1:%d (%d)\n", updvrx[0], updvrx[1], ins);
    print_f(mrs->plog, "fs152", mrs->log);
    #endif

    ins += 1;
    dnhstx = ppdn->pushtx;

    #if DBG_BKN_GATE
    sprintf_f(mrs->log, "[GW] dnhstx 0:%d 1:%d (%d)\n", dnhstx[0], dnhstx[1], ins);
    print_f(mrs->plog, "fs152", mrs->log);
    #endif
    
    ins += 1;
    dnhsrx = ppdn->pushrx;

    #if DBG_BKN_GATE
    sprintf_f(mrs->log, "[GW] dnhsrx 0:%d 1:%d (%d)\n", dnhsrx[0], dnhsrx[1], ins);
    print_f(mrs->plog, "fs152", mrs->log);
    #endif
    
    ins += 1;
    dndvtx = ppdn->pgattx;

    #if DBG_BKN_GATE
    sprintf_f(mrs->log, "[GW] dndvtx 0:%d 1:%d (%d)\n", dndvtx[0], dndvtx[1], ins);
    print_f(mrs->plog, "fs152", mrs->log);
    #endif
    
    ins += 1;
    dndvrx = ppdn->pgatrx;

    #if DBG_BKN_GATE
    sprintf_f(mrs->log, "[GW] dndvrx 0:%d 1:%d (%d)\n", dndvrx[0], dndvrx[1], ins);
    print_f(mrs->plog, "fs152", mrs->log);
    #endif


    ins += 1;
    upjpgtx = ppup->pjpgtx;

    #if DBG_BKN_GATE
    sprintf_f(mrs->log, "[GW] upjpgtx 0:%d 1:%d (%d)\n", upjpgtx[0], upjpgtx[1], ins);
    print_f(mrs->plog, "fs152", mrs->log);
    #endif
    
    ins += 1;
    upjpgrx = ppup->pjpgrx;

    #if DBG_BKN_GATE
    sprintf_f(mrs->log, "[GW] upjpgrx 0:%d 1:%d (%d)\n", upjpgrx[0], upjpgrx[1], ins);
    print_f(mrs->plog, "fs152", mrs->log);
    #endif
    
    ins += 1;
    dnjpgtx = ppdn->pjpgtx;

    #if DBG_BKN_GATE
    sprintf_f(mrs->log, "[GW] dnjpgtx 0:%d 1:%d (%d)\n", dnjpgtx[0], dnjpgtx[1], ins);
    print_f(mrs->plog, "fs152", mrs->log);
    #endif
    
    ins += 1;
    dnjpgrx = ppdn->pjpgrx;

    #if DBG_BKN_GATE
    sprintf_f(mrs->log, "[GW] dnjpgrx 0:%d 1:%d (%d)\n", dnjpgrx[0], dnjpgrx[1], ins);
    print_f(mrs->plog, "fs152", mrs->log);
    #endif

    
    pllfd[0].fd = uphstx[0];
    //pllfd[0].fd = upjpgtx[0];
    pllfd[0].events = POLLIN;
    outfd[0] = updvtx[1];
    infd[0] = uphsrx[1];
    //infd[0] = upjpgrx[1];

    pllfd[1].fd = updvrx[0];
    pllfd[1].events = POLLIN;
    outfd[1] = uphsrx[1];
    //outfd[1] = upjpgrx[1];
    infd[1] = updvtx[1];
    
    pllfd[2].fd = dnhstx[0];
    //pllfd[2].fd = dnjpgtx[0];
    pllfd[2].events = POLLIN;
    outfd[2] = dndvtx[1];
    infd[2] = dnhsrx[1];
    //infd[2] = dnjpgrx[1];
    
    pllfd[3].fd = dndvrx[0];
    pllfd[3].events = POLLIN;
    outfd[3] = dnhsrx[1];
    //outfd[3] = dnjpgrx[1];
    infd[3] = dndvtx[1];

    pllfd[15].fd = upjpgtx[0];
    pllfd[15].events = POLLIN;
    outfd[15] = updvtx[1];
    infd[15] = upjpgrx[1];
    
    pllfd[16].fd = dnjpgtx[0];
    pllfd[16].events = POLLIN;
    outfd[16] = dndvtx[1];
    infd[16] = dnjpgrx[1];
    
    //mrs_ipc_get(struct mainRes_s * mrs, char * str, int size, int idx)

    pllfd[4].fd = mrs->pipeup[12].rt[0];
    pllfd[4].events = POLLIN;

    pllfd[5].fd = mrs->pipeup[13].rt[0];
    pllfd[5].events = POLLIN;

    pllfd[6].fd = mrs->pipeup[7].rt[0];
    pllfd[6].events = POLLIN;

    pllfd[7].fd = mrs->pipeup[3].rt[0];
    pllfd[7].events = POLLIN;

    pllfd[8].fd = mrs->pipeup[8].rt[0];
    pllfd[8].events = POLLIN;

    pllfd[9].fd = mrs->pipeup[1].rt[0];
    pllfd[9].events = POLLIN;

    pllfd[10].fd = mrs->pipeup[2].rt[0];
    pllfd[10].events = POLLIN;

    pllfd[11].fd = mrs->pipeup[15].rt[0];
    pllfd[11].events = POLLIN;
    //outfd[11] = mrs->pipedn[18].rt[1];
    outfd[11] = mrs->pipedn[19].rt[1];
    infd[11] = mrs->pipedn[15].rt[1];
    
    pllfd[12].fd = mrs->pipeup[16].rt[0];
    pllfd[12].events = POLLIN;
    outfd[12] = mrs->pipedn[15].rt[1];
    infd[12] = mrs->pipedn[16].rt[1];

    pllfd[13].fd = mrs->pipeup[17].rt[0];
    pllfd[13].events = POLLIN;
    outfd[13] = mrs->pipedn[15].rt[1];
    infd[13] = mrs->pipedn[17].rt[1];

    pllfd[14].fd = mrs->pipeup[18].rt[0];
    pllfd[14].events = POLLIN;
    outfd[14] = uphsrx[1];
    infd[14] = mrs->pipedn[18].rt[1];

    pllfd[17].fd = mrs->pipeup[19].rt[0];
    pllfd[17].events = POLLIN;
    outfd[17] = mrs->pipedn[20].rt[1];
    infd[17] = mrs->pipedn[19].rt[1];

    pllfd[18].fd = mrs->pipeup[20].rt[0];
    pllfd[18].events = POLLIN;
    outfd[18] = mrs->pipedn[15].rt[1];
    infd[18] = mrs->pipedn[20].rt[1];

    while (1) {
        ret = read(pllfd[1].fd, &chv, 1);
        while (ret > 0) {
            ret = read(pllfd[1].fd, &chv, 1);
        }

        ret = read(pllfd[3].fd, &chv, 1);
        while (ret > 0) {
            ret = read(pllfd[3].fd, &chv, 1);
        }
        
        ret = read(pllfd[0].fd, &chv, 1);
        if ((ret > 0) && (chv == 'n')) {

            memset(latcmd, 0, MAX_152_EVENT);
            
            memset(matcmd, 0, MAX_152_EVENT);
            
            idxInit = 1;

            //cswinf = 0;

            memset(totsz, 0, sizeof(int)*MAX_152_EVENT);

            break;
        }
    }
    
    while(1) {
        ptret = poll(pllfd, MAX_152_EVENT, 100);
        #if DBG_BKN_GATE
        sprintf_f(mrs->log, "[GW] ===== poll return %d =====\n", ptret);
        print_f(mrs->plog, "fs152", mrs->log);
        #endif
        if (ptret < 0) {
            perror("poll");
            sprintf_f(mrs->log, "poll failed, errno: %d\n", errno);
            print_f(mrs->plog, "fs152", mrs->log);
        }
        
        if (ptret > 0) {
            evcnt = 0;
            memset(pllcmd, 0, MAX_152_EVENT);
            for (ins=0; ins < MAX_152_EVENT; ins++) {
                if ((pllfd[ins].revents & POLLIN) == POLLIN) {
                
                    read(pllfd[ins].fd, &pllcmd[ins], 1);
                    
                    #if DBG_BKN_GATE
                    sprintf_f(mrs->log, "[GW] id:%d pipe%d get chr: %c(0x%.2x) total:%d\n", ins, pllfd[ins].fd, pllcmd[ins], pllcmd[ins], ptret);
                    print_f(mrs->plog, "fs152", mrs->log);
                    #endif
                    
                    evcnt++;
                    if (ptret == evcnt) {
                        break;
                    }
                }
            }
            
            evcnt = 0;
            for (ins=0; ins < MAX_152_EVENT; ins++) {
            
                if (pllcmd[ins]) {
                    evcnt++;
                    switch(ins) {
                    case 9:
                    case 10:
                        if (pllcmd[ins] == 'O') {
                            //sprintf_f(mrs->log, "[GW] get ch from p3: %c (0x%.2x) \n", pllcmd[ins], pllcmd[ins]);
                            //print_f(mrs->plog, "fs152", mrs->log);
                            
                            mrs_ipc_get(mrs, minfo, 2, 2);
                            
                            //sprintf_f(mrs->log, "[GW] get info: 0x%.2x + 0x%.2x org: 0x%.2x + 0x%.2x  \n", minfo[0], minfo[1], indexfo[0], indexfo[1]);
                            //print_f(mrs->plog, "fs152", mrs->log);
                            
                            mindex = ((minfo[0] & 0x3f) << 5) | (minfo[1] & 0x1f);
                            mindex = mindex & 0x3ff;
                            
                            pubffedt = pubffh;
                            while (pubffedt) {
                                
                                #if DBG_BKN_GATE
                                sprintf_f(mrs->log, "    [CROP]  check 0x%.3x  get index: 0x%.3x \n", pubffedt->ubindex & 0x3ff, mindex);
                                print_f(mrs->plog, "fs152", mrs->log);
                                #endif
                                
                                if ((pubffedt->ubindex & 0x3ff) == mindex) {
                                    break;
                                }
                                pubffedt = pubffedt->ubnxt;
                            }
                            
                            if (pubffedt) {
                                ptinfomod = (struct aspMetaDataviaUSB_s *)pubffedt->ubinfoaddr;
                            }
                            
                            if (ptinfomod) {
                                addrc = (char *)&ptinfomod->CROP_POS_F1;
                                
                                ret = mrs_ipc_get(mrs, addrc, 16, 2);
                                if (ret != 16) {
                                    sprintf_f(mrs->log, "Error !!! get crop ch result ret: %d != 16 \n", ret);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                }
                            
                                //sprintf_f(mrs->log, "10 dump crop ch result ret: %d \n", ret);
                                //print_f(mrs->plog, "fs152", mrs->log);
                            
                                //shmem_dump(addrc, 16);
                            
                                //dbgMetaUsb(ptinfomod);
                            } else {
                                ret = mrs_ipc_get(mrs, cordbuf, 16, 2);
                                if (ret != 16) {
                                    sprintf_f(mrs->log, "Error !!! get crop ch result ret: %d != 16 \n", ret);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                }
                            
                                sprintf_f(mrs->log, "[GW] Error!!! can't find scan info address, get cord ret: %d\n", ret);
                                print_f(mrs->plog, "fs152", mrs->log);
                            
                                shmem_dump(cordbuf, 16);
                            }
                            
                            //sprintf_f(mrs->log, "[GW] pri or sec: %d\n", ptinfomod->PRI_O_SEC);
                            //print_f(mrs->plog, "fs152", mrs->log);
                            
                            if (ptinfomod->PRI_O_SEC == 0) {
                                //write(outfd[1], minfo, 2);
                                write(infd[15], minfo, 2);
                            } else {
                                //write(outfd[3], minfo, 2);
                                write(infd[16], minfo, 2);
                            }
                        }
                        else if (pllcmd[ins] == 'S') {
                            //sprintf_f(mrs->log, "[GW] get ch from p3: %c (0x%.2x) \n", pllcmd[ins], pllcmd[ins]);
                            //print_f(mrs->plog, "fs152", mrs->log);
                            
                            mrs_ipc_get(mrs, minfo, 2, 2);

                            //sprintf_f(mrs->log, "[GW] get forward msg from p3: 0x%.2x + 0x%.2x \n", minfo[0], minfo[1]);
                            //print_f(mrs->plog, "fs152", mrs->log);
                            
                            write(infd[11], minfo, 2);
                        } else {
                            sprintf_f(mrs->log, "[GW] Error!!! unknown cmd: 0x%.2x id: %d \n", pllcmd[ins], ins);
                            print_f(mrs->plog, "fs152", mrs->log);
                        }

                        break;
                    case 7:
                        modersp->c ++;
                        if (pllcmd[ins] == 'N') {
                            sprintf_f(mrs->log, "[GW] WiFi end transmit count: %d / %d!!! \n", modersp->c, modersp->v);
                            print_f(mrs->plog, "fs152", mrs->log);
                            
                            val = 0;
                            ret = cfgTableGetChk(mrs->configTable, ASPOP_MULTI_LOOP, &val, ASPOP_STA_WR);    
                            if (ret < 0) {
                                sprintf_f(mrs->log, "get pll%d ASPOP_MULTI_LOOP !!! ret: %d val: %d \n", ins, ret, val);
                                print_f(mrs->plog, "fs152", mrs->log);
                            }

                            csws = 0;
                            cfgTableGetChk(mrs->configTable, ASPOP_SCAN_STATUS, &csws, ASPOP_STA_UPD);
                            if (ret < 0) {
                                sprintf_f(mrs->log, "get pll%d ASPOP_SCAN_STATUS !!! ret: %d csws: 0x%.2x \n", ins, ret, csws);
                                print_f(mrs->plog, "fs152", mrs->log);
                            }

                            sprintf_f(mrs->log, "pll%d get ASPOP_SCAN_STATUS(0x%.2x) ASPOP_MULTI_LOOP(%d) \n", ins, csws, val);
                            print_f(mrs->plog, "fs152", mrs->log);

                            #if 1 /* test stopping multiple scan */
                            if ((csws) && (val)) {
                                cfgTableUpd(mrs->configTable, ASPOP_IMG_LEN, 0);
                            }
                            #endif
                                
                            if (modersp->t) {
                                mrs_ipc_put(mrs, "d", 1, 7);
                            } else {
                                mrs_ipc_put(mrs, "c", 1, 7);
                            }
                        }
                        break;
                    case 8:
                        modersp->c ++;
                        if (pllcmd[ins] == 'N') {
                            sprintf_f(mrs->log, "[GW] WiFi end duo transmit count: %d / %d!!! \n", modersp->c, modersp->v);
                            print_f(mrs->plog, "fs152", mrs->log);
                            
                            val = 0;
                            ret = cfgTableGetChk(mrs->configTable, ASPOP_MULTI_LOOP, &val, ASPOP_STA_WR);    
                            if (ret < 0) {
                                sprintf_f(mrs->log, "get pll%d ASPOP_MULTI_LOOP !!! ret: %d val: %d \n", ins, ret, val);
                                print_f(mrs->plog, "fs152", mrs->log);
                            }

                            csws = 0;
                            ret = cfgTableGetChk(mrs->configTable, ASPOP_SCAN_STATUS_DUO, &csws, ASPOP_STA_UPD);
                            if (ret < 0) {
                                sprintf_f(mrs->log, "get pll%d ASPOP_SCAN_STATUS_DUO !!! ret: %d csws: 0x%.2x \n", ins, ret, csws);
                                print_f(mrs->plog, "fs152", mrs->log);
                            }

                            sprintf_f(mrs->log, "pll%d get ASPOP_SCAN_STATUS_DUO(0x%.2x) ASPOP_MULTI_LOOP(%d) \n", ins, csws, val);
                            print_f(mrs->plog, "fs152", mrs->log);

                            #if 1 /* test stopping multiple scan */
                            if ((csws) && (val)) {
                                cfgTableUpd(mrs->configTable, ASPOP_IMG_LEN_DUO, 0);
                            }
                            #endif
                            
                            if (modersp->t) {
                                mrs_ipc_put(mrs, "d", 1, 7);
                            } else {
                                mrs_ipc_put(mrs, "c", 1, 7);
                            }

                        }
                        break;
                    case 6:
                        chu = pllcmd[ins];
                        
                        val = 0;
                        ret = cfgTableGetChk(mrs->configTable, ASPOP_MULTI_LOOP, &val, ASPOP_STA_WR);    
                        if (ret < 0) {
                            sprintf_f(mrs->log, "Error get pll%d ASPOP_MULTI_LOOP failed!!! ret: %d val: %d\n", ins, ret, val);
                            print_f(mrs->plog, "fs152", mrs->log);
                        }
                        
                        sprintf_f(mrs->log, "get pll%d ASPOP_MULTI_LOOP val: %d!!! ret: %d signal: %c \n", ins, val, ret, chu);
                        print_f(mrs->plog, "fs152", mrs->log);

                        if (chu == 'C') {
                            if (val) {
                                mrs_ipc_put(mrs, "t", 1, 12);
                                continue;
                            } else {
                                mrs_ipc_put(mrs, "b", 1, 13);
                            }
                        } else if (chu == 'D') {
                            if (val) {
                                mrs_ipc_put(mrs, "o", 1, 12);
                                mrs_ipc_put(mrs, "o", 1, 13);
                                continue;
                            } else {
                                mrs_ipc_put(mrs, "b", 1, 13);
                            }
                        } else {
                            csws = 0;
                            cfgTableGetChk(mrs->configTable, ASPOP_SCAN_STATUS, &csws, ASPOP_STA_UPD);
                            if (ret < 0) {
                                sprintf_f(mrs->log, "get pll%d ASPOP_SCAN_STATUS !!! ret: %d csws: 0x%.2x \n", ins, ret, csws);
                                print_f(mrs->plog, "fs152", mrs->log);
                            }
                        
                            mlen = 0;
                            ret = cfgTableGetChk(mrs->configTable, ASPOP_IMG_LEN, &mlen, ASPOP_STA_APP);    
                            if (ret < 0) {
                                sprintf_f(mrs->log, "Error get pll%d ASPOP_IMG_LEN failed!!! ret: %d mlen: %d\n", ins, ret, mlen);
                                print_f(mrs->plog, "fs152", mrs->log);
                            }

                            cswd = 0;
                            cfgTableGetChk(mrs->configTable, ASPOP_SCAN_STATUS_DUO, &cswd, ASPOP_STA_UPD);
                            if (ret < 0) {
                                sprintf_f(mrs->log, "get pll%d ASPOP_SCAN_STATUS_DUO !!! ret: %d csws: 0x%.2x \n", ins, ret, cswd);
                                print_f(mrs->plog, "fs152", mrs->log);
                            }
                        
                            dlen = 0;
                            ret = cfgTableGetChk(mrs->configTable, ASPOP_IMG_LEN_DUO, &dlen, ASPOP_STA_APP);    
                            if (ret < 0) {
                                sprintf_f(mrs->log, "Error get pll%d ASPOP_IMG_LEN_DUO failed!!! ret: %d mlen: %d\n", ins, ret, dlen);
                                print_f(mrs->plog, "fs152", mrs->log);
                            }

                            sprintf_f(mrs->log, "chu: [%c] csws: 0x%.2x mlen: %d cswd: 0x%.2x dlen: %d \n", chu, csws, mlen, cswd, dlen);
                            print_f(mrs->plog, "fs152", mrs->log);
                            
                            if (chu == 'E') {
                                if ((mlen == 0) || (csws != 0)) {
                                    pfat->fatSupdata = 0;
                                    pfat->fatSupcur = 0;

                                    mrs_ipc_put(mrs, "b", 1, 13);
                                
                                    sprintf_f(mrs->log, "P6 response BREAK loop chu = %c \n", chu);
                                    print_f(mrs->plog, "fs152", mrs->log);                                    
                                } else {
                                    mrs_ipc_put(mrs, "e", 1, 12);
                                    
                                    mrs_ipc_put(mrs, "t", 1, 12);
                                    
                                    sprintf_f(mrs->log, "P6 response CONTINUE loop chu = %c \n", chu);
                                    print_f(mrs->plog, "fs152", mrs->log);                                    

                                    continue;
                                }                        
                            }
                            else {
                                if ((mlen == 0) || (csws != 0) || (dlen == 0) || (cswd != 0)) {
                                    pfat->fatSupdata = 0;
                                    pfat->fatSupcur = 0;

                                    mrs_ipc_put(mrs, "b", 1, 13);
                            
                                    sprintf_f(mrs->log, "P6 response BREAK loop chu = %c \n", chu);
                                    print_f(mrs->plog, "fs152", mrs->log);                                    
                                } else {
                                    mrs_ipc_put(mrs, "e", 1, 12);
                                    
                                    mrs_ipc_put(mrs, "o", 1, 12);
                                    mrs_ipc_put(mrs, "o", 1, 13);
                                    
                                    sprintf_f(mrs->log, "P6 response CONTINUE loop chu = %c \n", chu);
                                    print_f(mrs->plog, "fs152", mrs->log);                                    

                                    continue;
                                }
                            }
                        }

                        break;
                    case 4:
                        
                        if (pllcmd[ins] == 's') {
                            modersp->v = 0;
                            modersp->c = 0;
                            modersp->t = 0;
                        }
                        else if (pllcmd[ins] == 'p') {
                            modersp->v += 1;
                            mrs_ipc_put(mrs, "n", 1, 3);
                        }
                        else if (pllcmd[ins] == 'd') {
                            modersp->v += 1;

                            mrs_ipc_put(mrs, "N", 1, 3);

                            sprintf_f(mrs->log, "[GW] end transmit count: %d !!! \n", modersp->v);
                            print_f(mrs->plog, "fs152", mrs->log);
                        } else {

                            switch(pllcmd[ins]) {
                            case 'e':
                                ret = mrs_ipc_get(mrs, minfo, 2, 12);
                                if (ret == 2) {
                                    acusz = 0;
                                    filefd = 0;
                                    
                                    wfileid = (minfo[0] << 8) | minfo[1];

                                    #if 0 /* debug */
                                    if (wfileid == 0) {
                                        wfileid = fileidcnt;
                                        fileidcnt ++;
                                    }
                                    #endif

                                    sprintf(idfile, filenames, wfileid);
                                    filefd = find_write(idfile);
                                    
                                    sprintf_f(mrs->log, "[GW] wget file id: %d filename[%s] filefd: %d !!! \n", wfileid, idfile, (uint32_t)filefd);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                } else {
                                    sprintf_f(mrs->log, "[GW] wget file id failed ret: %d !!! \n", ret);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                }
                                break;
                            case 'f':
                                len = 0;
                                len = ring_buf_cons(&mrs->cmdRx, &addrs);
                                while (len <= 0) {
                                    sprintf_f(mrs->log, "[GW] wget cons len: %d \n",len);
                                    print_f(mrs->plog, "fs152", mrs->log);

                                    usleep(100000);

                                    len = ring_buf_cons(&mrs->cmdRx, &addrs);
                                }

                                if (filefd) {
                                    ret = fwrite(addrs, 1, len, filefd);
                                    acusz += len;
                                    
                                    //sprintf_f(mrs->log, "[GW] wget write: %d(%d) acusz: %d \n",ret, len, acusz);
                                    //print_f(mrs->plog, "fs152", mrs->log);

                                    if (ret != len) {
                                        sprintf_f(mrs->log, "[GW] warnning!!! wget write size %d but ret %d \n",len, ret);
                                        print_f(mrs->plog, "fs152", mrs->log);
                                    }
                                } else {
                                    sprintf_f(mrs->log, "[GW] error!! wget filefd: %d len: %d \n", (uint32_t)filefd, len);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                }
                                
                                break;
                            case 'g':
                                //sprintf_f(mrs->log, "[GW] wget write end last: %d acusz: %d \n", len, acusz);
                                //print_f(mrs->plog, "fs152", mrs->log);

                                fflush(filefd);
                                fclose(filefd);
                                sync();

                                filefd = 0;
                                
                                filefd = find_read(idfile);

                                ret = fseek(filefd, 0, SEEK_END);
                                if (ret) {
                                    sprintf_f(mrs->log, "[GW] wget file seek failed!! ret:%d \n", ret);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                } 

                                maxsz = ftell(filefd);
                                fclose(filefd);
                                filefd = 0;
                                
                                sprintf_f(mrs->log, "[GW] wget file [%s] size: %d \n", idfile, maxsz);
                                print_f(mrs->plog, "fs152", mrs->log);

                                minfo[0] = 'w';
                                minfo[1] = (maxsz >> 24) & 0xff;
                                minfo[2] = (maxsz >> 16) & 0xff;
                                minfo[3] = (maxsz >> 8) & 0xff;
                                minfo[4] = (maxsz >> 0) & 0xff;

                                mrs_ipc_put(mrs, minfo, 5, 12);
                                
                                break;
                            case 'h':
                                ret = mrs_ipc_get(mrs, minfo, 2, 12);
                                if (ret == 2) {
                                    acusz = 0;
                                    filefd = 0;
                                    
                                    wfileid = (minfo[0] << 8) | minfo[1];
                                    
                                    #if 0 /* debug */
                                    if (wfileid == 0) {
                                        wfileid = fileidcnt;
                                        fileidcnt --;
                                        if (fileidcnt < 0) fileidcnt = 0;
                                    }
                                    #endif
                                    
                                    sprintf(idfile, filenames, wfileid);
                                    filefd = find_read(idfile);
                                    
                                    sprintf_f(mrs->log, "[GW] rget file id: %d filename[%s] filefd: %d !!! \n", wfileid, idfile, (uint32_t)filefd);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                }
                                else {
                                    sprintf_f(mrs->log, "[GW] rget file id failed ret: %d !!! \n", ret);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                }
                                break;
                            case 'i':
                                if (!filefd) {
                                    maxsz = 0;
                                    
                                    minfo[0] = 'r';
                                    minfo[1] = (maxsz >> 24) & 0xff;
                                    minfo[2] = (maxsz >> 16) & 0xff;
                                    minfo[3] = (maxsz >> 8) & 0xff;
                                    minfo[4] = (maxsz >> 0) & 0xff;

                                    mrs_ipc_put(mrs, minfo, 5, 12);

                                    sprintf_f(mrs->log, "[GW] rget file failed, not existed  !!! \n");
                                    print_f(mrs->plog, "fs152", mrs->log);

                                    break;
                                }

                                ret = fseek(filefd, 0, SEEK_END);
                                if (ret) {
                                    sprintf_f(mrs->log, "[GW] rget file seek failed!! ret:%d \n", ret);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                } 
                                maxsz = ftell(filefd);

                                minfo[0] = 'r';
                                minfo[1] = (maxsz >> 24) & 0xff;
                                minfo[2] = (maxsz >> 16) & 0xff;
                                minfo[3] = (maxsz >> 8) & 0xff;
                                minfo[4] = (maxsz >> 0) & 0xff;
                                
                                mrs_ipc_put(mrs, minfo, 5, 12);
                                    
                                sprintf_f(mrs->log, "[GW] rget file maxsz: %d !!! \n", maxsz);
                                print_f(mrs->plog, "fs152", mrs->log);

                                ret = fseek(filefd, 0, SEEK_SET);
                                if (ret) {
                                    sprintf_f(mrs->log, "[GW] rget file seek failed!! ret:%d \n", ret);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                } 

                                while (maxsz) {
                                    len = ring_buf_get(&mrs->cmdRx, &addrs);
                                    while (len <= 0) {
                                        sprintf_f(mrs->log, "[GW] rget buff len: %d \n",len);
                                        print_f(mrs->plog, "fs152", mrs->log);

                                        usleep(100000);

                                        len = ring_buf_get(&mrs->cmdRx, &addrs);
                                    }

                                    if (len > maxsz) {
                                        len = maxsz;
                                    }
                                    
                                    maxsz -= len;
                                    
                                    //sprintf_f(mrs->log, "[GW] read rfile len: %d last: %d\n",len, maxsz);
                                    //print_f(mrs->plog, "fs152", mrs->log);

                                    ret = fread(addrs, 1, len, filefd);
                                    if (ret != len) {
                                        sprintf_f(mrs->log, "[GW] read rfile failed ret: %d (%d) \n",ret, len);
                                        print_f(mrs->plog, "fs152", mrs->log);

                                        ring_buf_prod(&mrs->cmdRx);    
                                        break;
                                    }                                    

                                    ring_buf_prod(&mrs->cmdRx);    
                                    
                                }

                                ring_buf_set_last(&mrs->cmdRx, len);

                                fclose(filefd);
                                filefd = 0;

                                break;
                            case 'j':
                                break;
                            case 'k':
                                break;
                            default:
                                break;
                            }
                        }

                        break;
                    case 5:
                                            
                        //chs = pllcmd[ins];
                        if (pllcmd[ins] == 'b') {
                            /*
                            for (inold = 15; inold <= 16; inold++) {
                                
                                if (latcmd[inold] == 0xff) {
                                    write(infd[inold], &latcmd[inold], 1);
                                    sprintf_f(mrs->log, "[GW] in%d id:%d put chr: %c(0x%.2x) \n", inold, infd[inold], latcmd[inold], latcmd[inold]);            
                                    print_f(mrs->plog, "fs152", mrs->log);

                                    latcmd[inold] = 0;
                                    break;
                                }
                            }
                            */

                            //sprintf_f(mrs->log, "[GW] need buff from 15: %d 16: %d \n", latcmd[15], latcmd[16]);            
                            //print_f(mrs->plog, "fs152", mrs->log);
                            
                            gerr = -1;
                            while (gerr <= 0) {
                                gerr = read(pllfd[ins].fd, &chm, 1);
                            }

                            if (chm == 0x80) {
                                mfidx = 0;
                            } else {
                                mfidx = chm & 0x7f;
                            }

                            ret = aspBMPdecodeBuffStatusGet(&mrs->bmpDecMfour[mfidx], &mstatus);
                            sprintf_f(mrs->log, "[GW] free buff %d get status: 0x%.4x ret: %d \n", mfidx, mstatus, ret);
                            print_f(mrs->plog, "fs152", mrs->log);
                            
                            aspBMPdecodeBuffInit(&mrs->bmpDecMfour[mfidx]);

                            if ((latcmd[15]) && (latcmd[16])) {
                                if (latcmd[15] < latcmd[16]) {
                                    inold = 15;
                                } else {
                                    inold = 16;
                                }
                            }
                            else if (latcmd[15]) {
                                inold = 15;
                            }
                            else if (latcmd[16]) {
                                inold = 16;
                            } else {
                                inold = 0;
                            }

                            if (inold) {
                                //latcmd[inold] = 0xff;
                                chm = 0xff;
                                write(infd[inold], &chm, 1);
                                sprintf_f(mrs->log, "[GW] free buff to in%d id:%d put chr: %c(0x%.2x) \n", inold, infd[inold], chm, chm);            
                                print_f(mrs->plog, "fs152", mrs->log);

                                //latcmd[inold] = 0;
                            }
                        }
                        else if (pllcmd[ins] == 's') {
                            modersp->v = 0;
                            modersp->c = 0;
                            modersp->t = 1;
                        }
                        else if (pllcmd[ins] == 'p') {
                            modersp->v += 1;
                            mrs_ipc_put(mrs, "n", 1, 8);
                        }
                        else if (pllcmd[ins] == 'd') {
                            modersp->v += 1;

                            mrs_ipc_put(mrs, "N", 1, 8);

                            sprintf_f(mrs->log, "[GW] end duo transmit count: %d !!! \n", modersp->t);
                            print_f(mrs->plog, "fs152", mrs->log);
                        }

                        break;
                    case 11: // rs15 p12
                        //sprintf_f(mrs->log, "[GW] m4 get chr: %c(0x%.2x) id: %d\n", pllcmd[ins], pllcmd[ins], ins);
                        //print_f(mrs->plog, "fs152", mrs->log);

                        if (latcmd[0] == '1') {
                            sprintf_f(mrs->log, "[GW] m4 block till flow stop \n");
                            print_f(mrs->plog, "fs152", mrs->log);
                            break;
                        }

                        if (pllcmd[ins] == 'R') {
                            pollfo[0] = 'e';
                            gerr = -1;
                            while (gerr <= 0) {
                                gerr = read(pllfd[ins].fd, &chm, 1);
                            }
                                
                            if (chm == 0x80) {
                                mfidx = 0;
                            } else {
                                mfidx = chm & 0x7f;
                            }
                            
                            sprintf_f(mrs->log, "[GW] R m4 get sec chr: (0x%.2x) buff idx: %d\n", chm, mfidx);
                            print_f(mrs->plog, "fs152", mrs->log);
                            
                            
                            ret = aspBMPdecodeBuffStatusGet(&mrs->bmpDecMfour[mfidx], &mstatus);
                            sprintf_f(mrs->log, "[GW] decode bmp buff %d get status: 0x%.4x ret: %d \n", mfidx, mstatus, ret);
                            print_f(mrs->plog, "fs152", mrs->log);
                            
                            /*
                            mstatus = (mstatus << 1) | 0x01;
                            
                            ret = aspBMPdecodeBuffStatusSet(&mrs->bmpDecMfour[mfidx], mstatus);
                            sprintf_f(mrs->log, "[GW] decode bmp buff %d set status: 0x%.4x ret: %d \n", mfidx, mstatus, ret);
                            print_f(mrs->plog, "fs152", mrs->log);
                            */
                            
                            pollfo[1] = chm;
                            
                            write(infd[14], pollfo, 2);
                        }
                        else if (pllcmd[ins] == 'S') {
                            pollfo[0] = 'c';
                            gerr = -1;
                            while (gerr <= 0) {
                                gerr = read(pllfd[ins].fd, &chm, 1);
                            }
                                
                            if (chm == 0x80) {
                                mfidx = 0;
                            } else {
                                mfidx = chm & 0x7f;
                            }
                            
                            sprintf_f(mrs->log, "[GW] S m4 get sec chr: (0x%.2x) buff idx: %d\n", chm, mfidx);
                            print_f(mrs->plog, "fs152", mrs->log);
                            
                            
                            ret = aspBMPdecodeBuffStatusGet(&mrs->bmpDecMfour[mfidx], &mstatus);
                            sprintf_f(mrs->log, "[GW] decode bmp buff %d get status: 0x%.4x ret: %d \n", mfidx, mstatus, ret);
                            print_f(mrs->plog, "fs152", mrs->log);
                            
                            /*
                            mstatus = (mstatus << 1) | 0x01;
                            
                            ret = aspBMPdecodeBuffStatusSet(&mrs->bmpDecMfour[mfidx], mstatus);
                            sprintf_f(mrs->log, "[GW] decode bmp buff %d set status: 0x%.4x ret: %d \n", mfidx, mstatus, ret);
                            print_f(mrs->plog, "fs152", mrs->log);
                            */
                            
                            pollfo[1] = chm;
                            
                            write(infd[14], pollfo, 2);
                        }
                        else if (pllcmd[ins] == 'F') {
                            gerr = -1;
                            while (gerr <= 0) {
                                gerr = read(pllfd[ins].fd, &chm, 1);
                            }
                                
                            if (chm == 0x80) {
                                mfidx = 0;
                            } else {
                                mfidx = chm & 0x7f;
                            }
                            
                            sprintf_f(mrs->log, "[GW] F m4 get sec chr: (0x%.2x) buff idx: %d\n", chm, mfidx);
                            print_f(mrs->plog, "fs152", mrs->log);
                            
                            
                            ret = aspBMPdecodeBuffStatusGet(&mrs->bmpDecMfour[mfidx], &mstatus);
                            sprintf_f(mrs->log, "[GW] decode bmp buff %d get status: 0x%.4x ret: %d \n", mfidx, mstatus, ret);
                            print_f(mrs->plog, "fs152", mrs->log);
                            
                            /*
                            mstatus = (mstatus << 1) | 0x01;
                            
                            ret = aspBMPdecodeBuffStatusSet(&mrs->bmpDecMfour[mfidx], mstatus);
                            sprintf_f(mrs->log, "[GW] decode bmp buff %d set status: 0x%.4x ret: %d \n", mfidx, mstatus, ret);
                            print_f(mrs->plog, "fs152", mrs->log);
                            */
                            
                            pollfo[1] = chm;

                            pollfo[0] = 'a';
                            write(infd[17], pollfo, 2);
                            
                            pollfo[0] = 'i';
                            write(infd[18], pollfo, 2);
                        }
                        else {
                            sprintf_f(mrs->log, "[GW] Error!!! unknown ch !!!m4 get chr: %c(0x%.2x) id: %d\n", pllcmd[ins], pllcmd[ins], ins);
                            print_f(mrs->plog, "fs152", mrs->log);
                        }
                            
                        
                        break;
                    case 12: // p13p14
                    case 13:
                        if (pllcmd[ins] == 'd') {
                            //sprintf_f(mrs->log, "[GW] m4 decode get chr: %c(0x%.2x) id: %d\n", pllcmd[ins], pllcmd[ins], ins);
                            //print_f(mrs->plog, "fs152", mrs->log);
                            
                            gerr = -1;
                            while (gerr <= 0) {
                                gerr = read(pllfd[ins].fd, &chm, 1);
                            }
                                
                            if (chm == 0x80) {
                                mfidx = 0;
                            } else {
                                mfidx = chm & 0x7f;
                            }
                            
                            //sprintf_f(mrs->log, "[GW] m4 decode get sec chr: (0x%.2x) buff idx: %d\n", chm, mfidx);
                            //print_f(mrs->plog, "fs152", mrs->log);
                            
                            ret = aspBMPdecodeBuffStatusGet(&mrs->bmpDecMfour[mfidx], &mstatus);
                            sprintf_f(mrs->log, "[GW] decode bmp buff %d get status: 0x%.4x ret: %d \n", mfidx, mstatus, ret);
                            print_f(mrs->plog, "fs152", mrs->log);
                            
                            /*
                            mstatus = (mstatus << 1) | 0x01;
                            
                            ret = aspBMPdecodeBuffStatusSet(&mrs->bmpDecMfour[mfidx], mstatus);
                            sprintf_f(mrs->log, "[GW] decode bmp buff %d set status: 0x%.4x ret: %d \n", mfidx, mstatus, ret);
                            print_f(mrs->plog, "fs152", mrs->log);
                            */
                            
                            pollfo[1] = chm;
                            
                            #if 1 //to m4
                            pollfo[0] = 'f';
                            #else
                            //pollfo[0] = 's';
                            pollfo[0] = 'r';
                            #endif
                            
                            write(outfd[ins], pollfo, 2);

                        }
                        else if (pllcmd[ins] == 's') {
                            //sprintf_f(mrs->log, "[GW] m4 sample get chr: %c(0x%.2x) id: %d\n", pllcmd[ins], pllcmd[ins], ins);
                            //print_f(mrs->plog, "fs152", mrs->log);

                            gerr = -1;
                            while (gerr <= 0) {
                                gerr = read(pllfd[ins].fd, &chm, 1);
                            }
                                
                            if (chm == 0x80) {
                                mfidx = 0;
                            } else {
                                mfidx = chm & 0x7f;
                            }

                            //sprintf_f(mrs->log, "[GW] m4 sample get sec chr: %c(0x%.2x) buff idx: %d\n", chm, chm, mfidx);
                            //print_f(mrs->plog, "fs152", mrs->log);
                            
                            ret = aspBMPdecodeBuffStatusGet(&mrs->bmpDecMfour[mfidx], &mstatus);
                            //sprintf_f(mrs->log, "[GW] sample buff %d get status: 0x%.4x ret: %d \n", mfidx, mstatus, ret);
                            //print_f(mrs->plog, "fs152", mrs->log);
                            
                            pollfo[0] = 's';
                            pollfo[1] = chm;
                            
                            mrs_ipc_put(mrs, pollfo, 2, 2);

                        }
                        else {
                            sprintf_f(mrs->log, "[GW] Error!!! unknown sample command: 0x%.2x id: %d \n", pllcmd[ins], ins);
                            print_f(mrs->plog, "fs152", mrs->log);
                        }

                        break;
                    case 14: // p15
                        //sprintf_f(mrs->log, "[GW] m4 encode get chr: %c(0x%.2x) id: %d\n", pllcmd[ins], pllcmd[ins], ins);
                        //print_f(mrs->plog, "fs152", mrs->log);

                        if (latcmd[0] == '1') {
                            sprintf_f(mrs->log, "[GW] m4 encode block till flow stop \n");
                            print_f(mrs->plog, "fs152", mrs->log);
                            break;
                        }

                        if (pllcmd[ins] == 'P') {

                            pollfo[0] = 'P';

                            gerr = -1;
                            while (gerr <= 0) {
                                gerr = read(pllfd[ins].fd, &chm, 1);
                            }
                            
                            if (chm == 0x80) {
                                mfidx = 0;
                            } else {
                                mfidx = chm & 0x7f;
                            }

                            //sprintf_f(mrs->log, "[GW] to pc get sec chr: %c(0x%.2x) buff idx: %d\n", chm, chm, mfidx);
                            //print_f(mrs->plog, "fs152", mrs->log);


                            ret = aspBMPdecodeBuffStatusGet(&mrs->bmpDecMfour[mfidx], &mstatus);
                            //sprintf_f(mrs->log, "[GW] encode bmp buff %d get status: 0x%.4x ret: %d \n", mfidx, mstatus, ret);
                            //print_f(mrs->plog, "fs152", mrs->log);
                            
                            /*
                            mstatus = (mstatus << 1) | 0x01;
                        
                            ret = aspBMPdecodeBuffStatusSet(&mrs->bmpDecMfour[mfidx], mstatus);
                            sprintf_f(mrs->log, "[GW] encode bmp buff %d set status: 0x%.4x ret: %d \n", mfidx, mstatus, ret);
                            print_f(mrs->plog, "fs152", mrs->log);
                            */

                            pollfo[1] = chm;

                            write(outfd[ins], pollfo, 2);
                        }
                        break;
                    case 17: // p16
                        sprintf_f(mrs->log, "[GW] rjob0 get chr: %c(0x%.2x) id: %d\n", pllcmd[ins], pllcmd[ins], ins);
                        print_f(mrs->plog, "fs152", mrs->log);

                        write(outfd[ins], &pllcmd[ins], 1);
                        break;
                    case 18: // p17
                        sprintf_f(mrs->log, "[GW] rjob1 get chr: %c(0x%.2x) id: %d\n", pllcmd[ins], pllcmd[ins], ins);
                        print_f(mrs->plog, "fs152", mrs->log);

                        write(outfd[ins], &pllcmd[ins], 1);
                        break;
                    case 15: 
                    case 16:

                        if (ins == 15) {
                            inold = 0;
                        }
                        else if (ins == 16) {
                            inold = 2;
                        }

                        if (latcmd[inold] == 'b') {
                            if (((pllcmd[ins] & 0xc0) == 0xc0) || ((pllcmd[ins] & 0xc0) == 0x40)) {
                                sprintf_f(mrs->log, "[GW] id:%d pipe%d get chr: %c(0x%.2x) skip !!! \n", ins, outfd[ins], pllcmd[ins], pllcmd[ins]);
                                print_f(mrs->plog, "fs152", mrs->log);
                                break;
                            } 
                        }
                        
                        if ((pllcmd[ins] & 0xc0) == 0xc0) {
                            if (!pubffh) {
                                pllcmd[ins] = 0xff;
                                write(infd[ins], &pllcmd[ins], 1);
                                sprintf_f(mrs->log, "[GW] in%d id:%d put chr: %c(0x%.2x) total:%d\n", ins, infd[ins], pllcmd[ins], pllcmd[ins], evcnt);            
                                print_f(mrs->plog, "fs152", mrs->log);
                            } else {
                                chindex[0] = pllcmd[ins];

                                ptret = read(pllfd[ins].fd, &pllcmd[ins], 1);
                                while (ptret < 0) {
                                    ptret = read(pllfd[ins].fd, &pllcmd[ins], 1);
                                }
                                
                                if ((pllcmd[ins] & 0xc0) == 0x40) {
                                    chindex[1] = pllcmd[ins];
                                } else {
                                    sprintf_f(mrs->log, "[GW] WARNNING!!! unknow ch: 0x%.2x \n", pllcmd[ins]);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                    break;
                                }

                                mindex = ((chindex[0] & 0x3f) << 5) | (chindex[1] & 0x1f);
                                mindex = mindex & 0x3ff;
                                
                                sprintf_f(mrs->log, "[GW] pll%d get midx: %d (%d:%d)\n", ins, mindex, latcmd[15], latcmd[16]);
                                print_f(mrs->plog, "fs152", mrs->log);
                                
                                if (((latcmd[15] == 0) && (latcmd[16] == 0)) || (latcmd[ins])) {
                                    ret = aspBMPdecodeBuffGet(mrs->bmpDecMfour, &bidx, 4);
                                    sprintf_f(mrs->log, "[GW] get BMP decode buff id: %d ret: %d \n", bidx, ret);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                }
                                else {
                                    sprintf_f(mrs->log, "[GW] %d get BMP decode buff busy (%d, %d) \n", ins, latcmd[15], latcmd[16]);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                    
                                    ret = -1;
                                }
                                
                                if (ret < 0) {
                                    bidx = -1;

                                    //latcmd[ins] = 0xff;
                                    latcmd[ins] = mindex;
                                    //pllcmd[ins] = 0xff;
                                    
                                    //sprintf_f(mrs->log, "[GW] dump buff info(%d): \n", sizeof(struct bitmapDecodeMfour_s) * 4);
                                    //print_f(mrs->plog, "fs152", mrs->log);
                                    //shmem_dump((char *)mrs->bmpDecMfour, sizeof(struct bitmapDecodeMfour_s) * 4);
                                    #if 0
                                    write(infd[ins], &pllcmd[ins], 1);
                                    sprintf_f(mrs->log, "[GW] in%d id:%d put chr: %c(0x%.2x) total:%d\n", ins, infd[ins], pllcmd[ins], pllcmd[ins], evcnt);            
                                    print_f(mrs->plog, "fs152", mrs->log);
                                    #endif

                                    break;
                                }

                                latcmd[ins] = 0;
                                
                                if (!pubffo) {
                                    //sprintf_f(mrs->log, "[GW] find outbuf in pubffo \n");
                                    //print_f(mrs->plog, "fs152", mrs->log);
                                    pubffo = pubffh;
                                    while (pubffo) {
                                        //sprintf_f(mrs->log, "    [GW] 0x%.3x:0x%.3x \n", pubffo->ubindex, mindex);
                                        //print_f(mrs->plog, "fs152", mrs->log);
                                        if ((pubffo->ubindex & 0x3ff) == mindex) {
                                            break;
                                        }
                                        pubffo = pubffo->ubnxt;
                                    }

                                    if (pubffo) {
                                        outbf = pubffo->ubbufh;
                                    }
                                }
                                
                                #if 0 /* memory used debug */
                                if (pubffh) {
                                    memsz = 0;
                                    pageidx = 0;
                                    pubffm = pubffh;
                                    while (pubffm) {
                                        pageidx += 1;
                                        #if 1
                                        tmpbf = pubffm->ubbufh;
                                        trunkidx = 0;
                                        while (tmpbf) {
                                            memsz += USB_BUF_SIZE;
                                            trunkidx += 1;
                                            add32s = (uint32_t *)(tmpbf->bpt);
                                            sprintf_f(mrs->log, "    [GW] %d - 0x%.8x\n", trunkidx, (uint32_t)(*add32s));
                                            print_f(mrs->plog, "fs152", mrs->log);
                                            
                                            tmpbf = tmpbf->bn;
                                        }
                                        sprintf_f(mrs->log, "[GW] memory used: %d - %d idx: 0x%x \n", memsz, pageidx, pubffm->ubindex);
                                        print_f(mrs->plog, "fs152", mrs->log);
                                        #else
                                        sprintf_f(mrs->log, "[GW] mem(%d) idx: 0x%.8x \n", pageidx, pubffm->ubindex);
                                        print_f(mrs->plog, "fs152", mrs->log);
                                        #endif
                                        
                                        pubffm = pubffm->ubnxt;

                                    }
                                }
                                #endif
                                
                                if (!outbf) {
                                    pllcmd[ins] = 0xff;
                                    write(infd[ins], &pllcmd[ins], 1);
                                    sprintf_f(mrs->log, "[GW] in%d id:%d put chr: %c(0x%.2x) no outbf\n", ins, infd[ins], pllcmd[ins], pllcmd[ins]);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                } else if (mindex == (pubffo->ubindex & 0x3ff)) { 
                                
                                    midxfo[0] = ((pubffo->ubindex >> 5) & 0x3f) | 0x80;
                                    midxfo[1] = (pubffo->ubindex & 0x1f) | 0x40;
                                    prisec = pubffo->ubindex & 0x400;
                                    
                                    if ((pubffo->ubmetasize) && (pubffo->ublastsize)) {
                                        smax = pubffo->ubcylcnt - cycCnt[ins] + 2;
                                        #if 0
                                        if (smax > 0xff) {
                                            smax = CYCLE_LEN;
                                        }
                                        #else
                                        if (smax > 0xfff) {
                                            smax = 0xfff;
                                        }
                                        #endif
                                    } else {
                                        smax = CYCLE_LEN;
                                    }

                                    scnt = 0;
                                    while (scnt < smax) {
                                        ret = ring_buf_get(ringbf[ins], &addrd);
                                        if (ret <= 0) {
                                            sprintf_f(mrs->log, "[GW] get ring buffer failed !! ret: %d \n", ret);
                                            print_f(mrs->plog, "fs152", mrs->log);
                                            continue;
                                        }

                                        memallocsz -= 1;
                                        
                                        add32s = (uint32_t *) outbf->bpt;                                        
                                        addrs = (char *) *add32s;
                                        lens = outbf->bsz;

                                        if (lens & 0x40000) {
                                            lasflag = 0x40000;
                                        } else {
                                            lasflag = 0;
                                        }
                                        lens = lens & 0x1ffff;

                                        tmpbf = outbf->bn;
                                        
                                        if ((!tmpbf) && (pubffo->ubmetasize)) {
                                            lens = pubffo->ubmetasize;
                                            lastlen = pubffo->ublastsize;
                                            if ((lens == 0) || (lastlen == 0)) {
                                                sprintf_f(mrs->log, "\n[GW] get the last trunk size error!!! lens: %d lastlen: %d\n", lens, lastlen);
                                                print_f(mrs->plog, "fs152", mrs->log);
                                            }
                                            #if DBG_BKN_GATE
                                            else {
                                                sprintf_f(mrs->log, "\n[GW] get the last trunk size, lens: %d lastlen: %d\n\n", lens, lastlen);
                                                print_f(mrs->plog, "fs152", mrs->log);
                                            }
                                            #endif
                                        }
                                        
                                        msync(addrs, lens, MS_SYNC);
                                        
                                        #if DBG_DUMP_DAT32
                                        sprintf_f(mrs->log, "[GW] dump 32 - 2 - 1 [0x%.8x] \n", (uint32_t)addrs);
                                        print_f(mrs->plog, "fs152", mrs->log);
                                        shmem_dump(addrs, 32);
                                        #endif
                                        
                                        if (addrs == addrd) {
                                            
                                            #if DBG_DUMP_DAT32
                                            sprintf_f(mrs->log, "[GW] compare addr passed !! addr: 0x%.8x \n", (uint32_t)addrs);
                                            print_f(mrs->plog, "fs152", mrs->log);
                                            #endif
                                            
                                        } else {
                                            sprintf_f(mrs->log, "[GW] compare addr failed !! addrs: 0x%.8x addrd: 0x%.8x\n", (uint32_t)addrs, (uint32_t)addrd);
                                            print_f(mrs->plog, "fs152", mrs->log);
                                        }
                                        
                                        msync(addrd, lens, MS_SYNC);
                                        
                                        #if DBG_DUMP_DAT32
                                        sprintf_f(mrs->log, "[GW] dump 32 - 2 - 2 [0x%.8x]\n", (uint32_t)addrd);
                                        print_f(mrs->plog, "fs152", mrs->log);
                                        shmem_dump(addrd, 32);
                                        #endif
                                            
                                        if ((lens < USB_BUF_SIZE) && (lasflag)) {
                                            ret = ring_buf_prod_u(ringbf[ins], lens);
                                            ring_buf_set_last(ringbf[ins], lens);
                                            
                                            pllcmd[ins] = 0x7f;
                                            cswinf = pubffo->ubcswerr;
                                            
                                            outbf = 0;
                                        
                                            headbf = pubffo->ubbufh;
                                            while (headbf) {
                                                tmpbf = headbf;                                            
                                                headbf = tmpbf->bn;
                                                free(tmpbf->bpt);
                                                free(tmpbf);
                                            }
                                            tmpbf = 0;
                                        
                                            if(pubffh == pubffo) {
                                                pubffh = pubffo->ubnxt;
                                            } else {
                                                pubffm = pubffh;
                                                while (pubffm) {
                                                    if (pubffm->ubnxt == pubffo) {
                                                        pubffm->ubnxt = pubffo->ubnxt;
                                                        break;
                                                    }
                                                    pubffm = pubffm->ubnxt;
                                                }
                                            }
                                            
                                            free(pubffo);
                                            
                                            pubffo = 0;
                                            
                                            //sprintf_f(mrs->log, "[GW] the last trunk reach, set outbf == 0, pubffh: 0x%.8x \n", (uint32_t)pubffh);
                                            //print_f(mrs->plog, "fs152", mrs->log);
                                            
                                            scnt = scnt + 1;
                                            cycCnt[ins] = 0;
                                        
                                            break;
                                        }
                                        else if (tmpbf) {
                                            ret = ring_buf_prod_u(ringbf[ins], lens);
                                            outbf = tmpbf;
                                        }
                                        else {
                                            //pllcmd[ins] = 0x80;                                    
                                            sprintf_f(mrs->log, "[GW] Error!!! idle %d \n", cycCnt[ins]);
                                            print_f(mrs->plog, "fs152", mrs->log);
                                            break;
                                        }

                                        scnt = scnt + 1;
                                        cycCnt[ins] = cycCnt[ins] + 1;

                                    }
                                    
                                    if (tmpbf) {
                                        headbf = pubffo->ubbufh;
                                        while (headbf) {
                                            if  (headbf != outbf) {
                                                tmpbf = headbf;
                                                headbf = tmpbf->bn;
                                                //sprintf_f(mrs->log, "[GW] free used buf addr: 0x%.8x \n", tmpbf);
                                                //print_f(mrs->plog, "fs152", mrs->log);
                                                free(tmpbf->bpt);
                                                free(tmpbf);
                                            } else {
                                                break;
                                            }
                                        }
                                        pubffo->ubbufh = headbf;
                                    }

                                    if (pllcmd[ins] == 0x7f) {
                                        minfo[0] = 0x7f;
                                        
                                        minfo[1] = (scnt & 0x7f) | 0x80; // 0  // 0
                                        minfo[2] = ((scnt >> 7) & 0x7f) | 0x80;  // 1
                                        
                                        minfo[3] = (prisec == 0) ? 1:2; //latcmd[ins]; // 1  // 2
                                        
                                        minfo[4] = (char)(lastlen & 0xff); // 2  // 3
                                        minfo[5] = (char)((lastlen >> 8) & 0xff); // 3  // 4
                                        minfo[6] = (char)((lastlen >> 16) & 0xff); // 4  // 5
                                        minfo[7] = (char)((lastlen >> 24) & 0xff); // 5  // 6 

                                        minfo[8] = cswinf; // 6  // 7
                                        
                                        #if 1 /* memory used debug */
                                        pageidx = 0;
                                        if (pubffh) {
                                            pubffm = pubffh;
                                            while (pubffm) {
                                                if ((pubffm->ubindex & 0x800) == 0) {
                                                    pageidx += 1;
                                                }
                                                pubffm = pubffm->ubnxt;
                                            }
                                        }
                                        #endif
                                        
                                        minfo[9] = (char)(pageidx | 0x80); // 7  // 8

                                        if (bidx == 0) {
                                            minfo[10] = 0x80; // 8 // 9
                                        } else {
                                            minfo[10] = (char)(bidx & 0x7f); // 8 // 9
                                        }
                                        
                                        ret = aspBMPdecodeBuffStatusSet(&mrs->bmpDecMfour[bidx], 0);
                                        ret |= aspBMPdecodeBuffSetIdx(&mrs->bmpDecMfour[bidx], mindex);
                                        sprintf_f(mrs->log, "[GW] decode bmp buff %d set id: %d ret: %d \n", bidx, mindex, ret);
                                        print_f(mrs->plog, "fs152", mrs->log);
                                        
                                        write(infd[ins], &minfo, 11);

                                        
                                    }
                                    else {
                                        write(infd[ins], midxfo, 2);
                                    }
                                }      
                                else {                                   
                                    sprintf_f(mrs->log, "[GW] WARNNING!!! in%d id:%d cur index: %d get index: %d NOT handle buffer\n", ins, infd[ins], pubffo->ubindex, mindex);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                }
                            }
                        }
                        break;

                    case 0:
                    case 2:

                        if (latcmd[ins] == 'b') {
                            if (((pllcmd[ins] & 0xc0) == 0xc0) || ((pllcmd[ins] & 0xc0) == 0x40)) {
                                sprintf_f(mrs->log, "[GW] id:%d pipe%d get chr: %c(0x%.2x) skip !!! \n", ins, outfd[ins], pllcmd[ins], pllcmd[ins]);
                                print_f(mrs->plog, "fs152", mrs->log);
                                break;
                            } 
                        }
                        
                        if (pllcmd[ins] == 'd') {
                            latcmd[ins] = 'd';
                            latcmd[ins+1] = 'd';
                            matcmd[ins] = 'h';
                            matcmd[ins+1] = 'h';
                            write(outfd[ins], &pllcmd[ins], 1);
                        }
                        else if (pllcmd[ins] == 's') {
                            if (ins == 2) {
                                latcmd[ins] = 's';
                                latcmd[ins+1] = 's';
                                matcmd[ins] = 'h';
                                matcmd[ins+1] = 'h';
                            } else {
                                latcmd[ins] = 's';
                                latcmd[ins+1] = 's';
                                matcmd[ins] = 'h';
                                matcmd[ins+1] = 'h';
                            }
                        }
                        else if (pllcmd[ins] == 'q') {
                            if (latcmd[ins] == 'q') {
                                sprintf_f(mrs->log, "[GW] already in multiple id:%d lat:%c pll:%c\n", ins, latcmd[ins], pllcmd[ins]);
                                print_f(mrs->plog, "fs152", mrs->log);
                            } else if (latcmd[ins] == 'e') {
                                //sprintf_f(mrs->log, "[GW] already stop multiple id:%d lat:%c pll:%c\n", ins, latcmd[ins], pllcmd[ins]);
                                //print_f(mrs->plog, "fs152", mrs->log);

                                write(outfd[ins], &latcmd[ins], 1);
                            } else if (latcmd[ins] == 'R') {
                                sprintf_f(mrs->log, "[GW] already stop multiple id:%d lat:%c pll:%c waiting \n", ins, latcmd[ins], pllcmd[ins]);
                                print_f(mrs->plog, "fs152", mrs->log);
                            } else if (latcmd[ins] == 0) {
                                if (ins == 2) {
                                    //write(outfd[ins], &pllcmd[ins], 1);
                                    
                                    #if DBG_BKN_GATE
                                    sprintf_f(mrs->log, "[GW] id:%d lat:0x%.2x pll:0x%.2x \n", ins, latcmd[ins], pllcmd[ins]);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                    #endif
                                    
                                    latcmd[ins] = 'q';
                                    latcmd[ins+1] = 'q';
                                    matcmd[ins] = 'f';
                                    matcmd[ins+1] = 'f';
                                } else {
                                    latcmd[ins] = 'q';
                                    latcmd[ins+1] = 'q';
                                    matcmd[ins] = 'f';
                                    matcmd[ins+1] = 'f';
                                }
                            }
                            else {
                                sprintf_f(mrs->log, "[GW] unknown!! id:%d lat:%c(0x%.2x) pll:%c(0x%.2x) - q \n", ins, latcmd[ins], latcmd[ins], pllcmd[ins], pllcmd[ins]);
                                print_f(mrs->plog, "fs152", mrs->log);
                            }
                        }
                        else if (pllcmd[ins] == 'c') {
                            if (latcmd[ins] == 'c') {
                                sprintf_f(mrs->log, "[GW] already in multiple single id:%d lat:%c pll:%c\n", ins, latcmd[ins], pllcmd[ins]);
                                print_f(mrs->plog, "fs152", mrs->log);
                            } else if (latcmd[ins] == 'e') {
                                sprintf_f(mrs->log, "[GW] already stop multiple single id:%d lat:%c pll:%c\n", ins, latcmd[ins], pllcmd[ins]);
                                print_f(mrs->plog, "fs152", mrs->log);

                                write(outfd[ins], &latcmd[ins], 1);
                            } else if (latcmd[ins] == 'R') {
                                sprintf_f(mrs->log, "[GW] already stop multiple id:%d lat:%c pll:%c waiting \n", ins, latcmd[ins], pllcmd[ins]);
                                print_f(mrs->plog, "fs152", mrs->log);
                            } else if (latcmd[ins] == 0) {
                                latcmd[ins] = 'c';
                                latcmd[ins+1] = 'c';
                                matcmd[ins] = 'o';
                                matcmd[ins+1] = 'o';
                                write(outfd[ins], &pllcmd[ins], 1);
                            }
                            else {
                                sprintf_f(mrs->log, "[GW] unknown!! id:%d lat:%c(0x%.2x) pll:%c(0x%.2x) - c\n", ins, latcmd[ins], latcmd[ins], pllcmd[ins], pllcmd[ins]);
                                print_f(mrs->plog, "fs152", mrs->log);
                            }
                        }
                        else if ((pllcmd[ins] == 'p') || (pllcmd[ins] == 'r') || (pllcmd[ins] == 'a') || (pllcmd[ins] == 'k')) {
                            if ((latcmd[ins] == 'q') || (latcmd[ins] == 'c')) {
                            } else if ((latcmd[ins] == 'e') || (latcmd[ins] == 'R')) {
                            } else if (pllcmd[ins] == 'a') {
                                write(outfd[ins], &pllcmd[ins], 1);
                            } else if (pllcmd[ins] == 'k') {
                                write(outfd[ins], &pllcmd[ins], 1);
                            } else if (latcmd[ins] == 0) {
                                sprintf_f(mrs->log, "[GW] id:%d lat:0x%.2x pll:0x%.2x \n", ins, latcmd[ins], pllcmd[ins]);
                                print_f(mrs->plog, "fs152", mrs->log);
                                if (ins == 2) {
                                    write(outfd[ins], &pllcmd[ins], 1);
                                }
                                
                                totsz[ins] =0;
                                totsz[ins+1] = 0;
                            } else if (latcmd[ins] == 's') {
                                sprintf_f(mrs->log, "[GW] id:%d lat:0x%.2x pll:0x%.2x \n", ins, latcmd[ins], pllcmd[ins]);
                                print_f(mrs->plog, "fs152", mrs->log);
                                if (ins == 2) {
                                    write(outfd[ins], &pllcmd[ins], 1);
                                }
                            }
                            else {
                                sprintf_f(mrs->log, "[GW] unknown!! id:%d lat:%c(0x%.2x) pll:%c(0x%.2x) - qrak \n", ins, latcmd[ins], latcmd[ins], pllcmd[ins], pllcmd[ins]);
                                print_f(mrs->plog, "fs152", mrs->log);
                            }
                        }
                        else if ((pllcmd[ins] == 'm') || (pllcmd[ins] == 'n')) {
                            gval = 0;
                            ret = cfgTableGetChkDPI(pct, ASPOP_RESOLUTION, &gval, ASPOP_STA_APP);
                            resltion = gval;
                                
                            /* clean msg queue */
                            for (ix=0; ix<4; ix++) {
                                ret = read(pllfd[ix].fd, &chv, 1);
                                while (ret > 0) {
                                    sprintf_f(mrs->log, "[GW] id:%d pll:0x%.2x (clr)\n", ix, chv);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                    ret = read(pllfd[ix].fd, &chv, 1);
                                }
                            }
                            
                            for (ix=11; ix<19; ix++) {
                                ret = read(pllfd[ix].fd, &chv, 1);
                                while (ret > 0) {
                                    sprintf_f(mrs->log, "[GW] id:%d pll:0x%.2x (clr)\n", ix, chv);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                    ret = read(pllfd[ix].fd, &chv, 1);
                                }
                            }
                        
                            write(outfd[ins], &pllcmd[ins], 1);

                            latcmd[0] = 0;
                            latcmd[1] = 0;
                            latcmd[2] = 0;
                            latcmd[3] = 0;

                            matcmd[0] = 0;
                            matcmd[1] = 0;
                            matcmd[2] = 0;
                            matcmd[3] = 0;

                            pubffcd[0] = 0;
                            pubffcd[1] = 0;
                            pubffcd[2] = 0;
                            pubffcd[3] = 0;
                            
                            idxInit = 1;
                            
                            //cswinf = 0;

                            cmdex = 0;

                            if (pubffh) {
                                memsz = 0;
                                pageidx = 0;
                                
                                pubffm = pubffh;
                                while (pubffm) {
                                    pageidx += 1;

                                    headbf = pubffm->ubbufh;
                                    while (headbf) {
                                        memsz += USB_BUF_SIZE;
                                        tmpbf = headbf;                                            
                                        headbf = tmpbf->bn;
                                        //sprintf_f(mrs->log, "[GW] clean mem addr: 0x%.8x\n", tmpbf);
                                        //print_f(mrs->plog, "fs152", mrs->log);
                                        free(tmpbf->bpt);
                                        free(tmpbf);
                                    }
                                    
                                    tmpbf = 0;
                                            
                                    sprintf_f(mrs->log, "[GW] clean memory used: %d - %d idx: 0x%.2x \n", memsz, pageidx, pubffm->ubindex);
                                    print_f(mrs->plog, "fs152", mrs->log);

                                    pubfft = pubffm;
                                    pubffm = pubfft->ubnxt;

                                    free(pubfft);
                                }

                                pubffh = 0;
                            }
                            
                            totsz[ins] =0;
                            totsz[ins+1] = 0;
                            ring_buf_init(ringbf[ins]);
                            ring_buf_init(ringbf[ins+1]);
                            //ring_buf_init(&mrs->cmdTx);
                            ring_buf_init(&mrs->dataRx);

                            aspBMPdecodeBuffInit(&mrs->bmpDecMfour[0]);
                            aspBMPdecodeBuffInit(&mrs->bmpDecMfour[1]);
                            aspBMPdecodeBuffInit(&mrs->bmpDecMfour[2]);
                            aspBMPdecodeBuffInit(&mrs->bmpDecMfour[3]);
                        }
                        else if (pllcmd[ins] == 'b') {
                            write(outfd[ins], &pllcmd[ins], 1);
                        }
                        else if (pllcmd[ins] == 'x') {
                            //sprintf_f(mrs->log, "[GW] id%d pipe%d get ch: %c(0x%.2x) return stm\n", ins, outfd[ins], pllcmd[ins], pllcmd[ins]);
                            //print_f(mrs->plog, "fs152", mrs->log);
                            
                            pllinf = 0;
                            gerr = read(pllfd[ins].fd, &pllinf, 1);
                            while (gerr < 0) {
                                pllinf = 0;
                                gerr = read(pllfd[ins].fd, &pllinf, 1);
                            }

                            modersp->r = pllinf;

                            /* clean msg queue */
                            for (ix=0; ix<MAX_152_EVENT; ix++) {
                                ret = read(pllfd[ix].fd, &chv, 1);
                                while (ret > 0) {
                                    sprintf_f(mrs->log, "[GW] id:%d pll:0x%.2x (xclr)\n", ix, chv);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                    ret = read(pllfd[ix].fd, &chv, 1);
                                }
                            }
                            
                            return 1;  
                        }
                        else if (pllcmd[ins] == 'i') {
                            write(outfd[ins], &pllcmd[ins], 1);
                        }
                        else if (pllcmd[ins] == 'w') {
                            write(outfd[ins], &pllcmd[ins], 1);
                        }
                        else if (pllcmd[ins] == 'y') {
                            write(outfd[ins], &pllcmd[ins], 1);
                        }
                        else if (pllcmd[ins] == 'z') {
                            write(outfd[ins], &pllcmd[ins], 1);
                        }
                        else if (pllcmd[ins] == 't') {
                            write(outfd[0], &pllcmd[ins], 1);
                            write(outfd[2], &pllcmd[ins], 1);
                        }
                        #if USB_AUTO_RESUME
                        else if (pllcmd[ins] == 'v') {
                            write(outfd[2], &pllcmd[ins], 1);
                            //write(outfd[0], &pllcmd[ins], 1);
                            
                            sprintf_f(mrs->log, "[GW] resume id%d pipe%d get ch: %c \n", ins, outfd[ins], pllcmd[ins]);
                            print_f(mrs->plog, "fs152", mrs->log);
                        }
                        #endif
                        else if (pllcmd[ins] == 'j') {
                        
                            gerr = read(pllfd[ins].fd, minfo, 6);
                            while (gerr <= 0) {
                                gerr = read(pllfd[ins].fd, minfo, 6);
                            }

                            if (gerr != 6) {
                                sprintf_f(mrs->log, "[GW] fileacc id%d get minfo failed!! ret: %d\n", ins, gerr);
                                print_f(mrs->plog, "fs152", mrs->log);
                            }

                            wfileid = (minfo[0] << 8) | minfo[1];
                            wfiaddr = minfo[2];
                            wfiaddr |= minfo[3] << 8;
                            wfiaddr |= minfo[4] << 16;
                            wfiaddr |= minfo[5] << 24;

                            sprintf(idfile, filenames, wfileid);
                            filefd = find_read(idfile);

                            if (filefd) {
                                sprintf_f(mrs->log, "[GW] fileacc id%d get read filename:[%s] \n", ins, idfile);
                                print_f(mrs->plog, "fs152", mrs->log);

                                ret = fseek(filefd, 0, SEEK_END);
                                if (ret) {
                                    sprintf_f(mrs->log, "[GW] fileacc seek failed!! ret:%d \n", ret);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                } 

                                maxsz = ftell(filefd);
                                fclose(filefd);
                                filefd = 0;

                                sprintf_f(mrs->log, "[GW] fileacc id%d get read filename:[%s] size: %d waddr: 0x%.8x\n", ins, idfile, maxsz, wfiaddr);
                                print_f(mrs->plog, "fs152", mrs->log);

                                minfo[0] = pllcmd[ins];
                                minfo[1] = (maxsz >> 24) & 0xff;
                                minfo[2] = (maxsz >> 16) & 0xff;
                                minfo[3] = (maxsz >> 8) & 0xff;
                                minfo[4] = (maxsz >> 0) & 0xff;

                                minfo[5] = wfiaddr & 0xff;
                                minfo[6] = (wfiaddr >> 8) & 0xff;
                                minfo[7] = (wfiaddr >> 16) & 0xff;
                                minfo[8] = (wfiaddr >> 24) & 0xff;

                                write(outfd[ins], minfo, 9);

                                minfo[0] = 'H';                                
                                write(infd[ins], minfo, 5);
                                
                            }
                            else {
                                sprintf_f(mrs->log, "[GW] fileacc id%d get read fileid failed!! ret: %d filename:[%s]\n", ins, (uint32_t)filefd, idfile);
                                print_f(mrs->plog, "fs152", mrs->log);
                            }
                        }
                        else if (pllcmd[ins] == 'u') {
                            write(outfd[ins], &pllcmd[ins], 1);
                        }
                        else if (pllcmd[ins] == '0') {
                            write(outfd[ins], &pllcmd[ins], 1);
                        }
                        else if (pllcmd[ins] == '1') {

                            latcmd[ins] = '1';

                            write(infd[11], &latcmd[ins], 1);
                            write(infd[14], &latcmd[ins], 1);

                            while (1) {
                                pllinf = 0;
                                gerr = read(pllfd[11].fd, &pllinf, 1);
                                while (gerr < 0) {
                                    pllinf = 0;
                                    gerr = read(pllfd[11].fd, &pllinf, 1);
                                }

                                if (pllinf == '1') break;
                            }

                            while (1) {
                                pllinf = 0;
                                gerr = read(pllfd[14].fd, &pllinf, 1);
                                while (gerr < 0) {
                                    pllinf = 0;
                                    gerr = read(pllfd[14].fd, &pllinf, 1);
                                }

                                if (pllinf == '1') break;
                            }
                        }
                        else {
                            sprintf_f(mrs->log, "\n[GW] inpo%d Error !!! pipe(%d) get unknown chr:%c(0x%.2x) Error!! \n\n", ins, pllfd[ins].fd, pllcmd[ins], pllcmd[ins]);
                            print_f(mrs->plog, "fs152", mrs->log);
                        }

                        break;
                    case 1:
                    case 3:
                    
                        if ((pllcmd[ins] == 'D') || (pllcmd[ins] == 'E')) {

                            lens = ring_buf_cons_u(ringbf[ins], &addrs);                
                            while (lens < 0) {
                                sprintf_f(mrs->log, "[GW] cons ring buff ret: %d \n", lens);
                                print_f(mrs->plog, "fs152", mrs->log);
                                usleep(1000);
                                lens = ring_buf_cons_u(ringbf[ins], &addrs);
                            }
                            
                            if (lens & 0x40000) {
                                lasflag = 0x40000;
                            } else {
                                lasflag = 0;
                            }
                            lens = lens & 0x1ffff;

                            #if 0//DBG_BKN_GATE
                            sprintf_f(mrs->log, "[GW] cons u len: %d \n", lens);
                            print_f(mrs->plog, "fs152", mrs->log);
                            #endif

                            memallocsz += 1;

                            if (!pubffh) {
                                pubffh = malloc(sizeof(struct usbBuffLink_s));
                                
                                if (pubffh) {

                                    memset(pubffh, 0, sizeof(struct usbBuffLink_s));
                                    
                                    pubffh->ubindex = idxInit;
                                    idxInit += 1;

                                    if (!cmdex) {
                                        cmdex = latcmd[ins];
                                    }
                                    #if DBG_BKN_GATE
                                    sprintf_f(mrs->log, "[GW] ch%d new index: %d the next is %d latcmd: %c - 1\n", ins, pubffh->ubindex, idxInit, latcmd[ins]);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                    #endif
                                } else {
                                    sprintf_f(mrs->log, "[GW] ring%d allocate memory failed!! size: %d\n", ins, sizeof(struct usbBuffLink_s)); 
                                    print_f(mrs->plog, "fs152", mrs->log);
                                }

                                pubffcd[ins] = pubffh;
                            }

                            if (!pubffh) {
                                break;
                            }

                            if (!pubffcd[ins]) {
                            
                                if (((cmdex) && (latcmd[ins] != cmdex))) {

                                    #if DBG_BKN_GATE
                                    sprintf_f(mrs->log, "[GW] warnning !! latcmd[%d] != cmdex  %c(0x%.2x) : %c(0x%.2x) \n", ins, latcmd[ins], latcmd[ins], cmdex, cmdex); 
                                    print_f(mrs->plog, "fs152", mrs->log);  
                                    #endif
                                    
                                    break;
                                }

                                pubffcd[ins] = malloc(sizeof(struct usbBuffLink_s));
                                if (pubffcd[ins]) {
                                    memset(pubffcd[ins], 0, sizeof(struct usbBuffLink_s));
                                    
                                    pubffcd[ins]->ubindex = idxInit;
                                    idxInit += 1;
                                    
                                    #if DBG_BKN_GATE
                                    sprintf_f(mrs->log, "[GW] ch%d new index: %d the next is %d latcmd: %c - 2\n", ins, pubffcd[ins]->ubindex, idxInit, latcmd[ins]);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                    #endif
                                    
                                    pubffm = pubffh;
                                    pubfft = pubffm->ubnxt;
                                    while (pubfft) {
                                        pubffm = pubfft;
                                        pubfft = pubffm->ubnxt;
                                    }

                                    pubffm->ubnxt = pubffcd[ins];
                                }
                                else {
                                    sprintf_f(mrs->log, "[GW] ring%d allocate memory failed!! size: %d\n", ins, sizeof(struct usbBuffLink_s)); 
                                    print_f(mrs->plog, "fs152", mrs->log);
                                }
                            }

                            if (!pubffcd[ins]) {
                                break;
                            }
                            
                            if (!pubffcd[ins]->ubbufh) {
                                pubffcd[ins]->ubbufh= malloc(sizeof(struct usbBuff_s));
                                if (pubffcd[ins]->ubbufh) {
                                    
                                    pubffcd[ins]->ubbufh->bpt = malloc(sizeof(uint32_t));
                                    
                                    if (!pubffcd[ins]->ubbufh->bpt) {
                                        sprintf_f(mrs->log, "[GW] ring%d ubbufh allocate memory failed!! size: %d\n", ins, USB_BUF_SIZE); 
                                        print_f(mrs->plog, "fs152", mrs->log);
                                        break;
                                    }
                                    pubffcd[ins]->ubbufh->bn = 0;
                                } else {
                                    sprintf_f(mrs->log, "[GW] ring%d allocate memory failed!! size: %d\n", ins, sizeof(struct usbBuff_s)); 
                                    print_f(mrs->plog, "fs152", mrs->log);
                                    break;
                                }
                                
                                curbf = pubffcd[ins]->ubbufh;
                                pubffcd[ins]->ubbufc = curbf;
                            }
                            else {

                                curbf = pubffcd[ins]->ubbufc;
                                tmpbf = malloc(sizeof(struct usbBuff_s));
                                if (tmpbf) {
                                    
                                    tmpbf->bpt = malloc(sizeof(uint32_t));
                                    
                                    if (!tmpbf->bpt) {
                                        sprintf_f(mrs->log, "[GW] ring%d tmpbf allocate memory failed!! size: %d\n", ins, USB_BUF_SIZE); 
                                        print_f(mrs->plog, "fs152", mrs->log);
                                        break;
                                    }
                                    tmpbf->bn = 0;
                                    curbf->bn = tmpbf;
                                    pubffcd[ins]->ubbufc = tmpbf;
                                }
                            }
                            
                            curbf = pubffcd[ins]->ubbufc;

                            if ((!curbf) || (!pubffh->ubbufh)) {
                                break;
                            }
                            
                            add32d = (uint32_t *) curbf->bpt;
                            
                            msync(addrs, lens, MS_SYNC);
                            
                            #if DBG_DUMP_DAT32
                            sprintf_f(mrs->log, "[GW] dump 32 - 1 [0x%.8x] \n", (uint32_t)addrs);
                            print_f(mrs->plog, "fs152", mrs->log);
                            shmem_dump(addrs, 32);
                            #endif
                            
                            *add32d = (uint32_t)addrs;
                            curbf->bsz = lens;

                            totsz[ins] += lens;
                            
                            if (pllcmd[ins] == 'E') {
                                if ((matcmd[ins] == 'Q') ||(matcmd[ins] == 'D')) {
                                    if (pubffcd[ins]->ublastsize == 0) {
                                        pubffcd[ins]->ublastsize = lens;
                                        //sprintf_f(mrs->log, "[GW] ring%d the last trunk size: %d total: %d - 1\n", ins, lens, totsz[ins]);                                    
                                        //print_f(mrs->plog, "fs152", mrs->log);

                                        write(infd[ins], &matcmd[ins-1], 1);
                                                                            
                                        lens = -1;                                    
                                    } else {
                                        //sprintf_f(mrs->log, "[GW] ring%d meta size: %d \n", ins, lens);
                                        //print_f(mrs->plog, "fs152", mrs->log);
                                        pubffcd[ins]->ubmetasize = lens;
                                    }
                                } else {
                                    pubffcd[ins]->ublastsize = lens;
                                }
                            }
                            
                            if (lens < 0) {
                                len = pubffcd[ins]->ublastsize;
                                
                                //sprintf_f(mrs->log, "[GW] the last trunk size: %d \n", len);
                                //print_f(mrs->plog, "fs152", mrs->log);
                                dlen = &ptscaninfo->EPOINT_RESERVE1[0] - &ptscaninfo->ASP_MAGIC_ASPC[0];
                                
                                mlen = len % 512;
                                if (dlen < mlen) {
                                    sprintf_f(mrs->log, "Error!!! usb scaninfo size less than expected len: %d expect: %d \n", mlen, dlen);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                }

                                sprintf_f(mrs->log, "dump scaninfo size: %d tot: %d \n", mlen, len);
                                print_f(mrs->plog, "fs152", mrs->log);

                                addrd = addrs + (len - mlen);

                                //shmem_dump(addrd, 16);
                                
                                pubffcd[ins]->ubinfoaddr = addrd;
                                
                                if (ins == 1) {
                                    memset(ptscaninfo, 0xff, sizeof(struct aspMetaDataviaUSB_s));
                                    memcpy(ptscaninfo, addrd, mlen);

                                    ptusbmeta = ptscaninfo;
                                } else {
                                    memset(ptscaninfoduo, 0xff, sizeof(struct aspMetaDataviaUSB_s));
                                    memcpy(ptscaninfoduo, addrd, mlen);    
                                    
                                    ptusbmeta = ptscaninfoduo;
                                }

                                //dbgMetaUsb(ptusbmeta);

                            }
                            else if ((lens < USB_BUF_SIZE) && (lasflag)) {
                                #if DBG_BKN_GATE
                                sprintf_f(mrs->log, "[GW] ring%d scaninfo size: %d total: %d - 2\n", ins, lens, totsz[ins]);
                                print_f(mrs->plog, "fs152", mrs->log);
                                #endif

                                maxsz = 0;

                                #if 0 /* disable the skip short image mechanism */
                                gval = 0;
                                ret = cfgTableGetChkDPI(pct, ASPOP_RESOLUTION, &gval, ASPOP_STA_APP);
                                maxsz = gval;
                                #endif
            
                                if (ins == 1) {
                                    //sprintf_f(mrs->log, "get usb scaninfo lastlen: %d infolen: %d\n", pubffcd[ins]->ublastsize, pubffcd[ins]->ubmetasize); 
                                    //print_f(mrs->plog, "fs152", mrs->log);

                                    ret = aspMetafs145GetlenviaUsb(mrs);
                                    if (ret >= 0) {
                                        dlen = ret;
                                        //sprintf_f(mrs->log, "get scanlength: %d!!\n", dlen); 
                                        //print_f(mrs->plog, "fs152", mrs->log);
                                    }
                                    else {
                                        sprintf_f(mrs->log, "get scaninfo failed!!! ret: %d!!\n", ret); 
                                        print_f(mrs->plog, "fs152", mrs->log);

                                        shmem_dump((char *)ptscaninfo, sizeof(struct aspMetaDataviaUSB_s));
                                        //shmem_dump((char *)pubffcd[ins]->ubinfoaddr, sizeof(struct aspMetaDataviaUSB_s));
                                    }
                                }
                                else {          
                                    //sprintf_f(mrs->log, "duo get usb scaninfo lastlen: %d infolen: %d\n", pubffcd[ins]->ublastsize, pubffcd[ins]->ubmetasize); 
                                    //print_f(mrs->plog, "fs152", mrs->log);
                                    
                                    ret = aspMetafs145GetlenviaUsbDuo(mrs);
                                    if (ret >= 0) {                                    
                                        dlen = ret;
                                        //sprintf_f(mrs->log, "duo get scanlength: %d!!\n", dlen); 
                                        //print_f(mrs->plog, "fs152", mrs->log);                                    
                                    }
                                    else {
                                        sprintf_f(mrs->log, "duo get scaninfo failed!!! ret: %d!!\n", ret); 
                                        print_f(mrs->plog, "fs152", mrs->log);

                                        shmem_dump((char *)ptscaninfoduo, sizeof(struct aspMetaDataviaUSB_s));
                                        //shmem_dump((char *)pubffcd[ins]->ubinfoaddr, sizeof(struct aspMetaDataviaUSB_s));
                                    }
                                }
                                
                                #if DBG_BKN_GATE
                                sprintf_f(mrs->log, "[GW] get image length: %d max: %d [%s] PRI_O_SEC: %d \n", dlen, maxsz, ptusbmeta->ASP_MAGIC_ASPC, ptusbmeta->PRI_O_SEC);
                                print_f(mrs->plog, "fs152", mrs->log);
                                #endif
                                
                                if ((((dlen > 0) && (dlen > maxsz)) || (dlen == 0)) && 
                                     ((PRI_O_SEC_SELECT < 0) || ((PRI_O_SEC_SELECT >= 0) && (PRI_O_SEC_SELECT == ptusbmeta->PRI_O_SEC)))) {
                                    //pllcmd[ins] = (pubffcd[ins]->ubindex & 0x7f) | 0x80;
                                    if (ins == 3) {
                                        pubffcd[ins]->ubindex |= 0x400;
                                    }
                                
                                    indexfo[0] = ((pubffcd[ins]->ubindex >> 5) & 0x3f) | 0xc0;
                                    indexfo[1] = (pubffcd[ins]->ubindex & 0x1f) | 0x40;

                                    if ((pubffcd[ins]->ubindex >> 12) > 0) {
                                        sprintf_f(mrs->log, "\n[GW] WARNNING!!! pubffcd[ins]->ubindex: %d \n", pubffcd[ins]->ubindex);                                
                                        print_f(mrs->plog, "fs152", mrs->log);
                                    }

                                    totsz[ins] = 0;
                                
                                    curbf->bsz |= lasflag;

                                    #if 0
                                    write(outfd[ins], indexfo, 2);
                                    #else

                                    //memcpy(exptbuff, addrs, lens);    

                                    len = ring_buf_get(&mrs->dataRx, &addrc);
                                    while (len <= 0) {
                                        usleep(100000);
                                        len = ring_buf_get(&mrs->dataRx, &addrc);
                                    }
                                    memset(addrc, 0, len);    
                                    
                                    if (ins == 3) {
                                        ptscaninfoduo->ASP_MAGIC_ASPC[0] = indexfo[0];
                                        ptscaninfoduo->ASP_MAGIC_ASPC[1] = indexfo[1];
                                        ptscaninfoduo->MPIONT_LEN = lens;

                                        val = ptscaninfoduo->EXTRA_POINT - ptscaninfoduo->ASP_MAGIC_ASPC;
                                        
                                        //sprintf_f(mrs->log, "[GW] usb meta copy size: %d duo\n", val);                                
                                        //print_f(mrs->plog, "fs152", mrs->log);
                                        
                                        memcpy(addrc, ptscaninfoduo, val);
                                        //shmem_dump(addrc, val);
                                        //addrc += val;

                                        memcpy(addrc + val, addrs, lens);
                                        //shmem_dump(addrc + val, 32);

                                        //shmem_dump(addrc, val+lens);
                                        
                                        if ((val + lens) > len) {
                                            sprintf_f(mrs->log, "[GW] WARNNING!!! meta + extro point = %d + %d > %d !!! - 2\n", val, lens, len);                                
                                            print_f(mrs->plog, "fs152", mrs->log);
                                        }

                                        ptinfomod = ptscaninfoduo;
                                    }
                                    else {
                                        ptscaninfo->ASP_MAGIC_ASPC[0] = indexfo[0];
                                        ptscaninfo->ASP_MAGIC_ASPC[1] = indexfo[1];
                                        ptscaninfo->MPIONT_LEN = lens;

                                        val = ptscaninfo->EXTRA_POINT - ptscaninfo->ASP_MAGIC_ASPC;

                                        //sprintf_f(mrs->log, "[GW] usb meta copy size: %d \n", val);                                
                                        //print_f(mrs->plog, "fs152", mrs->log);

                                        memcpy(addrc, ptscaninfo, val);
                                        //shmem_dump(addrc, val);
                                        //addrc += val;

                                        memcpy(addrc+val, addrs, lens);
                                        //shmem_dump(addrc+val, 32);
                                        
                                        //shmem_dump(addrc, val+lens);

                                        if ((val + lens) > len) {
                                            sprintf_f(mrs->log, "[GW] WARNNING!!! meta + extro point = %d + %d > %d !!! - 1\n", val, lens, len);                                
                                            print_f(mrs->plog, "fs152", mrs->log);
                                        }
                                        
                                        ptinfomod = ptscaninfo;
                                    }
                                    #endif

                                    ring_buf_prod(&mrs->dataRx);

                                    //sprintf_f(mrs->log, "[GW] meta + extro point = %d + %d max:%d info: 0x%.2x + 0x%.2x \n", val, lens, len, indexfo[0], indexfo[1]);
                                    //print_f(mrs->plog, "fs152", mrs->log);

                                    #if MFOUR_SIM_MODE
                                    //mrs_ipc_put(mrs, "s", 1, 2);
                                    if (ptinfomod->PRI_O_SEC == 0) {
                                        write(infd[15], indexfo, 2);
                                    } else {
                                        write(infd[16], indexfo, 2);
                                    }
                                    #else
                                    mrs_ipc_put(mrs, "o", 1, 2);
                                    mrs_ipc_put(mrs, indexfo, 2, 2);
                                    #endif //#if MFOUR_SIM_MODE
                                    
                                    sprintf_f(mrs->log, "[GW] out%d id:%d put info: 0x%.2x + 0x%.2x remain: %d total count: %d index: 0x%.3x- end of transmission \n", 
                                                                  ins, outfd[ins], indexfo[0], indexfo[1], cycCnt[ins], pubffcd[ins]->ubcylcnt, pubffcd[ins]->ubindex);
                                    print_f(mrs->plog, "fs152", mrs->log);       

                                    //sprintf(mrs->log, "__END__TRANS__");
                                    //dbgShowTimeStamp(mrs->log, mrs, NULL, 2, mrs->log);

                                }
                                else {
                                    pubffcd[ins]->ubindex |= 0x800;
                                    sprintf_f(mrs->log, "[GW] WARNNING!!! image too short skip this page!!! scanlen: %d min: %d, PRI_O_SEC: %d / %d\n", dlen, maxsz, ptusbmeta->PRI_O_SEC, PRI_O_SEC_SELECT);                                
                                    print_f(mrs->plog, "fs152", mrs->log);
                                }
                                
                                cycCnt[ins] = 0;
                                pubffcd[ins] = 0;
                            }
                            else {
                                cycCnt[ins] += 1;                            
                                pubffcd[ins]->ubcylcnt += 1;

                                if ((cycCnt[ins] > CYCLE_LEN) && (pubffcd[ins]->ubcylcnt > CYCLE_LEN)) {
                                    /* send back index */
                                    //pllcmd[ins] = (pubffcd[ins]->ubindex & 0x7f) | 0x80;
                                    if (ins == 3) {
                                        pubffcd[ins]->ubindex |= 0x400;
                                    }
                                    
                                    indexfo[0] = ((pubffcd[ins]->ubindex >> 5) & 0x3f) | 0xc0;
                                    indexfo[1] = (pubffcd[ins]->ubindex & 0x1f) | 0x40;

                                    //if (resltion >= 600) {
                                    //    write(outfd[ins], indexfo, 2);
                                    //}

                                    #if DBG_BKN_GATE
                                    sprintf_f(mrs->log, "[GW] out%d id:%d put info: 0x%.2x + 0x%.2x - middle of transmission count: %d:%d \n", ins, outfd[ins], indexfo[0], indexfo[1], cycCnt[ins], pubffcd[ins]->ubcylcnt);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                    #endif
                                    
                                    cycCnt[ins] -= CYCLE_LEN;
                                }
                            }
                        }
                        else if (pllcmd[ins] == 'S') {
                            if (ins == 3) {
                                ons = 0;
                                if (latcmd[ons] == 's') {
                                    chq = 'p';
                                    write(outfd[ons], &chq, 1);

                                    write(outfd[ons], &latcmd[ons], 1);

                                } else if (latcmd[ons] == 'q') {
                                    chq = 'r';
                                    write(outfd[ons], &chq, 1);

                                    write(outfd[ons], &latcmd[ons], 1);

                                } else {

                                    chq = 'r';
                                    write(outfd[ons], &chq, 1);
                                    sprintf_f(mrs->log, "[GW] out%d id:%d put chr: %c(0x%.2x) \n", ons, outfd[ons], chq, chq);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                    chq = 'q';
                                    write(outfd[ons], &chq, 1);
                                    sprintf_f(mrs->log, "[GW] out%d id:%d put chr: %c(0x%.2x) \n", ons, outfd[ons], chq, chq);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                }

                                ons = 2;
                                if (latcmd[ons] == 's') {
                                    write(outfd[ons], &latcmd[ons], 1);

                                } else if (latcmd[ons] == 'q') {
                                    write(outfd[ons], &latcmd[ons], 1);

                                } else {

                                    chq = 'q';
                                    write(outfd[ons], &chq, 1);
                                    sprintf_f(mrs->log, "[GW] out%d id:%d put chr: %c(0x%.2x) \n", ons, outfd[ons], chq, chq);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                }
                            }
                        }
                        else if (pllcmd[ins] == 'Q') {

                            matcmd[ins] = pllcmd[ins];
                        }
                        else if (pllcmd[ins] == 'O') {

                            matcmd[ins] = 'o';
                            
                            write(infd[ins], &latcmd[ins], 1);
                            sprintf_f(mrs->log, "[GW] out%d id:%d put chr: %c(0x%.2x) \n", ins, infd[ins], latcmd[ins], latcmd[ins]);
                            print_f(mrs->plog, "fs152", mrs->log);
                        }
                        else if (pllcmd[ins] == 'F') {
                            matcmd[ins] = pllcmd[ins];
                            if (ins == 3) {
                                #if 1
                                latcmd[2] = 'q';
                                write(outfd[2], &latcmd[2], 1);
                                #else
                                if (latcmd[0] == 'Q') {
                                    latcmd[0] = 'q';
                                    latcmd[2] = 'q';
                                    write(outfd[2], &latcmd[2], 1);

                                    write(outfd[0], &latcmd[0], 1);

                                }
                                else if (latcmd[0] == 'R') {
                                    latcmd[3] = 's';
                                    chq = 'q';
                                    write(outfd[2], &chq, 1);
                                    latcmd[2] = 'Q';
                                } else {
                                    latcmd[2] = 'Q';
                                }
                                #endif
                            }
                            else {
                                #if 1
                                latcmd[0] = 'q';
                                write(outfd[0], &latcmd[0], 1);
                                #else
                                if (latcmd[2] == 'Q') {
                                    latcmd[0] = 'q';
                                    latcmd[2] = 'q';
                                    write(outfd[2], &latcmd[2], 1);

                                    write(outfd[0], &latcmd[0], 1);

                                }
                                else if (latcmd[2] == 'R') {
                                    latcmd[1] = 's';
                                    chq = 'q';
                                    write(outfd[0], &chq, 1);
                                    latcmd[0] = 'Q';
                                }
                                else {
                                    latcmd[0] = 'Q';
                                }
                                #endif
                            }
                        }
                        else if (pllcmd[ins] == 'R') {
                            if (ins == 3) {
                                if (latcmd[0] == 'R') {
                                    latcmd[0] = 'e';
                                    latcmd[2] = 'e';
                                    chq = 'g';
                                    write(outfd[0], &chq, 1);

                                    write(outfd[2], &chq, 1);

                                }
                                else if (latcmd[0] == 'Q') {
                                    latcmd[1] = 's';
                                    chq = 'q';
                                    write(outfd[0], &chq, 1);
                                    latcmd[2] = 'R';
                                }
                                else {
                                    latcmd[2] = 'R';
                                }                                
                            }
                            else {
                                if (latcmd[2] == 'R') {
                                    latcmd[0] = 'e';
                                    latcmd[2] = 'e';
                                    chq = 'g';
                                    write(outfd[0], &chq, 1);

                                    write(outfd[2], &chq, 1);

                                }
                                else if (latcmd[2] == 'Q') {
                                    latcmd[3] = 's';
                                    chq = 'q';
                                    write(outfd[2], &chq, 1);
                                    latcmd[0] = 'R';                                    
                                }
                                else {
                                    latcmd[0] = 'R';
                                }                                
                            }
                        }
                        else if (pllcmd[ins] == 'G') {
                            //pllcmd[ins] = 0xbf;;
                            //write(outfd[ins], &pllcmd[ins], 1);
                            //sprintf_f(mrs->log, "[GW] out%d id:%d put chr: %c(0x%.2x) - stall of transmission !!! \n", ins, outfd[ins], pllcmd[ins], pllcmd[ins]);
                            //print_f(mrs->plog, "fs152", mrs->log);
                        }
                        else if (pllcmd[ins] == 'B') {
                            sprintf_f(mrs->log, "[GW] id:%d conti read stop !!!\n", ins);
                            print_f(mrs->plog, "fs152", mrs->log);
                        }
                        else if (pllcmd[ins] == 'I') {
                            cswinf = 0;                        
                            gerr = read(pllfd[ins].fd, &cswinf, 1);
                            while (gerr < 0) {
                                cswinf = 0;
                                gerr = read(pllfd[ins].fd, &cswinf, 1);
                            }
                            
                            sprintf_f(mrs->log, "[GW] id:%d conti read get csw status: %c + 0x%.2x !!!\n", ins, pllcmd[ins], cswinf);
                            print_f(mrs->plog, "fs152", mrs->log);

                            if (pubffcd[ins]) {
                                if (pubffcd[ins]->ubcswerr == 0) {
                                    pubffcd[ins]->ubcswerr = cswinf;

                                    //pubffcd[ins] = 0;
                                } else {
                                    sprintf_f(mrs->log, "[GW] Error!!! id:%d conti read set error status failed alread been set val: 0x%.2x !!!\n", ins, pubffcd[ins]->ubcswerr);
                                    print_f(mrs->plog, "fs152", mrs->log);
                                }
                            } else {
                                sprintf_f(mrs->log, "[GW] Error!!! id:%d conti read set error status failed contenter is null !!!\n", ins);
                                print_f(mrs->plog, "fs152", mrs->log);
                            }
                            
                        }
                        else if (pllcmd[ins] == 'J') {
                            pllinf = 0;                        
                            gerr = read(pllfd[ins].fd, &pllinf, 1);
                            while (gerr < 0) {
                                pllinf = 0;
                                gerr = read(pllfd[ins].fd, &pllinf, 1);
                            }

                            pollfo[0] = 'J';
                            pollfo[1] = pllinf;
                            write(outfd[ins], pollfo, 2);
                        }
                        else if (pllcmd[ins] == 'T') {
                            chq = 't';
                            write(outfd[0], &chq, 1);
                            write(outfd[2], &chq, 1);                            
                        }
                        #if USB_AUTO_RESUME
                        else if (pllcmd[ins] == 'V') {
                            sprintf_f(mrs->log, "[GW] id:%d conti resume get ch: %c \n", ins, pllcmd[ins]);
                            print_f(mrs->plog, "fs152", mrs->log);

                            //usleep(5000000);

                            if (ins == 3) {
                                chq = 'v';
                                write(outfd[0], &chq, 1);                            
                            }
                        }
                        #endif
                        else if (pllcmd[ins] == 'X') {
                            pllinf = 0;                        
                            gerr = read(pllfd[ins].fd, &pllinf, 1);
                            while (gerr < 0) {
                                pllinf = 0;
                                gerr = read(pllfd[ins].fd, &pllinf, 1);
                            }
                            
                            sprintf_f(mrs->log, "[GW] id:%d write file erase get ch: %c pllinf: 0x%.2x \n", ins, pllcmd[ins], pllinf);
                            print_f(mrs->plog, "fs152", mrs->log);
                            
                            
                            
                            if (!pllinf) {
                                ring_buf_init(&mrs->cmdRx);
                                
                                sprintf(idfile, filenames, wfileid);
                                filefd = find_read(idfile);

                                if (filefd) {
                                    write(infd[ins], "u", 1);    

                                    ret = fseek(filefd, 0, SEEK_END);
                                    if (ret) {
                                        sprintf_f(mrs->log, "[GW] fileacc seek failed!! ret:%d \n", ret);
                                        print_f(mrs->plog, "fs152", mrs->log);
                                    } 

                                    maxsz = ftell(filefd);

                                    sprintf_f(mrs->log, "[GW] fileacc id%d get read filename:[%s] size: %d \n", ins, idfile, maxsz);
                                    print_f(mrs->plog, "fs152", mrs->log);                                

                                    ret = fseek(filefd, 0, SEEK_SET);
                                    if (ret) {
                                        sprintf_f(mrs->log, "[GW] fileacc seek failed!! ret:%d \n", ret);
                                        print_f(mrs->plog, "fs152", mrs->log);
                                    } 
                                    
                                    while(maxsz) {

                                        lens = ring_buf_get(&mrs->cmdRx, &addrs);
                                        while (lens <= 0) {
                                            usleep(100000);
                                            lens = ring_buf_get(&mrs->cmdRx, &addrs);
                                        }

                                        if (lens > maxsz) {
                                            lens = maxsz;
                                        }
                                        maxsz -= lens;

                                        ret = fread(addrs, 1, lens, filefd);
                                        if (ret != lens) {
                                            sprintf_f(mrs->log, "[GW] fileacc read file failed!! ret:%d (%d) \n", ret, lens);
                                            print_f(mrs->plog, "fs152", mrs->log);

                                            break;
                                        }
                                        
                                        //sprintf_f(mrs->log, "[GW] dump memory %d bytes: \n", lens);
                                        //print_f(mrs->plog, "fs152", mrs->log);
                                        //shmem_dump(addrs, lens);

                                        ring_buf_prod(&mrs->cmdRx);
                                    }

                                    if (maxsz) {
                                        sprintf_f(mrs->log, "[GW] fileacc error!!! read file failed!! remain size: %d \n", maxsz);
                                        print_f(mrs->plog, "fs152", mrs->log);                                
                                    }

                                    ring_buf_set_last(&mrs->cmdRx, lens);
                                    
                                    fclose(filefd);
                                    filefd = 0;
                                }
                            } else {
                                pollfo[0] = 'X';
                                pollfo[1] = pllinf;
                                write(outfd[ins], pollfo, 2);
                            }
                        }
                        else if (pllcmd[ins] == 'U') {
                            pllinf = 0;                        
                            gerr = read(pllfd[ins].fd, &pllinf, 1);
                            while (gerr < 0) {
                                pllinf = 0;
                                gerr = read(pllfd[ins].fd, &pllinf, 1);
                            }
                            
                            sprintf_f(mrs->log, "[GW] id:%d write file get ch: %c pllinf: 0x%.2x \n", ins, pllcmd[ins], pllinf);
                            print_f(mrs->plog, "fs152", mrs->log);

                            pollfo[0] = 'U';
                            pollfo[1] = pllinf;
                            write(outfd[ins], pollfo, 2);
                        }
                        else {
                            sprintf_f(mrs->log, "\n[GW] inpo%d Error !!! pipe(%d) get unknown chr:%c(0x%.2x) \n\n", ins, pllfd[ins].fd, pllcmd[ins], pllcmd[ins]);
                            print_f(mrs->plog, "fs152", mrs->log);
                        }
                        
                        break;
                    default:
                        write(outfd[ins], &pllcmd[ins], 1);
                        sprintf_f(mrs->log, "[GW] out%d put chr: %c(0x%.2x) total:%d\n", ins, pllcmd[ins], pllcmd[ins], evcnt);
                        print_f(mrs->plog, "fs152", mrs->log);
                        break;
                    }
                }
            }
        }
    }
    return 1;
}

static int fs153(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    sprintf_f(mrs->log, "empty !!!\n");
    print_f(mrs->plog, "fs153", mrs->log);

    return 1;
}

static int fs154(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    sprintf_f(mrs->log, "empty !!!\n");
    print_f(mrs->plog, "fs154", mrs->log);

    return 1;
}

#if 0
static int fs143(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    sprintf_f(mrs->log, "empty !!!\n");
    print_f(mrs->plog, "fs143", mrs->log);

    return 1;
}

static int fs144(struct mainRes_s *mrs, struct modersp_s *modersp)
{
    sprintf_f(mrs->log, "empty !!!\n");
    print_f(mrs->plog, "fs144", mrs->log);

    return 1;
}
#endif

#define LOG_P0_EN (0)
static int p0(struct mainRes_s *mrs)
{
#define PS_NUM 155

    int ret=0, len=0, tmp=0;
    char ch=0;
    struct timespec tidle[2];
    int tdiff=0, mbf=0;
    struct modersp_s *modesw = aspMemalloc(sizeof(struct modersp_s), 8);
    if (modesw == 0) {
        sprintf_f(mrs->log, "modesw memory allocation fail \n");
        print_f(mrs->plog, "P0", mrs->log);
    }
    
    prctl(PR_SET_NAME, "msp-p0");
    //sprintf(argv[0], "msp-p0");
    
    struct fselec_s afselec[PS_NUM] = {{ 0, fs00},{ 1, fs01},{ 2, fs02},{ 3, fs03},{ 4, fs04},
                                 { 5, fs05},{ 6, fs06},{ 7, fs07},{ 8, fs08},{ 9, fs09},
                                 {10, fs10},{11, fs11},{12, fs12},{13, fs13},{14, fs14},
                                 {15, fs15},{16, fs16},{17, fs17},{18, fs18},{19, fs19},
                                 {20, fs20},{21, fs21},{22, fs22},{23, fs23},{24, fs24},
                                 {25, fs25},{26, fs26},{27, fs27},{28, fs28},{29, fs29},
                                 {30, fs30},{31, fs31},{32, fs32},{33, fs33},{34, fs34},
                                 {35, fs35},{36, fs36},{37, fs37},{38, fs38},{39, fs39},
                                 {40, fs40},{41, fs41},{42, fs42},{43, fs43},{44, fs44},
                                 {45, fs45},{46, fs46},{47, fs47},{48, fs48},{49, fs49},
                                 {50, fs50},{51, fs51},{52, fs52},{53, fs53},{54, fs54},
                                 {55, fs55},{56, fs56},{57, fs57},{58, fs58},{59, fs59},
                                 {60, fs60},{61, fs61},{62, fs62},{63, fs63},{64, fs64},
                                 {65, fs65},{66, fs66},{67, fs67},{68, fs68},{69, fs69},
                                 {70, fs70},{71, fs71},{72, fs72},{73, fs73},{74, fs74},
                                 {75, fs75},{76, fs76},{77, fs77},{78, fs78},{79, fs79},
                                 {80, fs80},{81, fs81},{82, fs82},{83, fs83},{84, fs84},
                                 {85, fs85},{86, fs86},{87, fs87},{88, fs88},{89, fs89},
                                 {90, fs90},{91, fs91},{92, fs92},{93, fs93},{94, fs94},
                                 {95, fs95},{96, fs96},{97, fs97},{98, fs98},{99, fs99},
                                 {100, fs100},{101, fs101},{102, fs102},{103, fs103},{104, fs104},
                                 {105, fs105},{106, fs106},{107, fs107},{108, fs108},{109, fs109},
                                 {110, fs110},{111, fs111},{112, fs112},{113, fs113},{114, fs114},
                                 {115, fs115},{116, fs116},{117, fs117},{118, fs118},{119, fs119},
                                 {120, fs120},{121, fs121},{122, fs122},{123, fs123},{124, fs124},
                                 {125, fs125},{126, fs126},{127, fs127},{128, fs128},{129, fs129},
                                 {130, fs130},{131, fs131},{132, fs132},{133, fs133},{134, fs134},
                                 {135, fs135},{136, fs136},{137, fs137},{138, fs138},{139, fs139},
                                 {140, fs140},{141, fs141},{142, fs142},{143, fs143},{144, fs144},
                                 {145, fs145},{146, fs146},{147, fs147},{148, fs148},{149, fs149},
                                 {150, fs150},{151, fs151},{152, fs152},{153, fs153},{154, fs154}};
    struct fselec_s errHdle[PS_NUM] = {{ 0, hd00},{ 1, hd01},{ 2, hd02},{ 3, hd03},{ 4, hd04},
                                 { 5, hd05},{ 6, hd06},{ 7, hd07},{ 8, hd08},{ 9, hd09},
                                 {10, hd10},{11, hd11},{12, hd12},{13, hd13},{14, hd14},
                                 {15, hd15},{16, hd16},{17, hd17},{18, hd18},{19, hd19},
                                 {20, hd20},{21, hd21},{22, hd22},{23, hd23},{24, hd24},
                                 {25, hd25},{26, hd26},{27, hd27},{28, hd28},{29, hd29},
                                 {30, hd30},{31, hd31},{32, hd32},{33, hd33},{34, hd34},
                                 {35, hd35},{36, hd36},{37, hd37},{38, hd38},{39, hd39},
                                 {40, hd40},{41, hd41},{42, hd42},{43, hd43},{44, hd44},
                                 {45, hd45},{46, hd46},{47, hd47},{48, hd48},{49, hd49},
                                 {50, hd50},{51, hd51},{52, hd52},{53, hd53},{54, hd54},
                                 {55, hd55},{56, hd56},{57, hd57},{58, hd58},{59, hd59},
                                 {60, hd60},{61, hd61},{62, hd62},{63, hd63},{64, hd64},
                                 {65, hd65},{66, hd66},{67, hd67},{68, hd68},{69, hd69},
                                 {70, hd70},{71, hd71},{72, hd72},{73, hd73},{74, hd74},
                                 {75, hd75},{76, hd76},{77, hd77},{78, hd78},{79, hd79},
                                 {80, hd80},{81, hd81},{82, hd82},{83, hd83},{84, hd84},
                                 {85, hd85},{86, hd86},{87, hd87},{88, hd88},{89, hd89},
                                 {90, hd90},{91, hd91},{92, hd92},{93, hd93},{94, hd94},
                                 {95, hd95},{96, hd96},{97, hd97},{98, hd98},{99, hd99},
                                 {100, hd100},{101, hd101},{102, hd102},{103, hd103},{104, hd104},
                                 {105, hd105},{106, hd106},{107, hd107},{108, hd108},{109, hd109},
                                 {110, hd110},{111, hd111},{112, hd112},{113, hd113},{114, hd114},
                                 {115, hd115},{116, hd116},{117, hd117},{118, hd118},{119, hd119},
                                 {120, hd120},{121, hd121},{122, hd122},{123, hd123},{124, hd124},
                                 {125, hd125},{126, hd126},{127, hd127},{128, hd128},{129, hd129},
                                 {130, hd130},{131, hd131},{132, hd132},{133, hd133},{134, hd134},
                                 {135, hd135},{136, hd136},{137, hd137},{138, hd138},{139, hd139},
                                 {140, hd140},{141, hd141},{142, hd142},{143, hd143},{144, hd144},
                                 {145, hd145},{146, hd146},{147, hd147},{148, hd148},{149, hd149},
                                 {150, hd150},{151, hd151},{152, hd152},{153, hd153},{154, hd154}};
    p0_init(mrs);
    
    clock_gettime(CLOCK_REALTIME, &tidle[0]);  
    clock_gettime(CLOCK_REALTIME, &tidle[1]);  
    
    modesw->m = -2;
    modesw->r = 0;
    modesw->d = 0;
    modesw->t = 0;
    
    while (1) {
        //sprintf_f(mrs->log, ".\n");
        //print_f(mrs->plog, "P0", mrs->log);
        while (modesw->m < 0) {
            len = mrs_ipc_get(mrs, &ch, 1, 0);
            if (len > 0) {
                if ((ch >=0) && (ch < PS_NUM)) {
                    modesw->m = ch;
                    break;
                }
            } else {
                clock_gettime(CLOCK_REALTIME, &tidle[0]);   
                tdiff = time_diff(&tidle[1], &tidle[0], 1000000);           

                //sprintf_f(mrs->log, "%d \n", tdiff);
                //print_f(mrs->plog, "P0", mrs->log);

                if (tdiff > 200000) {
                    tdiff = 200000;
                }

                if (tdiff > 10000) {
                    usleep(tdiff);
                }

                mrs_ipc_put(mrs, "$", 1, 0);
                continue;
            }
        }


        //clock_gettime(CLOCK_REALTIME, &tidle[0]);    
        tdiff = 0;mbf = 0;
        while ((modesw->m >= 0) && (modesw->m < PS_NUM)) {
            msync(modesw, sizeof(struct modersp_s), MS_SYNC);
#if LOG_P0_EN
            sprintf_f(mrs->log, "pmode:%d rsp:%d - 1\n", modesw->m, modesw->r);
            print_f(mrs->plog, "P0", mrs->log);
#endif            
            if (mbf != modesw->m) {
                clock_gettime(CLOCK_REALTIME, &tidle[0]);    
                //sprintf_f(mrs->log, "pmode:%d rsp:%d - 1\n", modesw->m, modesw->r);
                //print_f(mrs->plog, "P0", mrs->log);
            }
            
            ret = (*afselec[modesw->m].pfunc)(mrs, modesw);

            msync(modesw, sizeof(struct modersp_s), MS_SYNC);
#if LOG_P0_EN
            sprintf_f(mrs->log, "pmode:%d rsp:%d - 2, ret: %d\n", modesw->m, modesw->r, ret);
            print_f(mrs->plog, "P0", mrs->log);
#endif
            if (mbf == modesw->m) {
                clock_gettime(CLOCK_REALTIME, &tidle[1]);    
                tdiff = time_diff(&tidle[0], &tidle[1], 1000000);            
            }
            
            if (ret == 1) {
                tmp = modesw->m;
                modesw->m = -1;
                break;
            }
            
            if (tdiff > 1000) {
                break;
            }

            mbf = modesw->m;
        }

        len = mrs_ipc_get(mrs, &ch, 1, 0);
        if (len > 0) {
#if LOG_P0_EN
            sprintf_f(mrs->log, "modesw.m:%d ch:%d\n", modesw->m, ch);
            print_f(mrs->plog, "P0", mrs->log);
#endif
            if (modesw->m == -2) {
                if ((ch >=0) && (ch < PS_NUM)) {
                    modesw->m = ch;
                }
            } else {
                /* todo: interrupt state machine here */
                if (ch == 0x7f) {
                    ret = 0;
                    ret = (*errHdle[modesw->m].pfunc)(mrs, modesw);
                    if (!ret) {
                        modesw->m = -1;
                        modesw->d = -1;
                        modesw->r = 0xed;
                    }
                    sprintf_f(mrs->log, "!! Error handle !! m:%d d:%d ret:%d\n", modesw->m, modesw->d, ret);
                    print_f(mrs->plog, "P0", mrs->log);
                }
            }
        }

        if (modesw->m == -1) {
#if LOG_P0_EN
            sprintf_f(mrs->log, "pmode:%d rsp:%d - end\n", tmp, modesw->r);
            print_f(mrs->plog, "P0", mrs->log);
#endif

            ch = modesw->r; /* response */
            modesw->r = 0;
            //modesw->v = 0; /* do not reset */
            modesw->d = 0;
            //modesw->t = 0; /* do not reset */
            modesw->m = -2;
            tmp = -1;

            mrs_ipc_put(mrs, &ch, 1, 0);

            aspMemClear(aspMemAsign, asptotMalloc, 0);
            //aspMemDebug(aspMemAsign, asptotMalloc, totSalloc);
        } else {
            mrs_ipc_put(mrs, "$", 1, 0);
        }

        //usleep(10);
    }

    p0_end(mrs);
    return 0;
}

#define LOG_P1_EN (0)
static int p1(struct procRes_s *rs, struct procRes_s *rcmd)
{
    uint32_t px, pi;
    int ret = 0, ci, len, logcnt=0;
    char ch, cmd, cmdt, str[128] = "good", er=0;
    char *addr;
    uint32_t evt;
    struct timespec tidle[2];
    int tdiff=0, tcur=0, tnxt=1;

    prctl(PR_SET_NAME, "msp-p1");
    //sprintf(argv[0], "msp-p1");
    
    clock_gettime(CLOCK_REALTIME, &tidle[0]);    
    clock_gettime(CLOCK_REALTIME, &tidle[1]);    
    
    sprintf_f(rs->logs, "p1\n");
    print_f(rs->plogs, "P1", rs->logs);
    struct psdata_s *stdata;
    stfunc pf[SMAX][PSMAX] = {{stspy_01, stspy_02, stspy_03, stspy_04, stspy_05}, //SPY
                            {stbullet_01, stbullet_02, stbullet_03, stbullet_04, stbullet_05}, //BULLET
                            {stlaser_01, stlaser_02, stlaser_03, stlaser_04, stlaser_05}, // LASER
                            {stdob_01, stdob_02, stdob_03, stdob_04, stdob_05}, // DOUBLEC
                            {stdob_06, stdob_07, stdob_08, stdob_09, stdob_10}, // DOUBLED
                            {streg_11, streg_12, streg_13, streg_14, streg_15}, // REGE
                            {streg_16, streg_17, stfat_18, stfat_19, stfat_20}, // REGF
                            {stfat_21, stfat_22, stfat_23, stfat_24, stfat_25}, // FATG
                            {stfat_26, stfat_27, stfat_28, stfat_29, stfat_30}, //FATH
                            {stsup_31, stsup_32, stsup_33, stsup_34, stsup_35}, // SUPI
                            {stsin_36, stdow_37, stupd_38, stupd_39, stupd_40}, // SINJ
                            {stsav_41, stsda_42, stsda_43, stsda_44, stsda_45}, // SAVK
                            {stsda_46, stsda_47, stsda_48, stsda_49, stsda_50}, // SDAL
                            {stsda_51, stsda_52, stsda_53, stsda_54, stsda_55}, // SDAM
                            {stsda_56, stsda_57, stsda_58, stsda_59, stsda_60}, // SDAN
                            {stsda_61, stsda_62, stwbk_63, stsdinit_64, stsdinit_65}, // SDAO
                            {stwtbak_66, stwtbak_67, stwtbak_68, stwtbak_69, stwtbak_70}, // WTBAKP
                            {stwtbak_71, stwtbak_72, stwtbak_73, stwtbak_74, stcrop_75}, // WTBAKQ
                            {stcrop_76, stcrop_77, stcrop_78, stcrop_79, stcrop_80}, // CROPR
                            {stvector_81, stvector_82, stapm_83, stapm_84, stapm_85}, // VECTORS
                            {stsparam_86, stsparam_87, stsparam_88, stcropmeta_89, stcropmeta_90}, //SAVPARM
                            {stcropmeta_91, stcropmeta_92, stcropmeta_93, stcropmeta_94, stmetaduo_95}, //METAT
                            {stmetaduo_96, stmetaduo_97, stmetaduo_98, stmetaduo_99, stmetasd_100},  //MDUOU
                            {stmetasd_101, stmetasd_102, stmetasd_103, stmetasd_104, stmetasd_105}, //MTSDV
                            {stocrw_106, stocrw_107, stocrw_108, stocrw_109, stocrw_110}, //OCRW
                            {stocrx_111, stfmtx_112, stfmtx_113, stfmtx_114, stfmtx_115}, //FMTX
                            {stfmty_116, stfmty_117, stcrtfdr_118, stusbscan_119, stusbscan_120},  //FMTY
                            {stusbscan_121, stusbscan_122, stusbscan_123, stusbscan_124, stusbscan_125},  //USBZ
                            {stusbbnote_126, stusbbnote_127, stusbbnote_128, stusbbnote_129, stusbbnote_130}}; //BMFA
                            

    p1_init(rs, rcmd);
    stdata = rs->pstdata;
    // wait for ch from p0
    // state machine control
    stdata->rs = rs;
    pi = 0;    stdata->result = 0;    cmd = '\0';   cmdt = '\0';
    while (1) {
        //sprintf_f(rs->logs, "+\n");
        //print_f(rs->plogs, "P1", rs->logs);

//     {'d', 'p', '=', 'n', 't', 'a', 'e', 'f', 'b', 's', 'h', 'u', 'v', 'c', 'k', 'g', 'i', 'j', 'm', 'o', 'q', 'r', 'y', 'z'};
//       a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, y, z, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 
//       A

        cmd = '\0';
        ci = 0; 
        if (cmdt != 'w') {
            //ci = rs_ipc_get(rcmd, &cmd, 1);
            ci = rs_ipc_get_ms(rcmd, &cmd, 1, 10);
            //ci = rs_ipc_get_ms(rcmd, &cmd, 1, 0);
        }

#if 0
        sprintf_f(rs->logs, "0x%x %d\n", cmd, ci);
        print_f(rs->plogs, "P1", rs->logs);
#endif

        while (ci > 0) {
#if LOG_P1_EN
            sprintf_f(rs->logs, "%c %d\n", cmd, ci);
            print_f(rs->plogs, "P1", rs->logs);
#endif
            if (cmdt == '\0') {
                if (cmd == 'd') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, BULLET, PSSET);
                } else if (cmd == 'p') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, SPY, PSTSM);
                } else if (cmd == '=') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, SMAX, PSMAX);
                } else if (cmd == 'n') {
                    cmdt = cmd;
                    
                    #if USB_META 
                    stdata->result = emb_stanPro(0, STINIT, USBZ, PSWT);
                    #else
                    stdata->result = emb_stanPro(0, STINIT, DOUBLEC, PSSET);
                    #endif
                    
                } else if (cmd == 't') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, DOUBLED, PSRLT);
                } else if (cmd == 'a') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, DOUBLED, PSRLT);
                } else if (cmd == 'e') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, REGE, PSRLT);
                } else if (cmd == 'f') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, DOUBLED, PSTSM);
                } else if (cmd == 'b') {
                    cmdt = cmd;
                    #if 0 /* 1: boot with OP_SDINIT and OP_SDSTATUS, 0: nope */
                    stdata->result = emb_stanPro(0, STINIT, SDAO, PSRLT);
                    #else
                    stdata->result = emb_stanPro(0, STINIT, FATH, PSTSM);
                    #endif
                } else if (cmd == 's') {
                    cmdt = cmd;
                    
                    #if USB_META
                    stdata->result = emb_stanPro(0, STINIT, USBZ, PSSET);
                    #else
                    stdata->result = emb_stanPro(0, STINIT, SUPI, PSWT);
                    #endif
                    
                } else if (cmd == 'h') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, SINJ, PSACT);
                } else if (cmd == 'u') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, SINJ, PSWT);
                } else if (cmd == 'v') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, SAVK, PSSET);
                } else if (cmd == 'c') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, SDAM, PSSET);
                } else if (cmd == 'k') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, SDAO, PSSET);
                } else if (cmd == 'g') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, WTBAKQ, PSSET);
                } else if (cmd == 'i') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, WTBAKQ, PSSET);
                } else if (cmd == 'j') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, WTBAKQ, PSSET);
                } else if (cmd == 'm') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, WTBAKQ, PSTSM);
                } else if (cmd == 'o') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, VECTORS, PSSET);
                } else if (cmd == 'q') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, VECTORS, PSWT);
                } else if (cmd == 'r') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, SAVPARM, PSSET);
                } else if (cmd == 'y') {
                    cmdt = cmd;
                    
                    #if USB_META
                    stdata->result = emb_stanPro(0, STINIT, FMTY, PSTSM);
                    #else
                    stdata->result = emb_stanPro(0, STINIT, SAVPARM, PSTSM);
                    #endif
                    
                } else if (cmd == 'z') {
                    cmdt = cmd;

                    #if USB_META 
                    stdata->result = emb_stanPro(0, STINIT, USBZ, PSACT);
                    #else
                    stdata->result = emb_stanPro(0, STINIT, SPY, PSSET);
                    #endif
                    
                } else if (cmd == 'l') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, METAT, PSWT);
                } else if (cmd == '1') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, MTSDV, PSWT);
                } else if (cmd == '2') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, MTSDV, PSRLT);
                } else if (cmd == '3') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, MTSDV, PSTSM);
                } else if (cmd == '4') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, FMTX, PSACT);
                } else if (cmd == '5') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, FMTX, PSWT);
                } else if (cmd == '6') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, FMTX, PSRLT);
                } else if (cmd == '7') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, FMTX, PSTSM);
                } else if (cmd == '8') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, FMTY, PSSET);
                } else if (cmd == '9') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, FMTY, PSWT);
                } else if (cmd == '0') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, FMTY, PSRLT);
                } else if (cmd == 'A') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, USBZ, PSSET);
                } else if (cmd == 'B') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, USBZ, PSRLT);
                } else if (cmd == 'C') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, USBZ, PSTSM);
                } else if (cmd == 'D') {
                    cmdt = cmd;
                    stdata->result = emb_stanPro(0, STINIT, BMFA, PSSET);
                }

                

                if (cmdt != '\0') {
                    evt = stdata->result;
                    pi = (evt >> 8) & 0xff;
                    px = (evt & 0xff);

                    sprintf_f(rs->logs, "cmdt:%c, [%d,%d] - 0\nSTART\n", cmdt, pi, px);
                    print_f(rs->plogs, "P1", rs->logs);

                    logcnt = 0;
                    break;
                }
            }
            else { /* command to interrupt state machine here */
                if (cmd == 'r') {
                    cmdt = cmd;
                    stdata->result = emb_result(stdata->result, BREAK);

                    evt = stdata->result;
                    pi = (evt >> 8) & 0xff;
                    px = (evt & 0xff);

                    sprintf_f(rs->logs, "cmdt:%c, [%d,%d] 0x%.8x - 0\nBREAK\n", cmdt, pi, px, stdata->result);
                    print_f(rs->plogs, "P1", rs->logs);

                    break;
                }
            }
            ci = 0;
            ci = rs_ipc_get(rcmd, &cmd, 1);            
        }
        
#if POLL_MODE_EN
        if (cmdt != '\0') {
            clock_gettime(CLOCK_REALTIME, &tidle[tcur]);    
        } else {
            clock_gettime(CLOCK_REALTIME, &tidle[tnxt]);    

            tdiff = time_diff(&tidle[tcur], &tidle[tnxt], 1000000);
            //sprintf_f(rs->logs, "tdiff: %d ms - 1\n", tdiff);
            //print_f(rs->plogs, "P1", rs->logs);
 
            if (tdiff > 1000) {
                //clock_gettime(CLOCK_REALTIME, &tidle[tcur]);    

                tnxt = (tnxt + 1) % 2;
                tcur = (tcur + 1) % 2;

                sprintf_f(rs->logs, "tdiff: %d ms \n", tdiff);
                print_f(rs->plogs, "P1", rs->logs);

                cmdt = 'w';
                stdata->result = emb_stanPro(0, STINIT, FMTY, PSACT);
            }
        }
#endif //#if POLL_MODE_EN

        ret = 0; ch = '\0';
        ret = rs_ipc_get(rs, &ch, 1);
#if LOG_P1_EN
        sprintf_f(rs->logs, "rsp, ret:%d ch:0x%.2x - 1\n", ret, ch);
        print_f(rs->plogs, "P1", rs->logs);
#endif

        if ((ret > 0) && (ch != '$')) {
#if LOG_P1_EN
            sprintf_f(rs->logs, "rsp, ret:%d ch:0x%.2x - 2\n", ret, ch);
            print_f(rs->plogs, "P1", rs->logs);
#endif
        }
        

        if (((ret > 0) && (ch != '$')) || (cmdt != '\0')){
            stdata->ansp0 = ch;
            msync(stdata, sizeof(struct psdata_s), MS_SYNC);
            evt = stdata->result;
            pi = (evt >> 8) & 0xff;
            px = (evt & 0xff);

            //sprintf_f(rs->logs, "[%d,%d] %c 0x%.2x 0x%.8x - 1\n", pi, px, cmdt, ch, stdata->result);
            //print_f(rs->plogs, "P1", rs->logs);

            if ((pi >= SMAX) && (px >= PSMAX)) {
                sprintf_f(rs->logs, "cmdt:%c ch: %c do nothing\n", cmdt, ch);
                print_f(rs->plogs, "P1", rs->logs);
            }
            else if ((pi >= SMAX) || (px >= PSMAX)) {
                sprintf_f(rs->logs, "ERROR [%d,%d] %c 0x%.2x 0x%.8x - 2\n", pi, px, cmdt, ch, stdata->result);
                print_f(rs->plogs, "P1", rs->logs);

                er = cmdt;
                rs_ipc_put(rcmd, &er, 1);
                er = ch;
                rs_ipc_put(rcmd, &er, 1);

                sprintf(str, "<%c,0x%x,unexpectedFailed>", cmdt, ch);
                len = strlen(str);
                if (len >= 256) len = 255;
                str[len] = '\0';
                
                rs_ipc_put(rcmd, str, len+1);
                logcnt = 0;

                sprintf_f(rs->logs, "result:0x%.8x\nBROKEN\n", stdata->result);
                print_f(rs->plogs, "P1", rs->logs);

                cmdt = '\0'; 
                stdata->result = emb_stanPro(0, STINIT, SPY, PSSET);
                continue;
            } else {
                stdata->result = (*pf[pi][px])(stdata);
            }

            msync(stdata, sizeof(struct psdata_s), MS_SYNC);
            evt = stdata->result;
            pi = (evt >> 8) & 0xff;
            px = (evt & 0xff);
/*
            sprintf_f(rs->logs, "[%d,%d] %c 0x%.2x 0x%.8x - 3\n", pi, px, cmdt, ch, stdata->result);
            print_f(rs->plogs, "P1", rs->logs);
*/
            if ((pi >= SMAX) || (px >= PSMAX)) {
#if LOG_P1_EN
                sprintf_f(rs->logs, "<%c,0x%x,done>\n", cmdt, ch);
                print_f(rs->plogs, "P1", rs->logs);
#endif
                if (((cmdt != '\0') && (cmdt != 'w')) && (px == PSMAX)) {
                    er = cmdt;
                    rs_ipc_put(rcmd, &er, 1);
                    er = stdata->ansp0;
                    rs_ipc_put(rcmd, &er, 1);

                    sprintf(str, "<%c,0x%x,done>", cmdt, ch);
                    len = strlen(str);
                    if (len >= 256) len = 255;
                    str[len] = '\0';
                    rs_ipc_put(rcmd, str, len+1);
                    logcnt = 0;

                    sprintf_f(rs->logs, "result:0x%.8x\nEND\n", stdata->result);
                    print_f(rs->plogs, "P1", rs->logs);

                    //sync();
                }

                cmdt = '\0'; 
                stdata->ansp0 = 0;
                //stdata.result = emb_stanPro(0, STINIT, SPY, PSSET);
                continue;
            }

            stdata->ansp0 = 0;
            
            //sprintf_f(rs->logs, "comdt:%c ch:0x%x evt:0x%.8x\n", cmdt, ch, stdata.result);
            //print_f(rs->plogs, "P1", rs->logs);
        }
        else {
            //sprintf_f(rs->logs, ";\n");
            //print_f(rs->plogs, "P1", rs->logs);

            if (logcnt > 100) {
                //rs_ipc_put(rcmd, ";", 1);
                logcnt = 0;
            }
        }

        logcnt++;
        //rs_ipc_put(rs, &ch, 1);
        //usleep(100000);
    }

    p1_end(rs, rcmd);
    return 0;
}

#define MSP_P2_SAVE_DAT (0)
#define IN_SAVE (0)

#define LOG_TIME_MEASURE_EN (0)
#define LOG_P2_TX_EN (1)
#define LOG_P2_CMD_EN (1)
#define LOG_P2_SIMPLE_EN (0)
static int p2(struct procRes_s *rs)
{
    FILE *fp=0;
    char fatPath[128] = "/tmp/fatTab.bin";
#if IN_SAVE
    char filename[128] = "/mnt/mmc2/tx/input_x3.bin";
    FILE *fin = NULL;
#endif

    //struct spi_ioc_transfer *tr = aspMemalloc(sizeof(struct spi_ioc_transfer));
    struct spi_ioc_transfer *tr = rs->rspioc1;
    struct timespec tnow;
    struct sdParseBuff_s *pabuf=0;
    int px, pi=0, ret, len=0, opsz=0, cmode=0, tdiff, tlast, twait, tlen=0, maxsz=0;
    int bitset, totsz=0;
    uint16_t send16, recv16;
    uint32_t secStr=0, secLen=0, datLen=0, minLen=0, maxLen=0;
    uint32_t fformat=0, tmp=0, cord=0;
    struct info16Bit_s *p=0, *c=0;
    struct sdFAT_s *pfat=0;
    struct sdFATable_s   *pftb=0;
    struct sdbootsec_s   *psec=0;
    struct aspConfig_s *pct=0, *pdt=0;
    struct aspMetaData_s *pmeta;
    CFLOAT thrput, fltime;
    struct aspMetaDataviaUSB_s *pusbmeta=0;
    struct aspCrop36_s *pcrp36=0;
    struct aspCropExtra_s *pcrpex=0;
    struct aspDoCropCalcu *pcrpdo=0;
    CFLOAT rotlf[2], rotup[2], rotrt[2], rotdn[2];
    pmeta = rs->pmetain;

    char ch, str[128], rx8[4], tx8[4], finfo[2], uinfo[32];
    char *addr, *laddr, *rx_buff;
    sprintf_f(rs->logs, "p2\n");
    print_f(rs->plogs, "P2", rs->logs);

    prctl(PR_SET_NAME, "msp-p2");
    //sprintf(argv[0], "msp-p2-spi");
    
    pct = rs->pcfgTable;
    pfat = rs->psFat;
    pftb = &pfat->fatTable;
    psec = &pfat->fatBootsec;
    
    c = &rs->pmch->cur;
    p = &rs->pmch->tmp;
    
    p2_init(rs);
    // wait for ch from p0
    // in charge of spi0 data mode
    // 'd': data mode, store the incomming infom into share memory
    // send 'd' to notice the p0 that we have incomming data chunk

    rx_buff = aspMemalloc(SPI_TRUNK_SZ, 8);
    ch = '2';

    while (1) {
        //sprintf_f(rs->logs, "!\n");
        //print_f(rs->plogs, "P2", rs->logs);

        ret = rs_ipc_get(rs, &ch, 1);
        if (ret > 0) {

            //sprintf_f(rs->logs, "recv ch: %c\n", ch);
            //print_f(rs->plogs, "P2", rs->logs);
            
#if LOG_DOT_PROG_EN
            printf("2%c", ch);
#endif
            aspMemClear(aspMemAsign, asptotMalloc, 2);

            //dbgShowTimeStamp("P2_BGN", 6);
            
            switch (ch) {
                case 'g':
                    cmode = 1;
                    break;
                case 'c':
                case 'C':
                    cmode = 2;
                    //sprintf_f(rs->logs, "cmode: %d - 1\n", cmode);
                    //print_f(rs->plogs, "P2", rs->logs);
                    break;
                case 'e':
                    pi = 0;
                case 'r':
                    cmode = 3;
                    break;
                case 'b':
                    cmode = 4;
                    break;
                case 'd':
                    cmode = 5;
                    break;
                case 'n':
                    cmode = 6;
                    break;
                case 's':
                    cmode = 7;
                    break;
                case 'k':
                    cmode = 9;
                    break;
                case 'u':
                    cmode = 10;
                    break;
                case 'f':
                    cmode = 11;
                    break;
                case 'w':
                    cmode = 12;
                    break;
                case 'x':
                    cmode = 13;
                    break;
                case 'y':
                    cmode = 14;
                    break;
                case 'z':
                    cmode = 15;
                    break;
                case 'l':
                    cmode = 16;
                    break;
                case 'a':
                    cmode = 17;
                    break;
                case 'h':
                    cmode = 18;
                    break;
                case 'o':
                    cmode = 19;
                    break;
                default:
                    break;
            }

            //sprintf_f(rs->logs, "cmode: %d - 2\n", cmode);
            //print_f(rs->plogs, "P2", rs->logs);
            
            if (cmode == 1) {
                //sprintf_f(rs->logs, "cmode: %d - 3\n", cmode);
                //print_f(rs->plogs, "P2", rs->logs);

                bitset = 1;
                msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_RD_CTL_PIN
                //sprintf_f(rs->logs, "Check if RDY pin == 0 (pin:%d)\n", bitset);
                //print_f(rs->plogs, "P2", rs->logs);

                while (1) {
                    bitset = 1;
                    msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_RD_CTL_PIN
                    //sprintf_f(rs->logs, "Get RDY pin: %d\n", bitset);
                    //print_f(rs->plogs, "P2", rs->logs);
                    if (bitset == 0) break;
                }
                if (!bitset) rs_ipc_put(rs, "G", 1);
            }
            else if (cmode == 2) {
                //sprintf_f(rs->logs, "cmode: %d - 4\n", cmode);
                //print_f(rs->plogs, "P2", rs->logs);

                len = 0;
                msync(rs->pmch, sizeof(struct machineCtrl_s), MS_SYNC);            
                send16 = pkg_info(&rs->pmch->cur);
                tx8[1] = send16 & 0xff;
                tx8[0] = (send16 >> 8) & 0xff;      

                sprintf(rs->logs, "_OP_0x%.2x_0x%.2x_ BEG", tx8[0], tx8[1]);
                dbgShowTimeStamp(rs->logs, NULL, rs, 4, "_O_T_");

#if LOG_P2_CMD_EN
                sprintf_f(rs->logs, "send 0x%.2x 0x%.2x \n", tx8[0], tx8[1]);
                print_f(rs->plogs, "P2", rs->logs);
#endif
                len = mtx_data(rs->spifd, rx8, tx8, 2, tr);

                msync(rx8, 4, MS_SYNC);                    
                
                if (len > 0) {
                    recv16 = rx8[1] | (rx8[0] << 8);
                    abs_info(&rs->pmch->get, recv16);
#if 0
                    sprintf_f(rs->logs, "op tx 0x%.2x rx 0x%.2x \n", tx8[0], rx8[0]);
                    print_f(rs->plogs, "P2", rs->logs);

                    rs_ipc_put(rs, "C", 1);
#else
                    if (tx8[0] == OP_FIH) {
                        if (rx8[0] != tx8[0]) {
                            sprintf_f(rs->logs, "ch = R, len = %d\n", len);
                            print_f(rs->plogs, "P2", rs->logs);

                            bitset = 0;
                            msp_spi_conf(rs->spifd, _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
                            
                            rs_ipc_put(rs, "R", 1);     
                        } else {
                            rs_ipc_put(rs, "C", 1);
                        }
                    } else {
                        rs_ipc_put(rs, "C", 1);
                    }
#endif
                } else {

                    sprintf_f(rs->logs, "ch = X, len = %d\n", len);
                    print_f(rs->plogs, "P2", rs->logs);
                    
                    bitset = 0;
                    msp_spi_conf(rs->spifd, _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN

                    rs_ipc_put(rs, "X", 1);                
                }

                sprintf(rs->logs, "_OP_0x%.2x_0x%.2x_ END", rx8[0], rx8[1]);
                dbgShowTimeStamp(rs->logs, NULL, rs, 4, "_O_R_");                

                
#if LOG_P2_CMD_EN
                sprintf_f(rs->logs, "recv 0x%.2x 0x%.2x len=%d\n", rx8[0], rx8[1], len);
                print_f(rs->plogs, "P2", rs->logs);
#endif

#if LOG_P2_SIMPLE_EN
                sprintf_f(rs->logs, "tx 0x%.2x 0x%.2x rx 0x%.2x 0x%.2x \n",  tx8[0], tx8[1], rx8[0], rx8[1]);
                print_f(rs->plogs, "P2", rs->logs);
#endif
            }
            else if (cmode == 4) {
                //sprintf_f(rs->logs, "cmode: %d - 5\n", cmode);
                //print_f(rs->plogs, "P2", rs->logs);

                bitset = 0; 
                px = 0;
                //msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_RD_CTL_PIN
                //sprintf_f(rs->logs, "Check if RDY pin == 1 (pin:%d)\n", bitset);
                //print_f(rs->plogs, "P2", rs->logs);
            
                while (1) {
                    bitset = 0;
                    msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_RD_CTL_PIN
                    //sprintf_f(rs->logs, "Get RDY pin: %d\n", bitset);
                    //print_f(rs->plogs, "P2", rs->logs);
                    
                    if (bitset == 1) break;

                    px ++;
                    usleep(1000);

                    if (px > 50) {
                        break;
                    }
                }
                
                if (bitset) {
                    rs_ipc_put(rs, "B", 1);
                } else {
                    rs_ipc_put(rs, "b", 1);
                }
            }
            else if (cmode == 5) {
#if MSP_P2_SAVE_DAT
                ret = file_save_get(&rs->fdat_s[0], "/mnt/mmc2/tx/p2%d.dat");
                if (ret) {
                    sprintf_f(rs->logs, "get tx log data file error - %d, hold here\n", ret);
                    print_f(rs->plogs, "P2", rs->logs);         
                    while(1);
                } else {
                    sprintf_f(rs->logs, "get tx log data file ok - %d, f: %d\n", ret, rs->fdat_s[0]);
                    print_f(rs->plogs, "P2", rs->logs);         
                }
#endif
                //sprintf_f(rs->logs, "cmode: %d\n", cmode);
                //print_f(rs->plogs, "P2", rs->logs);

                pi = 0;  

                while (1) {
                    len = ring_buf_get_dual(rs->pdataRx, &addr, pi);
                    //memset(addr, 0x55, len);
                    msync(addr, len, MS_SYNC);                    
                    //shmem_check(addr, len);
#if  LOG_TIME_MEASURE_EN
                    clock_gettime(CLOCK_REALTIME, rs->tm2[0]);
#endif
#if SPI_KTHREAD_USE
                    opsz = msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 15, __u32), addr);  //SPI_IOC_PROBE_THREAD
                    while (opsz == 0) {
#if SPI_KTHREAD_DLY
                        usleep(1000);
                        sprintf_f(rs->logs, "kth opsz:%d\n", opsz);
                        print_f(rs->plogs, "P2", rs->logs);  
#endif
                        opsz = msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 15, __u32), addr); //kthread 
                    }

#else
                    opsz = mtx_data(rs->spifd, addr, NULL, len, tr);

#endif        

                    if ((opsz > 0) && (opsz < SPI_TRUNK_SZ)) { // workaround to fit original design
                        opsz = 0 - opsz;
                    }
                    
#if SPI_TRUNK_FULL_FIX
                    if (opsz < 0) {
                        opsz = 0 - opsz;                    
                        if (opsz == SPI_TRUNK_SZ) {
                            opsz = 0 - opsz;    
                        } else {
                            sprintf_f(rs->logs, "Error!!! spi send tx failed, return %d \n", opsz);
                            print_f(rs->plogs, "P2", rs->logs);
                        }
                    }
#endif

#if MSP_P2_SAVE_DAT
                    msync(addr, len, MS_SYNC);                    
                    fwrite(addr, 1, len, rs->fdat_s[0]);
                    fflush(rs->fdat_s[0]);
#endif
                    //printf("0 spi %d\n", opsz);
#if LOG_P2_TX_EN
                    sprintf_f(rs->logs, "r %d / %d\n", opsz, len);
                    print_f(rs->plogs, "P2", rs->logs);
#endif
                    msync(rs->tm2, sizeof(struct timespec) * 2, MS_SYNC);                    
#if LOG_TIME_MEASURE_EN 
                    clock_gettime(CLOCK_REALTIME, &tnow);

                    tdiff = time_diff(rs->tm2[0], rs->tm2[1], 1000);
                    if (tdiff == -1) {
                         tdiff = 0 - time_diff(rs->tm2[1], rs->tm2[0], 1000);
                    }

                    //sprintf_f(rs->logs, "t %d us\n", tdiff);
                    //print_f(rs->plogs, "P2", rs->logs);                 

                    if (tdiff < 0) {
                        sprintf_f(rs->logs, "!!t %d - %d!!\n", tdiff, len);
                        print_f(rs->plogs, "P2", rs->logs);
                    }
#endif
                    if (opsz < 0) break;
                    
                    //msync(addr, len, MS_SYNC);
                    ring_buf_prod_dual(rs->pdataRx, pi);
                    //shmem_dump(addr, 32);

                    rs_ipc_put(rs, "p", 1);
                    pi += 2;
                }

                opsz = 0 - opsz;

                if (opsz == 1) opsz = 0;

#if JPG_FFD9_CUT /* find 0xcffd9 in jpg */
                ret = cfgTableGetChk(pct, ASPOP_FILE_FORMAT, &fformat, ASPOP_STA_CON);    
                if (ret) {
                    fformat = 0;
                }
                
                if ((fformat == 0) || (fformat == FILE_FORMAT_JPG) || (fformat == FILE_FORMAT_PDF)) {
                    sprintf_f(rs->logs, "fformat: 0x%x !!!\n", fformat);
                    print_f(rs->plogs, "P2", rs->logs);    

                    /* search the offset of 0xffd9 */
                    ret = findEOF(addr, opsz);
                    if (ret > 0) {
                        memset(addr + ret + 2, 0xff, opsz - ret - 2);
                    } else {
                        sprintf_f(rs->logs, "warnning!!! file format: 0x%x, ret: %d can't find ffd9\n", fformat, ret);
                        print_f(rs->plogs, "P2", rs->logs);    
                    }

                    sprintf_f(rs->logs, "fformat: 0x%x, ret: %d \n", fformat, ret);
                    print_f(rs->plogs, "P2", rs->logs);    
                }
#endif

                if (opsz > 0) {
                    ring_buf_prod_dual(rs->pdataRx, pi);
                }

                ring_buf_set_last_dual(rs->pdataRx, opsz, pi);
                rs_ipc_put(rs, "d", 1);
                sprintf_f(rs->logs, "spi0 recv end, the last sector size: %d\n", opsz);
                print_f(rs->plogs, "P2", rs->logs);

#if MSP_P2_SAVE_DAT
                fclose(rs->fdat_s[0]);
#endif
            }
            else if (cmode == 6) {
                totsz = 0;
                sprintf_f(rs->logs, "cmode: %d\n", cmode);
                print_f(rs->plogs, "P2", rs->logs);

#if MSP_P2_SAVE_DAT
                ret = file_save_get(&rs->fdat_s[0], "/mnt/mmc2/rx/p2%d.dat");
                if (ret) {
                    sprintf_f(rs->logs, "get tx log data file error - %d, hold here\n", ret);
                    print_f(rs->plogs, "P2", rs->logs);         
                    while(1);
                } else {
                    sprintf_f(rs->logs, "get tx log data file ok - %d, f: %d\n", ret, rs->fdat_s[0]);
                    print_f(rs->plogs, "P2", rs->logs);         
                }
#endif

                sprintf(rs->logs, "_SPI_0_ BEG");
                tlast = dbgShowTimeStamp(rs->logs, NULL, rs, 8, "_S0_S_");

                pi = 0;  
                while (1) {
                    len = 0;
                    len = ring_buf_get(rs->pcmdRx, &addr);
                    if (len > 0) {

                        //memset(addr, 0xaa, len);
                        msync(addr, len, MS_SYNC);
                        
                        opsz = 0;
                        while (opsz == 0) {
                            //shmem_check(addr, len);
#if SPI_KTHREAD_USE                    
                            opsz = msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 15, __u32), addr);  //SPI_IOC_PROBE_THREAD
                            if (opsz == 0) {
#if SPI_KTHREAD_DLY
                                usleep(1000);
                                sprintf_f(rs->logs, "kth opsz:%d\n", opsz);
                                print_f(rs->plogs, "P2", rs->logs);  
#endif
                                continue;
                            }
                            
#else
                            opsz = mtx_data(rs->spifd, addr, NULL, len, tr);
#endif

                            totsz += opsz;

#if MSP_P2_SAVE_DAT
                    msync(addr, len, MS_SYNC);                    
                    fwrite(addr, 1, len, rs->fdat_s[0]);
                    fflush(rs->fdat_s[0]);
#endif
                            
                            if ((opsz > 0) && (opsz < SPI_TRUNK_SZ)) { // workaround to fit original design
                                opsz = 0 - opsz;
                            }
                            
#if SPI_TRUNK_FULL_FIX
                            if (opsz < 0) {
                                opsz = 0 - opsz;                    
                                if (opsz == SPI_TRUNK_SZ) {
                                    opsz = 0 - opsz;    
                                } else {
                                    sprintf_f(rs->logs, "Error!!! spi send tx failed, return %d \n", opsz);
                                    print_f(rs->plogs, "P2", rs->logs);
                                }
                            }
#endif

                            //usleep(10000);
#if LOG_P2_TX_EN
                            sprintf_f(rs->logs, "r %d/%d - %d\n", opsz, totsz, pi);
                            print_f(rs->plogs, "P2", rs->logs);
#endif
                        }

                        //msync(addr, len, MS_SYNC);
                        ring_buf_prod(rs->pcmdRx);    
                        if (opsz < 0) {
                            //sprintf_f(rs->logs, "opsz:%d break!\n", opsz);
                            //print_f(rs->plogs, "P2", rs->logs);    
                            break;
                        }
                        rs_ipc_put(rs, "p", 1);
                        pi += 1;
                    }
                    else {
                        sprintf_f(rs->logs, "failed to get buffer len:%d!\n", len);
                        print_f(rs->plogs, "P2", rs->logs);    
                        usleep(100000);
                    }
                }

                sprintf_f(rs->logs, "totsz:%d opsz:%d ret:%d, break!\n", totsz, opsz, ret);
                print_f(rs->plogs, "P2", rs->logs);    

                opsz = 0 - opsz;

#if JPG_FFD9_CUT /* find 0xffd9 in jpg */
                ret = cfgTableGetChk(pct, ASPOP_FILE_FORMAT, &fformat, ASPOP_STA_CON);    
                if (ret) {
                    fformat = 0;
                }
                
                if ((fformat == 0) || (fformat == FILE_FORMAT_JPG) || (fformat == FILE_FORMAT_PDF)) {
                    sprintf_f(rs->logs, "fformat: 0x%x !!!\n", fformat);
                    print_f(rs->plogs, "P2", rs->logs);    

                    /* search the offset of 0xffd9 */
                    ret = findEOF(addr, opsz);
                    if (ret > 0) {
                        memset(addr + ret + 2, 0xff, opsz - ret - 2);
                    } else {
                        sprintf_f(rs->logs, "warnning!!! file format: 0x%x, ret: %d can't find ffd9\n", fformat, ret);
                        print_f(rs->plogs, "P2", rs->logs);    
                    }


                    sprintf_f(rs->logs, "fformat: 0x%x, ret: %d \n", fformat, ret);
                    print_f(rs->plogs, "P2", rs->logs);    
                }
#endif
                sprintf(rs->logs, "_SPI_0_ END %d bytes ", totsz);
                tdiff = dbgShowTimeStamp(rs->logs, NULL, rs, 8, "_S0_E_");           

                fltime = (CFLOAT)(tdiff - tlast);
                if (fltime == 0) {
                    thrput = 0;
                } else {
                    thrput = (CFLOAT) totsz /fltime;
                }

                cfgTableSet(pct, ASPOP_RAW_SIZE, totsz);
                sprintf(rs->logs, "_SPI_0_ throughput: %.2f MB/sec ", thrput);
                dbgShowTimeStamp(rs->logs, NULL, rs, 8, "done");                

#if MSP_P2_SAVE_DAT
                fclose(rs->fdat_s[0]);
#endif
                
                ring_buf_set_last(rs->pcmdRx, opsz);
                rs_ipc_put(rs, "d", 1);
                sprintf_f(rs->logs, "spi0 recv end totsz: %d\n", totsz);
                print_f(rs->plogs, "P2", rs->logs);

            }
            else if (cmode == 7) {
                secStr = c->opinfo;
                secLen = p->opinfo;
                datLen = secLen * 512;
                minLen = 16 * 512;

                pabuf = &rs->psFat->parBuf;
                maxLen = pabuf->dirBuffMax;
                
                sprintf_f(rs->logs, "cmode: %d, ready for rx %d/%d, secStr:%d, secLen:%d, maxLen:%d\n", cmode, datLen, minLen, secStr, secLen, maxLen);
                print_f(rs->plogs, "P2", rs->logs);
/*
                if (datLen < minLen) {
                    datLen = minLen;
                }
*/

                sprintf(rs->logs, "_SPI_0_ BEG");
                tlast = dbgShowTimeStamp(rs->logs, NULL, rs, 8, "_S0_S_");

                //addr = pabuf->dirParseBuff + pabuf->dirBuffUsed;
                totsz = 0;
                pi = 0;  
                while (1) {
                    len = 0;
                    len = ring_buf_get(rs->pdataRx, &addr);
                    
                    if (len > 0) {
                    msync(addr, SPI_TRUNK_SZ, MS_SYNC);     
                    //shmem_check(addr, len);
#if SPI_KTHREAD_USE
                    opsz = msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 15, __u32), addr);  //SPI_IOC_PROBE_THREAD
                    while (opsz == 0) {
#if SPI_KTHREAD_DLY
                        usleep(1000);
                        sprintf_f(rs->logs, "kth opsz:%d\n", opsz);
                        print_f(rs->plogs, "P2", rs->logs);  
#endif
                        opsz = msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 15, __u32), addr);  //SPI_IOC_PROBE_THREAD
                    }

#else
                    opsz = mtx_data(rs->spifd, addr, NULL, SPI_TRUNK_SZ, tr);
#endif
                    
                    if ((opsz > 0) && (opsz < SPI_TRUNK_SZ)) { // workaround to fit original design
                        opsz = 0 - opsz;
                    }
                    
#if SPI_TRUNK_FULL_FIX
                    if (opsz < 0) {
                        opsz = 0 - opsz;                    
                        if (opsz == SPI_TRUNK_SZ) {
                            opsz = 0 - opsz;    
                        } else {
                            sprintf_f(rs->logs, "Error!!! spi send tx failed, return %d \n", opsz);
                            print_f(rs->plogs, "P2", rs->logs);
                        }
                    }
#endif

#if LOG_P2_TX_EN
                    sprintf_f(rs->logs, "r %d\n", opsz);
                    print_f(rs->plogs, "P2", rs->logs);
#endif

                    if (opsz == 0) {
                        sprintf_f(rs->logs, "opsz:%d\n", opsz);
                        print_f(rs->plogs, "P2", rs->logs);    
                        continue;
                    }

                    ring_buf_prod(rs->pdataRx);
                    rs_ipc_put(rs, "s", 1);
                    if (opsz < 0) {
                        sprintf_f(rs->logs, "opsz:%d break!\n", opsz);
                        print_f(rs->plogs, "P2", rs->logs);    
                        break;
                    }
                    pi += 1;
                    totsz += opsz;                    
                    }
                }

                opsz = 0 - opsz;
                if (opsz == 1) opsz = 0;

                totsz += opsz;

                if (totsz != datLen) {
                    sprintf_f(rs->logs, "WARNNING!!! total len: %d, actual len: %d\n", totsz, datLen);
                    print_f(rs->plogs, "P2", rs->logs);
                }

                sprintf(rs->logs, "_SPI_0_ END %d bytes ", totsz);
                tdiff = dbgShowTimeStamp(rs->logs, NULL, rs, 8, "_S0_E_");

                fltime = (CFLOAT)(tdiff - tlast);
                if (fltime == 0) {
                    thrput = 0;
                } else {
                    thrput = (CFLOAT) totsz /fltime;
                }
                
                cfgTableSet(pct, ASPOP_RAW_SIZE, totsz);
                sprintf(rs->logs, "_SPI_0_ throughput: %.2f MB/sec ", thrput);
                dbgShowTimeStamp(rs->logs, NULL, rs, 8, "done");

                ring_buf_set_last(rs->pdataRx, opsz);
                rs_ipc_put(rs, "S", 1);
                //pabuf->dirBuffUsed += totsz;
                //msync(pabuf->dirParseBuff, len, MS_SYNC);
                rs_ipc_put(rs, "S", 1);

                sprintf_f(rs->logs, "spi0 recv end - totsz: %d\n", totsz);
                print_f(rs->plogs, "P2", rs->logs);
            }
            else if (cmode == 8) {
                pi = 0;
                while (1) {
                    len = ring_buf_cons(rs->pdataRx, &addr);
                    if (len >= 0) {
                        msync(addr, len, MS_SYNC);
                        if (len != 0) {
                            pi++;
                            #if 1
                            opsz = mtx_data(rs->spifd, addr, NULL, SPI_TRUNK_SZ, tr);
                            #else
                            opsz = len;
                            #endif
                            //sprintf_f(rs->logs, "t %d c %d \n", opsz, pi);
                            //print_f(rs->plogs, "P2", rs->logs);         

                            if (opsz < 0) break;
                        }
                    } else {
                        sprintf_f(rs->logs, "tx len:%d cnt:%d- end\n", opsz, pi);
                        print_f(rs->plogs, "P2", rs->logs);         
                        break;
                    }

                    if (ch != 'K') {
                        ch = 0;
                        rs_ipc_get(rs, &ch, 1);
                        sprintf_f(rs->logs, "ch:%c\n", ch);
                        print_f(rs->plogs, "P2", rs->logs);         
                    }
                }

                while (ch != 'K') {
                    sprintf_f(rs->logs, "%c clr\n", ch);
                    print_f(rs->plogs, "P2", rs->logs);         
                    ch = 0;
                    rs_ipc_get(rs, &ch, 1);
                }
                rs_ipc_put(rs, "K", 1);
                sprintf_f(rs->logs, "tx cnt:%d - end\n", pi);
                print_f(rs->plogs, "P2", rs->logs);         
            }
            else if (cmode == 9) {
                totsz = 0;
                pi = 0;
                sprintf_f(rs->logs, "cmode: %d \n", cmode);
                print_f(rs->plogs, "P2", rs->logs);
                
                while (1) {
                    if (ch != 'K') {
                        rs_ipc_get(rs, &ch, 1);
                    }


                    len = ring_buf_cons(rs->pdataRx, &addr);

                    //sprintf_f(rs->logs, "t %d\n", len);
                    //print_f(rs->plogs, "P2", rs->logs);          

                    if (len > 0) {
                        if (len < SPI_TRUNK_SZ) len = SPI_TRUNK_SZ;

                        msync(addr, len, MS_SYNC);
                        //shmem_check(addr, len);
#if SPI_KTHREAD_USE
                    opsz = msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 15, __u32), addr);  //SPI_IOC_PROBE_THREAD
                    while (opsz == 0) {
#if SPI_KTHREAD_DLY
                        usleep(1000);
                        sprintf_f(rs->logs, "kth opsz:%d\n", opsz);
                        print_f(rs->plogs, "P2", rs->logs);  
#endif
                        opsz = msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 15, __u32), addr); //kthread 
                    }

#else
                        opsz = mtx_data(rs->spifd, addr, addr, len, tr);
#endif
                        if ((opsz > 0) && (opsz < SPI_TRUNK_SZ)) { // workaround to fit original design
                            opsz = 0 - opsz;
                        }

#if SPI_TRUNK_FULL_FIX
                        if (opsz < 0) {
                            opsz = 0 - opsz;                    
                            if (opsz == SPI_TRUNK_SZ) {
                                opsz = 0 - opsz;    
                            } else {
                                sprintf_f(rs->logs, "Error!!! spi send tx failed, return %d \n", opsz);
                                print_f(rs->plogs, "P2", rs->logs);
                            }
                        }
#endif

                        pi++;
                        if (opsz < 0) break;
                        totsz += opsz;
                    }
                    if ((len < 0) && (ch == 'K')) break;
                }

                opsz = 0 - opsz;
                if (opsz > 0) {
                    totsz += opsz;
                }

                while (ch != 'K') {
                    rs_ipc_get(rs, &ch, 1);
                }

                rs_ipc_put(rs, "K", 1);
                sprintf_f(rs->logs, "tx cnt:%d - end\n", pi);
                print_f(rs->plogs, "P2", rs->logs);         
            }

            else if (cmode == 10) {
#if MSP_P2_SAVE_DAT
                ret = file_save_get(&rs->fdat_s[0], "/mnt/mmc2/tx/p2%d.dat");
                if (ret) {
                    sprintf_f(rs->logs, "get tx log data file error - %d, hold here\n", ret);
                    print_f(rs->plogs, "P2", rs->logs);         
                    while(1);
                } else {
                    sprintf_f(rs->logs, "get tx log data file ok - %d, f: %d\n", ret, rs->fdat_s[0]);
                    print_f(rs->plogs, "P2", rs->logs);         
                }
#endif

                sprintf(rs->logs, "_SPI_0_ BEG");
                tlast = dbgShowTimeStamp(rs->logs, NULL, rs, 8, "_S0_S_");
                
                totsz = 0;
                pi = 0;
                sprintf_f(rs->logs, "cmode: %d \n", cmode);
                print_f(rs->plogs, "P2", rs->logs);
                
                while (1) {
                    if (ch != 'U') {
                        rs_ipc_get(rs, &ch, 1);
                    }

                    len = ring_buf_cons(rs->pcmdTx, &addr);
                    
                    /* debug */
                    if (pi == 0) {
                        sprintf_f(rs->logs, "dump the first 128 byte of SD data: \n");
                        print_f(rs->plogs, "P2", rs->logs);  
                        //shmem_dump(addr, 128);
                    }

#if LOG_P2_TX_EN
                    sprintf(rs->logs, "u t %d\n", len);
                    print_f(rs->plogs, "P2", rs->logs);          
#endif

                    if (len > 0) {
                    msync(addr, len, MS_SYNC); 
#if MSP_P2_SAVE_DAT
                    fwrite(addr, 1, len, rs->fdat_s[0]);
                    fflush(rs->fdat_s[0]);
#endif

                        if (len < SPI_TRUNK_SZ) len = SPI_TRUNK_SZ;

#if SPI_KTHREAD_USE & SPI_UPD_NO_KTHREAD
                    opsz = msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 15, __u32), addr);  //SPI_IOC_PROBE_THREAD
                    while (opsz == 0) {
#if SPI_KTHREAD_DLY
                        usleep(1000);
                        sprintf_f(rs->logs, "kth opsz:%d\n", opsz);
                        print_f(rs->plogs, "P2", rs->logs);  
#endif
                        opsz = msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 15, __u32), addr); //kthread 
                    }
#else
                        opsz = mtx_data(rs->spifd, addr, addr, len, tr);
#endif

                         //sprintf_f(rs->logs, "opsz: %d \n", opsz);
                         //print_f(rs->plogs, "P2", rs->logs);

                        if ((opsz > 0) && (opsz < SPI_TRUNK_SZ)) { // workaround to fit original design
                            opsz = 0 - opsz;
                        }

#if 1 /*SPI_TRUNK_FULL_FIX*/
                    if (opsz < 0) {
                        opsz = 0 - opsz;                    
                        if (opsz == SPI_TRUNK_SZ) {
                            //opsz = 0 - opsz;    
                        } else {
                            opsz = 0 - opsz;    
                        }
                    }
#endif

                        pi++;
                        if (opsz < 0) break;
                        totsz += opsz;
                    }
                    if ((len < 0) && (ch == 'U')) break;
                }

                opsz = 0 - opsz;
                if (opsz > 0) {
                    totsz += opsz;
                }

                sprintf(rs->logs, "_SPI_0_ END %d bytes ", totsz);
                tdiff = dbgShowTimeStamp(rs->logs, NULL, rs, 8, "_S0_E_");

                fltime = (CFLOAT)(tdiff - tlast);
                if (fltime == 0) {
                    thrput = 0;
                } else {
                    thrput = (CFLOAT) totsz /fltime;
                }

                cfgTableSet(pct, ASPOP_RAW_SIZE, totsz);
                sprintf(rs->logs, "_SPI_0_ throughput: %.2f MB/sec ", thrput);
                dbgShowTimeStamp(rs->logs, NULL, rs, 8, "done");
                
                while (ch != 'U') {
                    rs_ipc_get(rs, &ch, 1);
                }

                rs_ipc_put(rs, "U", 1);
                sprintf_f(rs->logs, "tx cnt:%d - end\n", pi);
                print_f(rs->plogs, "P2", rs->logs);            

#if MSP_P2_SAVE_DAT
                fclose(rs->fdat_s[0]);
#endif
            }

            else if (cmode == 11) {
                fp = fopen(fatPath, "r");

                ret = fseek(fp, 0, SEEK_END);
                if (ret) {
                    sprintf_f(rs->logs, " file seek failed!! ret:%d \n", ret);
                    print_f(rs->plogs, "P2", rs->logs);
                } 
                
                maxsz = ftell(fp);
                sprintf_f(rs->logs, " file [%s] size: %d \n", fatPath, maxsz);
                print_f(rs->plogs, "P2", rs->logs);

                ret = fseek(fp, 0, SEEK_SET);
                if (ret) {
                    sprintf_f(rs->logs, " file seek failed!! ret:%d \n", ret);
                    print_f(rs->plogs, "P2", rs->logs);
                }

                addr = aspMemalloc(maxsz, 2);

                ret = fread(addr, 1, maxsz, fp);

                fclose(fp);

                sprintf_f(rs->logs, "FAT file read size: %d/%d \n", ret, maxsz);
                print_f(rs->plogs, "P2", rs->logs);
                
                secStr = c->opinfo;
                secLen = p->opinfo;
                datLen = secLen * 512;
                minLen = 16 * 512;

                sprintf_f(rs->logs, "ready for rx %d/%d, %d/%d\n", secStr, psec->secWhfat, datLen, minLen);
                print_f(rs->plogs, "P2", rs->logs);
/*
                if (datLen < minLen) {
                    datLen = minLen;
                }
*/
                laddr = addr;
                addr = addr + (secStr - psec->secWhfat) * 512;

                sprintf_f(rs->logs, "laddr:0x%.8x, addr:0x%.8x\n", (uint32_t)laddr, (uint32_t)addr);
                print_f(rs->plogs, "P2", rs->logs);


                sprintf(rs->logs, "_SPI_0_ BEG");
                tlast = dbgShowTimeStamp(rs->logs, NULL, rs, 8, "_S0_S_");

                totsz = datLen;
                len = 0;
                pi = 0;  
                
                while (1) {
                    tlen = SPI_TRUNK_SZ;
                    
#if SPI_KTHREAD_USE & SPI_UPD_NO_KTHREAD
                    opsz = msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 15, __u32), addr);  //SPI_IOC_PROBE_THREAD
                    while (opsz == 0) {
#if SPI_KTHREAD_DLY
                        usleep(1000);
                        sprintf_f(rs->logs, "kth opsz:%d\n", opsz);
                        print_f(rs->plogs, "P2", rs->logs);  
#endif
                        opsz = msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 15, __u32), addr);  //SPI_IOC_PROBE_THREAD
                    }
#else
                    msync(addr, tlen, MS_SYNC);                    
                    //shmem_dump(addr, datLen);
                    opsz = mtx_data(rs->spifd, addr, addr, tlen, tr);
#endif

                    if ((opsz > 0) && (opsz < SPI_TRUNK_SZ)) { // workaround to fit original design
                        opsz = 0 - opsz;
                    }

#if 1 /*SPI_TRUNK_FULL_FIX*/
                    if (opsz < 0) {
                        opsz = 0 - opsz;                    
                        if (opsz == SPI_TRUNK_SZ) {
                            //opsz = 0 - opsz;    
                        } else {
                            opsz = 0 - opsz;    
                        }
                    }
#endif

#if LOG_P2_TX_EN
                    sprintf_f(rs->logs, "r (%d)\n", opsz);
                    print_f(rs->plogs, "P2", rs->logs);
#endif
                    if (opsz == 0) {
                        sprintf_f(rs->logs, "opsz:%d\n", opsz);
                        print_f(rs->plogs, "P2", rs->logs);    
                        continue;
                    }

                    if (opsz < 0) break;

                    len += opsz;
                    addr += opsz;
                    
                    pi += 1;
                }

                opsz = 0 - opsz;
                if (opsz == 1) opsz = 0;

                len += opsz;

                sprintf(rs->logs, "_SPI_0_ END %d bytes ", len);
                tdiff = dbgShowTimeStamp(rs->logs, NULL, rs, 8, "_S0_E_");

                totsz = len;
                fltime = (CFLOAT)(tdiff - tlast);
                if (fltime == 0) {
                    thrput = 0;
                } else {
                    thrput = (CFLOAT) totsz /fltime;
                }
                
                cfgTableSet(pct, ASPOP_RAW_SIZE, totsz);
                sprintf(rs->logs, "_SPI_0_ throughput: %.2f MB/sec ", thrput);
                dbgShowTimeStamp(rs->logs, NULL, rs, 8, "done");
                
                if (len != datLen) {
                    sprintf_f(rs->logs, "total len: %d, actual len: %d\n", len, datLen);
                    print_f(rs->plogs, "P2", rs->logs);
                    len = datLen; 
                }

                aspMemFree(laddr, 2);
                rs_ipc_put(rs, "F", 1);

                sprintf_f(rs->logs, "spi0 recv end - total len: %d\n", len);
                print_f(rs->plogs, "P2", rs->logs);
            }
            else if (cmode == 12) {
                secStr = c->opinfo;
                secLen = p->opinfo;
                datLen = secLen * 512;
                minLen = 16 * 512;

                pabuf = &rs->psFat->parBuf;
                sprintf_f(rs->logs, "cmode: %d, ready for rx %d/%d\n", cmode, datLen, minLen);
                print_f(rs->plogs, "P2", rs->logs);
/*
                if (datLen < minLen) {
                    datLen = minLen;
                }
*/
                sprintf(rs->logs, "_SPI_0_ BEG");
                tlast = dbgShowTimeStamp(rs->logs, NULL, rs, 8, "_S0_S_");

                //addr = pabuf->dirParseBuff;
                //msync(addr, psec->secPrClst*512, MS_SYNC);
                
                totsz = 0;
                pi = 0;  
                while (1) {
                    len = 0;
                    opsz = 0;
                    len = ring_buf_cons(rs->pdataRx, &addr);
                    if (len < 0) {
                        //addr = rx_buff;
                        sprintf_f(rs->logs, "get ring buffer empty ret: %d \n",len);
                        print_f(rs->plogs, "P2", rs->logs);
                        break;
                    }
                    
                    msync(addr, SPI_TRUNK_SZ, MS_SYNC);    

                    sprintf_f(rs->logs, "dump %.2d packet, len: %d \n", pi, len);
                    print_f(rs->plogs, "P2", rs->logs);

                    //shmem_dump(addr, 32);
                    
#if SPI_KTHREAD_USE & SPI_UPD_NO_KTHREAD
                    opsz = msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 15, __u32), addr);  //SPI_IOC_PROBE_THREAD
                    while (opsz == 0) {
#if SPI_KTHREAD_DLY
                        usleep(1000);
                        sprintf_f(rs->logs, "kth opsz:%d\n", opsz);
                        print_f(rs->plogs, "P2", rs->logs);  
#endif
                        opsz = msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 15, __u32), addr);  //SPI_IOC_PROBE_THREAD
                    }
#else
                    opsz = mtx_data(rs->spifd, rx_buff, addr, SPI_TRUNK_SZ, tr);
#endif

                    if ((opsz > 0) && (opsz < SPI_TRUNK_SZ)) { // workaround to fit original design
                        opsz = 0 - opsz;
                    }

#if 1 /*SPI_TRUNK_FULL_FIX*/
                    if (opsz < 0) {
                        opsz = 0 - opsz;                    
                        if (opsz == SPI_TRUNK_SZ) {
                            //opsz = 0 - opsz;    
                        } else {
                            opsz = 0 - opsz;    
                        }
                    }
#endif

#if LOG_P2_TX_EN
                    sprintf_f(rs->logs, "r %d\n", opsz);
                    print_f(rs->plogs, "P2", rs->logs);
#endif
                    if (opsz == 0) {
                        sprintf_f(rs->logs, "opsz:%d\n", opsz);
                        print_f(rs->plogs, "P2", rs->logs);    
                        continue;
                    }

                    if (opsz < 0) break;
                    
                    totsz += opsz;
                    pi += 1;
                }

                opsz = 0 - opsz;
                if (opsz == 1) opsz = 0;

                totsz += opsz;

                sprintf(rs->logs, "_SPI_0_ END %d bytes ", totsz);
                tdiff = dbgShowTimeStamp(rs->logs, NULL, rs, 8, "_S0_E_");

                fltime = (CFLOAT)(tdiff - tlast);
                if (fltime == 0) {
                    thrput = 0;
                } else {
                    thrput = (CFLOAT) totsz /fltime;
                }

                cfgTableSet(pct, ASPOP_RAW_SIZE, totsz);
                sprintf(rs->logs, "_SPI_0_ throughput: %.2f MB/sec ", thrput);
                dbgShowTimeStamp(rs->logs, NULL, rs, 8, "done");
                
                if (totsz != datLen) {
                    sprintf_f(rs->logs, "WARNNING!!!total len: %d, actual len: %d\n", totsz, datLen);
                    print_f(rs->plogs, "P2", rs->logs);
                    totsz = datLen; 
                }

                rs_ipc_put(rs, "W", 1);

                sprintf_f(rs->logs, "spi0 recv end - total len: %d\n", totsz);
                print_f(rs->plogs, "P2", rs->logs);
            }
            else if (cmode == 13) {
                totsz = 0;
                len = 0;
                pi = 0;  
                while (1) {
                    len = 0;
                    len = ring_buf_get(rs->pcmdRx, &addr);
                    if (len > 0) {
                        msync(addr, len, MS_SYNC);
                        //shmem_check(addr, len);
                        
                        opsz = 0;
                        while (opsz == 0) {
#if SPI_KTHREAD_USE                    
                            opsz = msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 15, __u32), addr);  //SPI_IOC_PROBE_THREAD
                            if (opsz == 0) {
#if SPI_KTHREAD_DLY
                                usleep(1000);
                                sprintf_f(rs->logs, "kth opsz:%d\n", opsz);
                                print_f(rs->plogs, "P2", rs->logs);  
#endif
                                continue;
                            }
#else
                            opsz = mtx_data(rs->spifd, addr, NULL, len, tr);
#endif
                            if ((opsz > 0) && (opsz < SPI_TRUNK_SZ)) { // workaround to fit original design
                                opsz = 0 - opsz;
                            }

#if SPI_TRUNK_FULL_FIX
                            if (opsz < 0) {
                                opsz = 0 - opsz;                    
                                if (opsz == SPI_TRUNK_SZ) {
                                    opsz = 0 - opsz;    
                                } else {
                                    sprintf_f(rs->logs, "Error!!! spi send tx failed, return %d \n", opsz);
                                    print_f(rs->plogs, "P2", rs->logs);
                                }
                            }
#endif

                            //usleep(10000);
#if LOG_P2_TX_EN
                            sprintf_f(rs->logs, "spi0 recv %d\n", opsz);
                            print_f(rs->plogs, "P2", rs->logs);
#endif
                        }

                        //msync(addr, len, MS_SYNC);
                        ring_buf_prod(rs->pcmdRx);    
                        if (opsz < 0) {
                            sprintf_f(rs->logs, "opsz:%d break!\n", opsz);
                            print_f(rs->plogs, "P2", rs->logs);    
                            break;
                        }
                        rs_ipc_put(rs, "x", 1);
                        pi += 1;
                        totsz += opsz;
                    }
                }

                sprintf_f(rs->logs, "len:%d opsz:%d ret:%d, break!\n", len, opsz, ret);
                print_f(rs->plogs, "P2", rs->logs);    

                opsz = 0 - opsz;
                if (opsz == 1) opsz = 0;
                
                ring_buf_set_last(rs->pcmdRx, opsz);
                totsz += opsz;
                
                rs_ipc_put(rs, "X", 1);
                sprintf_f(rs->logs, "spi0 recv end, total: %d\n", totsz);
                print_f(rs->plogs, "P2", rs->logs);

            }
            else if (cmode == 14) {
                totsz = 0;
                len = 0;
                pi = 0;  
                len = 0;

                //len = 512;
                len = SPI_TRUNK_SZ;
                addr = (char *)rs->pmetaout;
                //laddr = (char *)rs->pmetain;
                laddr = (char *)rs->pmetaMass->masspt;
                
                memcpy(laddr, addr, 512);
                msync(laddr, SPI_TRUNK_SZ, MS_SYNC);

                sprintf(rs->logs, "_META_ BEG");
                dbgShowTimeStamp(rs->logs, NULL, rs, 8, "_M_S_");

                opsz = 0;
                while (opsz == 0) {
                    opsz = mtx_data(rs->spifd, laddr, laddr, len, tr);

                    if ((opsz > 0) && (opsz < SPI_TRUNK_SZ)) { // workaround to fit original design
                        opsz = 0 - opsz;
                    }

                    //usleep(10000);
#if LOG_P2_TX_EN
                    sprintf_f(rs->logs, "spi0 recv %d\n", opsz);
                    print_f(rs->plogs, "P2", rs->logs);
#endif
                    //shmem_dump(addr, 512);
                                        
                    if (opsz < 0) {
                        //sprintf(rs->logs, "opsz:%d break!\n", opsz);
                        //print_f(rs->plogs, "P2", rs->logs);    
                        break;
                    }

                }
                
                rs_ipc_put(rs, "Y", 1);

                pi += 1;
                
                opsz = 0 - opsz;
                if (opsz == 1) opsz = 0;


                totsz += opsz;

                memcpy(rs->pmetain, laddr, 512);
                msync(rs->pmetain, 512, MS_SYNC);

                sprintf_f(rs->logs, "meta get magic number: 0x%.2x 0x%.2x \n", pmeta->ASP_MAGIC[0], pmeta->ASP_MAGIC[1]);
                print_f(rs->plogs, "P2", rs->logs);

                sprintf_f(rs->logs, "totsz: %d, len:%d opsz:%d ret:%d, break!\n", totsz, len, opsz, ret);
                print_f(rs->plogs, "P2", rs->logs);

                if (totsz > rs->pmetaMass->massMax) {
                    rs->pmetaMass->massUsed = rs->pmetaMass->massMax;
                } else {
                    rs->pmetaMass->massUsed = totsz;
                }

                sprintf(rs->logs, "_META_ END %d bytes", totsz);
                dbgShowTimeStamp(rs->logs, NULL, rs, 8, "_M_E_");
                
            }
            else if (cmode == 15) {
                totsz = 0;
                sprintf_f(rs->logs, "cmode: %d\n", cmode);
                print_f(rs->plogs, "P2", rs->logs);

                sprintf(rs->logs, "_META_ BEG");
                dbgShowTimeStamp(rs->logs, NULL, rs, 8, "_M_S_");

                pi = 0;  
                while (1) {
                    len = 0;
                    len = ring_buf_get(rs->pcmdRx, &addr);
                    if (len > 0) {

                        //memset(addr, 0xaa, len);
                        msync(addr, len, MS_SYNC);
                        
                        opsz = 0;
                        while (opsz == 0) {
                            //shmem_check(addr, len);
#if SPI_KTHREAD_USE                    
                            opsz = msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 15, __u32), addr);  //SPI_IOC_PROBE_THREAD
                            if (opsz == 0) {
#if SPI_KTHREAD_DLY
                                usleep(1000);
                                sprintf_f(rs->logs, "kth opsz:%d\n", opsz);
                                print_f(rs->plogs, "P2", rs->logs);  
#endif
                                continue;
                            }
                            
#else
                            opsz = mtx_data(rs->spifd, addr, NULL, len, tr);
#endif
                            if ((opsz > 0) && (opsz < SPI_TRUNK_SZ)) { // workaround to fit original design
                                opsz = 0 - opsz;
                            }

#if SPI_TRUNK_FULL_FIX
                            if (opsz < 0) {
                                opsz = 0 - opsz;                    
                                if (opsz == SPI_TRUNK_SZ) {
                                    opsz = 0 - opsz;    
                                } else {
                                    sprintf_f(rs->logs, "Error!!! spi send tx failed, return %d \n", opsz);
                                    print_f(rs->plogs, "P2", rs->logs);
                                }
                            }
#endif

                            //usleep(10000);
#if LOG_P2_TX_EN
                            sprintf_f(rs->logs, "r %d - %d\n", opsz, pi);
                            print_f(rs->plogs, "P2", rs->logs);
#endif
                        }

                        totsz += opsz;

                        //msync(addr, len, MS_SYNC);
                        ring_buf_prod(rs->pcmdRx);    
                        if (opsz < 0) {
                            //sprintf(rs->logs, "opsz:%d break!\n", opsz);
                            //print_f(rs->plogs, "P2", rs->logs);    
                            break;
                        }
                        rs_ipc_put(rs, "p", 1);
                        pi += 1;
                    }
                }

                sprintf_f(rs->logs, "len:%d opsz:%d ret:%d, break!\n", len, opsz, ret);
                print_f(rs->plogs, "P2", rs->logs);    

                opsz = 0 - opsz;
                totsz += opsz;

                sprintf(rs->logs, "_META_ END %d bytes", totsz);
                dbgShowTimeStamp(rs->logs, NULL, rs, 8, "_M_E_");
                
                ring_buf_set_last(rs->pcmdRx, opsz);
                rs_ipc_put(rs, "d", 1);
                sprintf_f(rs->logs, "spi0 recv end\n");
                print_f(rs->plogs, "P2", rs->logs);

            }
            else if (cmode == 16) {
                pabuf = &rs->psFat->parBuf;
                maxLen = pabuf->dirBuffMax;
                
                sprintf_f(rs->logs, "cmode: %d, ready for tx, maxLen:%d\n", cmode, maxLen);
                print_f(rs->plogs, "P2", rs->logs);

                //addr = pabuf->dirParseBuff + pabuf->dirBuffUsed;
                totsz = 0;
                pi = 0;  
                while (1) {
                    len = 0;
                    len = ring_buf_get(rs->pdataRx, &addr);
                    
                    if (len > 0) {
                    msync(addr, SPI_TRUNK_SZ, MS_SYNC);     
                    //shmem_check(addr, len);
#if SPI_KTHREAD_USE
                    opsz = msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 15, __u32), addr);  //SPI_IOC_PROBE_THREAD
                    while (opsz == 0) {
#if SPI_KTHREAD_DLY
                        usleep(1000);
                        sprintf_f(rs->logs, "kth opsz:%d\n", opsz);
                        print_f(rs->plogs, "P2", rs->logs);  
#endif
                        opsz = msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 15, __u32), addr);  //SPI_IOC_PROBE_THREAD
                    }

#else
                    opsz = mtx_data(rs->spifd, addr, NULL, SPI_TRUNK_SZ, tr);
#endif

                    if ((opsz > 0) && (opsz < SPI_TRUNK_SZ)) { // workaround to fit original design
                        opsz = 0 - opsz;
                    }
                    
#if SPI_TRUNK_FULL_FIX
                    if (opsz < 0) {
                        opsz = 0 - opsz;                    
                        if (opsz == SPI_TRUNK_SZ) {
                            opsz = 0 - opsz;    
                        } else {
                            sprintf_f(rs->logs, "Error!!! spi send tx failed, return %d \n", opsz);
                            print_f(rs->plogs, "P2", rs->logs);
                        }
                    }
#endif

#if LOG_P2_TX_EN
                    sprintf_f(rs->logs, "r %d\n", opsz);
                    print_f(rs->plogs, "P2", rs->logs);
#endif

                    if (opsz == 0) {
                        sprintf_f(rs->logs, "opsz:%d\n", opsz);
                        print_f(rs->plogs, "P2", rs->logs);    
                        continue;
                    }

                    //msync(addr, len, MS_SYNC);
                    ring_buf_prod(rs->pdataRx);
                    rs_ipc_put(rs, "l", 1);
                    if (opsz < 0) {
                        sprintf_f(rs->logs, "opsz:%d break!\n", opsz);
                        print_f(rs->plogs, "P2", rs->logs);    
                        break;
                    }
                    pi += 1;
                    totsz += opsz;
                    }
                }

                opsz = 0 - opsz;
                if (opsz == 1) opsz = 0;

                totsz += opsz;
                
                ring_buf_set_last(rs->pdataRx, opsz);
                rs_ipc_put(rs, "L", 1);
                pabuf->dirBuffUsed += totsz;
                //msync(pabuf->dirParseBuff, len, MS_SYNC);
                rs_ipc_put(rs, "L", 1);

                sprintf_f(rs->logs, "spi0 recv end - totsz: %d\n", totsz);
                print_f(rs->plogs, "P2", rs->logs);
            }
            else if (cmode == 17) {
                sprintf_f(rs->logs, "cmode: %d\n", cmode);
                print_f(rs->plogs, "P2", rs->logs);

                sprintf(rs->logs, "_META_ BEG");
                dbgShowTimeStamp(rs->logs, NULL, rs, 8, "_M_S_");

                pi = 0;  
                while (1) {
                    len = 0;
                    len = ring_buf_get(rs->pcmdRx, &addr);
                    if (len > 0) {

                        //memset(addr, 0xaa, len);
                        msync(addr, len, MS_SYNC);
                        
                        opsz = 0;
                        while (opsz == 0) {
                            //shmem_check(addr, len);
#if SPI_KTHREAD_USE                    
                            opsz = msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 15, __u32), addr);  //SPI_IOC_PROBE_THREAD
                            if (opsz == 0) {
#if SPI_KTHREAD_DLY
                                usleep(1000);
                                sprintf_f(rs->logs, "kth opsz:%d\n", opsz);
                                print_f(rs->plogs, "P2", rs->logs);  
#endif
                                continue;
                            }
                            
#else
                            opsz = mtx_data(rs->spifd, addr, NULL, len, tr);
#endif
                            if ((opsz > 0) && (opsz < SPI_TRUNK_SZ)) { // workaround to fit original design
                                opsz = 0 - opsz;
                            }

#if SPI_TRUNK_FULL_FIX
                            if (opsz < 0) {
                                opsz = 0 - opsz;                    
                                if (opsz == SPI_TRUNK_SZ) {
                                    opsz = 0 - opsz;    
                                } else {
                                    sprintf_f(rs->logs, "Error!!! spi send tx failed, return %d \n", opsz);
                                    print_f(rs->plogs, "P2", rs->logs);
                                }
                            }
#endif

                            //usleep(10000);
#if LOG_P2_TX_EN
                            sprintf_f(rs->logs, "r %d - %d\n", opsz, pi);
                            print_f(rs->plogs, "P2", rs->logs);
#endif
                        }
                        
                        //msync(addr, len, MS_SYNC);
                        ring_buf_prod(rs->pcmdRx);    
                        if (opsz < 0) {
                            //sprintf_f(rs->logs, "opsz:%d break!\n", opsz);
                            //print_f(rs->plogs, "P2", rs->logs);    
                            break;
                        }
                        rs_ipc_put(rs, "p", 1);
                        totsz += opsz;
                        pi += 1;
                    }
                }

                sprintf_f(rs->logs, "len:%d opsz:%d ret:%d, break!\n", len, opsz, ret);
                print_f(rs->plogs, "P2", rs->logs);    

                opsz = 0 - opsz;

                totsz += opsz;

                sprintf(rs->logs, "_META_ END %d bytes", totsz);
                dbgShowTimeStamp(rs->logs, NULL, rs, 8, "_M_E_");

                
                ring_buf_set_last(rs->pcmdRx, opsz);
                rs_ipc_put(rs, "d", 1);
                sprintf_f(rs->logs, "spi0 recv end\n");
                print_f(rs->plogs, "P2", rs->logs);

            }
            else if (cmode == 18) {
                len = 0;
                msync(rs->pmch, sizeof(struct machineCtrl_s), MS_SYNC);            
                send16 = pkg_info(&rs->pmch->poll);
                tx8[1] = send16 & 0xff;
                tx8[0] = (send16 >> 8) & 0xff;      

                sprintf(rs->logs, "_OP_0x%.2x_0x%.2x_ BEG", tx8[0], tx8[1]);
                dbgShowTimeStamp(rs->logs, NULL, rs, 4, "_O_T_");

#if LOG_P2_CMD_EN
                sprintf_f(rs->logs, "send 0x%.2x 0x%.2x \n", tx8[0], tx8[1]);
                print_f(rs->plogs, "P2", rs->logs);
#endif
                len = mtx_data(rs->spifd, rx8, tx8, 2, tr);

                msync(rx8, 4, MS_SYNC);                    
                
                if (len > 0) {
                    recv16 = rx8[1] | (rx8[0] << 8);
                    abs_info(&rs->pmch->get, recv16);
                    rs_ipc_put(rs, "H", 1);
                } else {

                    sprintf_f(rs->logs, "ch = X, len = %d\n", len);
                    print_f(rs->plogs, "P2", rs->logs);
                    
                    bitset = 0;
                    msp_spi_conf(rs->spifd, _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN

                    rs_ipc_put(rs, "X", 1);                
                }

                sprintf(rs->logs, "_OP_0x%.2x_0x%.2x_ END", rx8[0], rx8[1]);
                dbgShowTimeStamp(rs->logs, NULL, rs, 4, "_O_R_");                

                
#if LOG_P2_CMD_EN
                sprintf_f(rs->logs, "recv 0x%.2x 0x%.2x len=%d\n", rx8[0], rx8[1], len);
                print_f(rs->plogs, "P2", rs->logs);
#endif

#if LOG_P2_SIMPLE_EN
                sprintf_f(rs->logs, "tx 0x%.2x 0x%.2x rx 0x%.2x 0x%.2x \n",  tx8[0], tx8[1], rx8[0], rx8[1]);
                print_f(rs->plogs, "P2", rs->logs);
#endif
            }
            else if (cmode == 19) {
                sprintf_f(rs->logs, "cmode: %d\n", cmode);
                print_f(rs->plogs, "P2", rs->logs);

                rs_ipc_get(rs, finfo, 2);

                sprintf_f(rs->logs, "get info: 0x%.2x + 0x%.2x \n", finfo[0], finfo[1]);
                print_f(rs->plogs, "P2", rs->logs);

                //usleep(500000);
                //sleep(10);
                len = ring_buf_cons(rs->pdataRx, &addr);
                if (len >= 0) {
                    sprintf_f(rs->logs, "get ring for crop len: %d\n", len);
                    print_f(rs->plogs, "P2", rs->logs);

                    //shmem_dump(addr, sizeof(struct aspMetaDataviaUSB_s));
                    pusbmeta = aspMemalloc(len, 2);
                    if (pusbmeta) {
                        memset(pusbmeta, 0, len);
                        memcpy(pusbmeta, addr, len);  

                        msync(pusbmeta, len, MS_SYNC);
                        
                        if ((pusbmeta->ASP_MAGIC_ASPC[0] == finfo[0]) && 
                            (pusbmeta->ASP_MAGIC_ASPC[1] == finfo[1])) {

                            totsz = (pusbmeta->EXTRA_POINT[2] << 8) | pusbmeta->EXTRA_POINT[3];
                            totsz += sizeof(struct aspMetaDataviaUSB_s);

                            //shmem_dump(addr, totsz);

                            pcrpdo = aspMemalloc(sizeof(struct aspDoCropCalcu), 2);
                            pcrpex = aspMemalloc(sizeof(struct aspCropExtra_s), 2); 
                            pcrp36 = aspMemalloc(sizeof(struct aspCrop36_s), 2); 
                            if ((pcrpdo) && (pcrpex) && (pcrp36)) {
                                memset(pcrpdo, 0, sizeof(struct aspDoCropCalcu));
                                memset(pcrpex, 0, sizeof(struct aspCropExtra_s));
                                memset(pcrp36, 0, sizeof(struct aspCrop36_s));
                                
                                pcrpdo->acrpex = pcrpex;
                                pcrpdo->acrp36 = pcrp36;
                                
                                sprintf_f(rs->logs, "crop memory allocate succeed size: %d \n", sizeof(struct aspDoCropCalcu) + sizeof(struct aspCropExtra_s) + sizeof(struct aspCrop36_s));
                                print_f(rs->plogs, "P2", rs->logs);

                                tmp = 0;
                                ret = cfgTableGetChkDPI(pct, ASPOP_RESOLUTION, &tmp, ASPOP_STA_APP);    
                                //sprintf_f(rs->logs, "user defined resulution: %d, ret:%d\n", tmp, ret);
                                //print_f(rs->plogs, "P2", rs->logs);
                                pcrpdo->acrpDPI = tmp;

                                ret = doCropCalcuPt(pcrpdo, pusbmeta, &pusbmeta->EXTRA_POINT[4], len - sizeof(struct aspMetaDataviaUSB_s), rs, 2);
                                sprintf_f(rs->logs, "do set extra points first ret: %d \n", ret);
                                print_f(rs->plogs, "P2", rs->logs);
                                
                                ret = doCropCalcu36(pcrpdo, addr, len, rs, 2);
                                sprintf_f(rs->logs, "do crop 36 ret: %d \n", ret);
                                print_f(rs->plogs, "P2", rs->logs);

                                ret = doCropCalcu(pcrpdo, addr, len, rs, 2);                                 
                                sprintf_f(rs->logs, "do crop extra ret: %d \n", ret);
                                print_f(rs->plogs, "P2", rs->logs);

                                ret = getRotateP1(pcrp36, rotlf);
                                if (!ret) {
                                    sprintf_f(rs->logs, "get rotateP1 (%.2lf, %.2lf) \n", rotlf[0], rotlf[1]);
                                    print_f(rs->plogs, "P2", rs->logs);
                                }
                                
                                ret = getRotateP2(pcrp36, rotup);
                                if (!ret) {
                                    sprintf_f(rs->logs, "get rotateP2 (%.2lf, %.2lf) \n", rotup[0], rotup[1]);
                                    print_f(rs->plogs, "P2", rs->logs);
                                }
                                
                                ret = getRotateP3(pcrp36, rotrt);
                                if (!ret) {
                                    sprintf_f(rs->logs, "get rotateP3 (%.2lf, %.2lf) \n", rotrt[0], rotrt[1]);
                                    print_f(rs->plogs, "P2", rs->logs);
                                }
                                
                                ret = getRotateP4(pcrp36, rotdn);
                                if (!ret) {
                                    sprintf_f(rs->logs, "get rotateP4 (%.2lf, %.2lf) \n", rotdn[0], rotdn[1]);
                                    print_f(rs->plogs, "P2", rs->logs);
                                }
                                
                                tmp = (uint32_t)round(rotlf[0]);
                                cord = (uint32_t)round(rotlf[1]);
                                cord = cord | (tmp <<16);
                                lsb2Msb32(&pusbmeta->CROP_POS_F1, cord);
                                
                                tmp = (uint32_t)round(rotup[0]);
                                cord = (uint32_t)round(rotup[1]);
                                cord = cord | (tmp <<16);
                                lsb2Msb32(&pusbmeta->CROP_POS_F2, cord);
                                
                                tmp = (uint32_t)round(rotrt[0]);
                                cord = (uint32_t)round(rotrt[1]);
                                cord = cord | (tmp <<16);
                                lsb2Msb32(&pusbmeta->CROP_POS_F3, cord);
                                
                                tmp = (uint32_t)round(rotdn[0]);
                                cord = (uint32_t)round(rotdn[1]);
                                cord = cord | (tmp <<16);
                                lsb2Msb32(&pusbmeta->CROP_POS_F4, cord);
                                
                                addr = (char *) &pusbmeta->CROP_POS_F1;
                                
                                //sprintf_f(rs->logs, "print usb info: \n");
                                //print_f(rs->plogs, "P2", rs->logs);
                                
                                //shmem_dump(addr, 16);
                                
                                //dbgMetaUsb(pusbmeta);
                                //getRotRectPoint(pcrp36, 0, 0, 2);
                             }
                             else {
                                 sprintf_f(rs->logs, "crop memory allocate failed!!! size: %d \n", sizeof(struct aspDoCropCalcu) + sizeof(struct aspCropExtra_s) + sizeof(struct aspCrop36_s));
                                 print_f(rs->plogs, "P2", rs->logs);
                             }
                        }
                        else {
                            sprintf_f(rs->logs, "Error!!! info not match !!!0x%.2x 0x%.2x vs 0x%.2x 0x%.2x \n", finfo[0], finfo[1], pusbmeta->ASP_MAGIC_ASPC[0], pusbmeta->ASP_MAGIC_ASPC[1]);
                            print_f(rs->plogs, "P2", rs->logs);

                            shmem_dump(addr, 512);
                            dbgMetaUsb(pusbmeta);

                            memset(addr, 0, 16);
                        }
                        
                        //dbgMetaUsb(pusbmeta);
                    } else {
                        sprintf_f(rs->logs, "Error!!! allocate memory for usb meta failed !!!\n");
                        print_f(rs->plogs, "P2", rs->logs);
                    }
                
                }
                
                memset(uinfo, 0, 32);
                uinfo[0] = 'O';
                uinfo[1] = finfo[0];
                uinfo[2] = finfo[1];
                memcpy(&uinfo[3], addr, 16);

                rs_ipc_put(rs, uinfo, 19);
                
            }
            else {
                sprintf_f(rs->logs, "cmode: %d \n", cmode);
                print_f(rs->plogs, "P2", rs->logs);
            }

            //dbgShowTimeStamp("P2_END", 6);

            aspMemClear(aspMemAsign, asptotMalloc, 2);
        }
    }

    p2_end(rs);
    return 0;
}

#define MSP_P3_SAVE_DAT (0)
#define LOG_P3_TX_EN  (1)
static int p3(struct procRes_s *rs)
{
#if IN_SAVE
    char filename[128] = "/mnt/mmc2/tx/input_x2.bin";
    FILE *fin = NULL;
#endif

    //struct spi_ioc_transfer *tr = aspMemalloc(sizeof(struct spi_ioc_transfer));
    struct spi_ioc_transfer *tr = rs->rspioc2;
    struct timespec tnow;
    struct aspConfig_s *pct=0, *pdt=0;
    
    int pi, ret, len, opsz, cmode=0, bitset, tdiff, tlast, twait, totsz=0;
    uint16_t send16, recv16;
    char ch, str[128], rx8[4], tx8[4], finfo[2], uinfo[32], chc=0;
    char *addr, *laddr, *tch=0;
    uint32_t fformat=0, tmp=0, cord=0, dpi=0;
    struct aspMetaData_s *pmetaduo;
    CFLOAT thrput, fltime;
    struct aspMetaDataviaUSB_s *pusbmeta=0, *pusbmetaOrg=0;
    struct aspCrop36_s *pcrp36=0;
    struct aspCropExtra_s *pcrpex=0;
    struct aspDoCropCalcu *pcrpdo=0;
    CFLOAT rotlf[2], rotup[2], rotrt[2], rotdn[2];
    int *result=0, *org=0, *mass=0;
    int org_len=0, mass_len=0, mbfidx=0, imgidx=0, mfbstat=0, exlen=0, yllen=0, val=0, mtlen=0, layeTot=0;
    char colrBits_L12=0, colrBits_L34=0, *colrBits_pt=0;
    struct bitmapDecodeMfour_s *pdec=0;
    struct bitmapDecodeItem_s *decjpg=0, *decmeta=0, *decexmt=0;
    char *pmeta=0, *pexmt=0;
    struct timespec crpS, crpE;
    int tmCost=0;

    //clock_gettime(CLOCK_REALTIME, &crpS);
    //tmCost = time_diff(&crpS, &crpE, 1000000);
    
    
    prctl(PR_SET_NAME, "msp-p3");
    //sprintf(argv[0], "msp-p3-spi");
    
    pmetaduo = rs->pmetainduo;
    pct = rs->pcfgTable;
    
    sprintf_f(rs->logs, "p3, spidev:%d \n", rs->spifd);
    print_f(rs->plogs, "P3", rs->logs);

    #if 0
    while (!rs->spifd) {
        ch = 0;
        ret = rs_ipc_get(rs, &ch, 1);
        if (ret > 0) {
            sprintf_f(rs->logs, "get ch:%c\n", ch);
            print_f(rs->plogs, "P3", rs->logs);
            rs_ipc_put(rs, "x", 1);
        }
    }
    #endif

    p3_init(rs);
    // wait for ch from p0
    // in charge of spi1 data mode
    // 'd': data mode, forward the socket incoming inform into share memory

    pi = 0;
    while (1) {
        //sprintf_f(rs->logs, "/\n");
        //print_f(rs->plogs, "P3", rs->logs);

        //sprintf(rs->logs, "__P3_START__"); 
        //tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 14, rs->logs);
                
        ret = rs_ipc_get(rs, &ch, 1);
        if (ret > 0) {
            //sprintf_f(rs->logs, "recv ch: %c\n", ch);
            //print_f(rs->plogs, "P3", rs->logs);
#if LOG_DOT_PROG_EN
            printf("3%c", ch);
#endif
            //sprintf(rs->logs, "__P3_START_CLR_IN__"); 
            //tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 14, rs->logs);

            aspMemClear(aspMemAsign, asptotMalloc, 3);

            //sprintf(rs->logs, "__P3_START_CLR_OUT__"); 
            //tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 14, rs->logs);

            //dbgShowTimeStamp("P3_BGN", 6);
            
            switch (ch) {
                case 'g':
                    cmode = 1;
                    break;
                case 'c':
                    cmode = 2;
                    break;
                case 'e':
                    pi = 0;
                case 'r':
                    cmode = 3;
                    break;
                case 'b':
                    cmode = 4;
                    break;
                case 'd':
                    cmode = 5;
                    break;
                case 'n':
                    cmode = 6;
                    break;
                case 'y':
                    cmode = 7;
                    break;
                case 'o':
                    cmode = 8;
                    break;
                case 's':
                    cmode = 9;
                    break;
                default:
                    break;
            }
            if (cmode == 1) {
                bitset = 1;
                msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_RD_CTL_PIN
                //sprintf_f(rs->logs, "Check if RDY pin == 0 (pin:%d)\n", bitset);
                //print_f(rs->plogs, "P3", rs->logs);

                while (1) {
                    bitset = 1;
                    msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_RD_CTL_PIN
                    //sprintf_f(rs->logs, "Get RDY pin: %d\n", bitset);
                    //print_f(rs->plogs, "P3", rs->logs);
                    if (bitset == 0) break;
                }
                if (!bitset) rs_ipc_put(rs, "G", 1);
            } else if (cmode == 2) {
                len = 0;
                msync(rs->pmch, sizeof(struct machineCtrl_s), MS_SYNC);            
                send16 = pkg_info(&rs->pmch->cur);
                tx8[0] = send16 & 0xff;
                tx8[1] = (send16 >> 8) & 0xff;      
                len = mtx_data(rs->spifd, rx8, tx8, 2, tr);
                if (len > 0) {
                    recv16 = rx8[0] | (rx8[1] << 8);
                    abs_info(&rs->pmch->get, recv16);
                    rs_ipc_put(rs, "C", 1);
                }
            } else if (cmode == 4) {
                bitset = 0;
                msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_RD_CTL_PIN
                //sprintf_f(rs->logs, "Check if RDY pin == 1 (pin:%d)\n", bitset);
                //print_f(rs->plogs, "P3", rs->logs);
            
                while (1) {
                    bitset = 0;
                    msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_RD_CTL_PIN
                    //sprintf_f(rs->logs, "Get RDY pin: %d\n", bitset);
                    //print_f(rs->plogs, "P4", rs->logs);
            
                    if (bitset == 1) break;
                }
                if (bitset) rs_ipc_put(rs, "B", 1);
            } else if (cmode == 5) {
                //sprintf_f(rs->logs, "cmode: %d\n", cmode);
                //print_f(rs->plogs, "P3", rs->logs);

                pi = 1;  

                while (1) {
                    len = ring_buf_get_dual(rs->pdataRx, &addr, pi);
                    memset(addr, 0xaa, len);
                    msync(addr, len, MS_SYNC);
#if LOG_TIME_MEASURE_EN
                    clock_gettime(CLOCK_REALTIME, rs->tm[1]);
#endif
#if SPI1_ENABLE
#if SPI_KTHREAD_USE
                    opsz = msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 15, __u32), addr);  //SPI_IOC_PROBE_THREAD
                    while (opsz == 0) {
#if SPI_KTHREAD_DLY
                        usleep(1000);
                        sprintf_f(rs->logs, "kth opsz:%d\n", opsz);
                        print_f(rs->plogs, "P2", rs->logs);  
#endif
                        opsz = msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 15, __u32), addr); //kthread 
                    }
#else // #if SPI_KTHREAD_USE
                    opsz = mtx_data(rs->spifd, addr, NULL, len, tr);
#endif // #if SPI_KTHREAD_USE

                    if ((opsz > 0) && (opsz < SPI_TRUNK_SZ)) { // workaround to fit original design
                        opsz = 0 - opsz;
                    }

#if SPI_TRUNK_FULL_FIX
                    if (opsz < 0) {
                        opsz = 0 - opsz;                    
                        if (opsz == SPI_TRUNK_SZ) {
                            opsz = 0 - opsz;    
                        } else {
                            sprintf_f(rs->logs, "Error!!! spi send tx failed, return %d \n", opsz);
                            print_f(rs->plogs, "P2", rs->logs);
                        }
                    }
#endif

#else // #if SPI1_ENABLE
                    opsz = SPI_TRUNK_SZ;
#endif // #if SPI1_ENABLE

#if SPI1_ENABLE
#if IN_SAVE
                   msync(addr, len, MS_SYNC);
                   fin = fopen(filename, "a+");
                    if (!fin) {
                        sprintf_f(rs->logs, "file read [%s] failed \n", filename);
                        print_f(rs->plogs, "P4", rs->logs);
                    } else {
                        sprintf_f(rs->logs, "file read [%s] ok \n", filename);
                        print_f(rs->plogs, "P4", rs->logs);

                        ret = fwrite(addr, 1, len, fin);

                        fflush(fin);
                        fclose(fin);
                        fin = NULL;
                }
#endif
#if LOG_P3_TX_EN
                    sprintf_f(rs->logs, "r %d / %d\n", opsz, len);
                    print_f(rs->plogs, "P3", rs->logs);
#endif
                    msync(rs->tm2, sizeof(struct timespec) * 2, MS_SYNC);

#if LOG_TIME_MEASURE_EN
                    clock_gettime(CLOCK_REALTIME, &tnow);
                    if (opsz == 0) {
                        //sprintf_f(rs->logs, "opsz:%d\n", opsz);
                        //print_f(rs->plogs, "P3", rs->logs);  
                        //usleep(1000);
                        continue;
                    }

                    tdiff = time_diff(rs->tm2[1], rs->tm2[0], 1000);
                    if (tdiff == -1) {
                         tdiff = 0 - time_diff(rs->tm2[0], rs->tm2[1], 1000);
                    }

                    //sprintf_f(rs->logs, "t %d us\n", tdiff);
                    //print_f(rs->plogs, "P3", rs->logs);
                    if (tdiff < 0) {                    
                        sprintf_f(rs->logs, "!!t %d - %d!!\n", tdiff, len);
                        print_f(rs->plogs, "P3", rs->logs);
                    }
#endif
                    //shmem_dump(addr, 32);
                    //msync(addr, len, MS_SYNC);
                    if (opsz < 0) break;
#else // #if SPI1_ENABLE
                    bitset = 1;
                    msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_RD_CTL_PIN
                    //sprintf_f(rs->logs, "Get RDY pin: %d\n", bitset);
                    //print_f(rs->plogs, "P3", rs->logs);
                    if (bitset == 0) {
                        opsz = -1;
                        break;
                    }
#endif // #if SPI1_ENABLE
                    ring_buf_prod_dual(rs->pdataRx, pi);

                    rs_ipc_put(rs, "p", 1);
                    pi += 2;
                }

                opsz = 0 - opsz;

                if (opsz == 1) opsz = 0;
#if JPG_FFD9_CUT /* find 0xcffd9 in jpg */
                ret = cfgTableGetChk(pct, ASPOP_FILE_FORMAT, &fformat, ASPOP_STA_CON);    
                if (ret) {
                    fformat = 0;
                }
                
                if ((fformat == 0) || (fformat == FILE_FORMAT_JPG) || (fformat == FILE_FORMAT_PDF)) {
                    sprintf_f(rs->logs, "fformat: 0x%x !!!\n", fformat);
                    print_f(rs->plogs, "P3", rs->logs);    

                    /* search the offset of 0xffd9 */
                    ret = findEOF(addr, opsz);
                    if (ret > 0) {
                        memset(addr + ret + 2, 0xff, opsz - ret - 2);
                    } else {
                        sprintf_f(rs->logs, "warnning!!! file format: 0x%x, ret: %d can't find ffd9\n", fformat, ret);
                        print_f(rs->plogs, "P3", rs->logs);    
                    }


                    sprintf_f(rs->logs, "fformat: 0x%x, ret: %d \n", fformat, ret);
                    print_f(rs->plogs, "P3", rs->logs);    
                }
#endif
                if (opsz > 0) {
                    ring_buf_prod_dual(rs->pdataRx, pi);
                }
 
                ring_buf_set_last_dual(rs->pdataRx, opsz, pi);
                rs_ipc_put(rs, "d", 1);

                sprintf_f(rs->logs, "spi1 recv end, the last sector size: %d\n", opsz);
                print_f(rs->plogs, "P3", rs->logs);
            }
            else if (cmode == 6) {
                totsz = 0;
                sprintf_f(rs->logs, "cmode: %d\n", cmode);
                print_f(rs->plogs, "P3", rs->logs);

                pi = 0;  
                
#if MSP_P3_SAVE_DAT
                ret = file_save_get(&rs->fdat_s[1], "/mnt/mmc2/rx/p3_%d.jpg");
                if (ret) {
                    sprintf_f(rs->logs, "get tx log data file error - %d, hold here\n", ret);
                    print_f(rs->plogs, "P3", rs->logs);         
                    while(1);
                } else {
                    sprintf_f(rs->logs, "get tx log data file ok - %d, f: %d\n", ret, rs->fdat_s[1]);
                    print_f(rs->plogs, "P3", rs->logs);         
                }
#endif
                tlast = dbgShowTimeStamp("_SPI_1_ BEG", NULL, rs, 8, "_S1_S_");

                while (1) {
                    len = 0;
                    len = ring_buf_get(rs->pcmdTx, &addr);
                    if (len > 0) {

                        msync(addr, len, MS_SYNC);
                        
                        opsz = 0;
                        while (opsz == 0) {
#if SPI_KTHREAD_USE 
                            opsz = msp_spi_conf(rs->spifd, _IOR(SPI_IOC_MAGIC, 15, __u32), addr);  //SPI_IOC_PROBE_THREAD
                            if (opsz == 0) {
#if SPI_KTHREAD_DLY
                                usleep(1000);
                                sprintf_f(rs->logs, "kth opsz:%d\n", opsz);
                                print_f(rs->plogs, "P3", rs->logs);  
#endif
                                continue;
                            }

#else // #if SPI_KTHREAD_USE
                            opsz = mtx_data(rs->spifd, addr, NULL, len, tr);
#endif

                            totsz += opsz;

#if MSP_P3_SAVE_DAT
                    msync(addr, len, MS_SYNC);                    
                    fwrite(addr, 1, len, rs->fdat_s[1]);
                    fflush(rs->fdat_s[1]);
#endif
                            if ((opsz > 0) && (opsz < SPI_TRUNK_SZ)) { // workaround to fit original design
                                opsz = 0 - opsz;
                            }

#if SPI_TRUNK_FULL_FIX
                            if (opsz < 0) {
                                opsz = 0 - opsz;                    
                                if (opsz == SPI_TRUNK_SZ) {
                                    opsz = 0 - opsz;    
                                } else {
                                    sprintf_f(rs->logs, "Error!!! spi send tx failed, return %d \n", opsz);
                                    print_f(rs->plogs, "P2", rs->logs);
                                }
                            }
#endif

#if LOG_P3_TX_EN
                            sprintf_f(rs->logs, "r %d/%d - %d\n", opsz, totsz, pi);
                            print_f(rs->plogs, "P3", rs->logs);
#endif
                        }

                        //msync(addr, len, MS_SYNC);
                        ring_buf_prod(rs->pcmdTx);    
                        if (opsz < 0) break;
                        rs_ipc_put(rs, "p", 1);
                        pi += 1;
                    }
                }
                opsz = 0 - opsz;

#if JPG_FFD9_CUT /* find 0xcffd9 in jpg */
                ret = cfgTableGetChk(pct, ASPOP_FILE_FORMAT, &fformat, ASPOP_STA_CON);    
                if (ret) {
                    fformat = 0;
                }
                
                if ((fformat == 0) || (fformat == FILE_FORMAT_JPG) || (fformat == FILE_FORMAT_PDF)) {
                    sprintf_f(rs->logs, "fformat: 0x%x !!!\n", fformat);
                    print_f(rs->plogs, "P3", rs->logs);    

                    /* search the offset of 0xffd9 */
                    ret = findEOF(addr, opsz);
                    if (ret > 0) {
                        memset(addr + ret + 2, 0xff, opsz - ret - 2);
                    } else {
                        sprintf_f(rs->logs, "warnning!!! file format: 0x%x, ret: %d can't find ffd9\n", fformat, ret);
                        print_f(rs->plogs, "P3", rs->logs);    
                    }

                    sprintf_f(rs->logs, "fformat: 0x%x, ret: %d \n", fformat, ret);
                    print_f(rs->plogs, "P3", rs->logs);    
                }
#endif

                sprintf(rs->logs, "_SPI_1_ END %d bytes ", totsz);
                tdiff = dbgShowTimeStamp(rs->logs, NULL, rs, 8, "_S1_E_");

                fltime = (CFLOAT)(tdiff - tlast);
                if (fltime == 0) {
                    thrput = 0;
                } else {
                    thrput = (CFLOAT) totsz /fltime;
                }

                cfgTableSet(pct, ASPOP_RAW_SIZE_DUO, totsz);
                sprintf(rs->logs, "_SPI_1_ throughput: %.2f MB/sec ", thrput);
                dbgShowTimeStamp(rs->logs, NULL, rs, 8, "done");                

#if MSP_P3_SAVE_DAT
                fclose(rs->fdat_s[1]);
#endif

                ring_buf_set_last(rs->pcmdTx, opsz);
                rs_ipc_put(rs, "d", 1);
                sprintf_f(rs->logs, "spi0 recv end totsz: %d\n", totsz);
                print_f(rs->plogs, "P3", rs->logs);
            }
            else if (cmode == 7) {
                totsz = 0;
                len = 0;
                pi = 0;  
                len = 0;

                //len = 512;
                len = SPI_TRUNK_SZ;
                addr = (char *)rs->pmetaout;
                //laddr = (char *)rs->pmetain;
                laddr = (char *)rs->pmetaMassduo->masspt;
                
                memcpy(laddr, addr, 512);
                msync(laddr, 512, MS_SYNC);

                opsz = 0;
                while (opsz == 0) {
                    opsz = mtx_data(rs->spifd, laddr, laddr, len, tr);

                    if ((opsz > 0) && (opsz < SPI_TRUNK_SZ)) { // workaround to fit original design
                        opsz = 0 - opsz;
                    }

                    //usleep(10000);
#if LOG_P3_TX_EN
                    sprintf_f(rs->logs, "spi1 recv %d\n", opsz);
                    print_f(rs->plogs, "P3", rs->logs);
#endif
                    //shmem_dump(addr, 512);
                                        
                    if (opsz < 0) {
                        //sprintf_f(rs->logs, "opsz:%d break!\n", opsz);
                        //print_f(rs->plogs, "P2", rs->logs);    
                        break;
                    }

                }
                
                rs_ipc_put(rs, "Y", 1);

                pi += 1;
                
                opsz = 0 - opsz;
                if (opsz == 1) opsz = 0;
                totsz += opsz;

                memcpy(rs->pmetainduo, laddr, 512);
                msync(rs->pmetainduo, 512, MS_SYNC);

                sprintf_f(rs->logs, "meta get magic number: 0x%.2x 0x%.2x \n", pmetaduo->ASP_MAGIC[0], pmetaduo->ASP_MAGIC[1]);
                print_f(rs->plogs, "P3", rs->logs);

                sprintf_f(rs->logs, "totsz: %d, len:%d opsz:%d ret:%d, break!\n", totsz, len, opsz, ret);
                print_f(rs->plogs, "P3", rs->logs);

                if (totsz > rs->pmetaMassduo->massMax) {
                    rs->pmetaMassduo->massUsed = rs->pmetaMassduo->massMax;
                } else {
                    rs->pmetaMassduo->massUsed = totsz;
                }
            }
            else if (cmode == 8) {
                //sprintf_f(rs->logs, "cmode: %d\n", cmode);
                //print_f(rs->plogs, "P3", rs->logs);

                //sprintf(rs->logs, "__WAIT_CROP_CALCUL_START_1__"); 
                //tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 14, rs->logs);

                ret = rs_ipc_get(rs, finfo, 2);

                //sprintf(rs->logs, "__WAIT_CROP_CALCUL_START_2__"); 
                //tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 14, rs->logs);
                
                //sprintf_f(rs->logs, "get info: 0x%.2x + 0x%.2x \n", finfo[0], finfo[1]);
                //print_f(rs->plogs, "P3", rs->logs);

                //sleep(10);
                len = ring_buf_cons(rs->pdataRx, &addr);
                if (len >= 0) {
                    sprintf_f(rs->logs, "get crop len: %d\n", len);
                    print_f(rs->plogs, "P3", rs->logs);
                
                    pusbmeta = aspMemalloc(len, 3);
                    if (pusbmeta) {
                        memset(pusbmeta, 0, len);
                        memcpy(pusbmeta, addr, len);  
                        
                        //shmem_dump(addr, 228);
                        //shmem_dump(addr+228, 32);
                        
                        msync(pusbmeta, len, MS_SYNC);

                        if ((pusbmeta->ASP_MAGIC_ASPC[0] == finfo[0]) && 
                            (pusbmeta->ASP_MAGIC_ASPC[1] == finfo[1])) {
                            
                            totsz = sizeof(struct aspMetaDataviaUSB_s);
                            org_len = (pusbmeta->EXTRA_POINT[2] << 8) | pusbmeta->EXTRA_POINT[3];
                            totsz += pusbmeta->MPIONT_LEN;

                            tch = (char *)&pusbmeta->YLines_Recorded;
                            mass_len = (int) ((tch[0]<<8) | tch[1]);

                            layeTot = (int)((pusbmeta->BKNote_Total_Layers > 0) && (pusbmeta->BKNote_Total_Layers < 9)) ? pusbmeta->BKNote_Total_Layers:1;
                            colrBits_pt = &pusbmeta->LEDMode;
                            
                            //shmem_dump(addr, totsz);
                            sprintf_f(rs->logs, "get total len: %d parsing len: %d, M_LEN: %d, yLine_rec: %d layeTot: %d, \n", totsz, org_len, (int)pusbmeta->MPIONT_LEN, mass_len, layeTot);
                            print_f(rs->plogs, "P3", rs->logs);

                            shmem_dump(colrBits_pt, 8);

                            if (pusbmeta->MPIONT_LEN > 4) {

                                org_len = 18*2;
                                mass_len = mass_len * 4;

                                sprintf(rs->logs, "__CROP_CALCUL_START__"); 
                                tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 14, rs->logs);
                        
                                result = aspMemalloc(sizeof(int)*8, 3);
                                org = aspMemalloc(sizeof(int)*org_len, 3);
                                mass = aspMemalloc(sizeof(int)*mass_len, 3);
                                if (!mass) {
                                    sprintf_f(rs->logs, "malloc size: %d failed !!! \n", sizeof(int)*mass_len);
                                    print_f(rs->plogs, "P3", rs->logs);
                                }
                                
                                memset(result, 0, sizeof(int)*8);
                                memset(org, 0, sizeof(int)*org_len);
                                memset(mass, 0, sizeof(int)*mass_len);
                                
                                clock_gettime(CLOCK_REALTIME, &crpS);
                        
                                ret = getOrg(org, addr, totsz, rs, layeTot);
                                if (ret) {
                                    sprintf_f(rs->logs, "getOrg ret: %d \n", ret);
                                    print_f(rs->plogs, "P3", rs->logs);
                                }
                                
                                ret = getExtra(mass, addr, totsz, rs, layeTot);
                                if (ret) {
                                    sprintf_f(rs->logs, "getExtra ret: %d \n", ret);
                                    print_f(rs->plogs, "P3", rs->logs);
                                }
                                else {
                                    //clock_gettime(CLOCK_REALTIME, &crpE);
                                    //tmCost = time_diff(&crpS, &crpE, 1000);

                                    //sprintf_f(rs->logs, "point deal time cost: %d.%d ms !!! \n", tmCost/1000, tmCost%1000);
                                    //print_f(rs->plogs, "P3", rs->logs);                        

                                    //clock_gettime(CLOCK_REALTIME, &crpS);

                                    doCalculate(result, org, org_len, mass, mass_len, rs, 3);
                                }
                                
                                sprintf(rs->logs, "__CROP_CALCUL_END__"); 
                                tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 14, rs->logs);

                                clock_gettime(CLOCK_REALTIME, &crpE);
                                tmCost = time_diff(&crpS, &crpE, 1000);

                                sprintf_f(rs->logs, "cropping calcu time cost: %d.%d ms !!! \n", tmCost/1000, tmCost%1000);
                                print_f(rs->plogs, "P3", rs->logs);                        
                                
                                sprintf_f(rs->logs, "get rotateP1 (%4d, %4d) \n", result[0], result[1]);
                                print_f(rs->plogs, "P3", rs->logs);

                                sprintf_f(rs->logs, "get rotateP2 (%4d, %4d) \n", result[2], result[3]);
                                print_f(rs->plogs, "P3", rs->logs);
                                
                                sprintf_f(rs->logs, "get rotateP3 (%4d, %4d) \n", result[4], result[5]);
                                print_f(rs->plogs, "P3", rs->logs);
                                
                                sprintf_f(rs->logs, "get rotateP4 (%4d, %4d) \n", result[6], result[7]);
                                print_f(rs->plogs, "P3", rs->logs);
                                
                                tmp = (uint32_t)result[0];
                                cord = (uint32_t)result[1];
                                cord = cord | (tmp <<16);
                                lsb2Msb32(&pusbmeta->CROP_POS_F1, cord);
                                
                                tmp = (uint32_t)result[2];
                                cord = (uint32_t)result[3];
                                cord = cord | (tmp <<16);
                                lsb2Msb32(&pusbmeta->CROP_POS_F2, cord);
                                
                                tmp = (uint32_t)result[4];
                                cord = (uint32_t)result[5];
                                cord = cord | (tmp <<16);
                                lsb2Msb32(&pusbmeta->CROP_POS_F3, cord);
                                
                                tmp = (uint32_t)result[6];
                                cord = (uint32_t)result[7];
                                cord = cord | (tmp <<16);
                                lsb2Msb32(&pusbmeta->CROP_POS_F4, cord);
                                
                                addr = (char *) &pusbmeta->CROP_POS_F1;

                                //sprintf(rs->logs, "__CROP_CALCUL_END_OUTLOOP__"); 
                                //tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 14, rs->logs);

                                //sprintf(rs->logs, "__CROP_CALCUL_END_SENDMSG_MEM_FAST__"); 
                                //tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 14, rs->logs);

                                //memset(uinfo, 0, 32);
                                uinfo[0] = 'O';
                                uinfo[1] = finfo[0];
                                uinfo[2] = finfo[1];
                                memcpy(&uinfo[3], addr, 16);

                                //sprintf(rs->logs, "__CROP_CALCUL_END_SENDMSG_IN_FAST__"); 
                                //tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 14, rs->logs);

                                rs_ipc_put(rs, uinfo, 19);

                                //sprintf(rs->logs, "__CROP_CALCUL_END_SENDMSG_OUT_FAST__"); 
                                //tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 14, rs->logs);
                
                                continue; //break the loop quickly
                            }
                            else {
                                sprintf_f(rs->logs, "no crop data, MPIONT_LEN: %d \n", pusbmeta->MPIONT_LEN);
                                print_f(rs->plogs, "P3", rs->logs);

                                addr = (char *) &pusbmeta->CROP_POS_F1;
                                memset(addr, 0, 16);
                            }
                        }
                        else {
                            sprintf_f(rs->logs, "Error!!! info not match !!!0x%.2x 0x%.2x vs 0x%.2x 0x%.2x \n", finfo[0], finfo[1], pusbmeta->ASP_MAGIC_ASPC[0], pusbmeta->ASP_MAGIC_ASPC[1]);
                            print_f(rs->plogs, "P3", rs->logs);

                            //shmem_dump(addr, 512);
                            //dbgMetaUsb(pusbmeta);

                            memset(addr, 0, 16);
                        }

                        //dbgMetaUsb(pusbmeta);
                    } 
                    else {
                        sprintf_f(rs->logs, "Error!!! allocate memory for usb meta failed !!!\n");
                        print_f(rs->plogs, "P3", rs->logs);
                        
                        memset(addr, 0, 16);
                    }
                }
                else {
                    addr = aspMemalloc(16, 3);
                    memset(addr, 0, 16);
                }

                //sprintf(rs->logs, "__CROP_CALCUL_END_SENDMSG_MEM__"); 
                //tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 14, rs->logs);

                //memset(uinfo, 0, 32);
                uinfo[0] = 'O';
                uinfo[1] = finfo[0];
                uinfo[2] = finfo[1];
                memcpy(&uinfo[3], addr, 16);
                
                //sprintf(rs->logs, "__CROP_CALCUL_END_SENDMSG_IN__"); 
                //tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 14, rs->logs);
                
                rs_ipc_put(rs, uinfo, 19);

                //sprintf(rs->logs, "__CROP_CALCUL_END_SENDMSG_OUT__"); 
                //tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 14, rs->logs);
                
            }
            #if MFOUR_SIM_MODE
            else if (cmode == 9) {
                //sprintf_f(rs->logs, "sim cmode: %d\n", cmode);
                //print_f(rs->plogs, "P3", rs->logs);

                //ret = rs_ipc_get(rs, finfo, 2);
                //sprintf(rs->logs, "__WAIT_CROP_CALCU_START_1__"); 
                //tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 14, rs->logs);
                        
                ret = rs_ipc_get(rs, &chc, 1);
                
                //sprintf(rs->logs, "__WAIT_CROP_CALCU_START_2__"); 
                //tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 14, rs->logs);
                
                if (chc == 0x80) {
                    mbfidx = 0;
                } else {
                    mbfidx = chc & 0x7f;
                }

                if (mbfidx > 3) {
                    sprintf_f(rs->logs, "crop get buff index %d error!!! \n", mbfidx);
                    print_f(rs->plogs, "P3", rs->logs);
                    break;
                } else {
                    //sprintf_f(rs->logs, "crop get buff index %d succed!!! \n", mbfidx);
                    //print_f(rs->plogs, "P3", rs->logs);
                }

                pdec = rs->pbDecMfour[mbfidx];
    
                imgidx = 0;
                mfbstat = 0;
                ret = aspBMPdecodeBuffGetIdx(pdec, &imgidx);
                ret = aspBMPdecodeBuffStatusGet(pdec, &mfbstat);
                sprintf_f(rs->logs, "crop get mfbuff index %d, imgindex: %d, status 0x%x succeed!!! \n", mbfidx, imgidx, mfbstat);
                print_f(rs->plogs, "P3", rs->logs);
                
                decjpg = &pdec->aspDecJpeg; //jpeg
                decmeta = &pdec->aspDecMeta; //meta
                decexmt = &pdec->aspDecMetaex; //meta

                aspBMPdecodeItemGet(decmeta, &pmeta, &mtlen);
                aspBMPdecodeItemGet(decexmt, &pexmt, &exlen);

                pusbmeta = 0;
                if ((mtlen > 0) && (exlen > 0)) {
                    len = sizeof(struct aspMetaDataviaUSB_s) + exlen;
                    addr = aspMemalloc(len, 3);
                    if (!addr) {
                        sprintf_f(rs->logs, "Error!!! failed to allocate memory for meta buff size: %d \n", len);
                        print_f(rs->plogs, "P3", rs->logs);

                        continue;
                    }
                    memset(addr, 0, len);

                    pusbmeta = (struct aspMetaDataviaUSB_s *)addr;
                    
                    /*
                    pusbmetaOrg = (struct aspMetaDataviaUSB_s *)pmeta;
                    
                    tmp = msb2lsb32(&pusbmetaOrg->CROP_POS_F1);
                    cord = tmp & 0xffff;
                    tmp = tmp >> 16;
                    
                    sprintf_f(rs->logs, "m4 before P1 (%4d, %4d) \n", tmp, cord);
                    print_f(rs->plogs, "P3", rs->logs);

                    tmp = msb2lsb32(&pusbmetaOrg->CROP_POS_F2);
                    cord = tmp & 0xffff;
                    tmp = tmp >> 16;
                    
                    sprintf_f(rs->logs, "m4 before P2 (%4d, %4d) \n", tmp, cord);
                    print_f(rs->plogs, "P3", rs->logs);
                    
                    tmp = msb2lsb32(&pusbmetaOrg->CROP_POS_F3);
                    cord = tmp & 0xffff;
                    tmp = tmp >> 16;
                    
                    sprintf_f(rs->logs, "m4 before P3 (%4d, %4d) \n", tmp, cord);
                    print_f(rs->plogs, "P3", rs->logs);

                    tmp = msb2lsb32(&pusbmetaOrg->CROP_POS_F4);
                    cord = tmp & 0xffff;
                    tmp = tmp >> 16;
                    
                    sprintf_f(rs->logs, "m4 before P4 (%4d, %4d) \n", tmp, cord);
                    print_f(rs->plogs, "P3", rs->logs);
                    */

                    //sprintf_f(rs->logs, "get meta crop info mtlen: %d, exlen: %d buffsize: %d \n", mtlen, exlen, len);
                    //print_f(rs->plogs, "P3", rs->logs);

                    val = (pexmt[2] << 8) | pexmt[3];

                    memcpy(pusbmeta, pmeta, len);
                    pusbmeta->MPIONT_LEN = val;
                    memcpy(pusbmeta->EXTRA_POINT, pexmt, exlen);
                    totsz = sizeof(struct aspMetaDataviaUSB_s);
                    totsz += pusbmeta->MPIONT_LEN;
                    
                    org_len = (pusbmeta->EXTRA_POINT[2] << 8) | pusbmeta->EXTRA_POINT[3];

                    tch = (char *)&pusbmeta->YLines_Recorded;
                    mass_len = (int) ((tch[0]<<8) | tch[1]);

                    layeTot = (int)((pusbmeta->BKNote_Total_Layers > 0) && (pusbmeta->BKNote_Total_Layers < 9)) ? pusbmeta->BKNote_Total_Layers:1;
                    colrBits_pt = &pusbmeta->LEDMode;
                            
                    sprintf_f(rs->logs, "get meta info total len: %d  masslen: %d, M_LEN: %d, ylrec: %d, layerTot: %d\n", totsz, org_len, (int)pusbmeta->MPIONT_LEN, mass_len*4+4, layeTot);
                    print_f(rs->plogs, "P3", rs->logs);

                    shmem_dump(colrBits_pt, 8);
                            
                    if (pusbmeta->MPIONT_LEN > 4) {

                        org_len = 18*2;
                        mass_len = mass_len * 4;

                        sprintf(rs->logs, "__CROP_CALCU_START(%d)__", mbfidx); 
                        tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 14, rs->logs);
                                
                        result = aspMemalloc(sizeof(int)*8, 3);
                        org = aspMemalloc(sizeof(int)*org_len, 3);
                        mass = aspMemalloc(sizeof(int)*mass_len, 3);
                        if ((!mass) || (!result) || (!org)) {
                            sprintf_f(rs->logs, "crop calcu memory malloc size: %d failed !!! \n", (8+org_len+mass_len)*sizeof(int));
                            print_f(rs->plogs, "P3", rs->logs);
                            continue;
                        }
                        memset(result, 0, sizeof(int)*8);
                        memset(org, 0, sizeof(int)*org_len);
                        memset(mass, 0, sizeof(int)*mass_len);

                        clock_gettime(CLOCK_REALTIME, &crpS);

                        ret = getOrg(org, addr, totsz, rs, layeTot);
                        if (ret) {
                            sprintf_f(rs->logs, "m4 getOrg ret: %d layeTot: %d\n", ret, layeTot);
                            print_f(rs->plogs, "P3", rs->logs);
                        }

                        ret = getExtra(mass, addr, totsz, rs, layeTot);
                        if (ret) {
                            sprintf_f(rs->logs, "m4 getExtra ret: %d layeTot: %d\n", ret, layeTot);
                            print_f(rs->plogs, "P3", rs->logs);
                        }
                        else {
                            doCalculate(result, org, org_len, mass, mass_len, rs, 3);
                        }

                        sprintf(rs->logs, "__CROP_CALCU_END(%d)__", mbfidx); 
                        tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 14, rs->logs);
                        
                        clock_gettime(CLOCK_REALTIME, &crpE);
                        tmCost = time_diff(&crpS, &crpE, 1000);

                        sprintf_f(rs->logs, "crop calcu time cost: %d.%d ms!!! \n", tmCost/1000, tmCost%1000);
                        print_f(rs->plogs, "P3", rs->logs);
                        
                        /*
                        sprintf_f(rs->logs, "m4 get rotateP1 (%4d, %4d) \n", result[0], result[1]);
                        print_f(rs->plogs, "P3", rs->logs);

                        sprintf_f(rs->logs, "m4 get rotateP2 (%4d, %4d) \n", result[2], result[3]);
                        print_f(rs->plogs, "P3", rs->logs);
                        
                        sprintf_f(rs->logs, "m4 get rotateP3 (%4d, %4d) \n", result[4], result[5]);
                        print_f(rs->plogs, "P3", rs->logs);
                        
                        sprintf_f(rs->logs, "m4 get rotateP4 (%4d, %4d) \n", result[6], result[7]);
                        print_f(rs->plogs, "P3", rs->logs);
                        */

                        pusbmetaOrg = (struct aspMetaDataviaUSB_s *)pmeta;
                        
                        tmp = msb2lsb32(&pusbmetaOrg->CROP_POS_F1);
                        cord = tmp & 0xffff;
                        tmp = tmp >> 16;
                        
                        sprintf_f(rs->logs, "m4 confirm P1 (%4d, %4d) vs (%4d, %4d) \n", result[0], result[1], tmp, cord);
                        print_f(rs->plogs, "P3", rs->logs);

                        tmp = msb2lsb32(&pusbmetaOrg->CROP_POS_F2);
                        cord = tmp & 0xffff;
                        tmp = tmp >> 16;
                        
                        sprintf_f(rs->logs, "m4 confirm P2 (%4d, %4d) vs (%4d, %4d) \n", result[2], result[3], tmp, cord);
                        print_f(rs->plogs, "P3", rs->logs);
                        
                        tmp = msb2lsb32(&pusbmetaOrg->CROP_POS_F3);
                        cord = tmp & 0xffff;
                        tmp = tmp >> 16;
                        
                        sprintf_f(rs->logs, "m4 confirm P3 (%4d, %4d) vs (%4d, %4d) \n", result[4], result[5], tmp, cord);
                        print_f(rs->plogs, "P3", rs->logs);

                        tmp = msb2lsb32(&pusbmetaOrg->CROP_POS_F4);
                        cord = tmp & 0xffff;
                        tmp = tmp >> 16;
                        
                        sprintf_f(rs->logs, "m4 confirm P4 (%4d, %4d) vs (%4d, %4d) \n", result[6], result[7], tmp, cord);
                        print_f(rs->plogs, "P3", rs->logs);

                        //addr = (char *) &pusbmeta->CROP_POS_F1;

                    }
                }
                
                memset(uinfo, 0, 32);
                uinfo[0] = 'S';
                uinfo[1] = 'f';
                uinfo[2] = chc;

                rs_ipc_put(rs, uinfo, 3);
                
            }
            #endif //#if MFOUR_SIM_MODE
            else {
                sprintf_f(rs->logs, "unknown cmode: %d\n", cmode);
                print_f(rs->plogs, "P3", rs->logs);
            }

            //dbgShowTimeStamp("P3_END", 6);

            //sprintf(rs->logs, "__P3_FINISH_CLR_IN__"); 
            //tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 14, rs->logs);

            aspMemClear(aspMemAsign, asptotMalloc, 3);

            //sprintf(rs->logs, "__P3_FINISH_CLR_OUT__"); 
            //tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 14, rs->logs);

        }
    }

    p3_end(rs);
    return 0;
}

static int socket_nonblock_set (int sfd)
{
    int val, ret;
    ret = fcntl (sfd, F_GETFL, 0);
    if (ret == -1)
    {
        perror ("fcntl");
        return -1;
    }

    val = ret;  
    val |= O_NONBLOCK;
    ret = fcntl (sfd, F_SETFL, val);
    if (ret == -1)
    {
        perror ("fcntl");
        return -1;
    }

    return 0;
}

#define MSP_P4_SAVE_DAT (0)
#define LOG_P4_TX_EN  (0)
static int p4(struct procRes_s *rs)
{
    CFLOAT flsize, fltime;
    int px, pi, ret=0, len=0, opsz, totsz, tdiff, tlast;
    int cmode=0, acuhk, errtor=0, cltport=0;
    char ch, str[128];
    char *addr, *pre, *cltaddr;
    struct info16Bit_s *p=0, *c=0;
    uint32_t secStr=0, secLen=0, datLen=0, minLen=0;
    struct sdFAT_s *pfat=0;
    struct sdFATable_s   *pftb=0;
    CFLOAT thrput;
    fd_set rfds;
    struct timeval tv;
    int socketfailed=0, expectSz=0;
#if (SOCKET_NON_BLOCK_RX | SOCKET_NON_BLOCK_TX)
    struct epoll_event event, events[MAX_EVENTS];
#endif    
    int  consfd, nfds, epollfd;

    prctl(PR_SET_NAME, "msp-p4");
    //sprintf(argv[0], "msp-p4-socket6000");
    
    pfat = rs->psFat;
    pftb = &pfat->fatTable;
    sprintf_f(rs->logs, "p4\n");
    print_f(rs->plogs, "P4", rs->logs);

    c = &rs->pmch->cur;
    p = &rs->pmch->tmp;

    p4_init(rs);
    // wait for ch from p0
    // in charge of socket send

    char *recvbuf, *tmp;

    recvbuf = aspMemalloc(1024, 8);
    if (!recvbuf) {
        sprintf_f(rs->logs, "p4 recvbuf alloc failed! \n");
        print_f(rs->plogs, "P4", rs->logs);
        return (-1);
    } else {
        sprintf_f(rs->logs, "p4 recvbuf alloc success! 0x%x\n", (uint32_t)recvbuf);
        print_f(rs->plogs, "P4", rs->logs);
    }

    rs->psocket_t->listenfd = socket(AF_INET, SOCK_STREAM, 0);
    if (rs->psocket_t->listenfd < 0) { 
        sprintf(rs->logs, "p4 get socket ret: %d", rs->psocket_t->listenfd);
        error_handle(rs->logs, 3128);
    }

    memset(&rs->psocket_t->serv_addr, '0', sizeof(struct sockaddr_in));

    rs->psocket_t->serv_addr.sin_family = AF_INET;
    rs->psocket_t->serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    rs->psocket_t->serv_addr.sin_port = htons(6000); 

    ret = bind(rs->psocket_t->listenfd, (struct sockaddr*)&rs->psocket_t->serv_addr, sizeof(struct sockaddr_in)); 
    if (ret < 0) {
        //perror("bind:");
        
        ret = -1;
        if (setsockopt(rs->psocket_t->listenfd, SOL_SOCKET, SO_REUSEADDR, &ret, sizeof(int)) == -1) {
            perror("setsockopt");    
            
            sprintf(rs->logs, "p4 get bind ret: %d", ret);
            error_handle(rs->logs, 22465);
        }
    }
    
    ret = listen(rs->psocket_t->listenfd, 10); 
    if (ret < 0) {
        sprintf(rs->logs, "p4 get listen ret: %d", ret);
        error_handle(rs->logs, 3146);
    }

#if SOCKET_EPOLL_EN
    epollfd = epoll_create1(O_CLOEXEC);
    if (epollfd < 0) {
        perror("epoll_create1");
        //exit(EXIT_FAILURE);
        sprintf_f(rs->logs, "epoll create failed, errno: %d\n", errno);
        print_f(rs->plogs, "P4", rs->logs);
    } else {
        sprintf_f(rs->logs, "epoll create succeed, epollfd: %d, errno: %d\n", epollfd, errno);
        print_f(rs->plogs, "P4", rs->logs);
    }
#endif

    while (1) {
        //printf("^");
        //sprintf_f(rs->logs, "^\n");
        //print_f(rs->plogs, "P4", rs->logs);
#if 1 /* remote for test */
        len = sizeof(struct sockaddr_in);
        memset(&rs->psocket_t->clint_addr, 0, len);
        rs->psocket_t->connfd = accept(rs->psocket_t->listenfd, (struct sockaddr*)&rs->psocket_t->clint_addr, &len);
        if (rs->psocket_t->connfd < 0) {
            sprintf(rs->logs, "P4 get connect failed ret:%d", rs->psocket_t->connfd);
            error_handle(rs->logs, 3157);
            continue;
        } else {
            //cltaddr = rs->psocket_t->clint_addr.sa_data;
            cltaddr = inet_ntoa(rs->psocket_t->clint_addr.sin_addr);
            cltport = ntohs(rs->psocket_t->clint_addr.sin_port);
            sprintf_f(rs->logs, "get connection id: %d [%s:%d]\n", rs->psocket_t->connfd, cltaddr, cltport);
            print_f(rs->plogs, "P4", rs->logs);

#if (SOCKET_NON_BLOCK_RX | SOCKET_NON_BLOCK_TX)
            //fcntl(rs->psocket_t->connfd, F_SETFL, O_NONBLOCK);
            consfd = rs->psocket_t->connfd;
            socket_nonblock_set(consfd);
            socketfailed = 0;
#endif
            aspMemClear(aspMemAsign, asptotMalloc, 4);
        }
#else
        rs->psocket_t->connfd = 4;
#endif
//        opsz = read(rs->psocket_t->connfd, recvbuf, 1024);
        opsz = 0;
        recvbuf[0] = '\0';
        //sprintf_f(rs->logs, "socket connected %d\n", rs->psocket_t->connfd);
        //print_f(rs->plogs, "P4", rs->logs);

        pi = 0;
        ret = 1;

        while (ret > 0) {

            ret = 0;
            ch = 0;
            ret = rs_ipc_get(rs, &ch, 1);               
            
            sprintf_f(rs->logs, "%c ret:%d \n", ch, ret);
            print_f(rs->plogs, "P4", rs->logs);

#if LOG_DOT_PROG_EN
            printf("4%c", ch);
#endif

            
            switch (ch) {
                case 'E':
                    goto socketEnd;
                    break;
                case 'd':
                    cmode = 1;
                    break;
                case 'c':
                    cmode = 2;
                    break;
                case 'r':
                    cmode = 3;
                    break;
                case 'n':
                    cmode = 4;
                    break;
                case 'u':
                    cmode = 5;
                    break;
                default:
                    break;
            }

            if (cmode == 3) {
                if (rs->psocket_t->connfd > 0) {
                    rs_ipc_put(rs, "R", 1);
                    continue;
                } else {
                    rs_ipc_put(rs, "r", 1);
                    break;
                }
            } 
            else if (cmode == 1) {
#if MSP_P4_SAVE_DAT
                ret = file_save_get(&rs->fdat_s[2], "/mnt/mmc2/tx/p4%d.dat");
                if (ret) {
                    sprintf_f(rs->logs, "get tx log data file error - %d, hold here\n", ret);
                    print_f(rs->plogs, "P4", rs->logs);         
                    while(1);
                } else {
                    sprintf_f(rs->logs, "get tx log data file ok - %d, f: %d\n", ret, rs->fdat_s[2]);
                    print_f(rs->plogs, "P4", rs->logs);         
                }
#endif
                totsz = 0;
                clock_gettime(CLOCK_REALTIME, &rs->tdf[0]);
                sprintf_f(rs->logs, "start at %ld s\n", rs->tdf[0].tv_sec);
                print_f(rs->plogs, "P4", rs->logs);                         

#if SOCKET_EPOLL_EN
                event.data.fd = consfd;
                event.events = EPOLLOUT | EPOLLLT;
                ret = epoll_ctl (epollfd, EPOLL_CTL_ADD, consfd, &event);
                if (ret == -1)
                {
                    perror ("epoll_ctl");
                    sprintf_f(rs->logs, "spoll set ctl failed errno: %ds\n", errno);
                    print_f(rs->plogs, "P4", rs->logs);                         
                    break;
                }
#endif

                while (1) {
                    len = ring_buf_cons_dual(rs->pdataRx, &addr, pi);
                    if (len >= 0) {
                        //printf("cons 0x%x %d %d \n", addr, len, pi);
                        pi++;
                    
                        msync(addr, len, MS_SYNC);
                        /* send data to wifi socket */
                        //sprintf_f(rs->logs, " %d -%d \n", len, pi);
                        //print_f(rs->plogs, "P4", rs->logs);         
                        if (len != 0) {
#if SOCKET_NON_BLOCK_TX
#if SOCKET_EPOLL_EN
                            expectSz = len;
                            while (expectSz > 0) {
                                if (!socketfailed) {
                                    nfds = epoll_wait (epollfd, events, MAX_EVENTS, 5000);
                                    if (nfds < 0) {
                                        perror("epoll_wait");
                                        sprintf_f(rs->logs, "nonblock send %d / %d failed, errno: %d\n", opsz, expectSz, errno);
                                        print_f(rs->plogs, "P4", rs->logs);         
                                        break;
                                    } else if (nfds == 0) {
                                        socketfailed = 1;
                                    } else {
                                        opsz = write(consfd, addr, expectSz);
#if LOG_P4_TX_EN
                                        sprintf_f(rs->logs, "epoll nonblock send %d / %d, n: %d\n", opsz, expectSz, nfds);
                                        print_f(rs->plogs, "P4", rs->logs);         
#endif
                                    }
                                } else {
                                    opsz = len;
                                }

                                expectSz -= opsz;
                                addr += opsz;
                            }
#else // #if SOCKET_EPOLL_EN
                            expectSz = len;
                            while (expectSz > 0) {
                                FD_ZERO(&rfds);
                                FD_SET(rs->psocket_t->connfd, &rfds);

                                tv.tv_sec = 5;
                                tv.tv_usec = 0;

                                if (!socketfailed) {
                                    ret = select(rs->psocket_t->connfd+1, NULL, &rfds, NULL, &tv);
                                    if (ret == -1) {
                                        perror("select()");
                                    } else if (ret) {
                                        opsz = write(rs->psocket_t->connfd, addr, expectSz);
#if LOG_P4_TX_EN
                                        sprintf_f(rs->logs, "nonblock send %d / %d \n", opsz, expectSz);
                                        print_f(rs->plogs, "P4", rs->logs);         
#endif
                                    } else {
                                        socketfailed = 1;
                                    }
                                } else {
                                    opsz = len;
                                }

                                expectSz -= opsz;
                                addr += opsz;
                            }
#endif // #if SOCKET_EPOLL_EN
#else
#if DBG_WIFI_REAL
                            opsz = write(rs->psocket_t->connfd, addr, len);
#else
                            opsz = len;
#endif
#endif  //#if SOCKET_NON_BLOCK_TX
                            totsz += len;
                            //printf("socket tx %d %d\n", rs->psocket_r->connfd, opsz);
#if LOG_P4_TX_EN
                            sprintf_f(rs->logs, "t %d -%d \n", opsz, pi);
                            print_f(rs->plogs, "P4", rs->logs);         
#endif
#if MSP_P4_SAVE_DAT
                            msync(addr, len, MS_SYNC);   
                            fwrite(addr, 1, len, rs->fdat_s[2]);
                            fflush(rs->fdat_s[2]);
#endif
                        } else {
                            sprintf_f(rs->logs, "len:%d \n", len);
                            print_f(rs->plogs, "P4", rs->logs);         
                        }
                    } else {
                        sprintf_f(rs->logs, "socket tx %d %d- wait\n", opsz, pi);
                        print_f(rs->plogs, "P4", rs->logs);         
                        //break;
                    }

                    if (ch != 'D') {
                        ch = 0;
                        rs_ipc_get(rs, &ch, 1);
                    } else {
                        if (len < 0) {
                           sprintf_f(rs->logs, "socket tx %d %d- END\n", opsz, pi);
                           print_f(rs->plogs, "P4", rs->logs);         
                            break;
                        }
                    }
                }
                
                clock_gettime(CLOCK_REALTIME, &rs->tdf[1]);
                sprintf_f(rs->logs, "end at %ld s\n", rs->tdf[1].tv_sec);
                print_f(rs->plogs, "P4", rs->logs);                         
                
                while (ch != 'D') {
                    sprintf_f(rs->logs, "%c clr\n", ch);
                    print_f(rs->plogs, "P4", rs->logs);         
                    ch = 0;
                    rs_ipc_get(rs, &ch, 1);
                }

                tdiff = time_diff(&rs->tdf[0], &rs->tdf[1], 1000);

                flsize = totsz;
                fltime = tdiff;
                sprintf_f(rs->logs, "time:%d us, totsz:%d bytes, thoutghput: %f MBits\n", tdiff, totsz, (flsize*8)/fltime);
                print_f(rs->plogs, "P4", rs->logs);

                rs_ipc_put(rs, "D", 1);
                sprintf_f(rs->logs, "%c socket tx %d - end\n", ch, pi);
                print_f(rs->plogs, "P4", rs->logs);         
#if MSP_P4_SAVE_DAT
                fclose(rs->fdat_s[2]);
#endif
                break;
            }
            else if (cmode == 2) {
                secStr = c->opinfo;
                secLen = p->opinfo;
                datLen = secLen * 512;
                minLen = 16 * 512;

                if (datLen < minLen) {
                    datLen = minLen;
                }

#if SOCKET_EPOLL_EN
                event.data.fd = consfd;
                event.events = EPOLLIN | EPOLLLT;
                ret = epoll_ctl (epollfd, EPOLL_CTL_ADD, consfd, &event);
                if (ret == -1)
                {
                    perror ("epoll_ctl");
                    sprintf_f(rs->logs, "spoll set ctl failed errno: %ds\n", errno);
                    print_f(rs->plogs, "P4", rs->logs);                         
                    break;
                }
#endif

                px = 0;

                len = 0;
                len = ring_buf_get(rs->pcmdTx, &addr);
                while (len <= 0) {
                    usleep(10000);
                    len = ring_buf_get(rs->pcmdTx, &addr);
                }
                acuhk = 0;
#if SOCKET_NON_BLOCK_RX 
#if SOCKET_EPOLL_EN
                if (!socketfailed) {
                    nfds = epoll_wait (epollfd, events, MAX_EVENTS, 5000);
                    if (nfds < 0) {
                        perror("epoll_wait");
                        sprintf_f(rs->logs, "nonblock read %d / %d failed, errno: %d\n", opsz, len, errno);
                        print_f(rs->plogs, "P4", rs->logs);         
                        break;
                    } else if (nfds == 0) {
                        socketfailed = 1;
                    } else {
                        opsz = read(consfd, addr, len);
#if LOG_P4_TX_EN
                        sprintf_f(rs->logs, "epoll nonblock read %d / %d, n: %d\n", opsz, len, nfds);
                        print_f(rs->plogs, "P4", rs->logs);         
#endif
                    }
                } else {
                    opsz = len;
                }
#else // #if SOCKET_EPOLL_EN
                FD_ZERO(&rfds);
                FD_SET(rs->psocket_t->connfd, &rfds);

                tv.tv_sec = 5;
                tv.tv_usec = 0;

                if (!socketfailed) {
                    ret = select(rs->psocket_t->connfd+1, &rfds, NULL, NULL, &tv);
                    if (ret == -1) {
                        perror("select()");
                    } else if (ret) {
                        opsz = read(rs->psocket_t->connfd, addr, len);
#if LOG_P4_TX_EN
                        sprintf_f(rs->logs, "nonblock read %d / %d \n", opsz, len);
                        print_f(rs->plogs, "P4", rs->logs);         
#endif

                    } else {
                        socketfailed = 1;
                    }
                } else {
                    opsz = len;
                }
#endif // #if SOCKET_EPOLL_EN
#else
                opsz = read(rs->psocket_t->connfd, addr, len);
#endif
                while (opsz <= 0) {
                    //sprintf_f(rs->logs, "[wait] socket receive %d/%d bytes from %d\n", px, opsz, len, rs->psocket_t->connfd);
                    //print_f(rs->plogs, "P4", rs->logs);
#if SOCKET_NON_BLOCK_RX
#if SOCKET_EPOLL_EN
                    if (!socketfailed) {
                        nfds = epoll_wait (epollfd, events, MAX_EVENTS, 5000);
                        if (nfds < 0) {
                            perror("epoll_wait");
                            sprintf_f(rs->logs, "nonblock read %d / %d failed, errno: %d\n", opsz, len, errno);
                            print_f(rs->plogs, "P4", rs->logs);         
                            break;
                        } else if (nfds == 0) {
                            socketfailed = 1;
                        } else {
                            opsz = read(consfd, addr, len);
#if LOG_P4_TX_EN
                            sprintf_f(rs->logs, "epoll nonblock read %d / %d, n: %d\n", opsz, len, nfds);
                            print_f(rs->plogs, "P4", rs->logs);         
#endif
                        }
                    } else {
                        opsz = len;
                    }
#else // #if SOCKET_EPOLL_EN
                    FD_ZERO(&rfds);
                    FD_SET(rs->psocket_t->connfd, &rfds);
                    tv.tv_sec = 5;
                    tv.tv_usec = 0;
                    if (!socketfailed) {
                        ret = select(rs->psocket_t->connfd+1, &rfds, NULL, NULL, &tv);
                        if (ret == -1) {
                            perror("select()");
                        } else if (ret) {
                            opsz = read(rs->psocket_t->connfd, addr, len);
#if LOG_P4_TX_EN
                            sprintf_f(rs->logs, "nonblock read %d / %d \n", opsz, len);
                            print_f(rs->plogs, "P4", rs->logs);         
#endif
                        } else {
                            socketfailed = 1;
                        }
                    } else {
                        opsz = len;
                    }
#endif // #if SOCKET_EPOLL_EN
#else
                    opsz = read(rs->psocket_t->connfd, addr, len);
#endif
                }

                addr += opsz;
                acuhk += opsz;
                while ((opsz < len) && (opsz > 0)) {
                    len = len - opsz;

                    errtor = 0;
#if SOCKET_NON_BLOCK_RX 
#if SOCKET_EPOLL_EN
                    if (!socketfailed) {
                        nfds = epoll_wait (epollfd, events, MAX_EVENTS, 5000);
                        if (nfds < 0) {
                            perror("epoll_wait");
                            sprintf_f(rs->logs, "nonblock read %d / %d failed, errno: %d\n", opsz, len, errno);
                            print_f(rs->plogs, "P4", rs->logs);         
                            break;
                        } else if (nfds == 0) {
                            socketfailed = 1;
                        } else {
                            opsz = read(consfd, addr, len);
#if LOG_P4_TX_EN
                            sprintf_f(rs->logs, "epoll nonblock read %d / %d, n: %d\n", opsz, len, nfds);
                            print_f(rs->plogs, "P4", rs->logs);         
#endif
                        }
                    } else {
                        opsz = len;
                    }
#else // #if SOCKET_EPOLL_EN
                    FD_ZERO(&rfds);
                    FD_SET(rs->psocket_t->connfd, &rfds);
                    tv.tv_sec = 5;
                    tv.tv_usec = 0;
                    if (!socketfailed) {
                        ret = select(rs->psocket_t->connfd+1, &rfds, NULL, NULL, &tv);
                        if (ret == -1) {
                            perror("select()");
                        } else if (ret) {
                            opsz = read(rs->psocket_t->connfd, addr, len);
#if LOG_P4_TX_EN
                            sprintf_f(rs->logs, "nonblock read %d / %d \n", opsz, len);
                            print_f(rs->plogs, "P4", rs->logs);         
#endif             
                        } else {
                            socketfailed = 1;
                        }
                    } else {
                        opsz = len;
                    }
#endif // #if SOCKET_EPOLL_EN
#else
                    opsz = read(rs->psocket_t->connfd, addr, len);
#endif
                    while (opsz <= 0) {
                        if (errtor > 3) break;
#if SOCKET_NON_BLOCK_RX 
#if SOCKET_EPOLL_EN
                        if (!socketfailed) {
                            nfds = epoll_wait (epollfd, events, MAX_EVENTS, 5000);
                            if (nfds < 0) {
                                perror("epoll_wait");
                                sprintf_f(rs->logs, "nonblock read %d / %d failed, errno: %d\n", opsz, len, errno);
                                print_f(rs->plogs, "P4", rs->logs);         
                                break;
                            } else if (nfds == 0) {
                                socketfailed = 1;
                            } else {
                                opsz = read(consfd, addr, len);
#if LOG_P4_TX_EN
                                sprintf_f(rs->logs, "epoll nonblock read %d / %d, n: %d\n", opsz, len, nfds);
                                print_f(rs->plogs, "P4", rs->logs);         
#endif
                            }
                        } else {
                            opsz = len;
                        }
#else // #if SOCKET_EPOLL_EN
                        FD_ZERO(&rfds);
                        FD_SET(rs->psocket_t->connfd, &rfds);
                        tv.tv_sec = 5;
                        tv.tv_usec = 0;
                        if (!socketfailed) {
                            ret = select(rs->psocket_t->connfd+1, &rfds, NULL, NULL, &tv);
                            if (ret == -1) {
                                perror("select()");
                            } else if (ret) {
                                opsz = read(rs->psocket_t->connfd, addr, len);
#if LOG_P4_TX_EN
                                sprintf_f(rs->logs, "nonblock read %d / %d \n", opsz, len);
                                print_f(rs->plogs, "P4", rs->logs);         
#endif
                            } else {
                                socketfailed = 1;
                            }
                        } else {
                            opsz = len;
                        }
#endif // #if SOCKET_EPOLL_EN
#else
                        opsz = read(rs->psocket_t->connfd, addr, len);
#endif
                        errtor ++;
                    }

                    addr += opsz;
                    acuhk += opsz;
                }
                
                //sprintf_f(rs->logs, "[%d] socket receive %d/%d bytes from %d, n:%d\n", px, acuhk, len, rs->psocket_t->connfd, n);
                //print_f(rs->plogs, "P4", rs->logs);
                px++;
                ring_buf_prod(rs->pcmdTx);
                rs_ipc_put(rs, "c", 1);

                if (opsz >= 0) {
                while (1) {
                    len = 0;
                    len = ring_buf_get(rs->pcmdTx, &addr);
                    while (len <= 0) {
                        usleep(10000);
                        len = ring_buf_get(rs->pcmdTx, &addr);
                    }

                    acuhk = 0;

                    errtor = 0;
#if SOCKET_NON_BLOCK_RX 
#if SOCKET_EPOLL_EN
                    if (!socketfailed) {
                        nfds = epoll_wait (epollfd, events, MAX_EVENTS, 5000);
                        if (nfds < 0) {
                            perror("epoll_wait");
                            sprintf_f(rs->logs, "nonblock read %d / %d failed, errno: %d\n", opsz, len, errno);
                            print_f(rs->plogs, "P4", rs->logs);         
                            break;
                        } else if (nfds == 0) {
                            socketfailed = 1;
                        } else {
                            opsz = read(consfd, addr, len);
#if LOG_P4_TX_EN
                            sprintf_f(rs->logs, "epoll nonblock read %d / %d, n: %d\n", opsz, len, nfds);
                            print_f(rs->plogs, "P4", rs->logs);         
#endif
                        }
                    } else {
                        opsz = len;
                    }
#else // #if SOCKET_EPOLL_EN
                    FD_ZERO(&rfds);
                    FD_SET(rs->psocket_t->connfd, &rfds);
                    tv.tv_sec = 5;
                    tv.tv_usec = 0;
                    if (!socketfailed) {
                        ret = select(rs->psocket_t->connfd+1, &rfds, NULL, NULL, &tv);
                        if (ret == -1) {
                            perror("select()");
                        } else if (ret) {
                            opsz = read(rs->psocket_t->connfd, addr, len);
#if LOG_P4_TX_EN
                            sprintf_f(rs->logs, "nonblock read %d / %d \n", opsz, len);
                            print_f(rs->plogs, "P4", rs->logs);         
#endif

                        } else {
                            socketfailed = 1;
                        }
                    } else {
                        opsz = len;
                    }
#endif // #if SOCKET_EPOLL_EN
#else
                    opsz = read(rs->psocket_t->connfd, addr, len);
#endif
                    while (opsz <= 0) {
                        if (errtor > 3) break;
#if SOCKET_NON_BLOCK_RX 
#if SOCKET_EPOLL_EN
                        if (!socketfailed) {
                            nfds = epoll_wait (epollfd, events, MAX_EVENTS, 5000);
                            if (nfds < 0) {
                                perror("epoll_wait");
                                sprintf_f(rs->logs, "nonblock read %d / %d failed, errno: %d\n", opsz, len, errno);
                                print_f(rs->plogs, "P4", rs->logs);         
                                break;
                            } else if (nfds == 0) {
                                socketfailed = 1;
                            } else {
                                opsz = read(consfd, addr, len);
#if LOG_P4_TX_EN
                                sprintf_f(rs->logs, "epoll nonblock read %d / %d, n: %d\n", opsz, len, nfds);
                                print_f(rs->plogs, "P4", rs->logs);         
#endif
                            }
                        } else {
                            opsz = len;
                        }
#else // #if SOCKET_EPOLL_EN
                        FD_ZERO(&rfds);
                        FD_SET(rs->psocket_t->connfd, &rfds);
                        tv.tv_sec = 5;
                        tv.tv_usec = 0;
                        if (!socketfailed) {
                            ret = select(rs->psocket_t->connfd+1, &rfds, NULL, NULL, &tv);
                            if (ret == -1) {
                                perror("select()");
                            } else if (ret) {
                                opsz = read(rs->psocket_t->connfd, addr, len);
#if LOG_P4_TX_EN
                                sprintf_f(rs->logs, "nonblock read %d / %d \n", opsz, len);
                                print_f(rs->plogs, "P4", rs->logs);         
#endif
                            } else {
                                socketfailed = 1;
                            }
                        } else {
                            opsz = len;
                        }
#endif // #if SOCKET_EPOLL_EN
#else
                        opsz = read(rs->psocket_t->connfd, addr, len);
#endif
                        errtor ++;
                    }

                    addr += opsz;
                    acuhk += opsz;
                    while ((opsz < len) && (opsz > 0)) {
                        len = len - opsz;

                        errtor = 0;
#if SOCKET_NON_BLOCK_RX 
#if SOCKET_EPOLL_EN
                        if (!socketfailed) {
                            nfds = epoll_wait (epollfd, events, MAX_EVENTS, 5000);
                            if (nfds < 0) {
                                perror("epoll_wait");
                                sprintf_f(rs->logs, "nonblock read %d / %d failed, errno: %d\n", opsz, len, errno);
                                print_f(rs->plogs, "P4", rs->logs);         
                                break;
                            } else if (nfds == 0) {
                                socketfailed = 1;
                            } else {
                                opsz = read(consfd, addr, len);
#if LOG_P4_TX_EN
                                sprintf_f(rs->logs, "epoll nonblock read %d / %d, n: %d\n", opsz, len, nfds);
                                print_f(rs->plogs, "P4", rs->logs);         
#endif
                            }
                        } else {
                            opsz = len;
                        }
#else // #if SOCKET_EPOLL_EN
                        FD_ZERO(&rfds);
                        FD_SET(rs->psocket_t->connfd, &rfds);
                        tv.tv_sec = 5;
                        tv.tv_usec = 0;
                        if (!socketfailed) {
                            ret = select(rs->psocket_t->connfd+1, &rfds, NULL, NULL, &tv);
                            if (ret == -1) {
                                perror("select()");
                            } else if (ret) {
                                opsz = read(rs->psocket_t->connfd, addr, len);
#if LOG_P4_TX_EN
                                sprintf_f(rs->logs, "nonblock read %d / %d \n", opsz, len);
                                print_f(rs->plogs, "P4", rs->logs);         
#endif
                            } else {
                                socketfailed = 1;
                            }
                        } else {
                            opsz = len;
                        }
#endif // #if SOCKET_EPOLL_EN
#else
                        opsz = read(rs->psocket_t->connfd, addr, len);
#endif
                        while (opsz <= 0) {
                            if (errtor > 3) break;
#if SOCKET_NON_BLOCK_RX 
#if SOCKET_EPOLL_EN
                            if (!socketfailed) {
                                nfds = epoll_wait (epollfd, events, MAX_EVENTS, 5000);
                                if (nfds < 0) {
                                    perror("epoll_wait");
                                    sprintf_f(rs->logs, "nonblock read %d / %d failed, errno: %d\n", opsz, len, errno);
                                    print_f(rs->plogs, "P4", rs->logs);         
                                    break;
                                } else if (nfds == 0) {
                                    socketfailed = 1;
                                } else {
                                    opsz = read(consfd, addr, len);
#if LOG_P4_TX_EN
                                    sprintf_f(rs->logs, "epoll nonblock read %d / %d, n: %d\n", opsz, len, nfds);
                                    print_f(rs->plogs, "P4", rs->logs);         
#endif
                                }
                            } else {
                                opsz = len;
                            }
#else // #if SOCKET_EPOLL_EN
                            FD_ZERO(&rfds);
                            FD_SET(rs->psocket_t->connfd, &rfds);
                            tv.tv_sec = 5;
                            tv.tv_usec = 0;
                            if (!socketfailed) {
                                ret = select(rs->psocket_t->connfd+1, &rfds, NULL, NULL, &tv);
                                if (ret == -1) {
                                    perror("select()");
                                } else if (ret) {
                                    opsz = read(rs->psocket_t->connfd, addr, len);
#if LOG_P4_TX_EN
                                    sprintf_f(rs->logs, "nonblock read %d / %d \n", opsz, len);
                                    print_f(rs->plogs, "P4", rs->logs);         
#endif
                                } else {
                                    socketfailed = 1;
                                }
                            } else {
                                opsz = len;
                            }
#endif // #if SOCKET_EPOLL_EN
#else
                            opsz = read(rs->psocket_t->connfd, addr, len);
#endif
                            errtor ++;
                        }

                        addr += opsz;
                        acuhk += opsz;
                    }
                    
                    //sprintf_f(rs->logs, "[%d] socket receive %d/%d bytes from %d n:%d\n", px, acuhk, len, rs->psocket_t->connfd, opsz);
                    //print_f(rs->plogs, "P4", rs->logs);
                    px++;

                    ring_buf_prod(rs->pcmdTx);
                    if (opsz <= 0) break;
                    //shmem_dump(addr, 32);

                    rs_ipc_put(rs, "c", 1);
                }
                }
                ring_buf_set_last(rs->pcmdTx, acuhk);

                sprintf_f(rs->logs, "[%d] socket receive %d/%d bytes end\n", px, opsz, len);
                print_f(rs->plogs, "P4", rs->logs);

                rs_ipc_put(rs, "C", 1);
                if (!pftb->c) {
                    break;
                }
            }
            else if (cmode == 4) {
#if MSP_P4_SAVE_DAT
                ret = file_save_get(&rs->fdat_s[2], "/mnt/mmc2/tx/p4%d.dat");
                if (ret) {
                    sprintf_f(rs->logs, "get tx log data file error - %d, hold here\n", ret);
                    print_f(rs->plogs, "P4", rs->logs);         
                    while(1);
                } else {
                    sprintf_f(rs->logs, "get tx log data file ok - %d, f: %d\n", ret, rs->fdat_s[2]);
                    print_f(rs->plogs, "P4", rs->logs);         
                }
#endif

#if SOCKET_EPOLL_EN
                event.data.fd = consfd;
                event.events = EPOLLOUT | EPOLLLT;
                ret = epoll_ctl (epollfd, EPOLL_CTL_ADD, consfd, &event);
                if (ret == -1)
                {
                    perror ("epoll_ctl");
                    sprintf_f(rs->logs, "spoll set ctl failed errno: %ds\n", errno);
                    print_f(rs->plogs, "P4", rs->logs);                         
                    break;
                }
#endif
                clock_gettime(CLOCK_REALTIME, &rs->tdf[0]);
                totsz = 0;
                pi = 0;

                tlast = dbgShowTimeStamp("_WIFI_0_ BEG",  NULL, rs, 8, "_F_S_");

                while (1) {
                    len = ring_buf_cons(rs->pcmdRx, &addr);

                    #if LOG_P4_TX_EN
                    sprintf_f(rs->logs, "get ring buff len: %d \n", len);
                    print_f(rs->plogs, "P4", rs->logs);         
                    #endif

                    if (len >= 0) {
                        pi++;
                    
                        /* send data to wifi socket */
#if LOG_P4_TX_EN
                        sprintf_f(rs->logs, " %d -%d \n", len, pi);
                        print_f(rs->plogs, "P4", rs->logs);         
#endif
                        if (len != 0) {
                            msync(addr, len, MS_SYNC);

#if SOCKET_NON_BLOCK_TX
#if SOCKET_EPOLL_EN
                            expectSz = len;
                            while (expectSz > 0) {
                                if (!socketfailed) {
                                    nfds = epoll_wait (epollfd, events, MAX_EVENTS, 5000);
                                    if (nfds < 0) {
                                        perror("epoll_wait");
                                        sprintf_f(rs->logs, "nonblock send %d / %d failed, errno: %d\n", opsz, expectSz, errno);
                                        print_f(rs->plogs, "P4", rs->logs);         
                                        break;
                                    } else if (nfds == 0) {
                                        socketfailed = 1;
                                    } else {
                                        opsz = write(consfd, addr, expectSz);
#if LOG_P4_TX_EN
                                        sprintf_f(rs->logs, "epoll nonblock send %d / %d, n: %d\n", opsz, expectSz, nfds);
                                        print_f(rs->plogs, "P4", rs->logs);         
#endif
                                    }
                                } else {
                                    opsz = len;
                                }

                                expectSz -= opsz;
                                addr += opsz;
                            }
#else // #if SOCKET_EPOLL_EN
                            expectSz = len;
                            while (expectSz > 0) {
                                FD_ZERO(&rfds);
                                FD_SET(rs->psocket_t->connfd, &rfds);
                                tv.tv_sec = 5;
                                tv.tv_usec = 0;

                                if (!socketfailed) {
                                    ret = select(rs->psocket_t->connfd+1, NULL, &rfds, NULL, &tv);
                                    if (ret == -1) {
                                        perror("select()");
                                    } else if (ret) {
                                        opsz = write(rs->psocket_t->connfd, addr, expectSz);
#if LOG_P4_TX_EN
                                        sprintf_f(rs->logs, "nonblock send %d / %d \n", opsz, expectSz);
                                        print_f(rs->plogs, "P4", rs->logs);         
#endif
                                    } else {
                                        socketfailed = 1;
                                    }
                                } else {
                                    opsz = len;
                                }

                                expectSz -= opsz;
                                addr += opsz;
                            }
#endif // #if SOCKET_EPOLL_EN
#else
                            #if DBG_WIFI_REAL
                            opsz = write(rs->psocket_t->connfd, addr, len);
                            #else
                            opsz = len;
                            #endif
#endif // #if SOCKET_NON_BLOCK_RX

                            //sprintf_f(rs->logs, "tx %d -%d \n", opsz, pi);
                            //print_f(rs->plogs, "P4", rs->logs);      
#if MSP_P4_SAVE_DAT
                            msync(addr, len, MS_SYNC);   
                            fwrite(addr, 1, len, rs->fdat_s[2]);
                            fflush(rs->fdat_s[2]);
#endif                            
                            totsz += len;
                        }
                        else {
                            sprintf_f(rs->logs, "len:%d \n", len);
                            print_f(rs->plogs, "P4", rs->logs);         
                        }
                        
                        rs_ipc_put(rs, "n", 1);
                    }
                    else {
                        sprintf_f(rs->logs, "%c socket tx %d %d %d- end\n", ch, rs->psocket_t->connfd, opsz, pi);
                        print_f(rs->plogs, "P4", rs->logs);         
                        break;
                    }

                    if (ch != 'N') {
                        ch = 0;
                        rs_ipc_get(rs, &ch, 1);
                    }
                }

                clock_gettime(CLOCK_REALTIME, &rs->tdf[1]);

                tdiff = time_diff(&rs->tdf[0], &rs->tdf[1], 1000);

                flsize = totsz;
                fltime = tdiff;
                sprintf_f(rs->logs, "time:%d us, totsz:%d bytes, thoutghput: %f MBits\n", tdiff, totsz, (flsize*8)/fltime);
                print_f(rs->plogs, "P4", rs->logs);

                while (ch != 'N') {
                    sprintf_f(rs->logs, "%c clr\n", ch);
                    print_f(rs->plogs, "P4", rs->logs);         
                    ch = 0;
                    rs_ipc_get(rs, &ch, 1);
                }

                sprintf(rs->logs, "_WIFI_0_ END %d bytes ", totsz);
                tdiff = dbgShowTimeStamp(rs->logs, NULL, rs, 8, "_F_E_");

                fltime = (CFLOAT)(tdiff - tlast);
                if (fltime == 0) {
                    thrput = 0;
                } else {
                    thrput = (CFLOAT) totsz /fltime;
                }

                sprintf(rs->logs, "_WIFI_0_ throughput: %.2f MB/sec ", thrput);
                dbgShowTimeStamp(rs->logs, NULL, rs, 8, "done");
                
                rs_ipc_put(rs, "N", 1);
                sprintf_f(rs->logs, "%c socket tx %d - end\n", ch, pi);
                print_f(rs->plogs, "P4", rs->logs);         
#if MSP_P4_SAVE_DAT
                fclose(rs->fdat_s[2]);
#endif
                if (!pftb->c) {
                    break;
                }
            }
            else if (cmode == 5) {
#if MSP_P4_SAVE_DAT
                ret = file_save_get(&rs->fdat_s[2], "/mnt/mmc2/tx/p4%d.dat");
                if (ret) {
                    sprintf_f(rs->logs, "get tx log data file error - %d, hold here\n", ret);
                    print_f(rs->plogs, "P4", rs->logs);         
                    while(1);
                } else {
                    sprintf_f(rs->logs, "get tx log data file ok - %d, f: %d\n", ret, rs->fdat_s[2]);
                    print_f(rs->plogs, "P4", rs->logs);         
                }
#endif
                secStr = c->opinfo;
                secLen = p->opinfo;
                datLen = secLen * 512;
                minLen = 16 * 512;

                sprintf_f(rs->logs, "ready for tx len: %d/%d\n", datLen, minLen);
                print_f(rs->plogs, "P4", rs->logs);         

                if (datLen < minLen) {
                    datLen = minLen;
                }
                
#if SOCKET_EPOLL_EN
                event.data.fd = consfd;
                event.events = EPOLLIN | EPOLLLT;
                ret = epoll_ctl (epollfd, EPOLL_CTL_ADD, consfd, &event);
                if (ret == -1)
                {
                    perror ("epoll_ctl");
                    sprintf_f(rs->logs, "spoll set ctl failed errno: %ds\n", errno);
                    print_f(rs->plogs, "P4", rs->logs);                         
                    break;
                }
#endif

                tlast = dbgShowTimeStamp("_WIFI_0_ BEGIN",  NULL, rs, 8, "_F_S_");
                totsz = 0;
                
                px = 0;

                len = 0;
                len = ring_buf_get(rs->pcmdTx, &addr);
                while (len <= 0) {
                    usleep(10000);
                    len = ring_buf_get(rs->pcmdTx, &addr);
                }
                
                if (len > datLen) {
                    len = datLen;
                    datLen = 0;
                } else {
                    datLen = datLen - len;
                }

                pre = addr;
                acuhk = 0;

                rs_ipc_put(rs, "h", 1);
#if SOCKET_NON_BLOCK_RX 
#if SOCKET_EPOLL_EN
                if (!socketfailed) {
                    nfds = epoll_wait (epollfd, events, MAX_EVENTS, 5000);
                    if (nfds < 0) {
                        perror("epoll_wait");
                        sprintf_f(rs->logs, "nonblock read %d / %d failed, errno: %d\n", opsz, len, errno);
                        print_f(rs->plogs, "P4", rs->logs);         
                        break;
                    } else if (nfds == 0) {
                        socketfailed = 1;
                    } else {
                        opsz = read(consfd, addr, len);
#if LOG_P4_TX_EN
                        sprintf_f(rs->logs, "epoll nonblock read %d / %d, n: %d\n", opsz, len, nfds);
                        print_f(rs->plogs, "P4", rs->logs);         
#endif
                    }
                } else {
                    opsz = len;
                }
#else // #if SOCKET_EPOLL_EN
                FD_ZERO(&rfds);
                FD_SET(rs->psocket_t->connfd, &rfds);
                tv.tv_sec = 5;
                tv.tv_usec = 0;
                if (!socketfailed) {
                    ret = select(rs->psocket_t->connfd+1, &rfds, NULL, NULL, &tv);
                    if (ret == -1) {
                        perror("select()");
                    } else if (ret) {
                        opsz = read(rs->psocket_t->connfd, addr, len);
#if LOG_P4_TX_EN
                        sprintf_f(rs->logs, "nonblock read %d / %d \n", opsz, len);
                        print_f(rs->plogs, "P4", rs->logs);         
#endif
                    } else {
                        socketfailed = 1;
                    }
                } else {
                    opsz = len;
                }
#endif // #if SOCKET_EPOLL_EN
#else
                opsz = read(rs->psocket_t->connfd, addr, len);
#endif
                while (opsz <= 0) {
                    rs_ipc_put(rs, "h", 1);
                    sprintf_f(rs->logs, "[wait] %d\n", opsz);
                    print_f(rs->plogs, "P4", rs->logs);
#if SOCKET_NON_BLOCK_RX 
#if SOCKET_EPOLL_EN
                    if (!socketfailed) {
                        nfds = epoll_wait (epollfd, events, MAX_EVENTS, 5000);
                        if (nfds < 0) {
                            perror("epoll_wait");
                            sprintf_f(rs->logs, "nonblock read %d / %d failed, errno: %d\n", opsz, len, errno);
                            print_f(rs->plogs, "P4", rs->logs);         
                            break;
                        } else if (nfds == 0) {
                            socketfailed = 1;
                        } else {
                            opsz = read(consfd, addr, len);
#if LOG_P4_TX_EN
                            sprintf_f(rs->logs, "epoll nonblock read %d / %d, n: %d\n", opsz, len, nfds);
                            print_f(rs->plogs, "P4", rs->logs);         
#endif
                        }
                    } else {
                        opsz = len;
                    }
#else // #if SOCKET_EPOLL_EN
                    FD_ZERO(&rfds);
                    FD_SET(rs->psocket_t->connfd, &rfds);
                    tv.tv_sec = 5;
                    tv.tv_usec = 0;
                    if (!socketfailed) {
                        ret = select(rs->psocket_t->connfd+1, &rfds, NULL, NULL, &tv);
                        if (ret == -1) {
                            perror("select()");
                        } else if (ret) {
                            opsz = read(rs->psocket_t->connfd, addr, len);
#if LOG_P4_TX_EN
                            sprintf_f(rs->logs, "nonblock read %d / %d \n", opsz, len);
                            print_f(rs->plogs, "P4", rs->logs);         
#endif
                        } else {
                            socketfailed = 1;
                        }
                    } else {
                        opsz = len;
                    }
#endif // #if SOCKET_EPOLL_EN
#else
                    opsz = read(rs->psocket_t->connfd, addr, len);
#endif
                }

                addr += opsz;
                acuhk += opsz;
                totsz += opsz;
                while ((opsz < len) && (opsz > 0)) {
                    len = len - opsz;

                    errtor = 0;
#if SOCKET_NON_BLOCK_RX 
#if SOCKET_EPOLL_EN
                    if (!socketfailed) {
                        nfds = epoll_wait (epollfd, events, MAX_EVENTS, 5000);
                        if (nfds < 0) {
                            perror("epoll_wait");
                            sprintf_f(rs->logs, "nonblock read %d / %d failed, errno: %d\n", opsz, len, errno);
                            print_f(rs->plogs, "P4", rs->logs);         
                            break;
                        } else if (nfds == 0) {
                            socketfailed = 1;
                        } else {
                            opsz = read(consfd, addr, len);
#if LOG_P4_TX_EN
                            sprintf_f(rs->logs, "epoll nonblock read %d / %d, n: %d\n", opsz, len, nfds);
                            print_f(rs->plogs, "P4", rs->logs);         
#endif
                        }
                    } else {
                        opsz = len;
                    }
#else // #if SOCKET_EPOLL_EN
                    FD_ZERO(&rfds);
                    FD_SET(rs->psocket_t->connfd, &rfds);
                    tv.tv_sec = 5;
                    tv.tv_usec = 0;
                    if (!socketfailed) {
                        ret = select(rs->psocket_t->connfd+1, &rfds, NULL, NULL, &tv);
                        if (ret == -1) {
                            perror("select()");
                        } else if (ret) {
                            opsz = read(rs->psocket_t->connfd, addr, len);
#if LOG_P4_TX_EN
                            sprintf_f(rs->logs, "nonblock read %d / %d \n", opsz, len);
                            print_f(rs->plogs, "P4", rs->logs);         
#endif
                        } else {
                            socketfailed = 1;
                        }
                    } else {
                        opsz = len;
                    }
#endif // #if SOCKET_EPOLL_EN
#else
                    opsz = read(rs->psocket_t->connfd, addr, len);
#endif
                    while (opsz <= 0) {
                        if (errtor > 3) break;
#if SOCKET_NON_BLOCK_RX 
#if SOCKET_EPOLL_EN
                        if (!socketfailed) {
                            nfds = epoll_wait (epollfd, events, MAX_EVENTS, 5000);
                            if (nfds < 0) {
                                perror("epoll_wait");
                                sprintf_f(rs->logs, "nonblock read %d / %d failed, errno: %d\n", opsz, len, errno);
                                print_f(rs->plogs, "P4", rs->logs);         
                                break;
                            } else if (nfds == 0) {
                                socketfailed = 1;
                            } else {
                                opsz = read(consfd, addr, len);
#if LOG_P4_TX_EN
                                sprintf_f(rs->logs, "epoll nonblock read %d / %d, n: %d\n", opsz, len, nfds);
                                print_f(rs->plogs, "P4", rs->logs);         
#endif
                            }
                        } else {
                            opsz = len;
                        }
#else // #if SOCKET_EPOLL_EN
                        FD_ZERO(&rfds);
                        FD_SET(rs->psocket_t->connfd, &rfds);
                        tv.tv_sec = 5;
                        tv.tv_usec = 0;
                        if (!socketfailed) {
                            ret = select(rs->psocket_t->connfd+1, &rfds, NULL, NULL, &tv);
                            if (ret == -1) {
                                perror("select()");
                            } else if (ret) {
                                opsz = read(rs->psocket_t->connfd, addr, len);
#if LOG_P4_TX_EN
                                sprintf_f(rs->logs, "nonblock read %d / %d \n", opsz, len);
                                print_f(rs->plogs, "P4", rs->logs);         
#endif
                            } else {
                                socketfailed = 1;
                            }
                        } else {
                            opsz = len;
                        }
#endif // #if SOCKET_EPOLL_EN
#else
                        opsz = read(rs->psocket_t->connfd, addr, len);
#endif
                        errtor ++;
                    }

                    addr += opsz;
                    acuhk += opsz;
                    totsz += opsz;
                }

                sprintf_f(rs->logs, "socket rx %d\n", acuhk);
                print_f(rs->plogs, "P4", rs->logs);

                
                if (datLen == 0) {
#if MSP_P4_SAVE_DAT 
                    msync(addr, len, MS_SYNC);   
                    fwrite(pre, 1, acuhk, rs->fdat_s[2]);
                    fflush(rs->fdat_s[2]);
#endif
                    ring_buf_prod(rs->pcmdTx);
                    ring_buf_set_last(rs->pcmdTx, acuhk);
                } else {
                    px++;
                    ring_buf_prod(rs->pcmdTx);
#if MSP_P4_SAVE_DAT 
                    msync(addr, len, MS_SYNC);   
                    fwrite(pre, 1, acuhk, rs->fdat_s[2]);
                    fflush(rs->fdat_s[2]);
#endif
                }
                rs_ipc_put(rs, "u", 1);
                
                if (datLen > 0) {
                while (1) {
                    len = 0;
                    len = ring_buf_get(rs->pcmdTx, &addr);
                    while (len <= 0) {
                        rs_ipc_put(rs, "h", 1);
                        usleep(10000);
                        len = ring_buf_get(rs->pcmdTx, &addr);
                    }

                    if (len > datLen) {
                        len = datLen;
                        datLen = 0;
                    } else {
                        datLen = datLen - len;
                    }

                    acuhk = 0;
                    pre = addr;

                    errtor = 0;
#if SOCKET_NON_BLOCK_RX 
#if SOCKET_EPOLL_EN
                    if (!socketfailed) {
                        nfds = epoll_wait (epollfd, events, MAX_EVENTS, 5000);
                        if (nfds < 0) {
                            perror("epoll_wait");
                            sprintf_f(rs->logs, "nonblock read %d / %d failed, errno: %d\n", opsz, len, errno);
                            print_f(rs->plogs, "P4", rs->logs);         
                            break;
                        } else if (nfds == 0) {
                            socketfailed = 1;
                        } else {
                            opsz = read(consfd, addr, len);
#if LOG_P4_TX_EN
                            sprintf_f(rs->logs, "epoll nonblock read %d / %d, n: %d\n", opsz, len, nfds);
                            print_f(rs->plogs, "P4", rs->logs);         
#endif
                        }
                    } else {
                        opsz = len;
                    }
#else // #if SOCKET_EPOLL_EN
                    FD_ZERO(&rfds);
                    FD_SET(rs->psocket_t->connfd, &rfds);
                    tv.tv_sec = 5;
                    tv.tv_usec = 0;
                    if (!socketfailed) {
                        ret = select(rs->psocket_t->connfd+1, &rfds, NULL, NULL, &tv);
                        if (ret == -1) {
                            perror("select()");
                        } else if (ret) {
                            opsz = read(rs->psocket_t->connfd, addr, len);
#if LOG_P4_TX_EN
                            sprintf_f(rs->logs, "nonblock read %d / %d \n", opsz, len);
                            print_f(rs->plogs, "P4", rs->logs);         
#endif
                        } else {
                            socketfailed = 1;
                        }
                    } else {
                        opsz = len;
                    }
#endif // #if SOCKET_EPOLL_EN
#else
                    opsz = read(rs->psocket_t->connfd, addr, len);
#endif
                    while (opsz <= 0) {
                        rs_ipc_put(rs, "h", 1);
                        sprintf_f(rs->logs, "[wait] %d\n", opsz);
                        print_f(rs->plogs, "P4", rs->logs);

                        if (errtor > 3) break;
#if SOCKET_NON_BLOCK_RX 
#if SOCKET_EPOLL_EN
                        if (!socketfailed) {
                            nfds = epoll_wait (epollfd, events, MAX_EVENTS, 5000);
                            if (nfds < 0) {
                                perror("epoll_wait");
                                sprintf_f(rs->logs, "nonblock read %d / %d failed, errno: %d\n", opsz, len, errno);
                                print_f(rs->plogs, "P4", rs->logs);         
                                break;
                            } else if (nfds == 0) {
                                socketfailed = 1;
                            } else {
                                opsz = read(consfd, addr, len);
#if LOG_P4_TX_EN
                                sprintf_f(rs->logs, "epoll nonblock read %d / %d, n: %d\n", opsz, len, nfds);
                                print_f(rs->plogs, "P4", rs->logs);         
#endif
                            }
                        } else {
                            opsz = len;
                        }
#else // #if SOCKET_EPOLL_EN
                        FD_ZERO(&rfds);
                        FD_SET(rs->psocket_t->connfd, &rfds);
                        tv.tv_sec = 5;
                        tv.tv_usec = 0;
                        if (!socketfailed) {
                            ret = select(rs->psocket_t->connfd+1, &rfds, NULL, NULL, &tv);
                            if (ret == -1) {
                                perror("select()");
                            } else if (ret) {
                                opsz = read(rs->psocket_t->connfd, addr, len);
#if LOG_P4_TX_EN
                                sprintf_f(rs->logs, "nonblock read %d / %d \n", opsz, len);
                                print_f(rs->plogs, "P4", rs->logs);         
#endif
                            } else {
                                socketfailed = 1;
                            }
                        } else {
                            opsz = len;
                        }
#endif // #if SOCKET_EPOLL_EN
#else
                        opsz = read(rs->psocket_t->connfd, addr, len);
#endif
                        errtor ++;
                    }

                    addr += opsz;
                    acuhk += opsz;
                    totsz += opsz;
                    
                    while ((opsz < len) && (opsz > 0)) {
                        len = len - opsz;

                        errtor = 0;
#if SOCKET_NON_BLOCK_RX 
#if SOCKET_EPOLL_EN
                        if (!socketfailed) {
                            nfds = epoll_wait (epollfd, events, MAX_EVENTS, 5000);
                            if (nfds < 0) {
                                perror("epoll_wait");
                                sprintf_f(rs->logs, "nonblock read %d / %d failed, errno: %d\n", opsz, len, errno);
                                print_f(rs->plogs, "P4", rs->logs);         
                                break;
                            } else if (nfds == 0) {
                                socketfailed = 1;
                            } else {
                                opsz = read(consfd, addr, len);
#if LOG_P4_TX_EN
                                sprintf_f(rs->logs, "epoll nonblock read %d / %d, n: %d\n", opsz, len, nfds);
                                print_f(rs->plogs, "P4", rs->logs);         
#endif
                            }
                        } else {
                            opsz = len;
                        }
#else // #if SOCKET_EPOLL_EN
                        FD_ZERO(&rfds);
                        FD_SET(rs->psocket_t->connfd, &rfds);
                        tv.tv_sec = 5;
                        tv.tv_usec = 0;
                        if (!socketfailed) {
                            ret = select(rs->psocket_t->connfd+1, &rfds, NULL, NULL, &tv);
                            if (ret == -1) {
                                perror("select()");
                            } else if (ret) {
                                opsz = read(rs->psocket_t->connfd, addr, len);
#if LOG_P4_TX_EN
                                sprintf_f(rs->logs, "nonblock read %d / %d \n", opsz, len);
                                print_f(rs->plogs, "P4", rs->logs);         
#endif
                            } else {
                                socketfailed = 1;
                            }
                        } else {
                            opsz = len;
                        }
#endif // #if SOCKET_EPOLL_EN
#else
                        opsz = read(rs->psocket_t->connfd, addr, len);
#endif
                        while (opsz <= 0) {
                            rs_ipc_put(rs, "h", 1);
                            sprintf_f(rs->logs, "[wait] %d\n", opsz);
                            print_f(rs->plogs, "P4", rs->logs);

                            if (errtor > 3) break;
#if SOCKET_NON_BLOCK_RX 
#if SOCKET_EPOLL_EN
                            if (!socketfailed) {
                                nfds = epoll_wait (epollfd, events, MAX_EVENTS, 5000);
                                if (nfds < 0) {
                                    perror("epoll_wait");
                                    sprintf_f(rs->logs, "nonblock read %d / %d failed, errno: %d\n", opsz, len, errno);
                                    print_f(rs->plogs, "P4", rs->logs);         
                                    break;
                                } else if (nfds == 0) {
                                    socketfailed = 1;
                                } else {
                                    opsz = read(consfd, addr, len);
#if LOG_P4_TX_EN
                                    sprintf_f(rs->logs, "epoll nonblock read %d / %d, n: %d\n", opsz, len, nfds);
                                    print_f(rs->plogs, "P4", rs->logs);         
#endif
                                }
                            } else {
                                opsz = len;
                            }
#else // #if SOCKET_EPOLL_EN
                            FD_ZERO(&rfds);
                            FD_SET(rs->psocket_t->connfd, &rfds);
                            tv.tv_sec = 5;
                            tv.tv_usec = 0;
                            if (!socketfailed) {
                                ret = select(rs->psocket_t->connfd+1, &rfds, NULL, NULL, &tv);
                                if (ret == -1) {
                                    perror("select()");
                                } else if (ret) {
                                    opsz = read(rs->psocket_t->connfd, addr, len);
#if LOG_P4_TX_EN
                                    sprintf_f(rs->logs, "nonblock read %d / %d \n", opsz, len);
                                    print_f(rs->plogs, "P4", rs->logs);         
#endif
                                } else {
                                    socketfailed = 1;
                                }
                            } else {
                                opsz = len;
                            }
#endif // #if SOCKET_EPOLL_EN
#else
                            opsz = read(rs->psocket_t->connfd, addr, len);
#endif
                            errtor ++;
                        }

                        addr += opsz;
                        acuhk += opsz;
                        totsz += opsz;
                    }
                    
                    sprintf_f(rs->logs, "socket rx %d\n", acuhk);
                    print_f(rs->plogs, "P4", rs->logs);
                    px++;
#if MSP_P4_SAVE_DAT 
                    msync(addr, len, MS_SYNC);   
                    fwrite(pre, 1, acuhk, rs->fdat_s[2]);
                    fflush(rs->fdat_s[2]);
#endif
                    
                    ring_buf_prod(rs->pcmdTx);

                    if (datLen == 0) break;
                    //if (opsz <= 0) break;
                    //shmem_dump(addr, 32);

                    rs_ipc_put(rs, "u", 1);
                }
                }

#if MSP_P4_SAVE_DAT
                fclose(rs->fdat_s[2]);
#endif

                sprintf(rs->logs, "_WIFI_0_ END %d bytes ", totsz);
                tdiff = dbgShowTimeStamp(rs->logs, NULL, rs, 8, "_F_E_");

                fltime = (CFLOAT)(tdiff - tlast);
                if (fltime == 0) {
                    thrput = 0;
                } else {
                    thrput = (CFLOAT) totsz /fltime;
                }
                sprintf(rs->logs, "_WIFI_0_ throughput: %.2f MB/sec ", thrput);
                dbgShowTimeStamp(rs->logs, NULL, rs, 8, "done");
                
                ring_buf_set_last(rs->pcmdTx, acuhk);

                sprintf_f(rs->logs, "[%d] socket receive %d/%d bytes end\n", px, opsz, len);
                print_f(rs->plogs, "P4", rs->logs);

                rs_ipc_put(rs, "U", 1);
                if (!pftb->c) {
                    sprintf_f(rs->logs, "break connection!! \n");
                    print_f(rs->plogs, "P4", rs->logs);

                    break;
                }
            }
            else {
                sprintf_f(rs->logs, "cmode: %d - 7\n", cmode);
                print_f(rs->plogs, "P4", rs->logs);
                error_handle(rs->logs, 4702);
            }
        }

        socketEnd:
        close(rs->psocket_t->connfd);
        rs->psocket_t->connfd = 0;
    }

    p4_end(rs);
    return 0;
}

static int p5(struct procRes_s *rs, struct procRes_s *rcmd)
{
    int px, pi, size, opsz, acusz, len, acu;
    int ret, n, num, hd, be, ed, ln, fg, cltport=0;
    char ch, *recvbuf, *addr, *sendbuf, *cltaddr;
    unsigned char opcode=0, param=0, flag = 0;
    char msg[256] = "boot";
    char tgr[8] = "tgr";

    prctl(PR_SET_NAME, "msp-p5");
    //sprintf(argv[0], "msp-p5-socket5000");
    
    sprintf_f(rs->logs, "p5\n");
    print_f(rs->plogs, "P5", rs->logs);

    p5_init(rs, rcmd);
    // wait for ch from p0
    // in charge of socket recv

    addr = aspMemalloc(1024, 8);
    if (!addr) {
        sprintf_f(rs->logs, "p5 addr alloc failed! \n");
        print_f(rs->plogs, "P5", rs->logs);
        return (-1);
    }
    
    sendbuf = aspMemalloc(OUT_BUFF_LEN, 8);
    if (!sendbuf) {
        sprintf_f(rs->logs, "p5 sendbuf alloc failed! \n");
        print_f(rs->plogs, "P5", rs->logs);
        return (-1);
    }

    recvbuf = aspMemalloc(2048, 8);
    if (!recvbuf) {
        sprintf_f(rs->logs, "p5 recvbuf alloc failed! \n");
        print_f(rs->plogs, "P5", rs->logs);
        return (-1);
    } else {
        sprintf_f(rs->logs, "p5 recvbuf alloc success! 0x%x\n", (uint32_t)recvbuf);
        print_f(rs->plogs, "P5", rs->logs);
    }

    rs->psocket_r->listenfd = socket(AF_INET, SOCK_STREAM, 0);
    if (rs->psocket_r->listenfd < 0) { 
        sprintf(rs->logs, "p5 get socket ret: %d", rs->psocket_r->listenfd);
        error_handle(rs->logs, 3302);
    }
    
    memset(&rs->psocket_r->serv_addr, '0', sizeof(struct sockaddr_in));

    rs->psocket_r->serv_addr.sin_family = AF_INET;
    rs->psocket_r->serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    rs->psocket_r->serv_addr.sin_port = htons(5000); 

    ret = bind(rs->psocket_r->listenfd, (struct sockaddr*)&rs->psocket_r->serv_addr, sizeof(struct sockaddr_in)); 
    if (ret < 0) {
        //perror("bind:");
        
        ret = -1;
        if (setsockopt(rs->psocket_r->listenfd, SOL_SOCKET, SO_REUSEADDR, &ret, sizeof(int)) == -1) {
            perror("setsockopt");    
            
            sprintf(rs->logs, "p5 get bind ret: %d", ret);
            error_handle(rs->logs, 23071);
        }
    }

    ret = listen(rs->psocket_r->listenfd, 10); 
    if (ret < 0) {
        sprintf(rs->logs, "p5 get listen ret: %d", ret);
        error_handle(rs->logs, 3320);
    }
    
#if 0 /* disable auto boot for testing */
    sprintf_f(rs->logs, "send the very first command [%s] \n", msg);
    print_f(rs->plogs, "P5", rs->logs);
    rs_ipc_put(rcmd, msg, 4);

    n = rs_ipc_get(rcmd, sendbuf, 2048);
    sprintf_f(rs->logs, "get boot result: [%s], ret: %d\n", sendbuf, n);
    print_f(rs->plogs, "P5", rs->logs);
#endif
    while (1) {
        //printf("#");
        //sprintf_f(rs->logs, "#\n");
        //print_f(rs->plogs, "P5", rs->logs);
        ret = -1;
                
        len = sizeof(struct sockaddr_in);
        memset(&rs->psocket_r->clint_addr, 0, len);
        rs->psocket_r->connfd = accept(rs->psocket_r->listenfd, (struct sockaddr*)&rs->psocket_r->clint_addr, &len);

        if (rs->psocket_r->connfd < 0) {
            sprintf(rs->logs, "P5 get connect failed ret:%d", rs->psocket_r->connfd);
            error_handle(rs->logs, 3331);
            continue;
        }
        else {
            //cltaddr = rs->psocket_r->clint_addr.sa_data;
            cltaddr = inet_ntoa(rs->psocket_r->clint_addr.sin_addr);
            cltport = ntohs(rs->psocket_r->clint_addr.sin_port);
            sprintf_f(rs->logs, "get connection id: %d [%s:%d]\n", rs->psocket_r->connfd, cltaddr, cltport);
            print_f(rs->plogs, "P5", rs->logs);

            aspMemClear(aspMemAsign, asptotMalloc, 5);
        }

        memset(recvbuf, 0x0, 1024);
        memset(sendbuf, 0x0, OUT_BUFF_LEN);
        memset(msg, 0x0, 256);

        n = read(rs->psocket_r->connfd, recvbuf, 1024);
        
        recvbuf[n-1] = '\0';
        //sprintf_f(rs->logs, "receive len[%d]content[%s]\n", n, recvbuf);
        //print_f(rs->plogs, "P5", rs->logs);
        memset(sendbuf, 0, OUT_BUFF_LEN);
        sprintf(sendbuf, "Leo heard [%s]\n", recvbuf);
        //strcpy(sendbuf, recvbuf);
        n = strlen(sendbuf);
        
        if (n <= 0) goto socketEnd;
        hd = atFindIdx(recvbuf, 0xfe);
        if (hd < 0) goto socketEnd;
        fg = atFindIdx(recvbuf, 0xfd);
        if (fg < 0) goto socketEnd;     
        be = atFindIdx(&recvbuf[hd], 0xfc);
        if (be < 0) goto socketEnd;
        ed = atFindIdx(&recvbuf[hd], 0xfb);
        if (ed < 0) goto socketEnd;
        ln = atFindIdx(&recvbuf[hd], '\0');
        //if (ln < 0) goto socketEnd;
        
        num = strlen(&recvbuf[hd]);
        if (num <= 0) {
            goto socketEnd;
        }

        //sprintf_f(rs->logs, "receive len[%d]content[%s]hd[%d]be[%d]ed[%d]ln[%d]fg[%d]\n", n, &recvbuf[hd], hd, be, ed, ln, fg);
        //print_f(rs->plogs, "P5", rs->logs);

        opcode = recvbuf[hd+1]; param = recvbuf[be-1]; flag = recvbuf[fg+1];
        sprintf_f(rs->logs, "opcode:[0x%x]arg[0x%x]flg[0x%x]\n", opcode, param, flag);
        print_f(rs->plogs, "P5", rs->logs);

        /* android socket api can't send data with '\0' */
        if ((fg+1) != (be-1)) {
            if (param == 0xff) {
                if (flag & 0x2) {
                    param = 0;
                }
            }
        }

        num = ed - be - 1;
        if ((num < 255) && (num > 0)) {
            memcpy(msg, &recvbuf[be+1], num);
            msg[num] = '\0';

            sprintf_f(rs->logs, "get msg from app [%s] size:%d\n", msg, num);
            print_f(rs->plogs, "P5", rs->logs);
        } else {
            goto socketEnd;
        }

#if SCANGO_CHECK 
        if (strcmp("meta", msg) == 0) {
            rs_ipc_put(rcmd, "scango", 6);
            ch = 0; ret = 0;
            ret = rs_ipc_get(rcmd, &ch, 1);
            if ((ret == 1) && (ch == 'Z')) {
                ret = rs_ipc_get(rcmd, addr, 1024);
                addr[ret] = '\0';
                sprintf_f(rs->logs, "get response [\n\n%s\n] len:%d\n", addr, ret);
                print_f(rs->plogs, "P5", rs->logs);
            } else {
                opcode = OP_ERROR; 
            }
        }
#endif

        switch (opcode) {
            case OP_ERROR:
                num = -1;
                break;
            case OP_MSG:
                break;
            case OP_SINGLE:
            case OP_DOUBLE:
            case OP_MSINGLE:
            case OP_MDOUBLE:
            case OP_HANDSCAN:
            case OP_NOTESCAN:
            case OP_ACTION:
                //num = 0;
                break;
            default:
                num = 0;
                break;
        }
        
        //sprintf_f(rs->logs, "num [%d] ch [%c] \n",num, ch);
        //print_f(rs->plogs, "P5", rs->logs);

        if (num < 0) {
            param = ch;
        } else if (num > 0) {
            //rs_ipc_put(rs, "s", 1);
            //rs_ipc_put(rs, msg, n);
            //sprintf_f(rs->logs, "send to p0 [%s]\n", recvbuf);
            //print_f(rs->plogs, "P5", rs->logs);
            
            //ret = write(rs->psocket_r->connfd, msg, n);
            //sprintf_f(rs->logs, "get msg from app [%s] size:%d\n", msg, num);
            //print_f(rs->plogs, "P5", rs->logs);
            if ((opcode == OP_SINGLE) || (opcode == OP_DOUBLE) || (opcode == OP_HANDSCAN)
                || (opcode == OP_MSINGLE) || (opcode == OP_MDOUBLE) || (opcode == OP_ACTION)
                || (opcode == OP_NOTESCAN)) {
                tgr[0] = 't';
                tgr[1] = 'g';
                tgr[2] = 'r';

                rs_ipc_put(rcmd, tgr, 3);

                ch = 0; ret = 0;
                ret = rs_ipc_get(rcmd, &ch, 1);

                if (ch == 'o') {
                    if (flag & 0x04) { /* 0xaa = write, 0xad = read */
                        tgr[0] = 0xad; 
                    } else {
                        tgr[0] = 0xaa; 
                    }
                    tgr[1] = opcode;
                    tgr[2] = '/';
                    tgr[3] = param;
                    tgr[4] = 0xa5;
                    rs_ipc_put(rcmd, tgr, 5);
                }

                ch = 0; ret = 0;
                ret = rs_ipc_get(rcmd, &ch, 1);

                if (ch != 'p') {
                    opcode = OP_ERROR; 
                    ret = rs_ipc_get(rcmd, &ch, 1);
                    param = ch;
                } else {
                    ret = rs_ipc_get(rcmd, &ch, 1);
                    param = ch;

                    ret = rs_ipc_get(rcmd, addr, 1024);
                    addr[ret] = '\0';
                    sprintf_f(rs->logs, "TGR response [\n\n%s\n] len:%d\n", addr, ret);
                    print_f(rs->plogs, "P5", rs->logs);

                    if ((strcmp("msingle", msg) == 0) || (strcmp("mdouble", msg) == 0) 
                        || (strcmp("mocr", msg) == 0)) {
                        while (1) {
                            rs_ipc_put(rcmd, msg, num);

                            ch = 0; ret = 0;
                            ret = rs_ipc_get(rcmd, &ch, 1);
                            if (ch == 'e') {
                                break;
                            }
                            
                            memset(sendbuf, 0, OUT_BUFF_LEN);

                            sendbuf[0] = 0xfe;
                            sendbuf[1] = ((opcode & 0x80) ? 1:0) + 1;
                            sendbuf[2] = opcode & 0x7f;
                            sendbuf[3] = 0xfd;
                            //sendbuf[3] = 'P';//0x0;
                            sendbuf[6] = 0xfc;

                            n = rs_ipc_get(rcmd, &sendbuf[7], OUT_BUFF_LEN);
                            sendbuf[4] = ((param & 0x80) ? 1:0) + 1;
                            sendbuf[5] = param & 0x7f;

                            sendbuf[7+n] = '\n';
                            sendbuf[7+n+1] = 0xfb;
                            sendbuf[7+n+2] = '\0';

                            //sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d, opcode:%d, [%x][%x][%x][%x]\n", 7+n+3, &sendbuf[7], rs->psocket_r->connfd, ret, opcode, sendbuf[1], sendbuf[2], sendbuf[4], sendbuf[5]);
                            //print_f(rs->plogs, "P5", rs->logs);
                            //printf("[p5]:%s\n", &sendbuf[7]);

                            ret = write(rs->psocket_r->connfd, sendbuf, 7+n+3);

                            sendbuf[7+n] = '\0';
                            sprintf_f(rs->logs, "NEXT send len[%d]content[\n\n%s\n\n]len[%d]\n", n, &sendbuf[7], n);
                            print_f(rs->plogs, "P5", rs->logs);
                        }
                    }
                    else {
                        rs_ipc_put(rcmd, msg, num);
                    }
                }        
            }
            else {
                rs_ipc_put(rcmd, msg, num);
            }
        }
        else {
            if ((opcode == OP_SINGLE) || (opcode == OP_DOUBLE)) {
                msg[0] = 't';
                msg[1] = 'g';
                msg[2] = 'r';
                rs_ipc_put(rcmd, msg, 3);
            } else {
                msg[0] = 'o';
                msg[1] = 'p';
                rs_ipc_put(rcmd, msg, 2);
            }

            ch = 0; num = 0;
            num = rs_ipc_get(rcmd, &ch, 1);

            if (ch == 'o') {
                if (flag & 0x04) { /* 0xaa = write, 0xad = read */
                    msg[0] = 0xad; 
                } else {
                    msg[0] = 0xaa; 
                }
                msg[1] = opcode;
                msg[2] = '/';
                msg[3] = param;
                msg[4] = 0xa5;
                rs_ipc_put(rcmd, msg, 5);
            }

            ch = 0; num = 0;
            num = rs_ipc_get(rcmd, &ch, 1);

            if (ch != 'p') {
                opcode = OP_ERROR; 
                num = rs_ipc_get(rcmd, &ch, 1);
                param = ch;
            } else {
                num = rs_ipc_get(rcmd, &ch, 1);
                param = ch;
            }
        }

        //usleep(100000);
        memset(sendbuf, 0, OUT_BUFF_LEN);

        sendbuf[0] = 0xfe;
        sendbuf[1] = ((opcode & 0x80) ? 1:0) + 1;
        sendbuf[2] = opcode & 0x7f;
        sendbuf[3] = 0xfd;
        //sendbuf[3] = 'P';//0x0;
        sendbuf[6] = 0xfc;

        n = rs_ipc_get(rcmd, &sendbuf[7], OUT_BUFF_LEN);
        sendbuf[4] = ((param & 0x80) ? 1:0) + 1;
        sendbuf[5] = param & 0x7f;
        
        sendbuf[7+n] = '\n';
        sendbuf[7+n+1] = 0xfb;
        sendbuf[7+n+2] = '\0';

        //sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d, opcode:%d, [%x][%x][%x][%x]\n", 7+n+3, &sendbuf[7], rs->psocket_r->connfd, ret, opcode, sendbuf[1], sendbuf[2], sendbuf[4], sendbuf[5]);
        //print_f(rs->plogs, "P5", rs->logs);
        //printf("[p5]:%s\n", &sendbuf[7]);

        socketEnd:
        ret = write(rs->psocket_r->connfd, sendbuf, 7+n+3);

        sendbuf[7+n] = '\0';
        //printf("[P5] END send len[%d]content[\n\n%s\n\n]len[%d]\n", n, &sendbuf[7], n);
        sprintf_f(rs->logs, "END send len[%d]content[\n\n%s\n\n]len[%d]\n", n, &sendbuf[7], n);
        print_f(rs->plogs, "P5", rs->logs);

        close(rs->psocket_r->connfd);
        rs->psocket_r->connfd = 0;
    }

    p5_end(rs, rcmd);
    return 0;
}

static int atFindIdx(char *str, char ch)
{
    int i, len;
    if (!str) return (-1);
    len = strlen(str);
    if (len > 1024) return (-2);

    i = 0;
    while (i < len) {
        if (*str == ch) {
            return i;
        }
        str++;
        i++;
    }
    return (-3);
}

#define P6_SEND_BUFF_SIZE (4096)

#define LOG_P6_RX_EN    (0)
#define LOG_P6_UTC_EN  (0)
#define LOG_P6_PARA_EN  (0)
static int p6(struct procRes_s *rs)
{
    char ssidPath[128] = "/root/scaner/ssid.bin";
    char pskPath[128] = "/root/scaner/psk.bin";
    FILE *fssid=0, *fpsk=0;
    char strFullPath[1024];
    char strPath[32][128];
    //char **strPath; 
    char *recvbuf, *sendbuf, *pr, *cltaddr;
    int ret, n, num, hd, be, ed, ln, cnt=0, i, len=0, cltport=0, slen=0;
    char opc=0;
    char opcode=0, param=0, flag = 0;
    uint32_t clstSize=0;
    uint32_t adata[3], atime[3];
    uint32_t *scanParam=0, op=0, cd=0, fg=0;
    int ix=0, idx=0;
    char curTime[16];
    char syscmd[256] = "ls -al";

    struct directnFile_s *fscur = 0, *nxtf = 0;
    struct directnFile_s *brt, *pa;
    struct directnFile_s *dnld=0, *upld=0, *chld=0;

    struct aspConfig_s *pct=0, *pdt=0;
    struct adFATLinkList_s *pflsh=0, *pflnt=0;
    struct sdFAT_s *pfat=0;
    struct sdFATable_s   *pftb=0;
    uint32_t secStr=0, secLen=0;

    struct aspMetaMass_s *pmass=0, *pmassduo=0;
    int masUsed=0, masRecd=0, masStart=0;
    int gap=0, cy=0, cxm=0, cxn=0, linecnt=0, plancnt=0;
    unsigned short *ptBuf;

    struct aspInfoSplit_s *strinfo=0, *nexinfo=0;

    struct apWifiConfig_s *pwfc=0;
    char ch=0;

    int cpn=0, cpx=0, cof=0, cls=0;
    struct aspCrop36_s *pcp36, *pcp36duo;
    struct aspCropExtra_s *pcpex, *pcpexduo;
    struct aspDoCropCalcu *pcpdo=0, *pcpdoduo=0;

    CFLOAT rotlf[2]={0}, rotup[2]={0}, rotrt[2]={0}, rotdn[2]={0};
    CFLOAT mostlft[2]={0}, mostrgt[2]={0}, lftgrp[10][2]={0}, rgtgrp[10][2]={0}, fhi=0.0, fwh=0.0, fwe=0.0;
    CFLOAT selecPic = 0.0, selecBase = 100.0, selecRatio = 0.0, selecCur = 0, selecMax = 0;
    int ipic=0, icur=0;

    struct sdFatDir_s *rsfatdir=0, *msfatdir=0;
    int idxL[] = {6, 7, 9, 11, 13, 15, 17, 2};
    int idxR[] = {5, 8, 10, 12, 14, 16, 18, 3};    

    char *ph=0;
    struct bitmapHeader_s *bheader;
    int clr=0, w=0, h=0, hduo=0, dpi=0, hlen=0, datlen=0, orglen=0, t=0, vhi=0, crpMx=0;
    uint32_t tmp=0, val=0, ffrmt=0, scanlen=0, csws=0, cswd=0;
    char *hbuff=0;
    struct aspMetaDataviaUSB_s *ptmetausb=0, *ptmetausbduo=0;
    
    prctl(PR_SET_NAME, "msp-p6");
    //sprintf(argv[0], "msp-p6-socket4000");
    
    pct = rs->pcfgTable;
    pfat = rs->psFat;
    pftb = &pfat->fatTable;
    pwfc = rs->pwifconf;
    pmass = rs->pmetaMass;
    pcp36 = rs->pcrop32;
    pcpex = rs->pcropex;
    pmassduo= rs->pmetaMassduo;
    pcp36duo= rs->pcrop32duo;
    pcpexduo= rs->pcropexduo;

    ptmetausb = rs->pmetausb;
    ptmetausbduo = rs->pmetausbduo;

    char dir[64] = "/mnt/mmc2";
    //char dir[256] = "/root";
    char folder[1024];

    sprintf_f(rs->logs, "p6\n");
    print_f(rs->plogs, "P6", rs->logs);

    p6_init(rs);

    rsfatdir = rs->cpyfatDirTr;
    msfatdir = &rs->psFat->fatDirTr;

/*
    while (!rs->psFat->fatRootdir);    
    fscur = rs->psFat->fatRootdir;
*/

    pcpdo = aspMemalloc(sizeof(struct aspDoCropCalcu), 8);
    memset(pcpdo, 0, sizeof(struct aspDoCropCalcu));
    pcpdoduo = aspMemalloc(sizeof(struct aspDoCropCalcu), 8);
    memset(pcpdoduo, 0, sizeof(struct aspDoCropCalcu));

    pcpdo->acrp36 = pcp36;
    pcpdo->acrpex = pcpex;

    pcpdoduo->acrp36 = pcp36duo;
    pcpdoduo->acrpex = pcpexduo;
    
    recvbuf = aspMemalloc(1024, 8);
    if (!recvbuf) {
        sprintf_f(rs->logs, "recvbuf alloc failed! \n");
        print_f(rs->plogs, "P6", rs->logs);
        return (-1);
    } else {
        sprintf_f(rs->logs, "recvbuf alloc success! 0x%x\n", (uint32_t)recvbuf);
        print_f(rs->plogs, "P6", rs->logs);
    }

    sendbuf = aspMemalloc(P6_SEND_BUFF_SIZE, 8);
    if (!sendbuf) {
        sprintf_f(rs->logs, "sendbuf alloc failed! \n");
        print_f(rs->plogs, "P6", rs->logs);
        return (-1);
    } else {
        sprintf_f(rs->logs, "sendbuf alloc success! 0x%x\n", (uint32_t)sendbuf);
        print_f(rs->plogs, "P6", rs->logs);
    }

    rs->psocket_at->listenfd = socket(AF_INET, SOCK_STREAM, 0);
    if (rs->psocket_at->listenfd < 0) { 
        sprintf(rs->logs, "p6 get socket ret: %d", rs->psocket_at->listenfd);
        error_handle(rs->logs, 3302);
    }

    memset(&rs->psocket_at->serv_addr, '0', sizeof(struct sockaddr_in));

    rs->psocket_at->serv_addr.sin_family = AF_INET;
    rs->psocket_at->serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    rs->psocket_at->serv_addr.sin_port = htons(4000); 

    ret = bind(rs->psocket_at->listenfd, (struct sockaddr*)&rs->psocket_at->serv_addr, sizeof(struct sockaddr_in)); 
    if (ret < 0) {
        //perror("bind:");
        ret = -1;
        if (setsockopt(rs->psocket_at->listenfd, SOL_SOCKET, SO_REUSEADDR, &ret, sizeof(int)) == -1) {
            perror("setsockopt");    
            
            sprintf(rs->logs, "p6 get bind ret: %d", ret);
            error_handle(rs->logs, 23360);
        }
    }

    ret = listen(rs->psocket_at->listenfd, 10); 
    if (ret < 0) {
        sprintf(rs->logs, "p6 get listen ret: %d", ret);
        error_handle(rs->logs, 3801);
    }

    while (1) {
        //sprintf_f(rs->logs, "@\n");
        //print_f(rs->plogs, "P6", rs->logs);
        cnt = 0;

        len = sizeof(struct sockaddr_in);
        memset(&rs->psocket_at->clint_addr, 0, len);
        rs->psocket_at->connfd = accept(rs->psocket_at->listenfd, (struct sockaddr*)&rs->psocket_at->clint_addr, &len); 
        if (rs->psocket_at->connfd < 0) {
            sprintf(rs->logs, "P6 get connect failed ret:%d", rs->psocket_at->connfd);
            error_handle(rs->logs, 3812);
            goto socketEnd;
        }
        else {
            //cltaddr = rs->psocket_at->clint_addr.sa_data;
            cltaddr = inet_ntoa(rs->psocket_at->clint_addr.sin_addr);
            cltport = ntohs(rs->psocket_at->clint_addr.sin_port);
            sprintf_f(rs->logs, "get connection id: %d [%s:%d]\n", rs->psocket_at->connfd, cltaddr, cltport);
            print_f(rs->plogs, "P6", rs->logs);

            aspMemClear(aspMemAsign, asptotMalloc, 6);
        }

        memset(recvbuf, 0x0, 1024);
        memset(sendbuf, 0x0, P6_SEND_BUFF_SIZE);
        
        n = read(rs->psocket_at->connfd, recvbuf, 1024);
        if (n <= 0) goto socketEnd;
        hd = atFindIdx(recvbuf, 0xfe);
        if (hd < 0) goto socketEnd;
        be = atFindIdx(&recvbuf[hd], 0xfc);
        if (be < 0) goto socketEnd;
        ed = atFindIdx(&recvbuf[hd], 0xfb);
        if (ed < 0) goto socketEnd;
        ln = atFindIdx(&recvbuf[hd], '\0');
        
        opcode = recvbuf[hd+1]; param = recvbuf[be-1];
#if 1
        sprintf_f(rs->logs, "opcode:[0x%x]arg[0x%x]\n", opcode, param);
        print_f(rs->plogs, "P6", rs->logs);
#endif
        n = strlen(&recvbuf[hd]);
        if (n <= 0) {
            goto socketEnd;
        }

#if LOG_P6_RX_EN
        //sprintf_f(rs->logs, "[P6] receive len[%d]contentStr[%s]hd[%d]be[%d]ed[%d]ln[%d]\n", n, &recvbuf[be], hd, be, ed, ln);
        //print_f(rs->plogs, "P6", rs->logs);

        sprintf_f(rs->logs, "opcode:[0x%x]arg[0x%x]\n", recvbuf[hd+1], recvbuf[be-1]);
        print_f(rs->plogs, "P6", rs->logs);
#endif
        n = ed - be - 1;
        sprintf_f(rs->logs, "n = %d \n", n);
        print_f(rs->plogs, "P6", rs->logs);
        if ((n < 1024) && (n > 0)) {
            memcpy(folder, &recvbuf[be+1], n);
            folder[n] = '\0';
        } else {

            memset(folder, 0x00, 1024);
            folder[0] = '\0';
            
            sprintf_f(rs->logs, "ERROR!!! string len = %d \n", n);
            print_f(rs->plogs, "P6", rs->logs);

            //goto socketEnd;
        }

        sprintf_f(rs->logs, "get folder:[%s]\n", folder);
        print_f(rs->plogs, "P6", rs->logs);

        sendbuf[0] = 0xfe;
        sendbuf[1] = opcode;
        sendbuf[2] = 0xfd;
        sendbuf[3] = 0x01; /*??*/
        sendbuf[4] = 0xfc;
        
        sendbuf[3] = 'F';

        if (opcode == 0x24) { /* send OCR hex*/
            sprintf_f(rs->logs, "handle opcode: 0x%x param: 0x%x (OCR hex)\n", opcode, param);
            print_f(rs->plogs, "P6", rs->logs);

            #if MOVE_MUTX_TO_FRONT_P6
            while (ch != 'c') {
                ret = rs_ipc_get_ms(rs, &ch, 1, 500);
                if (ret > 0) {
                    if (ch == 'c') {
                        sprintf_f(rs->logs, "succeed to get ch == %c\n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    } else {
                        sprintf_f(rs->logs, "wrong!! ch == %c \n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    }
                } else {
                    sprintf_f(rs->logs, "wait for c ret: %d \n", ret);
                    print_f(rs->plogs, "P6", rs->logs);    
                }
            }
            #endif
            
            pdt = &pct[ASPOP_IMG_LEN];
            
            cnt = 0;
            while (pdt->opStatus != ASPOP_STA_UPD) {
                usleep(2000);

                if (((cnt+1) % 500) == 0) {
                    sprintf_f(rs->logs, "wait img len cnt: %d - 1\n", cnt);
                    print_f(rs->plogs, "P6", rs->logs);    
                }

                msync(pdt, sizeof(struct aspConfig_s), MS_SYNC);

                cnt ++;
            }
            pdt->opStatus = ASPOP_STA_APP;
            
            sendbuf[3] = 'H';

            sprintf(rs->logs, "%d,\n\r", pdt->opValue & 0xffff);
            n = strlen(rs->logs);
            if (n > 256) n = 256;
            
            memcpy(&sendbuf[5], rs->logs, n);

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            print_f(rs->plogs, "P6", rs->logs);

            csws = 0;
            cfgTableGetChk(pct, ASPOP_SCAN_STATUS, &csws, ASPOP_STA_UPD);
            
            sprintf_f(rs->logs, "get usb scan status: 0x%.2x ret: %d\n", csws, ret);
            print_f(rs->plogs, "P6", rs->logs);

            sendbuf[3] = 'S';

            sprintf(rs->logs, "%d,\n\r", csws & 0xff);
            n = strlen(rs->logs);
            if (n > 256) n = 256;

            memcpy(&sendbuf[5], rs->logs, n);

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            print_f(rs->plogs, "P6", rs->logs);

            #if !MOVE_MUTX_TO_FRONT_P6
            ch = 0;
            while (ch != 'c') {
                ret = rs_ipc_get_ms(rs, &ch, 1, 500);
                if (ret > 0) {
                    if (ch == 'c') {
                        sprintf_f(rs->logs, "succeed to get ch == %c\n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    } else {
                        sprintf_f(rs->logs, "wrong!! ch == %c \n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    }
                } else {
                    sprintf_f(rs->logs, "wait for c ret: \n", ret);
                    print_f(rs->plogs, "P6", rs->logs);    
                }
            }
            #endif

            msync(&pct[ASPOP_IMG_LEN], sizeof(struct aspConfig_s), MS_SYNC);
            
            sprintf_f(rs->logs, "img len: opc: 0x%x, val: %d(%d), status: 0x%x \n", pdt->opCode, h, pdt->opValue, pdt->opStatus);
            print_f(rs->plogs, "P6", rs->logs);    
            
            val=0;
            ret = cfgTableGetChk(pct, ASPOP_IMG_LEN, &val, ASPOP_STA_APP);    

            #if LOG_P6_PARA_EN
            sprintf_f(rs->logs, "user defined image length: %d, ret:%d\n", val, ret);
            print_f(rs->plogs, "P6", rs->logs);
            #endif
            
            h = val;
            
            sendbuf[3] = 'O';

            msync(pmass->masspt, pmass->massMax, MS_SYNC);

            hbuff = pmass->masspt;
            bin2hex(&sendbuf[5], hbuff, 16);
            //memcpy(&sendbuf[5], hbuff, orglen);
            //memset(&sendbuf[5], 0x95, P6_SEND_BUFF_SIZE - 5);

            n = 16 * 2;

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';

            //shmem_dump(sendbuf, P6_SEND_BUFF_SIZE);
                        
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);

            sendbuf[5+n] = '\0';            
            sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, &sendbuf[5], rs->psocket_at->connfd, ret);
            print_f(rs->plogs, "P6", rs->logs);

            hbuff += 16;
            bin2hex(&sendbuf[5], hbuff, 16);
            //memcpy(&sendbuf[5], hbuff, orglen);
            //memset(&sendbuf[5], 0x95, P6_SEND_BUFF_SIZE - 5);

            n = 16 * 2;

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';

            //shmem_dump(sendbuf, P6_SEND_BUFF_SIZE);
                        
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);

            sendbuf[5+n] = '\0';            
            sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, &sendbuf[5], rs->psocket_at->connfd, ret);
            print_f(rs->plogs, "P6", rs->logs);        

            pmass->massRecd = 0;
            pmass->massUsed = 0;
            
            msync(pmass, sizeof(struct aspMetaMass_s), MS_SYNC);
            
            sprintf_f(rs->logs, "param: %c, image len: %d (%d) \n", param, h, pdt->opValue);
            print_f(rs->plogs, "P6", rs->logs); 
            
            if ((param == 'E') || (h == 0)) {
                rs_ipc_put(rs, "E", 1);
                sprintf_f(rs->logs, "return \"E\" \n");
                print_f(rs->plogs, "P6", rs->logs);    
            } else {
                rs_ipc_put(rs, "C", 1);
                sprintf_f(rs->logs, "return \"C\" \n");
                print_f(rs->plogs, "P6", rs->logs);    
            }
            
            goto socketEnd;
        }

        if (opcode == 0x23) { /* send duo img length*/
            sprintf_f(rs->logs, "handle opcode: 0x%x param: 0x%x (imglen)\n", opcode, param);
            print_f(rs->plogs, "P6", rs->logs);

            #if MOVE_MUTX_TO_FRONT_P6
            ch = 0;
            while (ch != 'd') {
                ret = rs_ipc_get_ms(rs, &ch, 1, 500);
                if (ret > 0) {
                    if (ch == 'd') {
                        sprintf_f(rs->logs, "succeed to get ch1 == %c\n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    } else {
                        sprintf_f(rs->logs, "wrong!! ch1 == %c \n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    }
                } else {
                    sprintf_f(rs->logs, "wait for d1 ret: %d \n", ret);
                    print_f(rs->plogs, "P6", rs->logs);    
                }
            }
            ch = 0;
            while (ch != 'd') {
                ret = rs_ipc_get_ms(rs, &ch, 1, 500);
                if (ret > 0) {
                    if (ch == 'd') {
                        sprintf_f(rs->logs, "succeed to get ch2 == %c\n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    } else {
                        sprintf_f(rs->logs, "wrong!! ch2 == %c \n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    }
                } else {
                    sprintf_f(rs->logs, "wait for d2 ret: %d \n", ret);
                    print_f(rs->plogs, "P6", rs->logs);    
                }
            }
            #endif
            
            /* first page */
            pdt = &pct[ASPOP_IMG_LEN];
            cnt = 0;
            while (pdt->opStatus != ASPOP_STA_UPD) {
                usleep(2000);

                if (((cnt+1) % 500) == 0) {
                    sprintf_f(rs->logs, "wait img len cnt: %d - 1\n", cnt);
                    print_f(rs->plogs, "P6", rs->logs);    
                }

                msync(pdt, sizeof(struct aspConfig_s), MS_SYNC);

                cnt ++;
            }
            pdt->opStatus = ASPOP_STA_APP;
            
            sendbuf[3] = 'H';

            sprintf(rs->logs, "%d,\n\r", pdt->opValue & 0xffff);
            n = strlen(rs->logs);
            if (n > 256) n = 256;

            memcpy(&sendbuf[5], rs->logs, n);

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            print_f(rs->plogs, "P6", rs->logs);

            val = 0;
            ret = cfgTableGetChk(pct, ASPOP_SCAN_SIDE, &val, ASPOP_STA_UPD);
            
            //sprintf_f(rs->logs, "get usb page side: 0x%.2x ret: %d\n", val, ret);
            //print_f(rs->plogs, "P6", rs->logs);

            sendbuf[3] = 'P';

            sprintf(rs->logs, "%d,\n\r", val & 0xff);
            n = strlen(rs->logs);
            if (n > 256) n = 256;

            memcpy(&sendbuf[5], rs->logs, n);

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            //sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            //print_f(rs->plogs, "P6", rs->logs);

            csws = 0;
            cfgTableGetChk(pct, ASPOP_SCAN_STATUS, &csws, ASPOP_STA_UPD);
            
            sprintf_f(rs->logs, "get usb scan status: 0x%.2x ret: %d\n", csws, ret);
            print_f(rs->plogs, "P6", rs->logs);

            sendbuf[3] = 'S';

            sprintf(rs->logs, "%d,\n\r", csws & 0xff);
            n = strlen(rs->logs);
            if (n > 256) n = 256;

            memcpy(&sendbuf[5], rs->logs, n);

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            //sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            //print_f(rs->plogs, "P6", rs->logs);

            /* second page */
            pdt = &pct[ASPOP_IMG_LEN_DUO];
            cnt = 0;
            while (pdt->opStatus != ASPOP_STA_UPD) {
                usleep(2000);

                if (((cnt+1) % 500) == 0) {
                    sprintf_f(rs->logs, "wait img len cnt: %d - 2\n", cnt);
                    print_f(rs->plogs, "P6", rs->logs);    
                }

                msync(pdt, sizeof(struct aspConfig_s), MS_SYNC);

                cnt ++;
            }
            pdt->opStatus = ASPOP_STA_APP;            
            
            sendbuf[3] = 'h';

            sprintf(rs->logs, "%d,\n\r", pdt->opValue & 0xffff);
            n = strlen(rs->logs);
            if (n > 256) n = 256;

            memcpy(&sendbuf[5], rs->logs, n);

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            print_f(rs->plogs, "P6", rs->logs);

            val = 0;
            ret = cfgTableGetChk(pct, ASPOP_SCAN_SIDE_DUO, &val, ASPOP_STA_UPD);
            
            //sprintf_f(rs->logs, "get duo usb page side: 0x%.2x ret: %d\n", val, ret);
            //print_f(rs->plogs, "P6", rs->logs);

            sendbuf[3] = 'p';

            sprintf(rs->logs, "%d,\n\r", val & 0xff);
            n = strlen(rs->logs);
            if (n > 256) n = 256;

            memcpy(&sendbuf[5], rs->logs, n);

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            //sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            //print_f(rs->plogs, "P6", rs->logs);
            
            cswd = 0;
            cfgTableGetChk(pct, ASPOP_SCAN_STATUS_DUO, &cswd, ASPOP_STA_UPD);
            
            sprintf_f(rs->logs, "get duo usb scan status (0x%.2x) ret: %d\n", cswd, ret);
            print_f(rs->plogs, "P6", rs->logs);

            sendbuf[3] = 's';

            sprintf(rs->logs, "%d,\n\r", cswd & 0xff);
            n = strlen(rs->logs);
            if (n > 256) n = 256;

            memcpy(&sendbuf[5], rs->logs, n);

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            //sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            //print_f(rs->plogs, "P6", rs->logs);
            
            /* send back bmp header */
            ret = cfgTableGetChk(pct, ASPOP_FILE_FORMAT, &tmp, ASPOP_STA_APP);    

            #if LOG_P6_PARA_EN
            sprintf_f(rs->logs, "user defined file format: %d, ret:%d\n", tmp, ret);
            print_f(rs->plogs, "P6", rs->logs);
            #endif

            val = 0;
            ret = cfgTableGetChk(pct, ASPOP_IMG_LEN, &val, ASPOP_STA_APP);    
            #if LOG_P6_PARA_EN
            sprintf_f(rs->logs, "user defined image length: %d, ret:%d\n", val, ret);
            print_f(rs->plogs, "P6", rs->logs);
            #endif
            h = val;

            if (tmp == FILE_FORMAT_RAW) {
                ph = &rs->pbheader->aspbmpMagic[2];
                len = sizeof(struct bitmapHeader_s) - 2;
                bheader = rs->pbheader;
                clr=0;w=0;dpi=0;
                
                //dbgBitmapHeader(bheader, len);
                
                /* bmp header needs 1.width 2.height 3.dpi 4.raw size */
                ret = cfgTableGetChk(pct, ASPOP_COLOR_MODE, &tmp, ASPOP_STA_APP);    
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "user defined color mode: %d, ret:%d\n", tmp, ret);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
                switch (tmp) {
                    case COLOR_MODE_COLOR:
                        clr = 24;
                        break;
                    case COLOR_MODE_GRAY:
                    case COLOR_MODE_GRAY_DETAIL:
                    case COLOR_MODE_BLACKWHITE:
                        clr = 8;
                        break;
                    default:
                        clr = 24;
                        break;
                }

                ret = cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_H, &val, ASPOP_STA_APP);    
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "user defined width high: %d, ret:%d\n", val, ret);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
                
                ret = cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_L, &tmp, ASPOP_STA_APP);    
                t = val << 8 | tmp;

                val = 0;
                ret = cfgTableGetChk(pct, ASPOP_SCAN_WIDTH, &val, ASPOP_STA_UPD);

                w = scanWidthConvert(t, val);
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "user defined width low: %d, ret:%d, w = %d (tag:%d)\n", tmp, ret, w, t);
                print_f(rs->plogs, "P6", rs->logs);
                #endif

                tmp = 0;
                ret = cfgTableGetChkDPI(pct, ASPOP_RESOLUTION, &tmp, ASPOP_STA_APP);    
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "user defined resulution: %d, ret:%d\n", tmp, ret);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
                dpi = tmp;
                
                hbuff = aspMemalloc(1078, 6);
                if (!hbuff) {
                    goto socketEnd;
                }
                
                if (clr == 8) {
                    hlen = 1078;
                } else if (clr == 24) {
                    hlen = 54;            
                } else {
                    printf("[P6] ERROR!!! color bits is %d \n", clr);
                    goto socketEnd;
                }
                
                orglen = hlen;
                
                ret = cfgTableGetChk(pct, ASPOP_RAW_SIZE, &val, ASPOP_STA_APP);    
                sprintf_f(rs->logs, "scan raw data size: %d, ret:%d\n", val, ret);
                print_f(rs->plogs, "P6", rs->logs);
                
                /* calculate sector start and sector length of file */            
                
                datlen = val + hlen;
                
                sprintf_f(rs->logs, "bitmap info color: %d, w: %d, h: %d, dpi: %d, imglen: %d, use: %d\n", clr, w, h, dpi, val, hlen);
                print_f(rs->plogs, "P6", rs->logs);
                
#if BMP_TEST /* for test */
                if (clr == 8) {
                    bitmapHeaderSetup(bheader, 8, 5184, 6524, 300, val);
                } else {
                    //bitmapHeaderSetup(bheader, 24, 2304, 3456, 600, val);
                    bitmapHeaderSetup(bheader, 24, 2160, 3496, 600, val);
                }
#else           
                bitmapHeaderSetup(bheader, clr, w, h, dpi, val);
#endif          
                ph = &rs->pbheader->aspbmpMagic[2];
                len = sizeof(struct bitmapHeader_s) - 2;
                memcpy(hbuff, ph, len);
                
                hlen -= len;
                if (hlen > 0) {
                    bitmapColorTableSetup(hbuff+len);
                    hlen -= 1024;
                }
                
                if (hlen) {
                    printf("[fs98] Error!!! the bitmap header len is wrong %d orginal is %d\n", hlen, orglen);
                    hlen = 0;
                } 
                
                dbgBitmapHeader(bheader, len);
                
                sendbuf[3] = 'L';
                
                sprintf(rs->logs, "%d,\n\r", orglen*2);
                n = strlen(rs->logs);
                if (n > (P6_SEND_BUFF_SIZE - 32)) n = P6_SEND_BUFF_SIZE - 32;
                
                memcpy(&sendbuf[5], rs->logs, n);
                
                sendbuf[5+n] = 0xfb;
                sendbuf[5+n+1] = '\n';
                sendbuf[5+n+2] = '\0';
                ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
                print_f(rs->plogs, "P6", rs->logs);
                
                sendbuf[3] = 'B';
                
                bin2hex(&sendbuf[5], hbuff, orglen);
                //memcpy(&sendbuf[5], hbuff, orglen);
                //memset(&sendbuf[5], 0x95, P6_SEND_BUFF_SIZE - 5);
                
                n = orglen * 2;
                
                sendbuf[5+n] = 0xfb;
                sendbuf[5+n+1] = '\n';
                sendbuf[5+n+2] = '\0';
                
                //shmem_dump(sendbuf, P6_SEND_BUFF_SIZE);
                            
                ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                //sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
                //print_f(rs->plogs, "P6", rs->logs);
            }

            /* send back bmp header */
            ret = cfgTableGetChk(pct, ASPOP_FILE_FORMAT, &tmp, ASPOP_STA_APP);    
            #if LOG_P6_PARA_EN
            sprintf_f(rs->logs, "user defined file format: %d, ret:%d\n", tmp, ret);
            print_f(rs->plogs, "P6", rs->logs);
            #endif
            
            if (tmp == FILE_FORMAT_RAW) { /* second page */
                ph = &rs->pbheaderDuo->aspbmpMagic[2];
                len = sizeof(struct bitmapHeader_s) - 2;
                bheader = rs->pbheaderDuo;
                clr=0;w=0;dpi=0;
                
                //dbgBitmapHeader(bheader, len);
                
                /* bmp header needs 1.width 2.height 3.dpi 4.raw size */
                ret = cfgTableGetChk(pct, ASPOP_COLOR_MODE, &tmp, ASPOP_STA_APP);    
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "user defined color mode: %d, ret:%d\n", tmp, ret);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
                switch (tmp) {
                    case COLOR_MODE_COLOR:
                        clr = 24;
                        break;
                    case COLOR_MODE_GRAY:
                    case COLOR_MODE_GRAY_DETAIL:
                    case COLOR_MODE_BLACKWHITE:
                        clr = 8;
                        break;
                    default:
                        clr = 24;
                        break;
                }

                val = 0;
                ret = cfgTableGetChk(pct, ASPOP_IMG_LEN_DUO, &val, ASPOP_STA_APP);    
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "duo user defined image length: %d, ret:%d duo\n", val, ret);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
                hduo = val;

                ret = cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_H, &val, ASPOP_STA_APP);    
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "user defined width high: %d, ret:%d\n", val, ret);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
                
                ret = cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_L, &tmp, ASPOP_STA_APP);    
                t = val << 8 | tmp;

                val = 0;
                ret = cfgTableGetChk(pct, ASPOP_SCAN_WIDTH_DUO, &val, ASPOP_STA_UPD);

                w = scanWidthConvert(t, val);
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "user defined width low: %d, ret:%d, w = %d (tag:%d)\n", tmp, ret, w, t);
                print_f(rs->plogs, "P6", rs->logs);
                #endif

                tmp = 0;
                ret = cfgTableGetChkDPI(pct, ASPOP_RESOLUTION, &tmp, ASPOP_STA_APP);    
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "user defined resulution: %d, ret:%d\n", tmp, ret);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
                dpi = tmp;
                
                //pct[ASPOP_IMG_LEN].opStatus = ASPOP_STA_APP;
                
                hbuff = aspMemalloc(1078, 6);
                if (!hbuff) {
                    goto socketEnd;
                }
                
                if (clr == 8) {
                    hlen = 1078;
                } else if (clr == 24) {
                    hlen = 54;            
                } else {
                    printf("[P6] ERROR!!! color bits is %d \n", clr);
                    goto socketEnd;
                }
                
                orglen = hlen;
                
                ret = cfgTableGetChk(pct, ASPOP_RAW_SIZE_DUO, &val, ASPOP_STA_APP);    
                sprintf_f(rs->logs, "scan raw data size: %d, ret:%d duo\n", val, ret);
                print_f(rs->plogs, "P6", rs->logs);
                
                /* calculate sector start and sector length of file */            
                
                datlen = val + hlen;
                
                sprintf_f(rs->logs, "bitmap info color: %d, w: %d, h: %d, dpi: %d, imglen: %d, use: %d duo\n", clr, w, h, dpi, val, hlen);
                print_f(rs->plogs, "P6", rs->logs);
                
#if BMP_TEST /* for test */
                if (clr == 8) {
                    bitmapHeaderSetup(bheader, 8, 5184, 6524, 300, val);
                } else {
                    //bitmapHeaderSetup(bheader, 24, 2304, 3456, 600, val);
                    bitmapHeaderSetup(bheader, 24, 2160, 3496, 600, val);
                }
#else           
                bitmapHeaderSetup(bheader, clr, w, hduo, dpi, val);
#endif          
                ph = &rs->pbheaderDuo->aspbmpMagic[2];
                len = sizeof(struct bitmapHeader_s) - 2;
                memcpy(hbuff, ph, len);
                
                hlen -= len;
                if (hlen > 0) {
                    bitmapColorTableSetup(hbuff+len);
                    hlen -= 1024;
                }
                
                if (hlen) {
                    printf("[fs98] Error!!! the bitmap header len is wrong %d orginal is %d\n", hlen, orglen);
                    hlen = 0;
                } 
                
                dbgBitmapHeader(bheader, len);
                
                sendbuf[3] = 'l';
                
                sprintf(rs->logs, "%d,\n\r", orglen*2);
                n = strlen(rs->logs);
                if (n > (P6_SEND_BUFF_SIZE - 32)) n = P6_SEND_BUFF_SIZE - 32;
                
                memcpy(&sendbuf[5], rs->logs, n);
                
                sendbuf[5+n] = 0xfb;
                sendbuf[5+n+1] = '\n';
                sendbuf[5+n+2] = '\0';
                ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d duo\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
                print_f(rs->plogs, "P6", rs->logs);
                
                sendbuf[3] = 'b';
                
                bin2hex(&sendbuf[5], hbuff, orglen);
                //memcpy(&sendbuf[5], hbuff, orglen);
                //memset(&sendbuf[5], 0x95, P6_SEND_BUFF_SIZE - 5);
                
                n = orglen * 2;
                
                sendbuf[5+n] = 0xfb;
                sendbuf[5+n+1] = '\n';
                sendbuf[5+n+2] = '\0';
                
                //shmem_dump(sendbuf, P6_SEND_BUFF_SIZE);
                            
                ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                //sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
                //print_f(rs->plogs, "P6", rs->logs);
            }
            
            while (1) {
                num = 0;
                for (i = 0; i < (CROP_MAX_NUM_META+1); i++) {
                    idx = ASPOP_CROP_01 + i;
                    
                    switch(idx) {
                        case ASPOP_CROP_01:
                        case ASPOP_CROP_02:
                        case ASPOP_CROP_03:
                        case ASPOP_CROP_04:
                        case ASPOP_CROP_05:
                        case ASPOP_CROP_06:
                        case ASPOP_CROP_07:
                        case ASPOP_CROP_08:
                        case ASPOP_CROP_09:
                        case ASPOP_CROP_10:
                        case ASPOP_CROP_11:
                        case ASPOP_CROP_12:
                        case ASPOP_CROP_13:
                        case ASPOP_CROP_14:
                        case ASPOP_CROP_15:
                        case ASPOP_CROP_16:
                        case ASPOP_CROP_17:
                        case ASPOP_CROP_18:
                            pdt = &pct[idx];
                            if (pdt->opStatus == ASPOP_STA_UPD) {
                                num++;
                            }

                            break;
                        default:
                            break;
                    }
                    
                }

                if (num == CROP_MAX_NUM_META) {
                    break;
                }

                sprintf_f(rs->logs, "wait crop %d, %d s\n", num, cnt/2);
                print_f(rs->plogs, "P6", rs->logs);

                usleep(500000);
            }
            
            for (i = 0; i < (CROP_MAX_NUM_META+1); i++) {
                idx = ASPOP_CROP_01 + i;
                pdt = &pct[idx];
                switch(idx) {
                    case ASPOP_CROP_01:
                    case ASPOP_CROP_02:
                    case ASPOP_CROP_03:
                    case ASPOP_CROP_04:
                    case ASPOP_CROP_05:
                    case ASPOP_CROP_06:
                    case ASPOP_CROP_07:
                    case ASPOP_CROP_08:
                    case ASPOP_CROP_09:
                    case ASPOP_CROP_10:
                    case ASPOP_CROP_11:
                    case ASPOP_CROP_12:
                    case ASPOP_CROP_13:
                    case ASPOP_CROP_14:
                    case ASPOP_CROP_15:
                    case ASPOP_CROP_16:
                    case ASPOP_CROP_17:
                    case ASPOP_CROP_18:
                        pdt = &pct[idx];
                        if (pdt->opStatus == ASPOP_STA_UPD) {
#if LOG_P6_CROP_EN
                            sprintf_f(rs->logs, "CROP%.2d. [0x%.8x]     {%d,  %d}  \n", i, pdt->opValue, pdt->opValue >> 16, pdt->opValue & 0xffff); 
                            print_f(rs->plogs, "P6", rs->logs);  
#endif
                            pdt->opStatus = ASPOP_STA_APP;
                        }

                        break;
                    default:
                        break;
                }
            }

            #if !MOVE_MUTX_TO_FRONT_P6
            ch = 0;
            while (ch != 'd') {
                ret = rs_ipc_get_ms(rs, &ch, 1, 500);
                if (ret > 0) {
                    if (ch == 'd') {
                        sprintf_f(rs->logs, "succeed to get ch1 == %c\n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    } else {
                        sprintf_f(rs->logs, "wrong!! ch1 == %c \n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    }
                } else {
                    sprintf_f(rs->logs, "wait for d1 ret: \n", ret);
                    print_f(rs->plogs, "P6", rs->logs);    
                }
            }
            ch = 0;
            while (ch != 'd') {
                ret = rs_ipc_get_ms(rs, &ch, 1, 500);
                if (ret > 0) {
                    if (ch == 'd') {
                        sprintf_f(rs->logs, "succeed to get ch2 == %c\n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    } else {
                        sprintf_f(rs->logs, "wrong!! ch2 == %c \n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    }
                } else {
                    sprintf_f(rs->logs, "wait for d2 ret: \n", ret);
                    print_f(rs->plogs, "P6", rs->logs);    
                }
            }
            #endif

            msync(pmass, sizeof(struct aspMetaMass_s), MS_SYNC);
            
            if (pmass->massRecd) {

                memset(pmass->masspt, 0, pmass->massMax);
                msync(pmass->masspt, pmass->massMax, MS_SYNC);
                
                pmass->massRecd = 0;
                pmass->massUsed = 0;
            }

            while (1) {
                num = 0;
                for (i = 0; i < (CROP_MAX_NUM_META+1); i++) {
                    idx = ASPOP_CROP_01_DUO+ i;
                    
                    switch(idx) {
                        case ASPOP_CROP_01_DUO:
                        case ASPOP_CROP_02_DUO:
                        case ASPOP_CROP_03_DUO:
                        case ASPOP_CROP_04_DUO:
                        case ASPOP_CROP_05_DUO:
                        case ASPOP_CROP_06_DUO:
                        case ASPOP_CROP_07_DUO:
                        case ASPOP_CROP_08_DUO:
                        case ASPOP_CROP_09_DUO:
                        case ASPOP_CROP_10_DUO:
                        case ASPOP_CROP_11_DUO:
                        case ASPOP_CROP_12_DUO:
                        case ASPOP_CROP_13_DUO:
                        case ASPOP_CROP_14_DUO:
                        case ASPOP_CROP_15_DUO:
                        case ASPOP_CROP_16_DUO:
                        case ASPOP_CROP_17_DUO:
                        case ASPOP_CROP_18_DUO:                         
                            pdt = &pct[idx];
                            if (pdt->opStatus == ASPOP_STA_UPD) {
                                num++;
                            }

                            break;
                        default:
                            break;
                    }
                    
                }

                if (num == CROP_MAX_NUM_META) {
                    break;
                }

                sprintf_f(rs->logs, "wait duo crop num:%d, %d s\n", num, cnt/2);
                print_f(rs->plogs, "P6", rs->logs);

                usleep(500000);
            }
            
            for (i = 0; i < (CROP_MAX_NUM_META+1); i++) {
                idx = ASPOP_CROP_01_DUO+ i;
                pdt = &pct[idx];
                switch(idx) {
                    case ASPOP_CROP_01_DUO:
                    case ASPOP_CROP_02_DUO:
                    case ASPOP_CROP_03_DUO:
                    case ASPOP_CROP_04_DUO:
                    case ASPOP_CROP_05_DUO:
                    case ASPOP_CROP_06_DUO:
                    case ASPOP_CROP_07_DUO:
                    case ASPOP_CROP_08_DUO:
                    case ASPOP_CROP_09_DUO:
                    case ASPOP_CROP_10_DUO:
                    case ASPOP_CROP_11_DUO:
                    case ASPOP_CROP_12_DUO:
                    case ASPOP_CROP_13_DUO:
                    case ASPOP_CROP_14_DUO:
                    case ASPOP_CROP_15_DUO:
                    case ASPOP_CROP_16_DUO:
                    case ASPOP_CROP_17_DUO:
                    case ASPOP_CROP_18_DUO:
                        pdt = &pct[idx];
                        if (pdt->opStatus == ASPOP_STA_UPD) {
#if LOG_P6_CROP_EN
                            sprintf_f(rs->logs, "CROP%.2d. [0x%.8x]     {%d,  %d}  \n", i, pdt->opValue, pdt->opValue >> 16, pdt->opValue & 0xffff); 
                            print_f(rs->plogs, "P6", rs->logs);  
#endif
                            pdt->opStatus = ASPOP_STA_APP;
                            pdt->opValue = 0;
                        }

                        break;
                    default:
                        break;
                }
            }

            msync(pmassduo, sizeof(struct aspMetaMass_s), MS_SYNC);
            
            if (pmassduo->massRecd) {

                memset(pmassduo->masspt, 0, pmassduo->massMax);
                msync(pmassduo->masspt, pmassduo->massMax, MS_SYNC);

                pmassduo->massRecd = 0;
                pmassduo->massUsed = 0;
            }

            val = 0;
            ret = cfgTableGetChk(pct, ASPOP_IMG_LEN, &val, ASPOP_STA_APP);    
            #if LOG_P6_PARA_EN
            sprintf_f(rs->logs, "user defined image length: %d, ret:%d\n", val, ret);
            print_f(rs->plogs, "P6", rs->logs);
            #endif
            h = val;

            val = 0;
            ret = cfgTableGetChk(pct, ASPOP_IMG_LEN_DUO, &val, ASPOP_STA_APP);    
            #if LOG_P6_PARA_EN
            sprintf_f(rs->logs, "duo user defined image length: %d, ret:%d\n", val, ret);
            print_f(rs->plogs, "P6", rs->logs);
            #endif
            hduo = val;

            sprintf_f(rs->logs, "param: %c, image len: %d (%d) duo: %d (%d) \n", param, h, pct[ASPOP_IMG_LEN].opValue, hduo, pct[ASPOP_IMG_LEN_DUO].opValue);
            print_f(rs->plogs, "P6", rs->logs); 
            
            if ((param == 'E') || (h == 0) || (csws != 0) || (cswd != 0)) {
                rs_ipc_put(rs, "Q", 1);
                sprintf_f(rs->logs, "return \"Q\" \n");
                print_f(rs->plogs, "P6", rs->logs);    
            } else {
                rs_ipc_put(rs, "D", 1);
                sprintf_f(rs->logs, "return \"D\" \n");
                print_f(rs->plogs, "P6", rs->logs);    
            }
            
            goto socketEnd;
        }
        
        if (opcode == 0x22) { /* send img length*/
            sprintf_f(rs->logs, "handle opcode: 0x%x param: 0x%x (imglen)\n", opcode, param);
            print_f(rs->plogs, "P6", rs->logs);
            
            #if MOVE_MUTX_TO_FRONT_P6
            ch = 0;
            while (ch != 'c') {
                ret = rs_ipc_get_ms(rs, &ch, 1, 500);
                if (ret > 0) {
                    if (ch == 'c') {
                        sprintf_f(rs->logs, "succeed to get ch == %c\n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    } else {
                        sprintf_f(rs->logs, "warnning!! ch == %c \n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    }
                } else {
                    sprintf_f(rs->logs, "wait for c ret: %d \n", ret);
                    print_f(rs->plogs, "P6", rs->logs);    
                }
            }
            #endif
            
            pdt = &pct[ASPOP_IMG_LEN];
            cnt = 0;
            while (pdt->opStatus != ASPOP_STA_UPD) {
                usleep(2000);

                if (((cnt+1) % 500) == 0) {
                    sprintf_f(rs->logs, "wait img len cnt: %d \n", cnt);
                    print_f(rs->plogs, "P6", rs->logs);    
                }

                msync(pdt, sizeof(struct aspConfig_s), MS_SYNC);

                cnt ++;
            }
            pdt->opStatus = ASPOP_STA_APP;
            
            sendbuf[3] = 'H';

            sprintf(rs->logs, "%d,\n\r", pdt->opValue & 0xffff);
            n = strlen(rs->logs);
            if (n > 256) n = 256;

            memcpy(&sendbuf[5], rs->logs, n);

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            print_f(rs->plogs, "P6", rs->logs);            

            /* send back bmp header */
            ret = cfgTableGetChk(pct, ASPOP_FILE_FORMAT, &tmp, ASPOP_STA_APP);    
            #if LOG_P6_PARA_EN
            sprintf_f(rs->logs, "user defined file format: %d, ret:%d\n", tmp, ret);
            print_f(rs->plogs, "P6", rs->logs);
            #endif
            
            val = 0;
            ret = cfgTableGetChk(pct, ASPOP_SCAN_SIDE, &val, ASPOP_STA_UPD);
            
            //sprintf_f(rs->logs, "get usb page side: 0x%.2x ret: %d\n", val, ret);
            //print_f(rs->plogs, "P6", rs->logs);

            sendbuf[3] = 'P';

            sprintf(rs->logs, "%d,\n\r", val & 0xff);
            n = strlen(rs->logs);
            if (n > 256) n = 256;

            memcpy(&sendbuf[5], rs->logs, n);

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            //sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            //print_f(rs->plogs, "P6", rs->logs);
            

            csws = 0;
            cfgTableGetChk(pct, ASPOP_SCAN_STATUS, &csws, ASPOP_STA_UPD);
            
            sprintf_f(rs->logs, "get usb scan status: 0x%.2x ret: %d\n", csws, ret);
            print_f(rs->plogs, "P6", rs->logs);

            sendbuf[3] = 'S';

            sprintf(rs->logs, "%d,\n\r", csws & 0xff);
            n = strlen(rs->logs);
            if (n > 256) n = 256;

            memcpy(&sendbuf[5], rs->logs, n);

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            //sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            //print_f(rs->plogs, "P6", rs->logs);

            #if !MOVE_MUTX_TO_FRONT_P6
            ch = 0;
            while (ch != 'c') {
                ret = rs_ipc_get_ms(rs, &ch, 1, 500);
                if (ret > 0) {
                    if (ch == 'c') {
                        sprintf_f(rs->logs, "succeed to get ch == %c\n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    } else {
                        sprintf_f(rs->logs, "warnning!! ch == %c \n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    }
                } else {
                    sprintf_f(rs->logs, "wait for c ret: \n", ret);
                    print_f(rs->plogs, "P6", rs->logs);    
                }
            }
            #endif
            
            val = 0;
            ret = cfgTableGetChk(pct, ASPOP_IMG_LEN, &val, ASPOP_STA_APP);    
            #if LOG_P6_PARA_EN
            sprintf_f(rs->logs, "user defined image length: %d, ret:%d\n", val, ret);
            print_f(rs->plogs, "P6", rs->logs);
            #endif
            h = val;

            if (tmp == FILE_FORMAT_RAW) {
                ph = &rs->pbheader->aspbmpMagic[2];
                len = sizeof(struct bitmapHeader_s) - 2;
                bheader = rs->pbheader;
                clr=0;w=0;dpi=0;
                
                //dbgBitmapHeader(bheader, len);
                
                /* bmp header needs 1.width 2.height 3.dpi 4.raw size */
                ret = cfgTableGetChk(pct, ASPOP_COLOR_MODE, &tmp, ASPOP_STA_APP);    
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "user defined color mode: %d, ret:%d\n", tmp, ret);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
                
                switch (tmp) {
                    case COLOR_MODE_COLOR:
                        clr = 24;
                        break;
                    case COLOR_MODE_GRAY:
                    case COLOR_MODE_GRAY_DETAIL:
                    case COLOR_MODE_BLACKWHITE:
                        clr = 8;
                        break;
                    default:
                        clr = 24;
                        break;
                }

                ret = cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_H, &val, ASPOP_STA_APP);    
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "user defined width high: %d, ret:%d\n", val, ret);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
                
                ret = cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_L, &tmp, ASPOP_STA_APP);    
                t = val << 8 | tmp;
                
                val = 0;
                ret = cfgTableGetChk(pct, ASPOP_SCAN_WIDTH, &val, ASPOP_STA_UPD);

                w = scanWidthConvert(t, val);
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "user defined width low: %d, ret:%d, w = %d (tag:%d)\n", tmp, ret, w, t);
                print_f(rs->plogs, "P6", rs->logs);
                #endif

                tmp = 0;
                ret = cfgTableGetChkDPI(pct, ASPOP_RESOLUTION, &tmp, ASPOP_STA_APP); 
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "user defined resulution: %d, ret:%d\n", tmp, ret);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
                dpi = tmp;
                
                //pct[ASPOP_IMG_LEN].opStatus = ASPOP_STA_APP;
                
                hbuff = aspMemalloc(1078, 6);
                if (!hbuff) {
                    goto socketEnd;
                }
                
                if (clr == 8) {
                    hlen = 1078;
                } else if (clr == 24) {
                    hlen = 54;            
                } else {
                    printf("[P6] ERROR!!! color bits is %d \n", clr);
                    goto socketEnd;
                }
                
                orglen = hlen;
                
                ret = cfgTableGetChk(pct, ASPOP_RAW_SIZE, &val, ASPOP_STA_APP);    
                sprintf_f(rs->logs, "scan raw data size: %d, ret:%d\n", val, ret);
                print_f(rs->plogs, "P6", rs->logs);
                
                /* calculate sector start and sector length of file */            
                
                datlen = val + hlen;
                
                sprintf_f(rs->logs, "bitmap info color: %d, w: %d, h: %d, dpi: %d, imglen: %d, use: %d\n", clr, w, h, dpi, val, hlen);
                print_f(rs->plogs, "P6", rs->logs);
                
#if BMP_TEST /* for test */
                if (clr == 8) {
                    bitmapHeaderSetup(bheader, 8, 5184, 6524, 300, val);
                } else {
                    //bitmapHeaderSetup(bheader, 24, 2304, 3456, 600, val);
                    bitmapHeaderSetup(bheader, 24, 2160, 3496, 600, val);
                }
#else           
                bitmapHeaderSetup(bheader, clr, w, h, dpi, val);
#endif          
                ph = &rs->pbheader->aspbmpMagic[2];
                len = sizeof(struct bitmapHeader_s) - 2;
                memcpy(hbuff, ph, len);
                
                hlen -= len;
                if (hlen > 0) {
                    bitmapColorTableSetup(hbuff+len);
                    hlen -= 1024;
                }
                
                if (hlen) {
                    printf("[fs98] Error!!! the bitmap header len is wrong %d orginal is %d\n", hlen, orglen);
                    hlen = 0;
                } 
                
                dbgBitmapHeader(bheader, len);
                
                sendbuf[3] = 'L';
                
                sprintf(rs->logs, "%d,\n\r", orglen*2);
                n = strlen(rs->logs);
                if (n > (P6_SEND_BUFF_SIZE - 32)) n = P6_SEND_BUFF_SIZE - 32;
                
                memcpy(&sendbuf[5], rs->logs, n);
                
                sendbuf[5+n] = 0xfb;
                sendbuf[5+n+1] = '\n';
                sendbuf[5+n+2] = '\0';
                ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
                print_f(rs->plogs, "P6", rs->logs);
                
                sendbuf[3] = 'B';
                
                bin2hex(&sendbuf[5], hbuff, orglen);
                //memcpy(&sendbuf[5], hbuff, orglen);
                //memset(&sendbuf[5], 0x95, P6_SEND_BUFF_SIZE - 5);
                
                n = orglen * 2;
                
                sendbuf[5+n] = 0xfb;
                sendbuf[5+n+1] = '\n';
                sendbuf[5+n+2] = '\0';
                
                //shmem_dump(sendbuf, P6_SEND_BUFF_SIZE);
                            
                ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                //sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
                //print_f(rs->plogs, "P6", rs->logs);
            }

            while (1) {
                num = 0;
                for (i = 0; i < (CROP_MAX_NUM_META+1); i++) {
                    idx = ASPOP_CROP_01 + i;
                    
                    switch(idx) {
                        case ASPOP_CROP_01:
                        case ASPOP_CROP_02:
                        case ASPOP_CROP_03:
                        case ASPOP_CROP_04:
                        case ASPOP_CROP_05:
                        case ASPOP_CROP_06:
                        case ASPOP_CROP_07:
                        case ASPOP_CROP_08:
                        case ASPOP_CROP_09:
                        case ASPOP_CROP_10:
                        case ASPOP_CROP_11:
                        case ASPOP_CROP_12:
                        case ASPOP_CROP_13:
                        case ASPOP_CROP_14:
                        case ASPOP_CROP_15:
                        case ASPOP_CROP_16:
                        case ASPOP_CROP_17:
                        case ASPOP_CROP_18:
                            pdt = &pct[idx];
                            if (pdt->opStatus == ASPOP_STA_UPD) {
                                num++;
                            }

                            break;
                        default:
                            break;
                    }
                    
                }

                if (num == CROP_MAX_NUM_META) {
                    break;
                }

                sprintf_f(rs->logs, "wait crop %d, %d s\n", num, cnt/2);
                print_f(rs->plogs, "P6", rs->logs);

                usleep(500000);
            }

            for (i = 0; i < (CROP_MAX_NUM_META+1); i++) {
                idx = ASPOP_CROP_01 + i;
                pdt = &pct[idx];
                switch(idx) {
                    case ASPOP_CROP_01:
                    case ASPOP_CROP_02:
                    case ASPOP_CROP_03:
                    case ASPOP_CROP_04:
                    case ASPOP_CROP_05:
                    case ASPOP_CROP_06:
                    case ASPOP_CROP_07:
                    case ASPOP_CROP_08:
                    case ASPOP_CROP_09:
                    case ASPOP_CROP_10:
                    case ASPOP_CROP_11:
                    case ASPOP_CROP_12:
                    case ASPOP_CROP_13:
                    case ASPOP_CROP_14:
                    case ASPOP_CROP_15:
                    case ASPOP_CROP_16:
                    case ASPOP_CROP_17:
                    case ASPOP_CROP_18:
                        pdt = &pct[idx];
                        if (pdt->opStatus == ASPOP_STA_UPD) {
#if LOG_P6_CROP_EN
                            sprintf_f(rs->logs, "CROP%.2d. [0x%.8x]     {%d,  %d}  \n", i, pdt->opValue, pdt->opValue >> 16, pdt->opValue & 0xffff); 
                            print_f(rs->plogs, "P6", rs->logs);  
#endif
                            pdt->opStatus = ASPOP_STA_APP;
                            pdt->opValue = 0;
                        }

                        break;
                    default:
                        break;
                }
            }
            
            msync(pmass, sizeof(struct aspMetaMass_s), MS_SYNC);
            
            if (pmass->massRecd > 1) {
                masUsed = pmass->massUsed;
                
                while (!masUsed) {
                    usleep(500000);
                    msync(pmass, sizeof(struct aspMetaMass_s), MS_SYNC);
                    masUsed = pmass->massUsed;
                    sprintf_f(rs->logs, "wait meta mass (used:%d) %d\n", masUsed, cnt); 
                    print_f(rs->plogs, "P6", rs->logs);
                }

                memset(pmass->masspt, 0, pmass->massMax);
                msync(pmass->masspt, pmass->massMax, MS_SYNC);
            }

            pmass->massRecd = 0;
            pmass->massUsed = 0;

            sprintf_f(rs->logs, "param: %c, image len: %d (%d) \n", param, h, pct[ASPOP_IMG_LEN].opValue);
            print_f(rs->plogs, "P6", rs->logs); 
            
            if ((param == 'E') || (h == 0)) {
                rs_ipc_put(rs, "E", 1);
                sprintf_f(rs->logs, "return \"E\" \n");
                print_f(rs->plogs, "P6", rs->logs);    
            } else {
                rs_ipc_put(rs, "C", 1);
                sprintf_f(rs->logs, "return \"C\" \n");
                print_f(rs->plogs, "P6", rs->logs);    
            }

            goto socketEnd;
        }
        
        if (opcode == 0x21) { /* send CROP info (raw)*/
            #define CROP_MAX_NUM (6)
            sprintf_f(rs->logs, "handle opcode: 0x%x(raw)\n", opcode);
            print_f(rs->plogs, "P6", rs->logs);

            pdt = &pct[ASPOP_IMG_LEN];
            sendbuf[3] = 'H';

            sprintf(rs->logs, "%d,\n\r", pdt->opValue & 0xffff);
            n = strlen(rs->logs);
            if (n > 256) n = 256;

            memcpy(&sendbuf[5], rs->logs, n);

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            print_f(rs->plogs, "P6", rs->logs);

            val = 0;
            ret = cfgTableGetChk(pct, ASPOP_SCAN_SIDE, &val, ASPOP_STA_UPD);
            
            //sprintf_f(rs->logs, "get usb page side: 0x%.2x ret: %d\n", val, ret);
            //print_f(rs->plogs, "P6", rs->logs);

            sendbuf[3] = 'P';

            sprintf(rs->logs, "%d,\n\r", val & 0xff);
            n = strlen(rs->logs);
            if (n > 256) n = 256;

            memcpy(&sendbuf[5], rs->logs, n);

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            //sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            //print_f(rs->plogs, "P6", rs->logs);
            
            goto socketEnd;
        }
        
        if (opcode == 0x20) { /* send CROP info (duo)*/
            sprintf_f(rs->logs, "handle opcode: 0x%x param: 0x%x (CROP duo)\n", opcode, param);
            print_f(rs->plogs, "P6", rs->logs);

            #if MOVE_MUTX_TO_FRONT_P6
            ch = 0; 
            while (ch != 'd') {
                ret = rs_ipc_get_ms(rs, &ch, 1, 500);
                if (ret > 0) {
                    if (ch == 'd') {
                        sprintf_f(rs->logs, "succeed to get ch == %c\n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    } else {
                        sprintf_f(rs->logs, "wrong!! ch == %c \n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    }
                } else {
                    sprintf_f(rs->logs, "wait for d1 ret: %d\n", ret);
                    print_f(rs->plogs, "P6", rs->logs);    
                }
            }
            ch = 0; 
            while (ch != 'd') {
                ret = rs_ipc_get_ms(rs, &ch, 1, 500);
                if (ret > 0) {
                    if (ch == 'd') {
                        sprintf_f(rs->logs, "duo succeed to get ch == %c\n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    } else {
                        sprintf_f(rs->logs, "duo wrong!! ch == %c \n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    }
                } else {
                    sprintf_f(rs->logs, "wait for d2 ret: %d\n", ret);
                    print_f(rs->plogs, "P6", rs->logs);    
                }
            }
            #endif //#if MOVE_MUTX_TO_FRONT_P6
            
            ret = cfgTableGetChk(pct, ASPOP_FILE_FORMAT, &ffrmt, ASPOP_STA_APP); 
            #if LOG_P6_PARA_EN
            sprintf_f(rs->logs, "user defined file format: %d, ret:%d\n", ffrmt, ret);
            print_f(rs->plogs, "P6", rs->logs);
            #endif

            tmp = 0;
            ret = cfgTableGetChkDPI(pct, ASPOP_RESOLUTION, &tmp, ASPOP_STA_APP);    
            dpi = tmp;

            #if LOG_P6_PARA_EN
            sprintf_f(rs->logs, "user defined resulution: %d(%d dpi), ret:%d\n", tmp, dpi, ret);
            print_f(rs->plogs, "P6", rs->logs);
            #endif
            
            cnt = 0;
            while (1) {
                num = 0;
                for (i = 0; i < (CROP_MAX_NUM_META+1); i++) {
                    idx = ASPOP_CROP_01 + i;
                    
                    switch(idx) {
                        case ASPOP_CROP_01:
                        case ASPOP_CROP_02:
                        case ASPOP_CROP_03:
                        case ASPOP_CROP_04:
                        case ASPOP_CROP_05:
                        case ASPOP_CROP_06:
                        case ASPOP_CROP_07:
                        case ASPOP_CROP_08:
                        case ASPOP_CROP_09:
                        case ASPOP_CROP_10:
                        case ASPOP_CROP_11:
                        case ASPOP_CROP_12:
                        case ASPOP_CROP_13:
                        case ASPOP_CROP_14:
                        case ASPOP_CROP_15:
                        case ASPOP_CROP_16:
                        case ASPOP_CROP_17:
                        case ASPOP_CROP_18:
                            pdt = &pct[idx];
                            if (pdt->opStatus == ASPOP_STA_UPD) {
                                num++;
                            }

                            break;
                        default:
                            break;
                    }
                    
                }

                if (num == CROP_MAX_NUM_META) {
                    break;
                }

                sprintf_f(rs->logs, "wait crop %d, %d s\n", num, cnt/2);
                print_f(rs->plogs, "P6", rs->logs);
/*
                if (cnt > 10) {
                    break;
                }
*/
                usleep(500000);
                cnt ++;
            }

            cnt = 0;
            while (1) {
                num = 0;
                for (i = 0; i < (CROP_MAX_NUM_META+1); i++) {
                    idx = ASPOP_CROP_01_DUO+ i;
                    
                    switch(idx) {
                        case ASPOP_CROP_01_DUO:
                        case ASPOP_CROP_02_DUO:
                        case ASPOP_CROP_03_DUO:
                        case ASPOP_CROP_04_DUO:
                        case ASPOP_CROP_05_DUO:
                        case ASPOP_CROP_06_DUO:
                        case ASPOP_CROP_07_DUO:
                        case ASPOP_CROP_08_DUO:
                        case ASPOP_CROP_09_DUO:
                        case ASPOP_CROP_10_DUO:
                        case ASPOP_CROP_11_DUO:
                        case ASPOP_CROP_12_DUO:
                        case ASPOP_CROP_13_DUO:
                        case ASPOP_CROP_14_DUO:
                        case ASPOP_CROP_15_DUO:
                        case ASPOP_CROP_16_DUO:
                        case ASPOP_CROP_17_DUO:
                        case ASPOP_CROP_18_DUO:                         
                            pdt = &pct[idx];
                            if (pdt->opStatus == ASPOP_STA_UPD) {
                                num++;
                            }

                            break;
                        default:
                            break;
                    }
                    
                }

                if (num == CROP_MAX_NUM_META) {
                    break;
                }

                sprintf_f(rs->logs, "wait duo crop num:%d, %d s\n", num, cnt/2);
                print_f(rs->plogs, "P6", rs->logs);
/*
                if (cnt > 10) {
                    break;
                }
*/
                usleep(500000);
                cnt ++;
            }

            /* send back bmp header */
            ret = cfgTableGetChk(pct, ASPOP_FILE_FORMAT, &tmp, ASPOP_STA_APP);    
            #if LOG_P6_PARA_EN
            sprintf_f(rs->logs, "user defined file format: %d, ret:%d\n", tmp, ret);
            print_f(rs->plogs, "P6", rs->logs);
            #endif

            val = 0;
            ret = cfgTableGetChk(pct, ASPOP_IMG_LEN, &val, ASPOP_STA_APP);
            #if LOG_P6_PARA_EN
            sprintf_f(rs->logs, "user defined image length: %d, ret:%d\n", val, ret);
            print_f(rs->plogs, "P6", rs->logs);
            #endif
            h = val;
                
            if (tmp == FILE_FORMAT_RAW) {
                ph = &rs->pbheader->aspbmpMagic[2];
                len = sizeof(struct bitmapHeader_s) - 2;
                bheader = rs->pbheader;
                clr=0;w=0;dpi=0;
                
                //dbgBitmapHeader(bheader, len);
                
                /* bmp header needs 1.width 2.height 3.dpi 4.raw size */
                ret = cfgTableGetChk(pct, ASPOP_COLOR_MODE, &tmp, ASPOP_STA_APP);
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "user defined color mode: %d, ret:%d\n", tmp, ret);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
                
                switch (tmp) {
                    case COLOR_MODE_COLOR:
                        clr = 24;
                        break;
                    case COLOR_MODE_GRAY:
                    case COLOR_MODE_GRAY_DETAIL:
                    case COLOR_MODE_BLACKWHITE:
                        clr = 8;
                        break;
                    default:
                        clr = 24;
                        break;
                }

                ret = cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_H, &val, ASPOP_STA_APP);
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "user defined width high: %d, ret:%d\n", val, ret);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
                
                ret = cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_L, &tmp, ASPOP_STA_APP);    
                t = val << 8 | tmp;
                
                val = 0;
                ret = cfgTableGetChk(pct, ASPOP_SCAN_WIDTH, &val, ASPOP_STA_UPD);

                w = scanWidthConvert(t, val);
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "user defined width low: %d, ret:%d, w = %d (tag:%d)\n", tmp, ret, w, t);
                print_f(rs->plogs, "P6", rs->logs);
                #endif

                tmp = 0;
                ret = cfgTableGetChkDPI(pct, ASPOP_RESOLUTION, &tmp, ASPOP_STA_APP);    
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "user defined resulution: %d, ret:%d\n", tmp, ret);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
                dpi = tmp;
                
                //pct[ASPOP_IMG_LEN].opStatus = ASPOP_STA_APP;
                
                hbuff = aspMemalloc(1078, 6);
                if (!hbuff) {
                    goto socketEnd;
                }
                
                if (clr == 8) {
                    hlen = 1078;
                } else if (clr == 24) {
                    hlen = 54;            
                } else {
                    printf("[P6] ERROR!!! color bits is %d \n", clr);
                    goto socketEnd;
                }
                
                orglen = hlen;
                
                ret = cfgTableGetChk(pct, ASPOP_RAW_SIZE, &val, ASPOP_STA_APP);    
                sprintf_f(rs->logs, "scan raw data size: %d, ret:%d\n", val, ret);
                print_f(rs->plogs, "P6", rs->logs);
                
                /* calculate sector start and sector length of file */            
                
                datlen = val + hlen;
                
                sprintf_f(rs->logs, "bitmap info color: %d, w: %d, h: %d, dpi: %d, imglen: %d, use: %d\n", clr, w, h, dpi, val, hlen);
                print_f(rs->plogs, "P6", rs->logs);
                
                #if BMP_TEST /* for test */
                if (clr == 8) {
                    bitmapHeaderSetup(bheader, 8, 5184, 6524, 300, val);
                } else {
                    //bitmapHeaderSetup(bheader, 24, 2304, 3456, 600, val);
                    bitmapHeaderSetup(bheader, 24, 2160, 3496, 600, val);
                }
                #else           
                bitmapHeaderSetup(bheader, clr, w, h, dpi, val);
                #endif
                
                ph = &rs->pbheader->aspbmpMagic[2];
                len = sizeof(struct bitmapHeader_s) - 2;
                memcpy(hbuff, ph, len);
                
                hlen -= len;
                if (hlen > 0) {
                    bitmapColorTableSetup(hbuff+len);
                    hlen -= 1024;
                }
                
                if (hlen) {
                    printf("[fs98] Error!!! the bitmap header len is wrong %d orginal is %d\n", hlen, orglen);
                    hlen = 0;
                } 
                
                dbgBitmapHeader(bheader, len);
                
                sendbuf[3] = 'L';
                
                sprintf(rs->logs, "%d,\n\r", orglen*2);
                n = strlen(rs->logs);
                if (n > (P6_SEND_BUFF_SIZE - 32)) n = P6_SEND_BUFF_SIZE - 32;
                
                memcpy(&sendbuf[5], rs->logs, n);
                
                sendbuf[5+n] = 0xfb;
                sendbuf[5+n+1] = '\n';
                sendbuf[5+n+2] = '\0';
                ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
                print_f(rs->plogs, "P6", rs->logs);
                
                sendbuf[3] = 'B';
                
                bin2hex(&sendbuf[5], hbuff, orglen);
                //memcpy(&sendbuf[5], hbuff, orglen);
                //memset(&sendbuf[5], 0x95, P6_SEND_BUFF_SIZE - 5);
                
                n = orglen * 2;
                
                sendbuf[5+n] = 0xfb;
                sendbuf[5+n+1] = '\n';
                sendbuf[5+n+2] = '\0';
                
                //shmem_dump(sendbuf, P6_SEND_BUFF_SIZE);
                            
                ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                //sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
                //print_f(rs->plogs, "P6", rs->logs);
            }

            /* send back bmp header */
            ret = cfgTableGetChk(pct, ASPOP_FILE_FORMAT, &tmp, ASPOP_STA_APP);    
            #if LOG_P6_PARA_EN
            sprintf_f(rs->logs, "user defined file format: %d, ret:%d\n", tmp, ret);
            print_f(rs->plogs, "P6", rs->logs);
            #endif

            val = 0;
            ret = cfgTableGetChk(pct, ASPOP_IMG_LEN_DUO, &val, ASPOP_STA_APP);    
            #if LOG_P6_PARA_EN
            sprintf_f(rs->logs, "user defined image length: %d, ret:%d duo\n", val, ret);
            print_f(rs->plogs, "P6", rs->logs);
            #endif
            hduo = val;

            if (tmp == FILE_FORMAT_RAW) { /* second page */
                ph = &rs->pbheaderDuo->aspbmpMagic[2];
                len = sizeof(struct bitmapHeader_s) - 2;
                bheader = rs->pbheaderDuo;
                clr=0;w=0;dpi=0;
                
                //dbgBitmapHeader(bheader, len);
                
                /* bmp header needs 1.width 2.height 3.dpi 4.raw size */
                ret = cfgTableGetChk(pct, ASPOP_COLOR_MODE, &tmp, ASPOP_STA_APP);    
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "user defined color mode: %d, ret:%d\n", tmp, ret);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
                switch (tmp) {
                    case COLOR_MODE_COLOR:
                        clr = 24;
                        break;
                    case COLOR_MODE_GRAY:
                    case COLOR_MODE_GRAY_DETAIL:
                    case COLOR_MODE_BLACKWHITE:
                        clr = 8;
                        break;
                    default:
                        clr = 24;
                        break;
                }
                
                ret = cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_H, &val, ASPOP_STA_APP);    
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "user defined width high: %d, ret:%d\n", val, ret);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
                
                ret = cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_L, &tmp, ASPOP_STA_APP);    
                t = val << 8 | tmp;
                
                val = 0;
                ret = cfgTableGetChk(pct, ASPOP_SCAN_WIDTH_DUO, &val, ASPOP_STA_UPD);

                w = scanWidthConvert(t, val);
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "user defined width low: %d, ret:%d, w = %d (tag:%d)\n", tmp, ret, w, t);
                print_f(rs->plogs, "P6", rs->logs);
                #endif

                tmp = 0;
                ret = cfgTableGetChkDPI(pct, ASPOP_RESOLUTION, &tmp, ASPOP_STA_APP);    
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "user defined resulution: %d, ret:%d\n", tmp, ret);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
                dpi = tmp;
                
                hbuff = aspMemalloc(1078, 6);
                if (!hbuff) {
                    goto socketEnd;
                }
                
                if (clr == 8) {
                    hlen = 1078;
                } else if (clr == 24) {
                    hlen = 54;            
                } else {
                    printf("[P6] ERROR!!! color bits is %d \n", clr);
                    goto socketEnd;
                }
                
                orglen = hlen;
                
                ret = cfgTableGetChk(pct, ASPOP_RAW_SIZE_DUO, &val, ASPOP_STA_APP);    
                sprintf_f(rs->logs, "scan raw data size: %d, ret:%d duo\n", val, ret);
                print_f(rs->plogs, "P6", rs->logs);
                
                /* calculate sector start and sector length of file */            
                
                datlen = val + hlen;
                
                sprintf_f(rs->logs, "bitmap info color: %d, w: %d, h: %d, dpi: %d, imglen: %d, use: %d duo\n", clr, w, h, dpi, val, hlen);
                print_f(rs->plogs, "P6", rs->logs);
                
                #if BMP_TEST /* for test */
                if (clr == 8) {
                    bitmapHeaderSetup(bheader, 8, 5184, 6524, 300, val);
                } else {
                    //bitmapHeaderSetup(bheader, 24, 2304, 3456, 600, val);
                    bitmapHeaderSetup(bheader, 24, 2160, 3496, 600, val);
                }
                #else           
                bitmapHeaderSetup(bheader, clr, w, hduo, dpi, val);
                #endif

                ph = &rs->pbheaderDuo->aspbmpMagic[2];
                len = sizeof(struct bitmapHeader_s) - 2;
                memcpy(hbuff, ph, len);
                
                hlen -= len;
                if (hlen > 0) {
                    bitmapColorTableSetup(hbuff+len);
                    hlen -= 1024;
                }
                
                if (hlen) {
                    printf("[fs98] Error!!! the bitmap header len is wrong %d orginal is %d\n", hlen, orglen);
                    hlen = 0;
                } 
                
                dbgBitmapHeader(bheader, len);
                
                sendbuf[3] = 'l';
                
                sprintf(rs->logs, "%d,\n\r", orglen*2);
                n = strlen(rs->logs);
                if (n > (P6_SEND_BUFF_SIZE - 32)) n = P6_SEND_BUFF_SIZE - 32;
                
                memcpy(&sendbuf[5], rs->logs, n);
                
                sendbuf[5+n] = 0xfb;
                sendbuf[5+n+1] = '\n';
                sendbuf[5+n+2] = '\0';
                ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d duo\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
                print_f(rs->plogs, "P6", rs->logs);
                
                sendbuf[3] = 'b';
                
                bin2hex(&sendbuf[5], hbuff, orglen);
                //memcpy(&sendbuf[5], hbuff, orglen);
                //memset(&sendbuf[5], 0x95, P6_SEND_BUFF_SIZE - 5);
                
                n = orglen * 2;
                
                sendbuf[5+n] = 0xfb;
                sendbuf[5+n+1] = '\n';
                sendbuf[5+n+2] = '\0';
                
                //shmem_dump(sendbuf, P6_SEND_BUFF_SIZE);
                            
                ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                //sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
                //print_f(rs->plogs, "P6", rs->logs);
            }
            
            /* initial cropping config */
            #if 0
            memset(pcp36, 0, sizeof(struct aspCrop36_s));
            memset(pcpex, 0, sizeof(struct aspCropExtra_s));

            memset(pcp36duo, 0, sizeof(struct aspCrop36_s));
            memset(pcpexduo, 0, sizeof(struct aspCropExtra_s));
            #endif
            
            #if 1
            pdt = &pct[ASPOP_CROP_02];
            crpMx = pdt->opValue & 0xffff;
            #else
            crpMx = h;
            #endif

            for (i = 0; i < (CROP_MAX_NUM_META+1); i++) {
                idx = ASPOP_CROP_01 + i;
                pdt = &pct[idx];
                switch(idx) {
                    case ASPOP_CROP_01:
                    case ASPOP_CROP_02:
                    case ASPOP_CROP_03:
                    case ASPOP_CROP_04:
                    case ASPOP_CROP_05:
                    case ASPOP_CROP_06:
                        cpn = (idx - ASPOP_CROP_01) + 1;
                        pdt = &pct[idx];
                        if (pdt->opStatus == ASPOP_STA_UPD) {

                            #if LOG_P6_CROP_EN
                            sprintf_f(rs->logs, "CROP%.2d. [0x%.8x]     {%d,  %d}  \n", i+1, pdt->opValue, pdt->opValue >> 16, pdt->opValue & 0xffff); 
                            print_f(rs->plogs, "P6", rs->logs);  
                            #endif

                            sendbuf[3] = 'C';

                            val = pdt->opValue >> 16;
                            if (dpi < 300) {
                                val = (val * dpi) / 300;
                            }

                            if (ffrmt == FILE_FORMAT_RAW) {
                                vhi = pdt->opValue & 0xffff;
                                if (crpMx < vhi) {
                                    vhi = 0xffff;
                                } else {
                                    vhi = crpMx - vhi;
                                }
                            } else {
                                vhi = pdt->opValue & 0xffff;
                            }

                            sprintf(rs->logs, "%d,%d,", val, vhi);
                            n = strlen(rs->logs);
                            
                            pcp36->crp36Pots[cpn*2+0] = val;
                            pcp36->crp36Pots[cpn*2+1] = vhi;

                            pdt->opStatus = ASPOP_STA_APP;
                        }

                        break;
                    case ASPOP_CROP_07:
                    case ASPOP_CROP_08:
                    case ASPOP_CROP_09:
                    case ASPOP_CROP_10:
                    case ASPOP_CROP_11:
                    case ASPOP_CROP_12:
                    case ASPOP_CROP_13:
                    case ASPOP_CROP_14:
                    case ASPOP_CROP_15:
                    case ASPOP_CROP_16:
                    case ASPOP_CROP_17:
                    case ASPOP_CROP_18:
                        cpn = idx - ASPOP_CROP_01;
                        pdt = &pct[idx];
                        if (pdt->opStatus == ASPOP_STA_UPD) {

                            #if LOG_P6_CROP_EN
                            sprintf_f(rs->logs, "CROP%.2d. [0x%.8x]     {%d,  %d}  \n", i, pdt->opValue, pdt->opValue >> 16, pdt->opValue & 0xffff); 
                            print_f(rs->plogs, "P6", rs->logs);  
                            #endif

                            sendbuf[3] = 'C';
                            
                            val = pdt->opValue >> 16;
                            if (dpi < 300) {
                                val = (val * dpi) / 300;
                            }

                            if (ffrmt == FILE_FORMAT_RAW) {
                                vhi = pdt->opValue & 0xffff;
                                if (crpMx < vhi) {
                                    vhi = 0xffff;
                                } else {
                                    vhi = crpMx - vhi;
                                }
                            } else {
                                vhi = pdt->opValue & 0xffff;
                            }

                            sprintf(rs->logs, "%d,%d,", val, vhi);
                            n = strlen(rs->logs);
                            
                            pcp36->crp36Pots[cpn*2+0] = val;
                            pcp36->crp36Pots[cpn*2+1] = vhi;

                            pdt->opStatus = ASPOP_STA_APP;
                        }

                        break;
                    case ASPOP_IMG_LEN:
                        pdt = &pct[idx];
                        
                        if (pdt->opStatus != ASPOP_STA_NONE) {
                            sendbuf[3] = 'H';
                            sprintf(rs->logs, "%d,\n\r", pdt->opValue & 0xffff);
                            n = strlen(rs->logs);
                        }
                        pdt->opStatus = ASPOP_STA_APP;
                        break;
                    default:
                        break;
                }

                if (n > (P6_SEND_BUFF_SIZE - 16)) n = (P6_SEND_BUFF_SIZE - 16);

                memcpy(&sendbuf[5], rs->logs, n);

                sendbuf[5+n] = 0xfb;
                sendbuf[5+n+1] = '\n';
                sendbuf[5+n+2] = '\0';
                ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);                                        
                
                #if 0//LOG_P6_CROP_EN
                sendbuf[5+n] = '\0'; 
                sprintf_f(rs->logs, "socket send CROP%.2d [ %s \n], len:%d \n", i, &sendbuf[5], 5+n+3);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
            }

            val = 0;
            ret = cfgTableGetChk(pct, ASPOP_SCAN_SIDE, &val, ASPOP_STA_UPD);
            
            //sprintf_f(rs->logs, "get usb page side: 0x%.2x ret: %d\n", val, ret);
            //print_f(rs->plogs, "P6", rs->logs);

            sendbuf[3] = 'P';

            sprintf(rs->logs, "%d,\n\r", val & 0xff);
            n = strlen(rs->logs);
            if (n > 256) n = 256;

            memcpy(&sendbuf[5], rs->logs, n);

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            //sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            //print_f(rs->plogs, "P6", rs->logs);
            
            csws = 0;
            cfgTableGetChk(pct, ASPOP_SCAN_STATUS, &csws, ASPOP_STA_UPD);
            
            sprintf_f(rs->logs, "get usb scan status: 0x%.2x ret: %d\n", csws, ret);
            print_f(rs->plogs, "P6", rs->logs);

            sendbuf[3] = 'S';

            sprintf(rs->logs, "%d,\n\r", csws & 0xff);
            n = strlen(rs->logs);
            if (n > 256) n = 256;

            memcpy(&sendbuf[5], rs->logs, n);

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            //sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            //print_f(rs->plogs, "P6", rs->logs);
            
            #if 1
            pdt = &pct[ASPOP_CROP_02_DUO];
            crpMx = pdt->opValue & 0xffff;
            #else
            crpMx = h;
            #endif

            for (i = 0; i < (CROP_MAX_NUM_META+1); i++) {
                idx = ASPOP_CROP_01_DUO+ i;
                pdt = &pct[idx];
                switch(idx) {
                    case ASPOP_CROP_01_DUO:
                    case ASPOP_CROP_02_DUO:
                    case ASPOP_CROP_03_DUO:
                    case ASPOP_CROP_04_DUO:
                    case ASPOP_CROP_05_DUO:
                    case ASPOP_CROP_06_DUO:
                        cpn = (idx - ASPOP_CROP_01_DUO) + 1;
                        pdt = &pct[idx];
                        if (pdt->opStatus == ASPOP_STA_UPD) {

                            #if LOG_P6_CROP_EN
                            sprintf_f(rs->logs, "duo CROP%.2d. [0x%.8x]     {%d,  %d}  \n", i+1, pdt->opValue, pdt->opValue >> 16, pdt->opValue & 0xffff); 
                            print_f(rs->plogs, "P6", rs->logs);  
                            #endif
                            
                            sendbuf[3] = 'c';
                            
                            val = pdt->opValue >> 16;
                            if (dpi < 300) {
                                val = (val * dpi) / 300;
                            }

                            if (ffrmt == FILE_FORMAT_RAW) {
                                vhi = pdt->opValue & 0xffff;
                                if (crpMx < vhi) {
                                    vhi = 0xffff;
                                } else {
                                    vhi = crpMx - vhi;
                                }
                            } else {
                                vhi = pdt->opValue & 0xffff;
                            }

                            sprintf(rs->logs, "%d,%d,", val, vhi);
                            n = strlen(rs->logs);
                            
                            pcp36duo->crp36Pots[cpn*2+0] = val;
                            pcp36duo->crp36Pots[cpn*2+1] = vhi;

                            pdt->opStatus = ASPOP_STA_APP;
                        }

                        break;
                    case ASPOP_CROP_07_DUO:
                    case ASPOP_CROP_08_DUO:
                    case ASPOP_CROP_09_DUO:
                    case ASPOP_CROP_10_DUO:
                    case ASPOP_CROP_11_DUO:
                    case ASPOP_CROP_12_DUO:
                    case ASPOP_CROP_13_DUO:
                    case ASPOP_CROP_14_DUO:
                    case ASPOP_CROP_15_DUO:
                    case ASPOP_CROP_16_DUO:
                    case ASPOP_CROP_17_DUO:
                    case ASPOP_CROP_18_DUO:
                        cpn = idx - ASPOP_CROP_01_DUO;
                        pdt = &pct[idx];
                        if (pdt->opStatus == ASPOP_STA_UPD) {

                            #if LOG_P6_CROP_EN
                            sprintf_f(rs->logs, "duo CROP%.2d. [0x%.8x]     {%d,  %d}  \n", i, pdt->opValue, pdt->opValue >> 16, pdt->opValue & 0xffff); 
                            print_f(rs->plogs, "P6", rs->logs);  
                            #endif
                            
                            sendbuf[3] = 'c';
                            
                            val = pdt->opValue >> 16;
                            if (dpi < 300) {
                                val = (val * dpi) / 300;
                            }

                            if (ffrmt == FILE_FORMAT_RAW) {
                                vhi = pdt->opValue & 0xffff;
                                if (crpMx < vhi) {
                                    vhi = 0xffff;
                                } else {
                                    vhi = crpMx - vhi;
                                }
                            } else {
                                vhi = pdt->opValue & 0xffff;
                            }

                            sprintf(rs->logs, "%d,%d,", val, vhi);
                            n = strlen(rs->logs);

                            pcp36duo->crp36Pots[cpn*2+0] = val;
                            pcp36duo->crp36Pots[cpn*2+1] = vhi;

                            pdt->opStatus = ASPOP_STA_APP;
                        }

                        break;
                    case ASPOP_IMG_LEN_DUO:
                        pdt = &pct[idx];
                        
                        if (pdt->opStatus != ASPOP_STA_NONE) {
                            sendbuf[3] = 'h';
                            sprintf(rs->logs, "%d,\n\r", pdt->opValue & 0xffff);
                            n = strlen(rs->logs);

                            //if (n > (P6_SEND_BUFF_SIZE - 16)) n = (P6_SEND_BUFF_SIZE - 16);
                            
                            //memcpy(&sendbuf[5], rs->logs, n);

                            //sendbuf[5+n] = 0xfb;
                            //sendbuf[5+n+1] = '\n';
                            //sendbuf[5+n+2] = '\0';
                            //ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);        
                        }
                        pdt->opStatus = ASPOP_STA_APP;
                        break;
                    default:
                        break;
                }

                if (n > (P6_SEND_BUFF_SIZE - 16)) n = (P6_SEND_BUFF_SIZE - 16);
                
                memcpy(&sendbuf[5], rs->logs, n);

                sendbuf[5+n] = 0xfb;
                sendbuf[5+n+1] = '\n';
                sendbuf[5+n+2] = '\0';
                ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);

                #if 0//LOG_P6_CROP_EN
                sendbuf[5+n] = '\0';                
                sprintf_f(rs->logs, "socket send CROP%.2d [ %s \n], len:%d \n", i, &sendbuf[5], 5+n+3);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
                
            }

            val = 0;
            ret = cfgTableGetChk(pct, ASPOP_SCAN_SIDE_DUO, &val, ASPOP_STA_UPD);
            
            //sprintf_f(rs->logs, "get duo usb page side: 0x%.2x ret: %d\n", val, ret);
            //print_f(rs->plogs, "P6", rs->logs);

            sendbuf[3] = 'p';

            sprintf(rs->logs, "%d,\n\r", val & 0xff);
            n = strlen(rs->logs);
            if (n > 256) n = 256;

            memcpy(&sendbuf[5], rs->logs, n);

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            //sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            //print_f(rs->plogs, "P6", rs->logs);
            
            cswd = 0;
            cfgTableGetChk(pct, ASPOP_SCAN_STATUS_DUO, &cswd, ASPOP_STA_UPD);
            
            sprintf_f(rs->logs, "get duo usb scan status (0x%.2x) ret: %d\n", cswd, ret);
            print_f(rs->plogs, "P6", rs->logs);

            sendbuf[3] = 's';

            sprintf(rs->logs, "%d,\n\r", cswd & 0xff);
            n = strlen(rs->logs);
            if (n > 256) n = 256;

            memcpy(&sendbuf[5], rs->logs, n);

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            //sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            //print_f(rs->plogs, "P6", rs->logs);

            #if 0
            cpn = 0;
            pcp36->crp36Pots[cpn*2+0] = 100;
            pcp36->crp36Pots[cpn*2+1] = 0;

            cpn = CROP_MAX_NUM_META+1;
            pcp36->crp36Pots[cpn*2+0] = 1100;
            pcp36->crp36Pots[cpn*2+1] = 0;

            msync(pmass, sizeof(struct aspMetaMass_s), MS_SYNC);
            msync(pmass->masspt, pmass->massUsed, MS_SYNC);
            ret = doCropCalcuPt(pcpdo, ptmetausb, pmass->masspt, pmass->massUsed, rs, 6);
            sprintf_f(rs->logs, "do set extra points first ret: %d \n", ret);
            print_f(rs->plogs, "P6", rs->logs);

            ret = doCropCalcu36(pcpdo, 0, 0, rs, 6); 
            sprintf_f(rs->logs, "do crop 36 ret: %d \n", ret);
            print_f(rs->plogs, "P6", rs->logs);

            cpn = 0;
            pcp36duo->crp36Pots[cpn*2+0] = 100;
            pcp36duo->crp36Pots[cpn*2+1] = 0;

            cpn = CROP_MAX_NUM_META+1;
            pcp36duo->crp36Pots[cpn*2+0] = 1100;
            pcp36duo->crp36Pots[cpn*2+1] = 0;

            msync(pmassduo, sizeof(struct aspMetaMass_s), MS_SYNC);
            msync(pmassduo->masspt, pmassduo->massUsed, MS_SYNC);
            ret = doCropCalcuPt(pcpdoduo, ptmetausbduo, pmassduo->masspt, pmassduo->massUsed, rs, 6);
            sprintf_f(rs->logs, "do set extra points duo first ret: %d \n", ret);
            print_f(rs->plogs, "P6", rs->logs);

            ret = doCropCalcu36(pcpdoduo, 0, 0, rs, 6); 
            sprintf_f(rs->logs, "do crop 36 duo ret: %d \n", ret);
            print_f(rs->plogs, "P6", rs->logs);
            #endif

            msync(pmass, sizeof(struct aspMetaMass_s), MS_SYNC);

            masRecd = pmass->massRecd;

            //sprintf_f(rs->logs, "%d \n\r", masRecd); 
            //print_f(rs->plogs, "P6", rs->logs);

            sendbuf[3] = 'T';
            sprintf(rs->logs, "%d \n\r", masRecd); 
            //print_f(rs->plogs, "P6", rs->logs);

            n = strlen(rs->logs);
            memcpy(&sendbuf[5], rs->logs, n);

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';

            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            //sprintf(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            //print_f(rs->plogs, "P6", rs->logs);  
            if (pmass->massRecd > 1) {
                #if 0
                if (ffrmt == FILE_FORMAT_RAW) {
                    cpx = 0;
                    cpn = 2;
                    pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                    cpn = 3;
                    pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];

                    cpx = 1;
                    cpn = 17;
                    pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                    cpn = 18;
                    pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];

                    cpx = 2;
                    cpn = 15;
                    pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                    cpn = 16;
                    pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];

                    cpx = 3;
                    cpn = 13;
                    pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                    cpn = 14;
                    pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];

                    cpx = 4;
                    cpn = 11;
                    pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                    cpn = 12;
                    pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                }
                else {
                    cpx = 0;
                    cpn = 6;
                    pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                    cpn = 5;
                    pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];

                    cpx = 1;
                    cpn = 7;
                    pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                    cpn = 8;
                    pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];

                    cpx = 2;
                    cpn = 9;
                    pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                    cpn = 10;
                    pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                }
                cof = cpx + 1;
                #else
                cof = 0;
                #endif

                ret = 0;

                masUsed = pmass->massUsed;
                masStart = pmass->massStart;

                sprintf_f(rs->logs, "wait meta mass (used:%d, start:%d) %d\n", masUsed, masStart, cnt); 
                print_f(rs->plogs, "P6", rs->logs);

                cnt = 0;
                
                while (!masUsed) {
                    usleep(500000);
                    msync(pmass, sizeof(struct aspMetaMass_s), MS_SYNC);
                    masUsed = pmass->massUsed;
                    sprintf_f(rs->logs, "wait meta mass (used:%d) %d\n", masUsed, cnt); 
                    print_f(rs->plogs, "P6", rs->logs);
                }

                msync(pmass->masspt, masUsed, MS_SYNC);
                ptBuf = (unsigned short *)pmass->masspt;
                
                cy = masStart;
                gap = pmass->massGap;

                #if 1
                pdt = &pct[ASPOP_CROP_02];
                crpMx = pdt->opValue & 0xffff;
                #else
                crpMx = h;
                #endif

                linecnt = 0;
                plancnt = masRecd;

                #ifdef CROP_SELEC_RATIO
                selecRatio = CROP_SELEC_RATIO / 100.0;
                selecCur = 0.0;
                selecPic = 0.0;
                selecMax = (CFLOAT) masRecd * selecRatio;
                plancnt = (int) selecMax;
                #endif

                //sprintf(rs->logs, "select ratio: %lf, line max: %d\n", selecRatio, plancnt); 
                //print_f(rs->plogs, "P6", rs->logs);
                
                for (i = 0; i < masRecd; i++) {
                    cy += gap;
                    cxm = *ptBuf;
                    ptBuf++;
                    cxn = *ptBuf;
                    ptBuf++;

                    #ifdef CROP_SELEC_RATIO
                    if ((i > CROP_SELEC_HEAD) && (i < (masRecd - CROP_SELEC_TAIL))) {
                        selecBase = i;
                        selecCur = selecBase * selecRatio;
                    
                        ipic = (int)(selecPic);
                        icur = (int)(selecCur);

                        //sprintf(rs->logs, "%d,(%d, %d)\n", i, icur, ipic); 
                        //print_f(rs->plogs, "P6", rs->logs);
                    
                        if (icur > ipic) {
                            selecPic = selecCur;
                            //sprintf(rs->logs, "%d,%d,%d (pick!!!)\n", i, cxm, cxn); 
                            //print_f(rs->plogs, "P6", rs->logs);
                        } else {
                            //sprintf(rs->logs, "%d,%d,%d (skip!!!)\n", i, cxm, cxn); 
                            //print_f(rs->plogs, "P6", rs->logs);
                            continue;
                        }
                    }
                    #endif                    

                    if (dpi < 300) {
                        cxm = (cxm * dpi) / 300;
                        cxn = (cxn * dpi) / 300;
                    }

                    if (ffrmt == FILE_FORMAT_RAW) {
                        vhi = crpMx - cy;
                    } else {
                        vhi = cy;
                    }

                    sprintf(rs->logs, "%d,%d,%d,\n\r", vhi, cxm, cxn); 

                    if (ffrmt == FILE_FORMAT_RAW) {
                        cpx = (plancnt - linecnt - 1) + cof;
                    } else {
                        cpx = linecnt + cof;
                    }

                    linecnt ++;

                    #if 0
                    pcpex->crpexLfPots[cpx*2+0] = cxm;
                    pcpex->crpexLfPots[cpx*2+1] = vhi;
                    pcpex->crpexRtPots[cpx*2+0] = cxn;
                    pcpex->crpexRtPots[cpx*2+1] = vhi;
                    #endif

                    #if 0
                    print_f(rs->plogs, "P6", rs->logs);
                    #endif

                    #if 1 /* send the unsort mass points to app */
                    sendbuf[3] = 'M';
                    n = strlen(rs->logs);
                    memcpy(&sendbuf[5], rs->logs, n);

                    sendbuf[5+n] = 0xfb;
                    sendbuf[5+n+1] = '\n';
                    sendbuf[5+n+2] = '\0';

                    ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                    sendbuf[5+n] = '\0';
                    sendbuf[5+n+1] = '\0';
                    //sprintf(rs->logs, "socket send, %d. [%s], ret:%d\n", i, &sendbuf[5], ret);
                    //print_f(rs->plogs, "P6", rs->logs);
                    #endif
                }

                cpx = linecnt + cof;
                cls =  masRecd + cof - 1;

                #if 0
                if (ffrmt == FILE_FORMAT_RAW) {
                    cpn = 9;
                    if (pcp36->crp36Pots[cpn*2+1] > pcpex->crpexRtPots[cls*2+1]) {
                        pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpn = 10;
                        pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }
                    
                    cpn = 7;
                    if (pcp36->crp36Pots[cpn*2+1] > pcpex->crpexRtPots[cls*2+1]) {
                        pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpn = 8;
                        pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }
                    
                    cpn = 5;
                    if (pcp36->crp36Pots[cpn*2+1] > pcpex->crpexRtPots[cls*2+1]) {
                        pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpn = 6;
                        pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }
                }
                else {
                    cpn = 11;
                    if (pcp36->crp36Pots[cpn*2+1] > pcpex->crpexRtPots[cls*2+1]) {
                        pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpn = 12;
                        pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }

                    cpn = 13;
                    if (pcp36->crp36Pots[cpn*2+1] > pcpex->crpexRtPots[cls*2+1]) {
                        pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpn = 14;
                        pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }

                    cpn = 15;
                    if (pcp36->crp36Pots[cpn*2+1] > pcpex->crpexRtPots[cls*2+1]) {
                        pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpn = 16;
                        pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }

                    cpn = 17;
                    if (pcp36->crp36Pots[cpn*2+1] > pcpex->crpexRtPots[cls*2+1]) {
                        pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpn = 18;
                        pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }

                    cpn = 2;
                    if (pcp36->crp36Pots[cpn*2+1] > pcpex->crpexRtPots[cls*2+1]) {
                        pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpn = 3;
                        pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }
                }
                
                pcpex->crpexSize = cpx*2;
                
                msync(pcpex, sizeof(struct aspCropExtra_s), MS_SYNC);
                
                sprintf_f(rs->logs, "total extra points size: %d \n", cpx);
                print_f(rs->plogs, "P6", rs->logs);

                aspSortD(pcpex->crpexLfPots, cpx); /* max sort = 1024 */
                aspSortD(pcpex->crpexRtPots, cpx); /* max sort = 1024 */

                ret = getRotateP1(pcp36, mostlft);
                
                #if LOG_P6_CROP_EN
                if (!ret) {
                    sprintf_f(rs->logs, "duo get most left (%lf, %lf) \n", mostlft[0], mostlft[1]);
                    print_f(rs->plogs, "P6", rs->logs);
                }
                #endif
                
                fwh = mostlft[1] - (gap * 2);
                if (fwh < 0.0) {
                    fwh = 0.0;
                }

                ret = getRotateP3(pcp36, mostrgt);
                
                #if LOG_P6_CROP_EN
                if (!ret) {
                    sprintf_f(rs->logs, "duo get most right (%lf, %lf) \n", mostrgt[0], mostrgt[1]);
                    print_f(rs->plogs, "P6", rs->logs);
                }
                #endif
                
                fwe = mostrgt[1] - (gap * 2);
                if (fwe < 0.0) {
                    fwe = 0.0;
                }
                
                cnt = 0; 
                ix = 0;
                for (i = 0; i < cpx; i++) {

                    #if LOG_P6_CROP_EN
                    sprintf_f(rs->logs, "duo %d. L%lf, %lf R%lf, %lf \n", i
                              , pcpex->crpexLfPots[i*2+0], pcpex->crpexLfPots[i*2+1], pcpex->crpexRtPots[i*2+0], pcpex->crpexRtPots[i*2+1]);
                    print_f(rs->plogs, "P6", rs->logs);
                    #endif

                    #if 1//CROP_MIGRATE_TO_APP
                    vhi = (int)pcpex->crpexLfPots[i*2+1];
                    cxm = (int)pcpex->crpexLfPots[i*2+0];
                    cxn = (int)pcpex->crpexRtPots[i*2+0];

                    #if 0 /* should use nonsort mass points */
                    sprintf(rs->logs, "%d,%d,%d,\r", vhi, cxm, cxn); 

                    sendbuf[3] = 'M';
                    n = strlen(rs->logs);
                    memcpy(&sendbuf[5], rs->logs, n);

                    sendbuf[5+n] = 0xfb;
                    sendbuf[5+n+1] = '\n';
                    sendbuf[5+n+2] = '\0';
                    ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                    #endif

                    #if 0
                    sendbuf[5+n] = '\0';
                    sendbuf[5+n+1] = '\0';
                    sprintf(rs->logs, "socket send, %d. [%s], ret:%d\n", cpx, &sendbuf[5], ret);
                    print_f(rs->plogs, "P6", rs->logs);
                    #endif
                    
                    fhi = (CFLOAT)vhi;
                    
                    if (cnt < 4) {
                        if (fhi > fwh) {
                            lftgrp[cnt][0] = cxm;
                            lftgrp[cnt][1] = fhi;

                            cnt ++;
                        }
                    }

                    if (ix < 4) {
                        if (fhi > fwe) {
                            rgtgrp[ix][0] = cxn;
                            rgtgrp[ix][1] = fhi;

                            ix ++;
                        }
                    }
                    #endif  // #if 1//CROP_MIGRATE_TO_APP

                }
                #endif
                
                //shmem_dump(pmass->masspt, pmass->massUsed);

                //pmass->massRecd = 0; /* move to the end of transmitting */ 
                //pmass->massUsed = 0;

                #if 0//!CROP_MIGRATE_TO_APP
                /* fix most left and most right shift */  
                fhi = 0.0; fwh = 0.0; fwe = 0.0;
                for (ix=0; ix < 4; ix++) {
                
                    #if LOG_P6_CROP_EN
                    sprintf_f(rs->logs, "duo left apporach group (%lf, %lf) \n", lftgrp[ix][0], lftgrp[ix][1]);
                    print_f(rs->plogs, "P6", rs->logs);
                    #endif
                    
                    fhi += lftgrp[ix][0] - mostlft[0];
                    fwh += lftgrp[ix][0];
                }
                
                fwe = fhi / 4.0;
                if (fwe > 15.0) {
                    mostlft[0] = fwh / 4.0;
                    setRotateP1(pcp36, mostlft);
                
                    #if 1//LOG_P6_CROP_EN
                    sprintf_f(rs->logs, "duo correct most left (%lf, %lf) \n", mostlft[0], mostlft[1]);
                    print_f(rs->plogs, "P6", rs->logs);
                    #endif
                
                }
                
                fhi = 0.0; fwh = 0.0; fwe = 0.0;
                for (ix=0; ix < 4; ix++) {
                
                    #if LOG_P6_CROP_EN
                    sprintf_f(rs->logs, "duo right apporach group (%lf, %lf) \n", rgtgrp[ix][0], rgtgrp[ix][1]);
                    print_f(rs->plogs, "P6", rs->logs);
                    #endif
                
                    fhi += mostrgt[0] - rgtgrp[ix][0];
                    fwh += rgtgrp[ix][0];
                }
                
                fwe = fhi / 4.0;
                if (fwe > 15.0) {
                    mostrgt[0] = fwh / 4.0;
                    setRotateP3(pcp36, mostrgt);
                
                    #if 1//LOG_P6_CROP_EN
                    sprintf_f(rs->logs, "duo correct most right (%lf, %lf) \n", mostrgt[0], mostrgt[1]);
                    print_f(rs->plogs, "P6", rs->logs);
                    #endif
                
                }
                #endif // #if !CROP_MIGRATE_TO_APP
            } 

            #if 0
            ret = doCropCalcu(pcpdo, 0, 0, rs, 6); 
            #endif // #if CROP_MIGRATE_TO_APP

            ret = cfgTableGet(pct, ASPOP_USBCROP_FP01, &val);
            cxm = (val>>16)&0xffff;
            cxn = val & 0xffff;
            //sprintf_f(rs->logs, "crop meta get F1: (%d, %d) ret: %d\n", cxm, cxn, ret); 
            //print_f(rs->plogs, "P6", rs->logs);                     
            rotlf[0] = (CFLOAT)cxm;
            rotlf[1] = (CFLOAT)cxn;

            ret = cfgTableGet(pct, ASPOP_USBCROP_FP02, &val);
            cxm = (val>>16)&0xffff;
            cxn = val & 0xffff;
            //sprintf_f(rs->logs, "crop meta get F2: (%d, %d) ret: %d\n", cxm, cxn, ret); 
            //print_f(rs->plogs, "P6", rs->logs);                     
            rotup[0] = (CFLOAT)cxm;
            rotup[1] = (CFLOAT)cxn;

            ret = cfgTableGet(pct, ASPOP_USBCROP_FP03, &val);
            cxm = (val>>16)&0xffff;
            cxn = val & 0xffff;
            //sprintf_f(rs->logs, "crop meta get F3: (%d, %d) ret: %d\n", cxm, cxn, ret); 
            //print_f(rs->plogs, "P6", rs->logs);                     
            rotrt[0] = (CFLOAT)cxm;
            rotrt[1] = (CFLOAT)cxn;

            ret = cfgTableGet(pct, ASPOP_USBCROP_FP04, &val);
            cxm = (val>>16)&0xffff;
            cxn = val & 0xffff;
            //sprintf_f(rs->logs, "crop meta get F4: (%d, %d) ret: %d\n", cxm, cxn, ret); 
            //print_f(rs->plogs, "P6", rs->logs);                     
            rotdn[0] = (CFLOAT)cxm;
            rotdn[1] = (CFLOAT)cxn;

            #if 0
            msync(pcp36, sizeof(struct aspCrop36_s), MS_SYNC);
            ret = getRotateP1(pcp36, rotlf);
            if (!ret) {
                sprintf_f(rs->logs, "get rotateP1 (%lf, %lf) \n", rotlf[0], rotlf[1]);
                print_f(rs->plogs, "P6", rs->logs);
            }

            ret = getRotateP2(pcp36, rotup);
            if (!ret) {
                sprintf_f(rs->logs, "get rotateP2 (%lf, %lf) \n", rotup[0], rotup[1]);
                print_f(rs->plogs, "P6", rs->logs);
            }

            ret = getRotateP3(pcp36, rotrt);
            if (!ret) {
                sprintf_f(rs->logs, "get rotateP3 (%lf, %lf) \n", rotrt[0], rotrt[1]);
                print_f(rs->plogs, "P6", rs->logs);
            }

            ret = getRotateP4(pcp36, rotdn);
            if (!ret) {
                sprintf_f(rs->logs, "get rotateP4 (%lf, %lf) \n", rotdn[0], rotdn[1]);
                print_f(rs->plogs, "P6", rs->logs);
            }
            #endif
            
            #if 0 /* debug print */
            for (i = 0; i < CROP_MAX_NUM_META+2; i++) {
                sprintf_f(rs->logs, "%d. %lf, %lf \n", i, pcp36->crp36Pots[i*2+0], pcp36->crp36Pots[i*2+1]);
                print_f(rs->plogs, "P6", rs->logs);
            }

            
            for (i = 0; i < pcpex->crpexSize; i++) {
                sprintf_f(rs->logs, "L%d. %lf, %lf \n", i, pcpex->crpexLfPots[i*2+0], pcpex->crpexLfPots[i*2+1]);
                print_f(rs->plogs, "P6", rs->logs);
            }

            for (i = 0; i < pcpex->crpexSize; i++) {
                sprintf_f(rs->logs, "R%d. %lf, %lf \n", i, pcpex->crpexRtPots[i*2+0], pcpex->crpexRtPots[i*2+1]);
                print_f(rs->plogs, "P6", rs->logs);
            }
            #endif     

            #if !CROP_MIGRATE_TO_APP
            for (i = 0; i < 4; i++) { /* send the cropping result to APP */
                sendbuf[3] = 'F';

                switch (i) {
                    case 0:
                        sprintf(rs->logs, "%d,%d,", (int)round(rotlf[0]), (int)round(rotlf[1]));
                        break;
                    case 1:
                        sprintf(rs->logs, "%d,%d,", (int)round(rotup[0]), (int)round(rotup[1]));
                        break;
                    case 2:
                        sprintf(rs->logs, "%d,%d,", (int)round(rotrt[0]), (int)round(rotrt[1]));
                        break;
                    case 3:
                        sprintf(rs->logs, "%d,%d,", (int)round(rotdn[0]), (int)round(rotdn[1]));
                        break;
                    default:
                        break;
                }
                n = strlen(rs->logs);
                memcpy(&sendbuf[5], rs->logs, n);

                sendbuf[5+n] = 0xfb;
                sendbuf[5+n+1] = '\n';
                sendbuf[5+n+2] = '\0';
                ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                #if 0 //LOG_P6_CROP_EN
                sprintf_f(rs->logs, "socket send CROP  %c %d [ %s ], len:%d \n", sendbuf[3], i, &sendbuf[5], 5+n+3);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
            }
            #endif // #if !CROP_MIGRATE_TO_APP

            msync(pmassduo, sizeof(struct aspMetaMass_s), MS_SYNC);

            masRecd = pmassduo->massRecd;
            //sprintf_f(rs->logs, "duo %d \n\r", masRecd); 
            //print_f(rs->plogs, "P6", rs->logs);

            sendbuf[3] = 't';
            sprintf(rs->logs, "%d \n\r", masRecd); 
            //print_f(rs->plogs, "P6", rs->logs);

            n = strlen(rs->logs);
            memcpy(&sendbuf[5], rs->logs, n);

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            //sprintf(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            //print_f(rs->plogs, "P6", rs->logs);
            if (pmassduo->massRecd > 1) {
                #if 0
                if (ffrmt == FILE_FORMAT_RAW) {
                    cpx = 0;
                    cpn = 2;
                    pcpexduo->crpexLfPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                    pcpexduo->crpexLfPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                    cpn = 3;
                    pcpexduo->crpexRtPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                    pcpexduo->crpexRtPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];

                    cpx = 1;
                    cpn = 17;
                    pcpexduo->crpexLfPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                    pcpexduo->crpexLfPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                    cpn = 18;
                    pcpexduo->crpexRtPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                    pcpexduo->crpexRtPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];

                    cpx = 2;
                    cpn = 15;
                    pcpexduo->crpexLfPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                    pcpexduo->crpexLfPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                    cpn = 16;
                    pcpexduo->crpexRtPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                    pcpexduo->crpexRtPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];

                    cpx = 3;
                    cpn = 13;
                    pcpexduo->crpexLfPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                    pcpexduo->crpexLfPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                    cpn = 14;
                    pcpexduo->crpexRtPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                    pcpexduo->crpexRtPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];

                    cpx = 4;
                    cpn = 11;
                    pcpexduo->crpexLfPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                    pcpexduo->crpexLfPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                    cpn = 12;
                    pcpexduo->crpexRtPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                    pcpexduo->crpexRtPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                }
                else {
                    cpx = 0;
                    cpn = 6;
                    pcpexduo->crpexLfPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                    pcpexduo->crpexLfPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                    cpn = 5;
                    pcpexduo->crpexRtPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                    pcpexduo->crpexRtPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];

                    cpx = 1;
                    cpn = 7;
                    pcpexduo->crpexLfPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                    pcpexduo->crpexLfPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                    cpn = 8;
                    pcpexduo->crpexRtPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                    pcpexduo->crpexRtPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];

                    cpx = 2;
                    cpn = 9;
                    pcpexduo->crpexLfPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                    pcpexduo->crpexLfPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                    cpn = 10;
                    pcpexduo->crpexRtPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                    pcpexduo->crpexRtPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                }

                cof = cpx + 1;
                #else
                cof = 0;
                #endif

                ret = 0;

                masUsed = pmassduo->massUsed;
                masStart = pmassduo->massStart;

                sprintf_f(rs->logs, "duo wait meta mass (used:%d, start:%d) %d\n", masUsed, masStart, cnt); 
                print_f(rs->plogs, "P6", rs->logs);

                cnt = 0;

                while (!masUsed) {
                    usleep(500000);
                    msync(pmassduo, sizeof(struct aspMetaMass_s), MS_SYNC);
                    masUsed = pmassduo->massUsed;
                    sprintf_f(rs->logs, "duo wait meta mass (used:%d) %d\n", masUsed, cnt); 
                    print_f(rs->plogs, "P6", rs->logs);
                }

                msync(pmassduo->masspt, masUsed, MS_SYNC);
                ptBuf = (unsigned short *)pmassduo->masspt;
                
                cy = masStart;
                gap = pmassduo->massGap;

                #if 1
                pdt = &pct[ASPOP_CROP_02];
                crpMx = pdt->opValue & 0xffff;
                #else
                crpMx = h;
                #endif

                linecnt = 0;
                plancnt = masRecd;

                #ifdef CROP_SELEC_RATIO
                selecRatio = CROP_SELEC_RATIO / 100.0;
                selecCur = 0.0;
                selecPic = 0.0;
                selecMax = (CFLOAT) masRecd * selecRatio;
                plancnt = (int) selecMax;
                #endif

                sprintf(rs->logs, "select ratio: %lf, line max: %d\n", selecRatio, plancnt); 
                print_f(rs->plogs, "P6", rs->logs);
                
                for (i = 0; i < masRecd; i++) {
                    cy += gap;
                    cxm = *ptBuf;
                    ptBuf++;
                    cxn = *ptBuf;
                    ptBuf++;

                    #ifdef CROP_SELEC_RATIO
                    if ((i > CROP_SELEC_HEAD) && (i < (masRecd - CROP_SELEC_TAIL))) {
                        selecBase = i;
                        selecCur = selecBase * selecRatio;
                    
                        ipic = (int)(selecPic);
                        icur = (int)(selecCur);

                        //sprintf(rs->logs, "%d,(%d, %d)\n", i, icur, ipic); 
                        //print_f(rs->plogs, "P6", rs->logs);
                    
                        if (icur > ipic) {
                            selecPic = selecCur;
                            //sprintf(rs->logs, "%d,%d,%d (pick!!!)\n", i, cxm, cxn); 
                            //print_f(rs->plogs, "P6", rs->logs);
                        } else {
                            //sprintf(rs->logs, "%d,%d,%d (skip!!!)\n", i, cxm, cxn); 
                            //print_f(rs->plogs, "P6", rs->logs);
                            continue;
                        }
                    }
                    #endif

                    if (dpi < 300) {
                        cxm = (cxm * dpi) / 300;
                        cxn = (cxn * dpi) / 300;
                    }

                     if (ffrmt == FILE_FORMAT_RAW) {
                        vhi = crpMx - cy;
                    } else {
                        vhi = cy;
                    }

                    sprintf(rs->logs, "%d,%d,%d,\n\r", vhi, cxm, cxn); 

                    if (ffrmt == FILE_FORMAT_RAW) {
                        cpx = (plancnt - linecnt - 1) + cof;
                    } else {
                        cpx = linecnt + cof;
                    }

                    linecnt ++;
                    
                    #if 0
                    pcpexduo->crpexLfPots[cpx*2+0] = cxm;
                    pcpexduo->crpexLfPots[cpx*2+1] = vhi;
                    pcpexduo->crpexRtPots[cpx*2+0] = cxn;
                    pcpexduo->crpexRtPots[cpx*2+1] = vhi;
                    #endif

                    #if 0
                    print_f(rs->plogs, "P6", rs->logs);
                    #endif

                    #if 1 /* send the unsort mass points to app */
                    sendbuf[3] = 'm';
                    n = strlen(rs->logs);
                    memcpy(&sendbuf[5], rs->logs, n);

                    sendbuf[5+n] = 0xfb;
                    sendbuf[5+n+1] = '\n';
                    sendbuf[5+n+2] = '\0';

                    ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                    sendbuf[5+n] = '\0';
                    sendbuf[5+n+1] = '\0';
                    //sprintf(rs->logs, "socket send, %d. [%s], ret:%d\n", i, &sendbuf[5], ret);
                    //print_f(rs->plogs, "P6", rs->logs);
                    #endif
                    
                }

                cpx = linecnt + cof;
                cls =  masRecd + cof - 1;

                #if 0
                if (ffrmt == FILE_FORMAT_RAW) {
                    cpn = 9;
                    if (pcp36duo->crp36Pots[cpn*2+1] > pcpexduo->crpexRtPots[cls*2+1]) {
                        pcpexduo->crpexLfPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                        pcpexduo->crpexLfPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                        cpn = 10;
                        pcpexduo->crpexRtPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                        pcpexduo->crpexRtPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }
                    
                    cpn = 7;
                    if (pcp36duo->crp36Pots[cpn*2+1] > pcpexduo->crpexRtPots[cls*2+1]) {
                        pcpexduo->crpexLfPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                        pcpexduo->crpexLfPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                        cpn = 8;
                        pcpexduo->crpexRtPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                        pcpexduo->crpexRtPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }
                    
                    cpn = 5;
                    if (pcp36duo->crp36Pots[cpn*2+1] > pcpexduo->crpexRtPots[cls*2+1]) {
                        pcpexduo->crpexLfPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                        pcpexduo->crpexLfPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                        cpn = 6;
                        pcpexduo->crpexRtPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                        pcpexduo->crpexRtPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }
                }
                else {
                    cpn = 11;
                    if (pcp36duo->crp36Pots[cpn*2+1] > pcpexduo->crpexRtPots[cls*2+1]) {
                        pcpexduo->crpexLfPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                        pcpexduo->crpexLfPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                        cpn = 12;
                        pcpexduo->crpexRtPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                        pcpexduo->crpexRtPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }

                    cpn = 13;
                    if (pcp36duo->crp36Pots[cpn*2+1] > pcpexduo->crpexRtPots[cls*2+1]) {
                        pcpexduo->crpexLfPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                        pcpexduo->crpexLfPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                        cpn = 14;
                        pcpexduo->crpexRtPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                        pcpexduo->crpexRtPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }

                    cpn = 15;
                    if (pcp36duo->crp36Pots[cpn*2+1] > pcpexduo->crpexRtPots[cls*2+1]) {
                        pcpexduo->crpexLfPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                        pcpexduo->crpexLfPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                        cpn = 16;
                        pcpexduo->crpexRtPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                        pcpexduo->crpexRtPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }

                    cpn = 17;
                    if (pcp36duo->crp36Pots[cpn*2+1] > pcpexduo->crpexRtPots[cls*2+1]) {
                        pcpexduo->crpexLfPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                        pcpexduo->crpexLfPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                        cpn = 18;
                        pcpexduo->crpexRtPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                        pcpexduo->crpexRtPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }

                    cpn = 2;
                    if (pcp36duo->crp36Pots[cpn*2+1] > pcpexduo->crpexRtPots[cls*2+1]) {
                        pcpexduo->crpexLfPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                        pcpexduo->crpexLfPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                        cpn = 3;
                        pcpexduo->crpexRtPots[cpx*2+0] = pcp36duo->crp36Pots[cpn*2+0];
                        pcpexduo->crpexRtPots[cpx*2+1] = pcp36duo->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }
                }
                
                pcpexduo->crpexSize = cpx*2;
                
                msync(pcpexduo, sizeof(struct aspCropExtra_s), MS_SYNC);

                sprintf_f(rs->logs, "total extra points size: %d \n", cpx);
                print_f(rs->plogs, "P6", rs->logs);
                
                sprintf_f(rs->logs, "total extra points size: %d \n", cpx);
                print_f(rs->plogs, "P6", rs->logs);
                
                aspSortD(pcpexduo->crpexLfPots, cpx); /* max sort = 1024 */
                aspSortD(pcpexduo->crpexRtPots, cpx); /* max sort = 1024 */
                
                ret = getRotateP1(pcp36duo, mostlft);
                
                #if LOG_P6_CROP_EN
                if (!ret) {
                    sprintf_f(rs->logs, "duo get most left (%lf, %lf) \n", mostlft[0], mostlft[1]);
                    print_f(rs->plogs, "P6", rs->logs);
                }
                #endif
                
                fwh = mostlft[1] - (gap * 2);
                if (fwh < 0.0) {
                    fwh = 0.0;
                }

                ret = getRotateP3(pcp36duo, mostrgt);
                
                #if LOG_P6_CROP_EN
                if (!ret) {
                    sprintf_f(rs->logs, "duo get most right (%lf, %lf) \n", mostrgt[0], mostrgt[1]);
                    print_f(rs->plogs, "P6", rs->logs);
                }
                #endif
                
                fwe = mostrgt[1] - (gap * 2);
                if (fwe < 0.0) {
                    fwe = 0.0;
                }

                cnt = 0; ix = 0;
                for (i = 0; i < cpx; i++) {
                
                    #if LOG_P6_CROP_EN
                    sprintf_f(rs->logs, " duo %d. L%lf, %lf R%lf, %lf \n", i
                              , pcpexduo->crpexLfPots[i*2+0], pcpexduo->crpexLfPots[i*2+1], pcpexduo->crpexRtPots[i*2+0], pcpexduo->crpexRtPots[i*2+1]);
                    print_f(rs->plogs, "P6", rs->logs);
                    #endif

                    #if 1//CROP_MIGRATE_TO_APP
                    vhi = (int)pcpexduo->crpexLfPots[i*2+1];
                    cxm = (int)pcpexduo->crpexLfPots[i*2+0];
                    cxn = (int)pcpexduo->crpexRtPots[i*2+0];

                    #if 0 /* should not send the sort mass points to app */
                    sprintf(rs->logs, "%d,%d,%d,\r", vhi, cxm, cxn); 

                    sendbuf[3] = 'm';
                    n = strlen(rs->logs);
                    memcpy(&sendbuf[5], rs->logs, n);

                    sendbuf[5+n] = 0xfb;
                    sendbuf[5+n+1] = '\n';
                    sendbuf[5+n+2] = '\0';
                    ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                    #endif

                    #if 0
                    sendbuf[5+n] = '\0';
                    sendbuf[5+n+1] = '\0';
                    sprintf(rs->logs, "socket send, %d. [%s], ret:%d\n", cpx, &sendbuf[5], ret);
                    print_f(rs->plogs, "P6", rs->logs);
                    #endif
                    
                    fhi = (CFLOAT)vhi;
                    if (cnt < 4) {
                        if (fhi > fwh) {
                            lftgrp[cnt][0] = cxm;
                            lftgrp[cnt][1] = fhi;

                            cnt ++;
                        }
                    }

                    if (ix < 4) {
                        if (fhi > fwe) {
                            rgtgrp[ix][0] = cxn;
                            rgtgrp[ix][1] = fhi;

                            ix ++;
                        }
                    }
                    #endif

                }
                #endif 
                
                //shmem_dump(pmass->masspt, pmass->massUsed);

                //pmassduo->massRecd = 0; /* move to the end of transmitting */
                //pmassduo->massUsed = 0;
                #if 0 //!CROP_MIGRATE_TO_APP
                /* fix most left and most right shift */  
                fhi = 0.0; fwh = 0.0; fwe = 0.0;
                for (ix=0; ix < 4; ix++) {
                
                    #if LOG_P6_CROP_EN
                    sprintf_f(rs->logs, "left duo apporach group (%lf, %lf) \n", lftgrp[ix][0], lftgrp[ix][1]);
                    print_f(rs->plogs, "P6", rs->logs);
                    #endif
                    
                    fhi += lftgrp[ix][0] - mostlft[0];
                    fwh += lftgrp[ix][0];
                }
                
                fwe = fhi / 4.0;
                if (fwe > 15.0) {
                    mostlft[0] = fwh / 4.0;
                    setRotateP1(pcp36, mostlft);
                
                    #if 1//LOG_P6_CROP_EN
                    sprintf_f(rs->logs, "correct duo most left (%lf, %lf) \n", mostlft[0], mostlft[1]);
                    print_f(rs->plogs, "P6", rs->logs);
                    #endif
                
                }
                
                fhi = 0.0; fwh = 0.0; fwe = 0.0;
                for (ix=0; ix < 4; ix++) {
                
                    #if LOG_P6_CROP_EN
                    sprintf_f(rs->logs, "right duo apporach group (%lf, %lf) \n", rgtgrp[ix][0], rgtgrp[ix][1]);
                    print_f(rs->plogs, "P6", rs->logs);
                    #endif
                
                    fhi += mostrgt[0] - rgtgrp[ix][0];
                    fwh += rgtgrp[ix][0];
                }
                
                fwe = fhi / 4.0;
                if (fwe > 15.0) {
                    mostrgt[0] = fwh / 4.0;
                    setRotateP3(pcp36, mostrgt);
                
                    #if 1//LOG_P6_CROP_EN
                    sprintf_f(rs->logs, "correct duo most right (%lf, %lf) \n", mostrgt[0], mostrgt[1]);
                    print_f(rs->plogs, "P6", rs->logs);
                    #endif
                
                }
                #endif // #if !CROP_MIGRATE_TO_APP
            } 

            #if 0
            ret = doCropCalcu(pcpdoduo, 0, 0, rs, 6); 
            #endif // #if CROP_MIGRATE_TO_APP

            ret = cfgTableGet(pct, ASPOP_USBCROP_FP01_DUO, &val);
            cxm = (val>>16)&0xffff;
            cxn = val & 0xffff;
            //sprintf_f(rs->logs, "crop meta get duo F1: (%d, %d) ret: %d\n", cxm, cxn, ret); 
            //print_f(rs->plogs, "P6", rs->logs);                     
            rotlf[0] = (CFLOAT)cxm;
            rotlf[1] = (CFLOAT)cxn;

            ret = cfgTableGet(pct, ASPOP_USBCROP_FP02_DUO, &val);
            cxm = (val>>16)&0xffff;
            cxn = val & 0xffff;
            //sprintf_f(rs->logs, "crop meta get duo F2: (%d, %d) ret: %d\n", cxm, cxn, ret); 
            //print_f(rs->plogs, "P6", rs->logs);                     
            rotup[0] = (CFLOAT)cxm;
            rotup[1] = (CFLOAT)cxn;

            ret = cfgTableGet(pct, ASPOP_USBCROP_FP03_DUO, &val);
            cxm = (val>>16)&0xffff;
            cxn = val & 0xffff;
            //sprintf_f(rs->logs, "crop meta get duo F3: (%d, %d) ret: %d\n", cxm, cxn, ret); 
            //print_f(rs->plogs, "P6", rs->logs);                     
            rotrt[0] = (CFLOAT)cxm;
            rotrt[1] = (CFLOAT)cxn;

            ret = cfgTableGet(pct, ASPOP_USBCROP_FP04_DUO, &val);
            cxm = (val>>16)&0xffff;
            cxn = val & 0xffff;
            //sprintf_f(rs->logs, "crop meta get duo F4: (%d, %d) ret: %d\n", cxm, cxn, ret); 
            //print_f(rs->plogs, "P6", rs->logs);                     
            rotdn[0] = (CFLOAT)cxm;
            rotdn[1] = (CFLOAT)cxn;

            #if 0
            msync(pcp36duo, sizeof(struct aspCrop36_s), MS_SYNC);
            ret = getRotateP1(pcp36duo, rotlf);
            if (!ret) {
                sprintf_f(rs->logs, "duo get rotateP1 (%lf, %lf) \n", rotlf[0], rotlf[1]);
                print_f(rs->plogs, "P6", rs->logs);
            }

            ret = getRotateP2(pcp36duo, rotup);
            if (!ret) {
                sprintf_f(rs->logs, "duo get rotateP2 (%lf, %lf) \n", rotup[0], rotup[1]);
                print_f(rs->plogs, "P6", rs->logs);
            }

            ret = getRotateP3(pcp36duo, rotrt);
            if (!ret) {
                sprintf_f(rs->logs, "duo get rotateP3 (%lf, %lf) \n", rotrt[0], rotrt[1]);
                print_f(rs->plogs, "P6", rs->logs);
            }

            ret = getRotateP4(pcp36duo, rotdn);
            if (!ret) {
                sprintf_f(rs->logs, "duo get rotateP4 (%lf, %lf) \n", rotdn[0], rotdn[1]);
                print_f(rs->plogs, "P6", rs->logs);
            }
            #endif

            #if 0 /* debug print */
            for (i = 0; i < CROP_MAX_NUM_META+2; i++) {
                sprintf_f(rs->logs, "%d. %lf, %lf \n", i, pcp36duo->crp36Pots[i*2+0], pcp36duo->crp36Pots[i*2+1]);
                print_f(rs->plogs, "P6", rs->logs);
            }

            
            for (i = 0; i < pcpexduo->crpexSize; i++) {
                sprintf_f(rs->logs, "L%d. %lf, %lf \n", i, pcpexduo->crpexLfPots[i*2+0], pcpexduo->crpexLfPots[i*2+1]);
                print_f(rs->plogs, "P6", rs->logs);
            }

            for (i = 0; i < pcpexduo->crpexSize; i++) {
                sprintf_f(rs->logs, "R%d. %lf, %lf \n", i, pcpexduo->crpexRtPots[i*2+0], pcpexduo->crpexRtPots[i*2+1]);
                print_f(rs->plogs, "P6", rs->logs);
            }
            #endif

            #if !CROP_MIGRATE_TO_APP
            for (i = 0; i < 4; i++) { /* send the cropping result to APP */
                sendbuf[3] = 'f';

                switch (i) {
                    case 0:
                        sprintf(rs->logs, "%d,%d,", (int)round(rotlf[0]), (int)round(rotlf[1]));
                        break;
                    case 1:
                        sprintf(rs->logs, "%d,%d,", (int)round(rotup[0]), (int)round(rotup[1]));
                        break;
                    case 2:
                        sprintf(rs->logs, "%d,%d,", (int)round(rotrt[0]), (int)round(rotrt[1]));
                        break;
                    case 3:
                        sprintf(rs->logs, "%d,%d,", (int)round(rotdn[0]), (int)round(rotdn[1]));
                        break;
                    default:
                        break;
                }
                n = strlen(rs->logs);
                memcpy(&sendbuf[5], rs->logs, n);

                sendbuf[5+n] = 0xfb;
                sendbuf[5+n+1] = '\n';
                sendbuf[5+n+2] = '\0';
                ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                #if 0//LOG_P6_CROP_EN
                sprintf_f(rs->logs, "socket send CROP  %c %d [ %s ], len:%d \n", sendbuf[3], i, &sendbuf[5], 5+n+3);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
            }          
            #endif // #if !CROP_MIGRATE_TO_APP

            #if !MOVE_MUTX_TO_FRONT_P6
            ch = 0; 
            while (ch != 'd') {
                ret = rs_ipc_get_ms(rs, &ch, 1, 500);
                if (ret > 0) {
                    if (ch == 'd') {
                        sprintf_f(rs->logs, "succeed to get ch == %c\n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    } else {
                        sprintf_f(rs->logs, "wrong!! ch == %c \n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    }
                } else {
                    sprintf_f(rs->logs, "wait for d1 ret: \n", ret);
                    print_f(rs->plogs, "P6", rs->logs);    
                }
            }
            ch = 0; 
            while (ch != 'd') {
                ret = rs_ipc_get_ms(rs, &ch, 1, 500);
                if (ret > 0) {
                    if (ch == 'd') {
                        sprintf_f(rs->logs, "duo succeed to get ch == %c\n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    } else {
                        sprintf_f(rs->logs, "duo wrong!! ch == %c \n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    }
                } else {
                    sprintf_f(rs->logs, "wait for d2 ret: \n", ret);
                    print_f(rs->plogs, "P6", rs->logs);    
                }
            }
            #endif

            if (pmass->massRecd) {
                //sprintf_f(rs->logs, "reset Record line and used buffer size, recd: %d, used: %d, duo recd: %d, used: %d\n", 
                //pmass->massRecd, pmass->massUsed, pmassduo->massRecd, pmassduo->massUsed);
                //print_f(rs->plogs, "P6", rs->logs);    
            
                pmass->massRecd = 0;
                pmass->massUsed = 0;

                pmassduo->massRecd = 0;
                pmassduo->massUsed = 0;
            }

            sprintf_f(rs->logs, "param: %c, image len: %d (%d) duo: %d (%d)\n", param, h, pct[ASPOP_IMG_LEN].opValue, hduo, pct[ASPOP_IMG_LEN_DUO].opValue);
            print_f(rs->plogs, "P6", rs->logs); 
            
            if ((param == 'E') || (csws != 0) || (cswd != 0)) {
                rs_ipc_put(rs, "Q", 1);
                sprintf_f(rs->logs, "return \"Q\" \n");
                print_f(rs->plogs, "P6", rs->logs);    
            } else {
                rs_ipc_put(rs, "D", 1);
                sprintf_f(rs->logs, "return \"D\" \n");
                print_f(rs->plogs, "P6", rs->logs);    
            }

            goto socketEnd;
        }
        
        if (opcode == 0x19) { /* send CROP info (new)*/
            sprintf_f(rs->logs, "handle opcode: 0x%x param: 0x%x (CROP new)\n", opcode, param);
            print_f(rs->plogs, "P6", rs->logs);

            #if MOVE_MUTX_TO_FRONT_P6
            ch = 0;
            while (ch != 'c') {
                ret = rs_ipc_get_ms(rs, &ch, 1, 500);
                if (ret > 0) {
                    if (ch == 'c') {
                        sprintf_f(rs->logs, "succeed to get ch == %c\n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    } else {
                        sprintf_f(rs->logs, "wrong!! ch == %c \n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    }
                } else {
                    sprintf_f(rs->logs, "wait for c ret: %d\n", ret);
                    print_f(rs->plogs, "P6", rs->logs);    
                }
            }
            #endif
            
            ret = cfgTableGetChk(pct, ASPOP_FILE_FORMAT, &ffrmt, ASPOP_STA_APP);    
            #if LOG_P6_PARA_EN
            sprintf_f(rs->logs, "user defined file format: %d, ret:%d\n", ffrmt, ret);
            print_f(rs->plogs, "P6", rs->logs);
            #endif

            tmp = 0;
            ret = cfgTableGetChkDPI(pct, ASPOP_RESOLUTION, &tmp, ASPOP_STA_APP);
            dpi = tmp;
            #if LOG_P6_PARA_EN
            sprintf_f(rs->logs, "user defined resulution: %d(dpi: %d), ret:%d\n", tmp, dpi, ret);
            print_f(rs->plogs, "P6", rs->logs);
            #endif
            
            cnt = 0;
            while (1) {
                num = 0;
                for (i = 0; i < (CROP_MAX_NUM_META+1); i++) {
                    idx = ASPOP_CROP_01 + i;
                    
                    switch(idx) {
                        case ASPOP_CROP_01:
                        case ASPOP_CROP_02:
                        case ASPOP_CROP_03:
                        case ASPOP_CROP_04:
                        case ASPOP_CROP_05:
                        case ASPOP_CROP_06:
                        case ASPOP_CROP_07:
                        case ASPOP_CROP_08:
                        case ASPOP_CROP_09:
                        case ASPOP_CROP_10:
                        case ASPOP_CROP_11:
                        case ASPOP_CROP_12:
                        case ASPOP_CROP_13:
                        case ASPOP_CROP_14:
                        case ASPOP_CROP_15:
                        case ASPOP_CROP_16:
                        case ASPOP_CROP_17:
                        case ASPOP_CROP_18:
                            pdt = &pct[idx];
                            if (pdt->opStatus == ASPOP_STA_UPD) {
                                num++;
                            }

                            break;
                        default:
                            break;
                    }
                    
                }

                if (num == CROP_MAX_NUM_META) {
                    break;
                }

                sprintf_f(rs->logs, "wait crop %d, %d s\n", num, cnt/2);
                print_f(rs->plogs, "P6", rs->logs);
                
                usleep(500000);
                cnt ++;
            }

            /* send back bmp header */
            tmp = 0;
            ret = cfgTableGetChk(pct, ASPOP_FILE_FORMAT, &tmp, ASPOP_STA_APP);    
            #if LOG_P6_PARA_EN
            sprintf_f(rs->logs, "user defined file format: %d, ret:%d\n", tmp, ret);
            print_f(rs->plogs, "P6", rs->logs);
            #endif
                
            val=0;
            ret = cfgTableGetChk(pct, ASPOP_IMG_LEN, &val, ASPOP_STA_APP);    
            #if LOG_P6_PARA_EN
            sprintf_f(rs->logs, "user defined image length: %d, ret:%d\n", val, ret);
            print_f(rs->plogs, "P6", rs->logs);
            #endif
            h = val;
                
            if (tmp == FILE_FORMAT_RAW) {
                ph = &rs->pbheader->aspbmpMagic[2];
                len = sizeof(struct bitmapHeader_s) - 2;
                bheader = rs->pbheader;
                clr=0;w=0;
                
                //dbgBitmapHeader(bheader, len);
                
                /* bmp header needs 1.width 2.height 3.dpi 4.raw size */
                ret = cfgTableGetChk(pct, ASPOP_COLOR_MODE, &tmp, ASPOP_STA_APP);    
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "user defined color mode: %d, ret:%d\n", tmp, ret);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
                switch (tmp) {
                    case COLOR_MODE_COLOR:
                        clr = 24;
                        break;
                    case COLOR_MODE_GRAY:
                    case COLOR_MODE_GRAY_DETAIL:
                    case COLOR_MODE_BLACKWHITE:
                        clr = 8;
                        break;
                    default:
                        clr = 24;
                        break;
                }
                
                ret = cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_H, &val, ASPOP_STA_APP);    
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "user defined width high: %d, ret:%d\n", val, ret);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
                
                ret = cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_L, &tmp, ASPOP_STA_APP);    
                t = val << 8 | tmp;

                val = 0;
                ret = cfgTableGetChk(pct, ASPOP_SCAN_WIDTH, &val, ASPOP_STA_UPD);

                w = scanWidthConvert(t, val);
                #if LOG_P6_PARA_EN
                sprintf_f(rs->logs, "user defined width low: %d, ret:%d, w = %d (tag:%d)\n", tmp, ret, w, t);
                print_f(rs->plogs, "P6", rs->logs);                
                #endif
                
                //pct[ASPOP_IMG_LEN].opStatus = ASPOP_STA_APP;
                
                hbuff = aspMemalloc(1078, 6);
                if (!hbuff) {
                    goto socketEnd;
                }
                
                if (clr == 8) {
                    hlen = 1078;
                } else if (clr == 24) {
                    hlen = 54;            
                } else {
                    printf("[P6] ERROR!!! color bits is %d \n", clr);
                    goto socketEnd;
                }
                
                orglen = hlen;
                
                ret = cfgTableGetChk(pct, ASPOP_RAW_SIZE, &val, ASPOP_STA_APP);    
                sprintf_f(rs->logs, "scan raw data size: %d, ret:%d\n", val, ret);
                print_f(rs->plogs, "P6", rs->logs);
                
                /* calculate sector start and sector length of file */            
                
                datlen = val + hlen;
                
                sprintf_f(rs->logs, "bitmap info color: %d, w: %d, h: %d, dpi: %d, imglen: %d, use: %d\n", clr, w, h, dpi, val, hlen);
                print_f(rs->plogs, "P6", rs->logs);

                #if BMP_TEST /* for test */
                if (clr == 8) {
                    bitmapHeaderSetup(bheader, 8, 5184, 6524, 300, val);
                } else {
                    //bitmapHeaderSetup(bheader, 24, 2304, 3456, 600, val);
                    bitmapHeaderSetup(bheader, 24, 2160, 3496, 600, val);
                }
                #else           
                bitmapHeaderSetup(bheader, clr, w, h, dpi, val);
                #endif
                
                ph = &rs->pbheader->aspbmpMagic[2];
                len = sizeof(struct bitmapHeader_s) - 2;
                memcpy(hbuff, ph, len);
                
                hlen -= len;
                if (hlen > 0) {
                    bitmapColorTableSetup(hbuff+len);
                    hlen -= 1024;
                }
                
                if (hlen) {
                    printf("[fs98] Error!!! the bitmap header len is wrong %d orginal is %d\n", hlen, orglen);
                    hlen = 0;
                } 
                
                dbgBitmapHeader(bheader, len);
                
                sendbuf[3] = 'L';
                
                sprintf(rs->logs, "%d,\n\r", orglen*2);
                n = strlen(rs->logs);
                if (n > (P6_SEND_BUFF_SIZE - 32)) n = P6_SEND_BUFF_SIZE - 32;
                
                memcpy(&sendbuf[5], rs->logs, n);
                
                sendbuf[5+n] = 0xfb;
                sendbuf[5+n+1] = '\n';
                sendbuf[5+n+2] = '\0';
                ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
                print_f(rs->plogs, "P6", rs->logs);
                
                sendbuf[3] = 'B';
                
                bin2hex(&sendbuf[5], hbuff, orglen);
                //memcpy(&sendbuf[5], hbuff, orglen);
                //memset(&sendbuf[5], 0x95, P6_SEND_BUFF_SIZE - 5);
                
                n = orglen * 2;
                
                sendbuf[5+n] = 0xfb;
                sendbuf[5+n+1] = '\n';
                sendbuf[5+n+2] = '\0';
                
                //shmem_dump(sendbuf, P6_SEND_BUFF_SIZE);
                            
                ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                //sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
                //print_f(rs->plogs, "P6", rs->logs);
            }
            
            /* initial cropping config */
            memset(pcp36, 0, sizeof(struct aspCrop36_s));
            memset(pcpex, 0, sizeof(struct aspCropExtra_s));

            #if 1
            pdt = &pct[ASPOP_CROP_02];
            crpMx = pdt->opValue & 0xffff;
            #else
            crpMx = h;
            #endif

            for (i = 0; i < (CROP_MAX_NUM_META+1); i++) {
                idx = ASPOP_CROP_01 + i;
                pdt = &pct[idx];
                switch(idx) {
                    case ASPOP_CROP_01:
                    case ASPOP_CROP_02:
                    case ASPOP_CROP_03:
                    case ASPOP_CROP_04:
                    case ASPOP_CROP_05:
                    case ASPOP_CROP_06:
                        cpn = (idx - ASPOP_CROP_01) + 1;
                        pdt = &pct[idx];
                        if (pdt->opStatus == ASPOP_STA_UPD) {

                            #if LOG_P6_CROP_EN
                            sprintf_f(rs->logs, "CROP%.2d. [0x%.8x]     {%d,  %d}  \n", i+1, pdt->opValue, pdt->opValue >> 16, pdt->opValue & 0xffff); 
                            print_f(rs->plogs, "P6", rs->logs);  
                            #endif
                            
                            sendbuf[3] = 'C';

                            val = pdt->opValue >> 16;
                            if (dpi < 300) {
                                val = (val * dpi) / 300;
                            }

                            if (ffrmt == FILE_FORMAT_RAW) {
                                vhi = pdt->opValue & 0xffff;
                                if (crpMx < vhi) {
                                    vhi = 0xffff;
                                } else {
                                    vhi = crpMx - vhi;
                                }
                            } else {
                                vhi = pdt->opValue & 0xffff;
                            }
                            
                            sprintf(rs->logs, "%d,%d,", val, vhi);
                            n = strlen(rs->logs);

                            #if 0
                            pcp36->crp36Pots[cpn*2+0] = val;
                            pcp36->crp36Pots[cpn*2+1] = vhi;
                            #endif

                            pdt->opStatus = ASPOP_STA_APP;
                        }

                        break;
                    case ASPOP_CROP_07:
                    case ASPOP_CROP_08:
                    case ASPOP_CROP_09:
                    case ASPOP_CROP_10:
                    case ASPOP_CROP_11:
                    case ASPOP_CROP_12:
                    case ASPOP_CROP_13:
                    case ASPOP_CROP_14:
                    case ASPOP_CROP_15:
                    case ASPOP_CROP_16:
                    case ASPOP_CROP_17:
                    case ASPOP_CROP_18:
                        cpn = idx - ASPOP_CROP_01;
                        pdt = &pct[idx];
                        if (pdt->opStatus == ASPOP_STA_UPD) {

                            #if LOG_P6_CROP_EN
                            sprintf_f(rs->logs, "CROP%.2d. [0x%.8x]     {%d,  %d}  \n", i, pdt->opValue, pdt->opValue >> 16, pdt->opValue & 0xffff); 
                            print_f(rs->plogs, "P6", rs->logs);  
                            #endif
                            
                            sendbuf[3] = 'C';

                            val = pdt->opValue >> 16;
                            if (dpi < 300) {
                                val = (val * dpi) / 300;
                            }

                            if (ffrmt == FILE_FORMAT_RAW) {
                                vhi = pdt->opValue & 0xffff;
                                if (crpMx < vhi) {
                                    vhi = 0xffff;
                                } else {
                                    vhi = crpMx - vhi;
                                }
                            } else {
                                vhi = pdt->opValue & 0xffff;
                            }
                            
                            sprintf(rs->logs, "%d,%d,", val, vhi);
                            n = strlen(rs->logs);

                            #if 0
                            pcp36->crp36Pots[cpn*2+0] = val;
                            pcp36->crp36Pots[cpn*2+1] = vhi;
                            #endif

                            pdt->opStatus = ASPOP_STA_APP;
                        }

                        break;
                    case ASPOP_IMG_LEN:
                        pdt = &pct[idx];
                        
                        if (pdt->opStatus != ASPOP_STA_NONE) {
                            sendbuf[3] = 'H';
                            sprintf(rs->logs, "%d,\n\r", pdt->opValue & 0xffff);
                            n = strlen(rs->logs);
                        }
                        pdt->opStatus = ASPOP_STA_APP;
                        break;
                    default:
                        break;
                }
                
                #if 1//CROP_MIGRATE_TO_APP
                if (n > (P6_SEND_BUFF_SIZE - 16)) n = (P6_SEND_BUFF_SIZE - 16);
                
                memcpy(&sendbuf[5], rs->logs, n);

                sendbuf[5+n] = 0xfb;
                sendbuf[5+n+1] = '\n';
                sendbuf[5+n+2] = '\0';
                ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                #if 0//LOG_P6_CROP_EN
                sendbuf[5+n] = '\0';         
                sprintf_f(rs->logs, "socket send CROP%.2d [ %s \n], len:%d \n", i, &sendbuf[5], 5+n+3);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
                #endif

            }

            val = 0;
            ret = cfgTableGetChk(pct, ASPOP_SCAN_SIDE, &val, ASPOP_STA_UPD);
            
            //sprintf_f(rs->logs, "get usb page side: 0x%.2x ret: %d\n", val, ret);
            //print_f(rs->plogs, "P6", rs->logs);

            sendbuf[3] = 'P';

            sprintf(rs->logs, "%d,\n\r", val & 0xff);
            n = strlen(rs->logs);
            if (n > 256) n = 256;

            memcpy(&sendbuf[5], rs->logs, n);

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            //sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            //print_f(rs->plogs, "P6", rs->logs);
            
            csws = 0;
            cfgTableGetChk(pct, ASPOP_SCAN_STATUS, &csws, ASPOP_STA_UPD);

            sprintf_f(rs->logs, "get usb scan status: 0x%.2x ret: %d\n", csws, ret);
            print_f(rs->plogs, "P6", rs->logs);

            sendbuf[3] = 'S';

            sprintf(rs->logs, "%d,\n\r", csws & 0xff);
            n = strlen(rs->logs);
            if (n > 256) n = 256;

            memcpy(&sendbuf[5], rs->logs, n);

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            //sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            //print_f(rs->plogs, "P6", rs->logs);

            val = 0;
            cfgTableGetChk(pct, ASPOP_IMG_LEN, &val, ASPOP_STA_UPD);

            sprintf_f(rs->logs, "get image len: %d ret: %d\n", val, ret);
            print_f(rs->plogs, "P6", rs->logs);

            sendbuf[3] = 'L';

            sprintf(rs->logs, "%d,\n\r", val & 0xff);
            n = strlen(rs->logs);
            if (n > 256) n = 256;

            memcpy(&sendbuf[5], rs->logs, n);

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            print_f(rs->plogs, "P6", rs->logs);

            #if 0
            cpn = 0;
            pcp36->crp36Pots[cpn*2+0] = 100;
            pcp36->crp36Pots[cpn*2+1] = 0;

            cpn = CROP_MAX_NUM_META+1;
            pcp36->crp36Pots[cpn*2+0] = 1100;
            pcp36->crp36Pots[cpn*2+1] = 0;

            msync(pmass, sizeof(struct aspMetaMass_s), MS_SYNC);
            msync(pmass->masspt, pmass->massUsed, MS_SYNC);
            ret = doCropCalcuPt(pcpdo, ptmetausb, pmass->masspt, pmass->massUsed, rs, 6);
            sprintf_f(rs->logs, "do set extra points first ret: %d \n", ret);
            print_f(rs->plogs, "P6", rs->logs);

            ret = doCropCalcu36(pcpdo, 0, 0, rs, 6);
            sprintf_f(rs->logs, "do crop 36 ret: %d \n", ret);
            print_f(rs->plogs, "P6", rs->logs);
            #endif
            
            masRecd = pmass->massRecd;

            sendbuf[3] = 'T';
            sprintf(rs->logs, "%d \n\r", masRecd); 
            print_f(rs->plogs, "P6", rs->logs);

            n = strlen(rs->logs);
            memcpy(&sendbuf[5], rs->logs, n);

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';

            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            //sprintf(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            //print_f(rs->plogs, "P6", rs->logs);

            if (pmass->massRecd > 1) {

                #if 0
                if (ffrmt == FILE_FORMAT_RAW) {
                    cpx = 0;
                    cpn = 2;
                    pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                    cpn = 3;
                    pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];

                    cpx = 1;
                    cpn = 17;
                    pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                    cpn = 18;
                    pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];

                    cpx = 2;
                    cpn = 15;
                    pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                    cpn = 16;
                    pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];

                    cpx = 3;
                    cpn = 13;
                    pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                    cpn = 14;
                    pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];

                    cpx = 4;
                    cpn = 11;
                    pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                    cpn = 12;
                    pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                }
                else {
                    cpx = 0;
                    cpn = 6;
                    pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                    cpn = 5;
                    pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];

                    cpx = 1;
                    cpn = 7;
                    pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                    cpn = 8;
                    pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];

                    cpx = 2;
                    cpn = 9;
                    pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                    cpn = 10;
                    pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                    pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                }

                cof = cpx + 1;
                #else
                cof = 0;
                #endif

                ret = 0;
                
                masUsed = pmass->massUsed;
                masStart = pmass->massStart;                
                
                sprintf_f(rs->logs, "wait meta mass (used:%d, start:%d) %d\n", masUsed, masStart, cnt); 
                print_f(rs->plogs, "P6", rs->logs);

                cnt = 0;

                masUsed = pmass->massUsed;
                while (!masUsed) {
                    usleep(500000);
                    msync(pmass, sizeof(struct aspMetaMass_s), MS_SYNC);
                    masUsed = pmass->massUsed;
                    sprintf_f(rs->logs, "wait meta mass (used:%d) %d\n", masUsed, cnt); 
                    print_f(rs->plogs, "P6", rs->logs);
                }

                msync(pmass->masspt, masUsed, MS_SYNC);
                ptBuf = (unsigned short *)pmass->masspt;
                
                cy = masStart;
                gap = pmass->massGap;

                #if 1
                pdt = &pct[ASPOP_CROP_02];
                crpMx = pdt->opValue & 0xffff;
                #else
                crpMx = h;
                #endif

                linecnt = 0;
                plancnt = masRecd;

                #ifdef CROP_SELEC_RATIO
                selecRatio = CROP_SELEC_RATIO / 100.0;
                selecCur = 0.0;
                selecPic = 0.0;
                selecMax = (CFLOAT) masRecd * selecRatio;
                plancnt = (int) selecMax;
                #endif

                //sprintf(rs->logs, "start line:%d, gap: %d, select ratio: %lf, line max: %d\n", cy, gap, selecRatio, plancnt); 
                //print_f(rs->plogs, "P6", rs->logs);
                    
                for (i = 0; i < masRecd; i++) {
                    cxm = *ptBuf;
                    ptBuf++;
                    cxn = *ptBuf;
                    ptBuf++;

                    #ifdef CROP_SELEC_RATIO
                    if ((i > CROP_SELEC_HEAD) && (i < (masRecd - CROP_SELEC_TAIL))) {
                        selecBase = i;
                        selecCur = selecBase * selecRatio;
                    
                        ipic = (int)(selecPic);
                        icur = (int)(selecCur);

                        //sprintf(rs->logs, "%d,(%d, %d)\n", i, icur, ipic); 
                        //print_f(rs->plogs, "P6", rs->logs);
                    
                        if (icur > ipic) {
                            selecPic = selecCur;
                            //sprintf(rs->logs, "%d,%d,%d (pick!!!)\n", i, cxm, cxn); 
                            //print_f(rs->plogs, "P6", rs->logs);
                        } else {
                            sprintf(rs->logs, "%d,%d,%d (skip!!!)\n", i, cxm, cxn); 
                            print_f(rs->plogs, "P6", rs->logs);
                            continue;
                        }
                    }
                    #endif

                    if (dpi < 300) {
                        cxm = (cxm * dpi) / 300;
                        cxn = (cxn * dpi) / 300;
                    }

                    if (ffrmt == FILE_FORMAT_RAW) {
                        vhi = crpMx - cy;
                    } else {
                        vhi = cy;
                    }

                    sprintf(rs->logs, "%d,%d,%d,\n\r", vhi, cxm, cxn); 
                    
                    if (ffrmt == FILE_FORMAT_RAW) {
                        cpx = (plancnt - linecnt - 1) + cof;
                    } else {
                        cpx = linecnt + cof;
                    }

                    linecnt ++;

                    #if 0
                    pcpex->crpexLfPots[cpx*2+0] = cxm;
                    pcpex->crpexLfPots[cpx*2+1] = vhi;
                    pcpex->crpexRtPots[cpx*2+0] = cxn;
                    pcpex->crpexRtPots[cpx*2+1] = vhi;
                    #endif

                    cy += gap;

                    #if 1 /* send unsort mass points to app */
                    sendbuf[3] = 'M';
                    n = strlen(rs->logs);
                    memcpy(&sendbuf[5], rs->logs, n);

                    sendbuf[5+n] = 0xfb;
                    sendbuf[5+n+1] = '\n';
                    sendbuf[5+n+2] = '\0';
                    ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                    sendbuf[5+n] = '\0';
                    sendbuf[5+n+1] = '\0';
                    //sprintf(rs->logs, "socket send, %d. [%s], ret:%d\n", cpx, &sendbuf[5], ret);
                    //print_f(rs->plogs, "P6", rs->logs);
                    #endif

                }

                cpx = linecnt + cof;
                cls =  masRecd + cof - 1;

                #if 0
                if (ffrmt == FILE_FORMAT_RAW) {
                    cpn = 9;
                    if (pcp36->crp36Pots[cpn*2+1] > pcpex->crpexRtPots[cls*2+1]) {
                        pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpn = 10;
                        pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }
                    
                    cpn = 7;
                    if (pcp36->crp36Pots[cpn*2+1] > pcpex->crpexRtPots[cls*2+1]) {
                        pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpn = 8;
                        pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }
                    
                    cpn = 5;
                    if (pcp36->crp36Pots[cpn*2+1] > pcpex->crpexRtPots[cls*2+1]) {
                        pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpn = 6;
                        pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }
                }
                else {
                    cpn = 11;
                    if (pcp36->crp36Pots[cpn*2+1] > pcpex->crpexRtPots[cls*2+1]) {
                        pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpn = 12;
                        pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }

                    cpn = 13;
                    if (pcp36->crp36Pots[cpn*2+1] > pcpex->crpexRtPots[cls*2+1]) {
                        pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpn = 14;
                        pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }

                    cpn = 15;
                    if (pcp36->crp36Pots[cpn*2+1] > pcpex->crpexRtPots[cls*2+1]) {
                        pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpn = 16;
                        pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }

                    cpn = 17;
                    if (pcp36->crp36Pots[cpn*2+1] > pcpex->crpexRtPots[cls*2+1]) {
                        pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpn = 18;
                        pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }

                    cpn = 2;
                    if (pcp36->crp36Pots[cpn*2+1] > pcpex->crpexRtPots[cls*2+1]) {
                        pcpex->crpexLfPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexLfPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpn = 3;
                        pcpex->crpexRtPots[cpx*2+0] = pcp36->crp36Pots[cpn*2+0];
                        pcpex->crpexRtPots[cpx*2+1] = pcp36->crp36Pots[cpn*2+1];
                        cpx += 1;
                    }
                }

                
                pcpex->crpexSize = cpx*2;
                
                msync(pcpex, sizeof(struct aspCropExtra_s), MS_SYNC);

                sprintf_f(rs->logs, "total extra points size: %d \n", cpx);
                print_f(rs->plogs, "P6", rs->logs);

                aspSortD(pcpex->crpexLfPots, cpx); /* max sort = 1024 */
                aspSortD(pcpex->crpexRtPots, cpx); /* max sort = 1024 */
                
                ret = getRotateP1(pcp36, mostlft);
                
                #if LOG_P6_CROP_EN
                if (!ret) {
                    sprintf_f(rs->logs, "get most left (%lf, %lf) \n", mostlft[0], mostlft[1]);
                    print_f(rs->plogs, "P6", rs->logs);
                }
                #endif
                
                fwh = mostlft[1] - (gap * 2);
                if (fwh < 0.0) {
                    fwh = 0.0;
                }

                ret = getRotateP3(pcp36, mostrgt);
                
                #if LOG_P6_CROP_EN
                if (!ret) {
                    sprintf_f(rs->logs, "get most right (%lf, %lf) \n", mostrgt[0], mostrgt[1]);
                    print_f(rs->plogs, "P6", rs->logs);
                }
                #endif
                
                fwe = mostrgt[1] - (gap * 2);
                if (fwe < 0.0) {
                    fwe = 0.0;
                }
                
                cnt = 0; 
                ix = 0;
                for (i = 0; i < cpx; i++) {

                    #if LOG_P6_CROP_EN
                    sprintf_f(rs->logs, "%d. L%lf, %lf R%lf, %lf \n", i
                              , pcpex->crpexLfPots[i*2+0], pcpex->crpexLfPots[i*2+1], pcpex->crpexRtPots[i*2+0], pcpex->crpexRtPots[i*2+1]);
                    print_f(rs->plogs, "P6", rs->logs);
                    #endif

                    vhi = (int)pcpex->crpexLfPots[i*2+1];
                    cxm = (int)pcpex->crpexLfPots[i*2+0];
                    cxn = (int)pcpex->crpexRtPots[i*2+0];

                    #if 0 /* should not send the sort mass points */
                    sprintf(rs->logs, "%d,%d,%d,\r", vhi, cxm, cxn); 

                    sendbuf[3] = 'M';
                    n = strlen(rs->logs);
                    memcpy(&sendbuf[5], rs->logs, n);

                    sendbuf[5+n] = 0xfb;
                    sendbuf[5+n+1] = '\n';
                    sendbuf[5+n+2] = '\0';
                    ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                    #endif
                    
                    #if 0
                    sendbuf[5+n] = '\0';
                    sendbuf[5+n+1] = '\0';
                    sprintf(rs->logs, "socket send, %d. [%s], ret:%d\n", cpx, &sendbuf[5], ret);
                    print_f(rs->plogs, "P6", rs->logs);
                    #endif
                    
                    fhi = (CFLOAT)vhi;
                    
                    if (cnt < 4) {
                        if (fhi > fwh) {
                            lftgrp[cnt][0] = cxm;
                            lftgrp[cnt][1] = fhi;

                            cnt ++;
                        }
                    }

                    if (ix < 4) {
                        if (fhi > fwe) {
                            rgtgrp[ix][0] = cxn;
                            rgtgrp[ix][1] = fhi;

                            ix ++;
                        }
                    }
                    
                }
                #endif
                
                //shmem_dump(pmass->masspt, pmass->massUsed);

                #if 0
                masStart = pmass->massStart;
                while (masStart != 0) {
                    masStart = pmass->massStart;
                    usleep(100000);
                }
                #endif

                //pmass->massRecd = 0; /* move to the end of transmitting */
                //pmass->massUsed = 0;
                #if 0// !CROP_MIGRATE_TO_APP
                /* fix most left and most right shift */  
                fhi = 0.0; fwh = 0.0; fwe = 0.0;
                for (ix=0; ix < 4; ix++) {
                
                    #if LOG_P6_CROP_EN
                    sprintf_f(rs->logs, "left apporach group (%lf, %lf) \n", lftgrp[ix][0], lftgrp[ix][1]);
                    print_f(rs->plogs, "P6", rs->logs);
                    #endif
                    
                    fhi += lftgrp[ix][0] - mostlft[0];
                    fwh += lftgrp[ix][0];
                }
                
                fwe = fhi / 4.0;
                if (fwe > 15.0) {
                    mostlft[0] = fwh / 4.0;
                    setRotateP1(pcp36, mostlft);
                
                    #if 1//LOG_P6_CROP_EN
                    sprintf_f(rs->logs, "correct most left (%lf, %lf) \n", mostlft[0], mostlft[1]);
                    print_f(rs->plogs, "P6", rs->logs);
                    #endif
                
                }
                
                fhi = 0.0; fwh = 0.0; fwe = 0.0;
                for (ix=0; ix < 4; ix++) {
                
                    #if LOG_P6_CROP_EN
                    sprintf_f(rs->logs, "right apporach group (%lf, %lf) \n", rgtgrp[ix][0], rgtgrp[ix][1]);
                    print_f(rs->plogs, "P6", rs->logs);
                    #endif
                
                    fhi += mostrgt[0] - rgtgrp[ix][0];
                    fwh += rgtgrp[ix][0];
                }
                
                fwe = fhi / 4.0;
                if (fwe > 15.0) {
                    mostrgt[0] = fwh / 4.0;
                    setRotateP3(pcp36, mostrgt);
                
                    #if 1//LOG_P6_CROP_EN
                    sprintf_f(rs->logs, "correct most right (%lf, %lf) \n", mostrgt[0], mostrgt[1]);
                    print_f(rs->plogs, "P6", rs->logs);
                    #endif
                
                }
                #endif  // #if !CROP_MIGRATE_TO_APP
            } 

            #if 0
            ret = doCropCalcu(pcpdo, 0, 0, rs, 6); 
            #endif

            ret = cfgTableGet(pct, ASPOP_USBCROP_FP01, &val);
            cxm = (val>>16)&0xffff;
            cxn = val & 0xffff;
            //sprintf_f(rs->logs, "crop meta get F1: (%d, %d) ret: %d\n", cxm, cxn, ret); 
            //print_f(rs->plogs, "P6", rs->logs);                     
            rotlf[0] = (CFLOAT)cxm;
            rotlf[1] = (CFLOAT)cxn;

            ret = cfgTableGet(pct, ASPOP_USBCROP_FP02, &val);
            cxm = (val>>16)&0xffff;
            cxn = val & 0xffff;
            //sprintf_f(rs->logs, "crop meta get F2: (%d, %d) ret: %d\n", cxm, cxn, ret); 
            //print_f(rs->plogs, "P6", rs->logs);                     
            rotup[0] = (CFLOAT)cxm;
            rotup[1] = (CFLOAT)cxn;

            ret = cfgTableGet(pct, ASPOP_USBCROP_FP03, &val);
            cxm = (val>>16)&0xffff;
            cxn = val & 0xffff;
            //sprintf_f(rs->logs, "crop meta get F3: (%d, %d) ret: %d\n", cxm, cxn, ret); 
            //print_f(rs->plogs, "P6", rs->logs);                     
            rotrt[0] = (CFLOAT)cxm;
            rotrt[1] = (CFLOAT)cxn;

            ret = cfgTableGet(pct, ASPOP_USBCROP_FP04, &val);
            cxm = (val>>16)&0xffff;
            cxn = val & 0xffff;
            //sprintf_f(rs->logs, "crop meta get F4: (%d, %d) ret: %d\n", cxm, cxn, ret); 
            //print_f(rs->plogs, "P6", rs->logs);                     
            rotdn[0] = (CFLOAT)cxm;
            rotdn[1] = (CFLOAT)cxn;

            #if 0
            msync(pcp36, sizeof(struct aspCrop36_s), MS_SYNC);
            ret = getRotateP1(pcp36, rotlf);
            if (!ret) {
                sprintf_f(rs->logs, "get rotateP1 (%lf, %lf) \n", rotlf[0], rotlf[1]);
                print_f(rs->plogs, "P6", rs->logs);
            }

            ret = getRotateP2(pcp36, rotup);
            if (!ret) {
                sprintf_f(rs->logs, "get rotateP2 (%lf, %lf) \n", rotup[0], rotup[1]);
                print_f(rs->plogs, "P6", rs->logs);
            }

            ret = getRotateP3(pcp36, rotrt);
            if (!ret) {
                sprintf_f(rs->logs, "get rotateP3 (%lf, %lf) \n", rotrt[0], rotrt[1]);
                print_f(rs->plogs, "P6", rs->logs);
            }

            ret = getRotateP4(pcp36, rotdn);
            if (!ret) {
                sprintf_f(rs->logs, "get rotateP4 (%lf, %lf) \n", rotdn[0], rotdn[1]);
                print_f(rs->plogs, "P6", rs->logs);
            }
            #endif

            #if 0 /* debug print */
            for (i = 0; i < CROP_MAX_NUM_META+2; i++) {
                sprintf_f(rs->logs, "%d. %lf, %lf \n", i, pcp36->crp36Pots[i*2+0], pcp36->crp36Pots[i*2+1]);
                print_f(rs->plogs, "P6", rs->logs);
            }

            
            for (i = 0; i < pcpex->crpexSize; i++) {
                sprintf_f(rs->logs, "L%d. %lf, %lf \n", i, pcpex->crpexLfPots[i*2+0], pcpex->crpexLfPots[i*2+1]);
                print_f(rs->plogs, "P6", rs->logs);
                sprintf_f(rs->logs, "R%d. %lf, %lf \n", i, pcpex->crpexRtPots[i*2+0], pcpex->crpexRtPots[i*2+1]);
                print_f(rs->plogs, "P6", rs->logs);
            }
            #endif

            #if !CROP_MIGRATE_TO_APP
            for (i = 0; i < 4; i++) { /* send the cropping result to APP */
                sendbuf[3] = 'F';

                switch (i) {
                    case 0:
                        sprintf(rs->logs, "%d,%d,", (int)round(rotlf[0]), (int)round(rotlf[1]));
                        break;
                    case 1:
                        sprintf(rs->logs, "%d,%d,", (int)round(rotup[0]), (int)round(rotup[1]));
                        break;
                    case 2:
                        sprintf(rs->logs, "%d,%d,", (int)round(rotrt[0]), (int)round(rotrt[1]));
                        break;
                    case 3:
                        sprintf(rs->logs, "%d,%d,", (int)round(rotdn[0]), (int)round(rotdn[1]));
                        break;
                    default:
                        break;
                }
                n = strlen(rs->logs);
                memcpy(&sendbuf[5], rs->logs, n);

                sendbuf[5+n] = 0xfb;
                sendbuf[5+n+1] = '\n';
                sendbuf[5+n+2] = '\0';
                ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                #if 0//LOG_P6_CROP_EN
                sprintf_f(rs->logs, "socket send CROP  F %d [ %s ], len:%d \n", i, &sendbuf[5], 5+n+3);
                print_f(rs->plogs, "P6", rs->logs);
                #endif
            }
            #endif  //#if !CROP_MIGRATE_TO_APP

            #if !MOVE_MUTX_TO_FRONT_P6
            ch = 0;
            while (ch != 'c') {
                ret = rs_ipc_get_ms(rs, &ch, 1, 500);
                if (ret > 0) {
                    if (ch == 'c') {
                        sprintf_f(rs->logs, "succeed to get ch == %c\n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    } else {
                        sprintf_f(rs->logs, "wrong!! ch == %c \n", ch);
                        print_f(rs->plogs, "P6", rs->logs);    
                    }
                } else {
                    sprintf_f(rs->logs, "wait for c ret: \n", ret);
                    print_f(rs->plogs, "P6", rs->logs);    
                }
            }
            #endif
            
            if (pmass->massRecd) {
                //sprintf_f(rs->logs, "reset Record line and used buffer size, recd: %d, used: %d\n", 
                //pmass->massRecd, pmass->massUsed);
                //print_f(rs->plogs, "P6", rs->logs);    
                    
                pmass->massRecd = 0;
                pmass->massUsed = 0;
            }

            sprintf_f(rs->logs, "param: %c, image len: %d (%d) \n", param, h, pct[ASPOP_IMG_LEN].opValue);
            print_f(rs->plogs, "P6", rs->logs);    

            if ((param == 'E') || (csws != 0)) {
                rs_ipc_put(rs, "E", 1);
                sprintf_f(rs->logs, "return \"E\" \n");
                print_f(rs->plogs, "P6", rs->logs);    
            } else {
                rs_ipc_put(rs, "C", 1);
                sprintf_f(rs->logs, "return \"C\" \n");
                print_f(rs->plogs, "P6", rs->logs);    
            }

            goto socketEnd;
        }
        
        if (opcode == 0x18) { /* update parameter */
            sprintf_f(rs->logs, "handle opcode: 0x%x(PARA)\n", opcode);
            print_f(rs->plogs, "P6", rs->logs);

            ret = asp_strsplit(&strinfo, folder, n);
            n = 0;
            if (ret > 0) {
                sprintf_f(rs->logs, "split str found, ret:%d\n", ret);
                print_f(rs->plogs, "P6", rs->logs);
                len = ret;
                memset(recvbuf, 0, 1024);
                
                scanParam = aspMemalloc(len * sizeof(uint32_t), 6);
                memset(scanParam, 0, len * sizeof(uint32_t));
                
                if (scanParam) {
                    for (i = 0; i < len; i++) {
                        nexinfo = asp_getInfo(strinfo, i);
                        if (nexinfo) {
#if LOG_P6_PARA_EN
                            sprintf_f(rs->logs, "%d.[%s]\n", i, nexinfo->infoStr);
                            print_f(rs->plogs, "P6", rs->logs);
#endif
                            scanParam[i] = atoi(nexinfo->infoStr);
                            
                        } else {
                            sprintf_f(rs->logs, "split info error!!!\n");
                            print_f(rs->plogs, "P6", rs->logs);
                        }
                    }                            


                    for (i = 0; i < (len/3); i++) {
                        for (ix = 0; ix < ASPOP_CODE_MAX; ix++) {
                            pdt = &pct[ix];
                            op = scanParam[i*3+1];
                            cd = scanParam[i*3+2] & 0xff;
                            fg = scanParam[i*3+2] >> 8;

                            if (op == pdt->opCode) {
                                if ((cd == 0xff) && ((fg & 0x02) != 0)) {
                                    cd = 0;
                                }
                                
                                //ret = -1; /* test code */
                                ret = cmdfunc_opchk_single(cd, pdt->opMask, pdt->opBitlen, pdt->opType);
                                if (ret > 0) {
                                    pdt->opValue = cd;
                                    pdt->opStatus |= ASPOP_STA_CON;

#if LOG_P6_PARA_EN
                                    sprintf_f(rs->logs, "get 0x%.2x = 0x%.2x (%d)\n", op, cd, fg);
                                    print_f(rs->plogs, "P6", rs->logs);
#endif
                                    
                                    sprintf(rs->logs, "%d,", scanParam[i*3]);

                                    slen = strnlen(rs->logs, sizeof(rs->logs));
                                    strncpy(&recvbuf[n], rs->logs, slen);
                                    n += slen;
                                }
                                else {
                                    sprintf_f(rs->logs, "Error!!! get 0x%.2x = 0x%.2x (%d) mask: 0x%x out of range ret: %d\n", op, cd, fg, pdt->opMask, ret);
                                    print_f(rs->plogs, "P6", rs->logs);
                                }
                            }
                        }
                    }

                    nexinfo = asp_getInfo(strinfo, (len - 1));
                    if (nexinfo) {
                        sprintf(rs->logs, "%d.%s\n", (len - 1), nexinfo->infoStr);
                        print_f(rs->plogs, "P6", rs->logs);

                        if (strcmp("ASP", nexinfo->infoStr) != 0) {
                            sendbuf[3] = 'F';
                        } else {
                            sendbuf[3] = 'D';
                            strncpy(&sendbuf[5], recvbuf, n);
                        }
                    }
                }                   
            }
            else {
                sprintf_f(rs->logs, "split str not found, ret:%d\n", ret);
                print_f(rs->plogs, "P6", rs->logs);
            }

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            print_f(rs->plogs, "P6", rs->logs);

            /* free memory */
            nexinfo = strinfo;
            while(nexinfo) {
                nexinfo = asp_freeInfo(nexinfo);
            }
            
            if (scanParam) {
                aspMemFree(scanParam, 6);
                scanParam = 0;
            }
            
            goto socketEnd;
        }
        
        if (opcode == 0x17) { /* send WIFI info */
            sprintf_f(rs->logs, "handle opcode: 0x%x(WIFI_PSK)\n", opcode);
            print_f(rs->plogs, "P6", rs->logs);
            n = 0;

            len = strlen(folder);
            sprintf_f(rs->logs, "get psk[%s] size: %d\n", folder, len);
            print_f(rs->plogs, "P6", rs->logs);

            fpsk = fopen(pskPath, "w+");
            if (fpsk) {
                fwrite(folder, 1, len, fpsk);
                fflush(fpsk);
                fclose(fpsk);

                if ((len >=8) && (len <= 63)) {
                    memset(pwfc->wfpsk, 0, 64);
                    memcpy(pwfc->wfpsk, folder, len);
                    pwfc->wfpskLen = len;
                    msync(pwfc->wfpsk, len, MS_SYNC);
                }
                
                sprintf(rs->logs, "PSK_OK");
            } else {
                sprintf(rs->logs, "PSK_NG");
            }

            n = strnlen(rs->logs, sizeof(rs->logs));
            strncpy(&sendbuf[5], rs->logs, n);
            
            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            print_f(rs->plogs, "P6", rs->logs);
            goto socketEnd;
        }
        
        if (opcode == 0x16) { /* send WIFI info */
            sprintf_f(rs->logs, "handle opcode: 0x%x(WIFI_SSID)\n", opcode);
            print_f(rs->plogs, "P6", rs->logs);
            n = 0;
            len = strlen(folder);
            sprintf_f(rs->logs, "get ssid[%s] size: %d\n", folder, len);
            print_f(rs->plogs, "P6", rs->logs);

            fssid = fopen(ssidPath, "w+");
            if (fssid) {
                fwrite(folder, 1, len, fssid);
                fflush(fssid);
                fclose(fssid);

                if (len <= 32) {
                    memset(pwfc->wfssid, 0, 36);
                    memcpy(pwfc->wfssid, folder, len);
                    pwfc->wfsidLen = len;
                    msync(pwfc->wfssid, len, MS_SYNC);
                }

                sprintf(rs->logs, "SSID_OK");
            } else {
                sprintf(rs->logs, "SSID_NG");
            }

            n = strnlen(rs->logs, sizeof(rs->logs));
            strncpy(&sendbuf[5], rs->logs, n);
            
            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            print_f(rs->plogs, "P6", rs->logs);

            goto socketEnd;
        }
        
        if (opcode == 0x15) { /* send CROP info (old)*/
            #define CROP_MAX_NUM (6)
            sprintf_f(rs->logs, "handle opcode: 0x%x(CROP)\n", opcode);
            print_f(rs->plogs, "P6", rs->logs);

            cnt = 0;
            while (1) {
                num = 0;
                for (i = 0; i < (CROP_MAX_NUM+1); i++) {
                    idx = ASPOP_CROP_01 + i;
                    
                    switch(idx) {
                        case ASPOP_CROP_01:
                        case ASPOP_CROP_02:
                        case ASPOP_CROP_03:
                        case ASPOP_CROP_04:
                        case ASPOP_CROP_05:
                        case ASPOP_CROP_06:
                            pdt = &pct[idx];
                            if (pdt->opStatus == ASPOP_STA_UPD) {
                                num++;
                            }

                            break;
                        default:
                            break;
                    }
                    
                }

                if (num == CROP_MAX_NUM) {
                    break;
                }

                sprintf_f(rs->logs, "wait crop %d, %d s\n", num, cnt/2);
                print_f(rs->plogs, "P6", rs->logs);
/*
                if (cnt > 10) {
                    break;
                }
*/
                usleep(500000);
                cnt ++;
            }

            for (i = 0; i < (CROP_MAX_NUM+1); i++) {
                idx = ASPOP_CROP_01 + i;
                pdt = &pct[idx];
                switch(idx) {
                    case ASPOP_CROP_01:
                    case ASPOP_CROP_02:
                    case ASPOP_CROP_03:
                    case ASPOP_CROP_04:
                    case ASPOP_CROP_05:
                    case ASPOP_CROP_06:
                        pdt = &pct[idx];
                        if (pdt->opStatus == ASPOP_STA_UPD) {
                            sprintf_f(rs->logs, "%d. %x (%d, %d) [0x%.8x]\n", i, pdt->opStatus, pdt->opValue >> 16, pdt->opValue & 0xffff, pdt->opValue); 
                            print_f(rs->plogs, "P6", rs->logs);  
                            sendbuf[3] = 'C';

                            sprintf(rs->logs, "%d,%d,\n\r", pdt->opValue >> 16, pdt->opValue & 0xffff);
                            n = strlen(rs->logs);

                            pdt->opStatus = ASPOP_STA_APP;
                        }

                        break;
                    case ASPOP_IMG_LEN:
                        pdt = &pct[idx];
                        
                        if (pdt->opStatus != ASPOP_STA_NONE) {
                            sendbuf[3] = 'L';
                            sprintf(rs->logs, "%d,\n\r", pdt->opValue & 0xffff);
                            n = strlen(rs->logs);
                        }
                        break;
                    default:
                        break;
                }
                
                if (n > 256) n = 256;
                
                memcpy(&sendbuf[5], rs->logs, n);

                sendbuf[5+n] = 0xfb;
                sendbuf[5+n+1] = '\n';
                sendbuf[5+n+2] = '\0';
                ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
                print_f(rs->plogs, "P6", rs->logs);
            }
            
            goto socketEnd;
        }

        if (opcode == 0x14) { /* update UTC time */
            sprintf_f(rs->logs, "handle opcode: 0x%x(UTC)\n", opcode);
            print_f(rs->plogs, "P6", rs->logs);

            ret = asp_strsplit(&strinfo, folder, n);
            n = 0;
            if (ret > 0) {
#if LOG_P6_UTC_EN
                sprintf_f(rs->logs, "split str found, ret:%d\n", ret);
                print_f(rs->plogs, "P6", rs->logs);
#endif
                for (i = 0; i < ret; i++) {
                    nexinfo = asp_getInfo(strinfo, i);
                    if (nexinfo) {
#if LOG_P6_UTC_EN
                        sprintf_f(rs->logs, "%d.[%s]\n", i, nexinfo->infoStr);
                        print_f(rs->plogs, "P6", rs->logs);
#endif
                    } else {
                        sprintf_f(rs->logs, "split info error!!!\n");
                        print_f(rs->plogs, "P6", rs->logs);
                    }
                }                

                nexinfo = asp_getInfo(strinfo, 0);
                if (nexinfo) {
                    sprintf_f(rs->logs, "%d.%s\n", 0, nexinfo->infoStr);
                    print_f(rs->plogs, "P6", rs->logs);
                }
        
                nexinfo = asp_getInfo(strinfo, 6);
                if (nexinfo) {
                    sprintf_f(rs->logs, "%d.%s\n", 6, nexinfo->infoStr);
                    print_f(rs->plogs, "P6", rs->logs);

                    if (strcmp("ASP", nexinfo->infoStr) != 0) {
                        sendbuf[3] = 'F';
                    }
                    else {
                        sendbuf[3] = 'D';
                    }
                }

                for (i = 0 ; i < 3; i++) {
                    nexinfo = asp_getInfo(strinfo, i);
                    if (nexinfo) {
                        adata[i] = atoi(nexinfo->infoStr);
#if LOG_P6_RX_EN
                        sprintf_f(rs->logs, "%d.%s = %d\n", 2+i, nexinfo->infoStr, adata[i]);
                        print_f(rs->plogs, "P6", rs->logs);
#endif
                    } else {
                        break;
                    } 
                }

                for (i = 0 ; i < 3; i++) {
                    nexinfo = asp_getInfo(strinfo, i+3);
                    if (nexinfo) {
                        atime[i] = atoi(nexinfo->infoStr);
#if LOG_P6_RX_EN
                        sprintf_f(rs->logs, "%d.%s = %d\n", 5+i, nexinfo->infoStr, atime[i]);
                        print_f(rs->plogs, "P6", rs->logs);
#endif
                    } else {
                        break;
                    } 
                }

                memset(curTime, 0, 16);
                sprintf(curTime, "%.4d%.2d%.2d%.2d%.2d", adata[0], adata[1], adata[2], atime[0], atime[1]);

                sprintf(syscmd, "date -s %s", curTime);
                ret = system(syscmd);
#if LOG_P6_UTC_EN
                sprintf_f(rs->logs, "system command:[%s] ret:%d \n", syscmd, ret);
                print_f(rs->plogs, "P6", rs->logs);
#endif
                sprintf(syscmd, "hwclock -w");
                ret = system(syscmd);
#if LOG_P6_UTC_EN
                sprintf_f(rs->logs, "system command:[%s] ret:%d \n", syscmd, ret);
                print_f(rs->plogs, "P6", rs->logs);
#endif
                sprintf(syscmd, "date");
                ret = system(syscmd);
#if LOG_P6_UTC_EN
                sprintf_f(rs->logs, "system command:[%s] ret:%d \n", syscmd, ret);
                print_f(rs->plogs, "P6", rs->logs);

                sprintf_f(rs->logs, "system time update: %s \n", curTime);
                print_f(rs->plogs, "P6", rs->logs);
#endif                
                char *wday[]={"Sun","Mon","Tue","Wed","Thu","Fri","Sat"}; 
                struct tm *p; 
                time_t timep;

                time(&timep);
#if LOG_P6_UTC_EN
                sprintf_f(rs->logs, "get current %s in C \n", ctime(&timep));
                print_f(rs->plogs, "P6", rs->logs);
#endif
                p=localtime(&timep); /*oa*/ 
                sprintf_f(rs->logs, "%.4d%.2d%.2d \n", (1900+p->tm_year),( 1+p-> tm_mon), p->tm_mday); 
                print_f(rs->plogs, "P6", rs->logs);
                sprintf_f(rs->logs, "%s,%.2d:%.2d:%.2d\n", wday[p->tm_wday],p->tm_hour, p->tm_min, p->tm_sec); 
                print_f(rs->plogs, "P6", rs->logs);
            
            }
            else {
                sendbuf[3] = 'F';
                sprintf_f(rs->logs, "split str not found, ret:%d\n", ret);
                print_f(rs->plogs, "P6", rs->logs);
            }

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            print_f(rs->plogs, "P6", rs->logs);

            /* free memory */
            nexinfo = strinfo;
            while(nexinfo) {
                nexinfo = asp_freeInfo(nexinfo);
            }
            goto socketEnd;
        }

        if  (rs->cpyfatDirTr) {
            ret = aspFScpFatDir(rsfatdir, msfatdir, rs);
            sprintf_f(rs->logs, "copy fat dir, opcode = 0x%.2x, ret = %d\n", opcode, ret);
            print_f(rs->plogs, "P6", rs->logs);

            if (ret < 0) {
                sendbuf[3] = 'E';
                sendbuf[5+1] = '\n';
                sendbuf[5+2] = '\0';
                ret = write(rs->psocket_at->connfd, sendbuf, 5+3);
                sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+3, sendbuf, rs->psocket_at->connfd, ret);
                print_f(rs->plogs, "P6", rs->logs);    

                sprintf_f(rs->logs, "error!! get opcode = 0x%x\n", opcode);
                print_f(rs->plogs, "P6", rs->logs);
                goto socketEnd;
            }
        }


        if (!fscur) {
            fscur = rs->cpyfatDirTr->dirCur;
            
            aspFScpDir(&pfat->fatCurDir, fscur);
        }

        if (opcode == 0x10) { /* get current path */
        
            //ret = mspFS_folderJump(&nxtf, fscur, folder);
            //ret = mspFS_FolderSearch(&nxtf, rs->psFat->fatRootdir, folder);
            ret = mspFS_Search(&nxtf, rs->cpyfatDirTr->dirRoot, folder, ASPFS_TYPE_DIR);
            if (ret) {
                sprintf_f(rs->logs, "jump folder:[%s] failed, ret:%d \n", folder, ret);
                print_f(rs->plogs, "P6", rs->logs);
            } else {
                fscur = nxtf;
            }
            
            n = 0;

            memset(strPath, 0, 32*128);

            pa = fscur;
            i = 0;
            while(pa) {
                strcpy(strPath[i],((pa->dflen > 0) && (pa->dflen < 128))? pa->dfLFN:pa->dfSFN);
                pa = pa->pa;
                i++;
                if (i >= 32) break;
            }

            memset(strFullPath, 0, 544);
        
            pr = strFullPath;
            while (i) {
                i --;
                *pr = '/';
                pr += 1;
            
                ret = strnlen(strPath[i], sizeof(strPath[i]));
                strncpy(pr, strPath[i], ret);
                pr += ret;        
            }

            *pr = '\0';
            
            sendbuf[3] = 'R';
            sprintf(rs->logs, "%s,%s,%c", strFullPath, ((fscur->dflen > 0) && (fscur->dflen < 128))? fscur->dfLFN:fscur->dfSFN, (fscur->dftype==ASPFS_TYPE_ROOT)?'R':((fscur->dftype==ASPFS_TYPE_DIR)?'D':'F'));
            n = strlen(rs->logs);
            if (n > 256) n = 256;
            memcpy(&sendbuf[5], rs->logs, n);
            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            print_f(rs->plogs, "P6", rs->logs);
        }
        else if (opcode == 0x12) { /* download file */
            sprintf_f(rs->logs, "handle opcode: 0x%x \n", opcode);
            print_f(rs->plogs, "P6", rs->logs);
            
            #if 0 /* don't have to update fat here */
            ret = aspFScpFatDir(rsfatdir, msfatdir, rs);
            sprintf_f(rs->logs, "copy fat ret = %d\n", ret);
            print_f(rs->plogs, "P6", rs->logs);
            #endif
            
            n = 0;
            //ret = mspFS_FileSearch(&dnld, rs->psFat->fatRootdir, folder);
            ret = mspFS_Search(&dnld, rs->cpyfatDirTr->dirRoot, folder, ASPFS_TYPE_FILE);
            if (ret) {
                sprintf_f(rs->logs, "search file failed ret=%d\n", ret);
                print_f(rs->plogs, "P6", rs->logs);

                sendbuf[3] = 'F';
            } else {
                sprintf_f(rs->logs, "search file OK ret=%d\n", ret);
                print_f(rs->plogs, "P6", rs->logs);

                sprintf_f(rs->logs, "show folder: \n");
                print_f(rs->plogs, "P6", rs->logs);
                mspFS_showFolder(dnld->pa);
                secStr = (dnld->dfclstnum - 2)*rs->psFat->fatBootsec.secPrClst + rs->psFat->fatBootsec.secWhroot;
                secLen = dnld->dflength / 512 + ((dnld->dflength%512)==0?0:1);
                sprintf_f(rs->logs, "start sector:%d sector len:%d, clstStr:%d, size:%d\n", secStr, secLen, dnld->dfclstnum, dnld->dflength);
                print_f(rs->plogs, "P6", rs->logs);

                if (pfat->fatFileDnld.dfindex) {
                    sprintf_f(rs->logs, "SD read file to APP (pendding) status:0x%.8x\n", pfat->fatStatus);
                    print_f(rs->plogs, "P6", rs->logs);
                    sendbuf[3] = 'P'; /* pendding */
                } else {
                    if (dnld->dflength) {
                        //pfat->fatFileDnld = dnld;
                        aspFScpDir(&pfat->fatFileDnld, dnld);
                        pftb->h = 0;
                        sendbuf[3] = 'D';
                    } else {
                        sprintf_f(rs->logs, "SD read file to APP (empty) status:0x%.8x\n", pfat->fatStatus);
                        print_f(rs->plogs, "P6", rs->logs);
                        sendbuf[3] = 'Z'; /* zero size */
                    }
                }
                memset(strFullPath, 0, 1024);
                sprintf(strFullPath, "%s,%d,0x%.8x", (dnld->dflen == 0)?dnld->dfSFN:dnld->dfLFN, dnld->dflength, dnld->dftype);
                n = strlen(strFullPath);
                memcpy(&sendbuf[5], strFullPath, n);
            }

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            print_f(rs->plogs, "P6", rs->logs);
            
        } 
        else if (opcode == 0x11) { /* folder list */
            sprintf_f(rs->logs, "handle opcode: 0x%x \n", opcode);
            print_f(rs->plogs, "P6", rs->logs);
            
            #if 0 /* don't have to update fat here */
            ret = aspFScpFatDir(rsfatdir, msfatdir, rs);
            sprintf_f(rs->logs, "copy fat ret: %d \n", ret);
            print_f(rs->plogs, "P6", rs->logs);
            #endif
            
            nxtf = 0;
            //ret = mspFS_folderJump(&nxtf, fscur, folder);
            //ret = mspFS_FolderSearch(&nxtf, rs->psFat->fatRootdir, folder);
            ret = mspFS_Search(&nxtf, rs->cpyfatDirTr->dirRoot, folder, ASPFS_TYPE_DIR);
            if (ret) {
                sprintf_f(rs->logs, "jump folder:[%s] failed, ret:%d - 2\n", folder, ret);
                print_f(rs->plogs, "P6", rs->logs);
                nxtf = fscur;
            }

            if (nxtf) {
                sprintf_f(rs->logs, "jump folder:[%s] done, ret:%d, get next folder: [%s]\n", folder, ret, nxtf->dfSFN);
                print_f(rs->plogs, "P6", rs->logs);
                fscur = nxtf;
            } else {
                sprintf_f(rs->logs, "jump folder:[%s] failed, ret:%d, get next folder == 0\n", folder, ret);
                print_f(rs->plogs, "P6", rs->logs);
                
                sendbuf[1] = 0x10;
                sendbuf[3] = 'E';
                sendbuf[5+1] = '\n';
                sendbuf[5+2] = '\0';
                ret = write(rs->psocket_at->connfd, sendbuf, 5+3);
                sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+3, sendbuf, rs->psocket_at->connfd, ret);
                print_f(rs->plogs, "P6", rs->logs);

                goto socketEnd;
            }

            brt = fscur->ch;
            //debugPrintDir(brt);

            while (brt) {
                if ((brt->dfstats != ASPFS_STATUS_EN) || (strcmp(brt->dfSFN, ".") == 0) 
                       || (brt->dfattrib & ASPFS_ATTR_HIDDEN) 
                       || (brt->dfattrib & ASPFS_ATTR_SYSTEM) 
                       || (brt->dfattrib & ASPFS_ATTR_VOLUME_ID)) {
                    sprintf_f(rs->logs, "file status[0x%.8x] name[%c] type[0x%.8x] attrib[0x%.8x]\n", brt->dfstats, brt->dfSFN[0], brt->dftype, brt->dfattrib);
                    print_f(rs->plogs, "P6", rs->logs);
                    brt = brt->br; 
                    continue;
                }

                if (brt->dflen) {
                    n = strlen(brt->dfLFN);
                    memcpy(&sendbuf[5], brt->dfLFN, n);
                } else {
                    n = strlen(brt->dfSFN);
                    memcpy(&sendbuf[5], brt->dfSFN, n);
                }

                if (brt->dftype == ASPFS_TYPE_FILE) {
                    sendbuf[3] = 'F';
                } else {
                    sendbuf[3] = 'D';
                }

                sendbuf[5+n] = 0xfb;
                sendbuf[5+n+1] = '\n';
                sendbuf[5+n+2] = '\0';
                ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
                print_f(rs->plogs, "P6", rs->logs);

                brt = brt->br;
                cnt++;
            }

            if (cnt == 0) {
                n = strlen("_EMPTY_");
                memcpy(&sendbuf[5], "_EMPTY_", n);

                sendbuf[3] = 'E';
                sendbuf[5+n] = 0xfb;
                sendbuf[5+n+1] = '\n';
                sendbuf[5+n+2] = '\0';
                ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
                print_f(rs->plogs, "P6", rs->logs);

                /* send twice with different type to confirm and back compatible */
                sendbuf[3] = 'F';
                sendbuf[5+n] = 0xfb;
                sendbuf[5+n+1] = '\n';
                sendbuf[5+n+2] = '\0';
                ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
                sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
                print_f(rs->plogs, "P6", rs->logs);
                    
                fscur = rs->cpyfatDirTr->dirRoot;
            }

            //pfat->fatCurDir = fscur;
            aspFScpDir(&pfat->fatCurDir, fscur);

        }
        else if (opcode == 0x13) { /* 0x13: upload file */
            sprintf_f(rs->logs, "handle opcode: 0x%x\n", opcode);
            print_f(rs->plogs, "P6", rs->logs);

            #if 0 /* don't have to update fat here */
            ret = aspFScpFatDir(rsfatdir, msfatdir, rs);
            sprintf_f(rs->logs, "copy fat ret = %d\n", ret);
            print_f(rs->plogs, "P6", rs->logs);
            #endif

            ret = asp_strsplit(&strinfo, folder, n);
            n = 0;
            if (ret > 0) {
                sprintf_f(rs->logs, "split str found, ret:%d\n", ret);
                print_f(rs->plogs, "P6", rs->logs);
                /*
                nexinfo = strinfo;
                i = 0;
                while (nexinfo) {
                    sprintf_f(rs->logs, "%d.[%s],len:%d \n", i, nexinfo->infoStr, nexinfo->infoLen);
                    print_f(rs->plogs, "P6", rs->logs);
                    nexinfo = nexinfo->n;
                    i++;
                }
                */
                for (i = 0; i < ret; i++) {
                    nexinfo = asp_getInfo(strinfo, i);
                    if (nexinfo) {
                        sprintf_f(rs->logs, "%d.[%s]\n", i, nexinfo->infoStr);
                        print_f(rs->plogs, "P6", rs->logs);
                    }
                }                

                nexinfo = asp_getInfo(strinfo, 0);
                if (nexinfo) {
                    sprintf_f(rs->logs, "%d.%s\n", 0, nexinfo->infoStr);
                    print_f(rs->plogs, "P6", rs->logs);
                }
            
                //ret = mspFS_FileSearch(&dnld, rs->psFat->fatRootdir, nexinfo->infoStr);
                ret = mspFS_Search(&upld, rs->cpyfatDirTr->dirRoot, nexinfo->infoStr, ASPFS_TYPE_FILE);
                if (ret) {
                    sprintf_f(rs->logs, "search upload file[%s], not found ret=%d\n", nexinfo->infoStr, ret);
                    print_f(rs->plogs, "P6", rs->logs);

                    sendbuf[3] = 'O';
                } else {
                    sprintf_f(rs->logs, "search upload file[%s], found ret=%d\n", nexinfo->infoStr, ret);
                    print_f(rs->plogs, "P6", rs->logs);

                    if (recvbuf[be-1] == 'O')  {
                        sendbuf[3] = 'O';
                    } else {
                        sendbuf[3] = 'W';            
                    }
                }

                nexinfo = asp_getInfo(strinfo, 9);
                if (nexinfo) {
                    sprintf_f(rs->logs, "%d.%s\n", 9, nexinfo->infoStr);
                    print_f(rs->plogs, "P6", rs->logs);

                    if (strcmp("ASP", nexinfo->infoStr) != 0) {
                        sendbuf[3] = 'F';
                    }
                } else {
                    sendbuf[3] = 'F';
                }

                nexinfo = asp_getInfo(strinfo, 2);
                if (nexinfo) {
                    sprintf_f(rs->logs, "%d.%s\n", 2, nexinfo->infoStr);
                    print_f(rs->plogs, "P6", rs->logs);
                } else {
                    sendbuf[3] = 'F';
                }

                num = atoi(nexinfo->infoStr);
                sprintf_f(rs->logs, "file length: %d\n", num);
                print_f(rs->plogs, "P6", rs->logs);

                clstSize = pfat->fatBootsec.secSize * pfat->fatBootsec.secPrClst;
                if (num == 0) {
                    cnt = 0;
                } else if (num % clstSize) {
                    cnt = num / clstSize + 1;
                } else {
                    cnt = num / clstSize;
                }

                if (sendbuf[3] == 'W') {
                    nexinfo = asp_getInfo(strinfo, 0);
                    if (nexinfo) {
                        sprintf_f(rs->logs, "%d.%s\n", 0, nexinfo->infoStr);
                        print_f(rs->plogs, "P6", rs->logs);
                    }
                    sprintf_f(rs->logs, "WARNING!!! file [%s] existed !!\n", nexinfo->infoStr);
                    print_f(rs->plogs, "P6", rs->logs);
                } else if (cnt > pftb->ftbMng.ftfreeClst) {
                    sendbuf[3] = 'F';
                } else if (pfat->fatFileUpld.dfindex) {
                    sendbuf[3] = 'P';
                } else {
                    mspFS_allocDir(rs->cpyfatDirTr, &upld, 8);
                    //mspFS_allocDir(&pfat->fatDirTr, &upld);
                    if (!upld) {
                        sendbuf[3] = 'F';
                    } else {
                        //memset(upld, 0, sizeof(struct directnFile_s));
                        upld->dftype = ASPFS_TYPE_FILE;
                        upld->dfstats = ASPFS_STATUS_EN;  //upld->dfstats = ASPFS_STATUS_DIS;
                        upld->dfattrib = ASPFS_ATTR_ARCHIVE;
                        upld->dfclstnum = 0; /* start cluster */

                        for (i = 0 ; i < 3; i++) {
                            nexinfo = asp_getInfo(strinfo, 3+i);
                            if (nexinfo) {
                                adata[i] = atoi(nexinfo->infoStr);
                                sprintf_f(rs->logs, "%d.%s = %d\n", 2+i, nexinfo->infoStr, adata[i]);
                                print_f(rs->plogs, "P6", rs->logs);
                            } else {
                                break;
                            } 
                        }

                        for (i = 0 ; i < 3; i++) {
                            nexinfo = asp_getInfo(strinfo, 6+i);
                            if (nexinfo) {
                                atime[i] = atoi(nexinfo->infoStr);
                                sprintf_f(rs->logs, "%d.%s = %d\n", 5+i, nexinfo->infoStr, atime[i]);
                                print_f(rs->plogs, "P6", rs->logs);
                            } else {
                                break;
                            } 
                        }
                        
                        upld->dfcredate = ((((adata[0] - 1980) & 0xff) << 16) | ((adata[1] & 0xff) << 8) | (adata[2] & 0xff));
                        upld->dfcretime = (((atime[0]&0xff) << 16) | ((atime[1]&0xff) << 8) | (atime[2]&0xff));
                        upld->dflstacdate = ((((adata[0] - 1980)&0xff) << 16) | ((adata[1]&0xff) << 8) | (adata[2]&0xff));
                        upld->dfrecodate = ((((adata[0] - 1980)&0xff) << 16) | ((adata[1]&0xff) << 8) | (adata[2]&0xff));
                        upld->dfrecotime = (((atime[0]&0xff) << 16) | ((atime[1]&0xff) << 8) | (atime[2]&0xff));

                        upld->dflength = num; /* file length */
                        
                        nexinfo = asp_getInfo(strinfo, 1);
                        if (nexinfo) {
                            sprintf_f(rs->logs, "%d.%s\n", 1, nexinfo->infoStr);
                            print_f(rs->plogs, "P6", rs->logs);
                        } else {
                            sendbuf[3] = 'F';
                        } 
                        
                        len = strlen(nexinfo->infoStr);
                        if (len > 255) {
                            len = 255;
                        }

                        ret = asp_idxofch(nexinfo->infoStr, '.', 0, len);

                        sprintf_f(rs->logs, "find SFN len: %d, ret: %d\n", len, ret);
                        print_f(rs->plogs, "P6", rs->logs);

                        if (ret == -1) {
                            if (len > 11) {
                                strncpy(upld->dfSFN, nexinfo->infoStr, 10);
                                upld->dfSFN[10] = '~';
                                upld->dfSFN[11] = '\0';
                                strncpy(upld->dfLFN,  nexinfo->infoStr, len);
                                upld->dflen = len;
                                upld->dfLFN[len] = '\0';
                            } else {
                                strncpy(upld->dfSFN, nexinfo->infoStr, len);
                                upld->dfSFN[len] = '\0';
                            }
                        } else {
                            if (ret == (len - 1 - 3)) {
                                if (len > 12) {
                                    strncpy(upld->dfSFN, nexinfo->infoStr, 7);
                                    upld->dfSFN[7] = '~';
                                    upld->dfSFN[8] = '.';
                                    strncpy(&upld->dfSFN[9], &nexinfo->infoStr[len -3], 3);
                                    upld->dfSFN[12] = '\0';
                                    strncpy(upld->dfLFN,  nexinfo->infoStr, len);
                                    upld->dflen = len;
                                    upld->dfLFN[len] = '\0';
                                } else {
                                    strncpy(upld->dfSFN, nexinfo->infoStr, len);
                                    upld->dfSFN[len] = '\0';                        
                                }
                            } else {
                                if (len > 11) {
                                    strncpy(upld->dfSFN, nexinfo->infoStr, 10);
                                    upld->dfSFN[10] = '~';
                                    upld->dfSFN[11] = '\0';
                                    strncpy(upld->dfLFN,  nexinfo->infoStr, len);
                                    upld->dflen = len;
                                    upld->dfLFN[len] = '\0';
                                } else {
                                    strncpy(upld->dfSFN, nexinfo->infoStr, len);
                                    upld->dfSFN[len] = '\0';
                                }
                            }
                        }

                        sprintf_f(rs->logs, "SFN[%s] LFS[%d] len:%d\n", upld->dfSFN, upld->dfLFN[0], upld->dflen);
                        print_f(rs->plogs, "P6", rs->logs);
/*
                        nexinfo = asp_getInfo(strinfo, 0);
                        if (nexinfo) {
                            sprintf_f(rs->logs, "%d.%s\n", 0, nexinfo->infoStr);
                            print_f(rs->plogs, "P6", rs->logs);
                        } else {
                            break;
                        } 

                        ret = mspFS_FileSearch(&dnld, rs->psFat->fatRootdir, nexinfo->infoStr);
                        if (ret) {
                            sprintf_f(rs->logs, "search upload file[%s], not found ret=%d\n", nexinfo->infoStr, ret);
                            print_f(rs->plogs, "P6", rs->logs);
                            sendbuf[3] = 'O';
                        } else {
                            sendbuf[3] = 'W';            
                        }
*/                        
                        aspFS_insertFATChild(fscur, upld);

                        //pfat->fatFileUpld = upld;
                        //memcpy(&pfat->fatFileUpld, upld, sizeof(struct directnFile_s));
                        aspFScpDir(&pfat->fatFileUpld, upld);
                        
                        debugPrintDir(upld);

                        //mspFS_list(fscur, 4);
                        
                    }
                }

                memset(strFullPath, 0, 1024);
                sprintf(strFullPath, "%s,%d,0x%.8x", (upld->dflen == 0)?upld->dfSFN:upld->dfLFN, upld->dflength, upld->dftype);
                n = strlen(strFullPath);
                memcpy(&sendbuf[5], strFullPath, n);
                
                sprintf_f(rs->logs, "new file need %d clst, available %d clst\n", cnt, pftb->ftbMng.ftfreeClst);
                print_f(rs->plogs, "P6", rs->logs);
                
            }
            else {
                sendbuf[3] = 'F';
                sprintf_f(rs->logs, "split str not found, ret:%d\n", ret);
                print_f(rs->plogs, "P6", rs->logs);
            }

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            print_f(rs->plogs, "P6", rs->logs);

            /* free memory */
            nexinfo = strinfo;
            while(nexinfo) {
                nexinfo = asp_freeInfo(nexinfo);
            }
        } 
        else if (opcode == 0x25) { /* 0x25: create folder */
            sprintf_f(rs->logs, "handle opcode: 0x%x\n", opcode);
            print_f(rs->plogs, "P6", rs->logs);

            ret = asp_strsplit(&strinfo, folder, n);
            n = 0;
            if (ret > 0) {
                sprintf_f(rs->logs, "split str found, ret:%d\n", ret);
                print_f(rs->plogs, "P6", rs->logs);

                nexinfo = asp_getInfo(strinfo, 0);
                if (nexinfo) {
                    sprintf_f(rs->logs, "%d.%s\n", 0, nexinfo->infoStr);
                    print_f(rs->plogs, "P6", rs->logs);
                }
            
                ret = mspFS_Search(&upld, rs->cpyfatDirTr->dirRoot, nexinfo->infoStr, ASPFS_TYPE_DIR);
                if (ret) {
                    sprintf_f(rs->logs, "search upload folder[%s], not found ret=%d\n", nexinfo->infoStr, ret);
                    print_f(rs->plogs, "P6", rs->logs);

                    sendbuf[3] = 'O';
                } else {
                    sprintf_f(rs->logs, "search upload folder[%s], found ret=%d\n", nexinfo->infoStr, ret);
                    print_f(rs->plogs, "P6", rs->logs);

                    if (recvbuf[be-1] == 'O')  {
                        sendbuf[3] = 'O';
                    } else {
                        sendbuf[3] = 'W';            
                    }
                }

                nexinfo = asp_getInfo(strinfo, 9);
                if (nexinfo) {
                    sprintf_f(rs->logs, "%d.%s\n", 9, nexinfo->infoStr);
                    print_f(rs->plogs, "P6", rs->logs);

                    if (strcmp("ASP", nexinfo->infoStr) != 0) {
                        sendbuf[3] = 'F';
                    }
                } else {
                    sendbuf[3] = 'F';
                }

                nexinfo = asp_getInfo(strinfo, 2);
                if (nexinfo) {
                    sprintf_f(rs->logs, "%d.%s\n", 2, nexinfo->infoStr);
                    print_f(rs->plogs, "P6", rs->logs);
                } else {
                    sendbuf[3] = 'F';
                }

                num = atoi(nexinfo->infoStr);
                sprintf_f(rs->logs, "file length: %d\n", num);
                print_f(rs->plogs, "P6", rs->logs);

                clstSize = pfat->fatBootsec.secSize * pfat->fatBootsec.secPrClst;
                if (num == 0) {
                    cnt = 0;
                } else if (num % clstSize) {
                    cnt = num / clstSize + 1;
                } else {
                    cnt = num / clstSize;
                }

                if (sendbuf[3] == 'W') {
                    nexinfo = asp_getInfo(strinfo, 0);
                    if (nexinfo) {
                        sprintf_f(rs->logs, "%d.%s\n", 0, nexinfo->infoStr);
                        print_f(rs->plogs, "P6", rs->logs);
                    }
                    sprintf_f(rs->logs, "WARNING!!! file [%s] existed !!\n", nexinfo->infoStr);
                    print_f(rs->plogs, "P6", rs->logs);
                } else if (cnt > pftb->ftbMng.ftfreeClst) {
                    sendbuf[3] = 'F';
                } else if (pfat->fatFileUpld.dfindex) {
                    sendbuf[3] = 'P';
                } else {
                    mspFS_allocDir(rs->cpyfatDirTr, &upld, 8);
                    mspFS_allocDir(rs->cpyfatDirTr, &chld, 8);
                    if ((!upld) || (!chld)) {
                        sendbuf[3] = 'F';
                    } else {
                        //memset(upld, 0, sizeof(struct directnFile_s));
                        upld->dftype = ASPFS_TYPE_DIR;
                        upld->dfstats = ASPFS_STATUS_EN;  //upld->dfstats = ASPFS_STATUS_DIS;
                        upld->dfattrib = ASPFS_ATTR_DIRECTORY;
                        upld->dfclstnum = 0; /* start cluster */

                        chld->dftype = ASPFS_TYPE_DIR;
                        chld->dfstats = ASPFS_STATUS_EN;  //upld->dfstats = ASPFS_STATUS_DIS;
                        chld->dfattrib = ASPFS_ATTR_DIRECTORY;
                        chld->dfclstnum = 0; /* start cluster */
                        
                        for (i = 0 ; i < 3; i++) {
                            nexinfo = asp_getInfo(strinfo, 3+i);
                            if (nexinfo) {
                                adata[i] = atoi(nexinfo->infoStr);
                                sprintf_f(rs->logs, "%d.%s = %d\n", 2+i, nexinfo->infoStr, adata[i]);
                                print_f(rs->plogs, "P6", rs->logs);
                            } else {
                                break;
                            } 
                        }

                        for (i = 0 ; i < 3; i++) {
                            nexinfo = asp_getInfo(strinfo, 6+i);
                            if (nexinfo) {
                                atime[i] = atoi(nexinfo->infoStr);
                                sprintf_f(rs->logs, "%d.%s = %d\n", 5+i, nexinfo->infoStr, atime[i]);
                                print_f(rs->plogs, "P6", rs->logs);
                            } else {
                                break;
                            } 
                        }
                        
                        upld->dfcredate = ((((adata[0] - 1980) & 0xff) << 16) | ((adata[1] & 0xff) << 8) | (adata[2] & 0xff));
                        upld->dfcretime = (((atime[0]&0xff) << 16) | ((atime[1]&0xff) << 8) | (atime[2]&0xff));
                        upld->dflstacdate = ((((adata[0] - 1980)&0xff) << 16) | ((adata[1]&0xff) << 8) | (adata[2]&0xff));
                        upld->dfrecodate = ((((adata[0] - 1980)&0xff) << 16) | ((adata[1]&0xff) << 8) | (adata[2]&0xff));
                        upld->dfrecotime = (((atime[0]&0xff) << 16) | ((atime[1]&0xff) << 8) | (atime[2]&0xff));

                        upld->dflength = 0; /* folder's file length is 0 */

                        chld->dfcredate = upld->dfcredate;
                        chld->dfcretime = upld->dfcretime;
                        chld->dflstacdate = upld->dflstacdate;
                        chld->dfrecodate = upld->dfrecodate;
                        chld->dfrecotime = upld->dfrecotime;
                        chld->dflength = 0; /* folder's file length is 0 */
                        
                        nexinfo = asp_getInfo(strinfo, 1);
                        if (nexinfo) {
                            sprintf_f(rs->logs, "%d.%s\n", 1, nexinfo->infoStr);
                            print_f(rs->plogs, "P6", rs->logs);
                        } else {
                            sendbuf[3] = 'F';
                        } 
                        
                        len = strlen(nexinfo->infoStr);
                        if (len > 255) {
                            len = 255;
                        }

                        ret = asp_idxofch(nexinfo->infoStr, '.', 0, len);

                        sprintf_f(rs->logs, "find SFN len: %d, ret: %d\n", len, ret);
                        print_f(rs->plogs, "P6", rs->logs);

                        if (ret == -1) {
                            if (len > 11) {
                                strncpy(upld->dfSFN, nexinfo->infoStr, 10);
                                upld->dfSFN[10] = '~';
                                upld->dfSFN[11] = '\0';
                                strncpy(upld->dfLFN,  nexinfo->infoStr, len);
                                upld->dflen = len;
                                upld->dfLFN[len] = '\0';
                            } else {
                                strncpy(upld->dfSFN, nexinfo->infoStr, len);
                                upld->dfSFN[len] = '\0';
                                strncpy(upld->dfLFN,  nexinfo->infoStr, len);
                                upld->dflen = len;
                                upld->dfLFN[len] = '\0';
                            }
                        } else {
                            if (ret == (len - 1 - 3)) {
                                if (len > 12) {
                                    strncpy(upld->dfSFN, nexinfo->infoStr, 7);
                                    upld->dfSFN[7] = '~';
                                    upld->dfSFN[8] = '.';
                                    strncpy(&upld->dfSFN[9], &nexinfo->infoStr[len -3], 3);
                                    upld->dfSFN[12] = '\0';
                                    strncpy(upld->dfLFN,  nexinfo->infoStr, len);
                                    upld->dflen = len;
                                    upld->dfLFN[len] = '\0';
                                } else {
                                    strncpy(upld->dfSFN, nexinfo->infoStr, len);
                                    upld->dfSFN[len] = '\0';                        
                                }
                            } else {
                                if (len > 11) {
                                    strncpy(upld->dfSFN, nexinfo->infoStr, 10);
                                    upld->dfSFN[10] = '~';
                                    upld->dfSFN[11] = '\0';
                                    strncpy(upld->dfLFN,  nexinfo->infoStr, len);
                                    upld->dflen = len;
                                    upld->dfLFN[len] = '\0';
                                } else {
                                    strncpy(upld->dfSFN, nexinfo->infoStr, len);
                                    upld->dfSFN[len] = '\0';
                                }
                            }
                        }

                        strcpy(chld->dfSFN, "..");
    
                        sprintf_f(rs->logs, "upld: SFN[%s] LFS[%d] len:%d\n", upld->dfSFN, upld->dfLFN[0], upld->dflen);
                        print_f(rs->plogs, "P6", rs->logs);
                        
                        sprintf_f(rs->logs, "chld: SFN[%s] LFS[%d] len:%d\n", chld->dfSFN, chld->dfLFN[0], chld->dflen);
                        print_f(rs->plogs, "P6", rs->logs);

/*
                        nexinfo = asp_getInfo(strinfo, 0);
                        if (nexinfo) {
                            sprintf_f(rs->logs, "%d.%s\n", 0, nexinfo->infoStr);
                            print_f(rs->plogs, "P6", rs->logs);
                        } else {
                            break;
                        } 

                        ret = mspFS_FileSearch(&dnld, rs->psFat->fatRootdir, nexinfo->infoStr);
                        if (ret) {
                            sprintf_f(rs->logs, "search upload file[%s], not found ret=%d\n", nexinfo->infoStr, ret);
                            print_f(rs->plogs, "P6", rs->logs);
                            sendbuf[3] = 'O';
                        } else {
                            sendbuf[3] = 'W';            
                        }
*/                        

                        //debugPrintDir(upld);
                        //debugPrintDir(fscur);

                        aspFS_insertFATChild(fscur, upld);
                        
                        //debugPrintDir(upld);
                        //debugPrintDir(fscur);
                        //debugPrintDir(chld);                        

                        aspFS_insertFATChild(upld, chld);

                        //debugPrintDir(chld);                                                
                        //debugPrintDir(upld);


                        //pfat->fatFileUpld = upld;
                        //memcpy(&pfat->fatFileUpld, upld, sizeof(struct directnFile_s));
                        aspFScpDir(&pfat->fatFileUpld, upld);
                        aspFScpDir(&pfat->fatFolderCrt, chld);
                        
                        mspFS_list(fscur, 4);
                        
                    }
                }

                memset(strFullPath, 0, 1024);
                sprintf(strFullPath, "%s,%d,0x%.8x", (upld->dflen == 0)?upld->dfSFN:upld->dfLFN, upld->dflength, upld->dftype);
                n = strlen(strFullPath);
                memcpy(&sendbuf[5], strFullPath, n);
                
                sprintf_f(rs->logs, "new file need %d clst, available %d clst\n", cnt, pftb->ftbMng.ftfreeClst);
                print_f(rs->plogs, "P6", rs->logs);
                
            }
            else {
                sendbuf[3] = 'F';
                sprintf_f(rs->logs, "split str not found, ret:%d\n", ret);
                print_f(rs->plogs, "P6", rs->logs);
            }

            sendbuf[5+n] = 0xfb;
            sendbuf[5+n+1] = '\n';
            sendbuf[5+n+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+n+3);
            sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+n+3, sendbuf, rs->psocket_at->connfd, ret);
            print_f(rs->plogs, "P6", rs->logs);

            /* free memory */
            nexinfo = strinfo;
            while(nexinfo) {
                nexinfo = asp_freeInfo(nexinfo);
            }
        } 

        else {
            sendbuf[3] = 'E';
            sendbuf[5+1] = '\n';
            sendbuf[5+2] = '\0';
            ret = write(rs->psocket_at->connfd, sendbuf, 5+3);
            sprintf_f(rs->logs, "socket send, len:%d content[%s] from %d, ret:%d\n", 5+3, sendbuf, rs->psocket_at->connfd, ret);
            print_f(rs->plogs, "P6", rs->logs);    

            sprintf_f(rs->logs, "error!! get opcode = 0x%x\n", opcode);
            print_f(rs->plogs, "P6", rs->logs);
        }

        socketEnd:
        
        close(rs->psocket_at->connfd);
        rs->psocket_at->connfd = 0;
    }

    p6_end(rs);
    return 0;
}

#define MSP_P7_SAVE_DAT (0)
#define LOG_P7_TX_EN (0)
static int p7(struct procRes_s *rs)
{
    char chbuf[32];
    char ch=0, *addr=0, *cltaddr;
    int ret=0, len=0, num=0, tx=0, cltport=0, totsz=0;
    int cmode=0, tdiff, tlast;
    struct sdFAT_s *pfat=0;
    struct sdFATable_s   *pftb=0;
    uint32_t secStr=0, secLen=0, datLen=0, minLen=0;
    struct info16Bit_s *p=0, *c=0;
    CFLOAT thrput, fltime;
    fd_set rfds;
    struct timeval tv;
    int socketfailed=0, expectSz=0;
#if (SOCKET_NON_BLOCK_RX | SOCKET_NON_BLOCK_TX)
    struct epoll_event event, events[MAX_EVENTS];
#endif
    int  consfd, nfds, epollfd;

    prctl(PR_SET_NAME, "msp-p7");
    //sprintf(argv[0], "msp-p7-socket7000");
    
    pfat = rs->psFat;
    pftb = &pfat->fatTable;

    sprintf_f(rs->logs, "p7\n");
    print_f(rs->plogs, "P7", rs->logs);

    c = &rs->pmch->cur;
    p = &rs->pmch->tmp;

    p7_init(rs);

    rs->psocket_n->listenfd = socket(AF_INET, SOCK_STREAM, 0);
    if (rs->psocket_n->listenfd < 0) { 
        sprintf(rs->logs, "p7 get socket ret: %d", rs->psocket_n->listenfd);
        error_handle(rs->logs, 4017);
    }

    memset(&rs->psocket_n->serv_addr, '0', sizeof(struct sockaddr_in));

    rs->psocket_n->serv_addr.sin_family = AF_INET;
    rs->psocket_n->serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    rs->psocket_n->serv_addr.sin_port = htons(7000); 

    ret = bind(rs->psocket_n->listenfd, (struct sockaddr*)&rs->psocket_n->serv_addr, sizeof(struct sockaddr_in));
    if (ret < 0) {
        //perror("bind:");
        ret = -1;
        if (setsockopt(rs->psocket_n->listenfd, SOL_SOCKET, SO_REUSEADDR, &ret, sizeof(int)) == -1) {
            perror("setsockopt");    
            
            sprintf(rs->logs, "p7 get bind ret: %d", ret);
            error_handle(rs->logs, 24127);
        }
    }


    ret = listen(rs->psocket_n->listenfd, 10); 
    if (ret < 0) {
        sprintf(rs->logs, "p7 get listen ret: %d", ret);
        error_handle(rs->logs, 4035);
    }

#if SOCKET_EPOLL_EN
    epollfd = epoll_create1(O_CLOEXEC);
    if (epollfd < 0) {
        perror("epoll_create1");
        //exit(EXIT_FAILURE);
        sprintf_f(rs->logs, "epoll create failed, errno: %d\n", errno);
        print_f(rs->plogs, "P7", rs->logs);
    } else {
        sprintf_f(rs->logs, "epoll create succeed, epollfd: %d, errno: %d\n", epollfd, errno);
        print_f(rs->plogs, "P7", rs->logs);
    }
#endif

    while (1) {
        //sprintf_f(rs->logs, ")\n");
        //print_f(rs->plogs, "P7", rs->logs);
#if 1 /* disable for testing */
        len = sizeof(struct sockaddr_in);
        memset(&rs->psocket_n->clint_addr, 0, len);
        rs->psocket_n->connfd = accept(rs->psocket_n->listenfd, (struct sockaddr*)&rs->psocket_n->clint_addr, &len); 
        if (rs->psocket_n->connfd < 0) {
            sprintf(rs->logs, "P7 get connect failed ret:%d", rs->psocket_n->connfd);
            error_handle(rs->logs, 4045);
            goto socketEnd;
        } else {
            //cltaddr = rs->psocket_n->clint_addr.sa_data;
            cltaddr = inet_ntoa(rs->psocket_n->clint_addr.sin_addr);
            cltport = ntohs(rs->psocket_n->clint_addr.sin_port);
            sprintf_f(rs->logs, "get connection id: %d [%s:%d]\n", rs->psocket_n->connfd, cltaddr, cltport);
            print_f(rs->plogs, "P7", rs->logs);

#if (SOCKET_NON_BLOCK_RX | SOCKET_NON_BLOCK_TX)
            //fcntl(rs->psocket_n->connfd, F_SETFL, O_NONBLOCK);
            consfd = rs->psocket_n->connfd;
            socket_nonblock_set(consfd);
            socketfailed = 0;
#endif
            aspMemClear(aspMemAsign, asptotMalloc, 7);
        }
#else
        rs->psocket_n->connfd = 7;
#endif
        ret = 1; ch = 0;
        while (ret > 0) {

            ret = rs_ipc_get(rs, &ch, 1);

            sprintf_f(rs->logs, "%c ret:%d \n", ch, ret);
            print_f(rs->plogs, "P7", rs->logs);

#if LOG_DOT_PROG_EN
            printf("7%c", ch);
#endif

            
            switch (ch) {
                case 'E':
                    goto socketEnd;
                    break;
                case 'n':
                    cmode = 1;
                    break;
                case 'r':
                    cmode = 2;
                    break;
                case 'd':
                    cmode = 3;
                    break;
                case 'u':
                    cmode = 4;
                    break;
                default:
                    break;
            }

            if (cmode == 1) {
                tx = 0;num = 0;totsz=0;

#if MSP_P7_SAVE_DAT
                ret = file_save_get(&rs->fdat_s[3], "/mnt/mmc2/tx/p7_%d.jpg");
                if (ret) {
                    sprintf_f(rs->logs, "get tx log data file error - %d, hold here\n", ret);
                    print_f(rs->plogs, "P7", rs->logs);         
                    while(1);
                } else {
                    sprintf_f(rs->logs, "get tx log data file ok - %d, f: %d\n", ret, rs->fdat_s[3]);
                    print_f(rs->plogs, "P7", rs->logs);         
                }
#endif
                
#if SOCKET_EPOLL_EN
                event.data.fd = consfd;
                event.events = EPOLLOUT | EPOLLLT;
                ret = epoll_ctl (epollfd, EPOLL_CTL_ADD, consfd, &event);
                if (ret == -1)
                {
                    perror ("epoll_ctl");
                    sprintf_f(rs->logs, "spoll set ctl failed errno: %ds\n", errno);
                    print_f(rs->plogs, "P7", rs->logs);                         
                    break;
                }
#endif
                tlast = dbgShowTimeStamp("_WIFI_1_ BEG",  NULL, rs, 8, "_F1_S_");

                while (1) {
                    len = ring_buf_cons(rs->pcmdTx, &addr);

                    #if LOG_P7_TX_EN
                    sprintf_f(rs->logs, "get ring buff len: %d \n", len);
                    print_f(rs->plogs, "P7", rs->logs);         
                    #endif

                    if (len >= 0) {
                        tx++;
                    
                        msync(addr, len, MS_SYNC);
#if MSP_P7_SAVE_DAT
                            msync(addr, len, MS_SYNC);   
                            fwrite(addr, 1, len, rs->fdat_s[3]);
                            fflush(rs->fdat_s[3]);
#endif
                        /* send data to wifi socket */
                        //sprintf_f(rs->logs, " %d -%d \n", len, tx);
                        //print_f(rs->plogs, "P7", rs->logs);         
                        if (len != 0) {
#if SOCKET_NON_BLOCK_TX 
#if SOCKET_EPOLL_EN
                            expectSz = len;
                            while (expectSz > 0) {
                                if (!socketfailed) {
                                    nfds = epoll_wait (epollfd, events, MAX_EVENTS, 5000);
                                    if (nfds < 0) {
                                        perror("epoll_wait");
                                        sprintf_f(rs->logs, "nonblock send %d / %d failed, errno: %d\n", num, expectSz, errno);
                                        print_f(rs->plogs, "P7", rs->logs);         
                                        break;
                                    } else if (nfds == 0) {
                                        socketfailed = 1;
                                    } else {
                                        num = write(consfd, addr, expectSz);
#if LOG_P7_TX_EN
                                        sprintf_f(rs->logs, "epoll nonblock send %d / %d, n: %d\n", num, expectSz, nfds);
                                        print_f(rs->plogs, "P7", rs->logs);         
#endif
                                    }
                                } else {
                                    num = len;
                                }

                                expectSz -= num;
                                addr += num;
                            }
#else // #if SOCKET_EPOLL_EN
                            expectSz = len;
                            while (expectSz > 0) {
                                FD_ZERO(&rfds);
                                FD_SET(rs->psocket_n->connfd, &rfds);
                                tv.tv_sec = 5;
                                tv.tv_usec = 0;
                                if (!socketfailed) {
                                    ret = select(rs->psocket_n->connfd+1, NULL, &rfds, NULL, &tv);
                                    if (ret == -1) {
                                        perror("select()");
                                    } else if (ret) {
                                        num = write(rs->psocket_n->connfd, addr, expectSz);
#if LOG_P7_TX_EN
                                        sprintf_f(rs->logs, "nonblock send %d / %d \n", num, expectSz);
                                        print_f(rs->plogs, "P7", rs->logs);         
#endif
                                    } else {
                                        socketfailed = 1;
                                    }
                                } else {
                                    num = len;
                                }
                                expectSz -= num;
                                addr += num;
                            }
#endif // #if SOCKET_EPOLL_EN
#else
                            #if DBG_WIFI_REAL
                            num = write(rs->psocket_n->connfd, addr, len);
                            #else
                            num = len;
                            #endif
#endif

#if LOG_P7_TX_EN
                            sprintf_f(rs->logs, "tx %d - %d \n", num, tx);
                            print_f(rs->plogs, "P7", rs->logs);         
#endif
                        }

                        totsz += len;
                        
                        rs_ipc_put(rs, "n", 1);
                    } else {
                        sprintf_f(rs->logs, "%c socket tx %d %d %d- end\n", ch, rs->psocket_n->connfd, num, tx);
                        print_f(rs->plogs, "P7", rs->logs);         
                        break;
                    }

                    if (ch != 'N') {
                        ch = 0;
                        rs_ipc_get(rs, &ch, 1);
                    }
                }
                while (ch != 'N') {
                    sprintf_f(rs->logs, "%c clr\n", ch);
                    print_f(rs->plogs, "P7", rs->logs);         
                    ch = 0;
                    rs_ipc_get(rs, &ch, 1);
                }

                sprintf(rs->logs, "_WIFI_1_ END %d bytes ", totsz);
                tdiff = dbgShowTimeStamp(rs->logs, NULL, rs, 8, "_F1_E_");

                fltime = (CFLOAT)(tdiff - tlast);
                if (fltime == 0) {
                    thrput = 0;
                } else {
                    thrput = (CFLOAT) totsz /fltime;
                }

                sprintf(rs->logs, "_WIFI_1_ throughput: %.2f MB/sec ", thrput);
                dbgShowTimeStamp(rs->logs, NULL, rs, 8, "done");

#if MSP_P7_SAVE_DAT
                fclose(rs->fdat_s[3]);
#endif
                rs_ipc_put(rs, "N", 1);
                sprintf_f(rs->logs, "%c socket tx %d - end\n", ch, tx);
                print_f(rs->plogs, "P7", rs->logs);                  

                break;
            }
            else if (cmode == 2) {
                if (rs->psocket_n->connfd > 0) {
                    rs_ipc_put(rs, "R", 1);
                    continue;
                } else {
                    rs_ipc_put(rs, "r", 1);
                    break;
                }
            }
            else if (cmode == 3) {
#if MSP_P7_SAVE_DAT
                ret = file_save_get(&rs->fdat_s[3], "/mnt/mmc2/tx/p7_%d.dat");
                if (ret) {
                    sprintf_f(rs->logs, "get tx log data file error - %d, hold here\n", ret);
                    print_f(rs->plogs, "P7", rs->logs);         
                    while(1);
                } else {
                    sprintf_f(rs->logs, "get tx log data file ok - %d, f: %d\n", ret, rs->fdat_s[3]);
                    print_f(rs->plogs, "P7", rs->logs);         
                }
#endif
#if SOCKET_EPOLL_EN
                event.data.fd = consfd;
                event.events = EPOLLOUT | EPOLLLT;
                ret = epoll_ctl (epollfd, EPOLL_CTL_ADD, consfd, &event);
                if (ret == -1)
                {
                    perror ("epoll_ctl");
                    sprintf_f(rs->logs, "spoll set ctl failed errno: %ds\n", errno);
                    print_f(rs->plogs, "P7", rs->logs);                         
                    break;
                }
#endif

                tx = 0;
                while (1) {
                    len = ring_buf_cons_dual(rs->pdataRx, &addr, tx);
                    if (len >= 0) {
                        //printf("cons 0x%x %d %d \n", addr, len, tx);
                        tx++;
                    
                        msync(addr, len, MS_SYNC);
                        /* send data to wifi socket */
#if LOG_P7_TX_EN
                        sprintf_f(rs->logs, " %d -%d \n", len, tx);
                        print_f(rs->plogs, "P7", rs->logs);         
#endif
                        if (len != 0) {
#if SOCKET_NON_BLOCK_TX 
                            expectSz = len;
                            while (expectSz > 0) {
                                FD_ZERO(&rfds);
                                FD_SET(rs->psocket_n->connfd, &rfds);
                                tv.tv_sec = 5;
                                tv.tv_usec = 0;
                                if (!socketfailed) {
                                    ret = select(rs->psocket_n->connfd+1, NULL, &rfds, NULL, &tv);
                                    if (ret == -1) {
                                        perror("select()");
                                    } else if (ret) {
                                        num = write(rs->psocket_n->connfd, addr, expectSz);
#if LOG_P7_TX_EN
                                        sprintf_f(rs->logs, "nonblock send %d / %d \n", num, expectSz);
                                        print_f(rs->plogs, "P7", rs->logs);         
#endif
                                    } else {
                                        socketfailed = 1;
                                    }
                                } else {
                                    num = len;
                                }
                                expectSz -= num;
                                addr += num;
                            }

#if SOCKET_EPOLL_EN
                            expectSz = len;
                            while (expectSz > 0) {
                                if (!socketfailed) {
                                    nfds = epoll_wait (epollfd, events, MAX_EVENTS, 5000);
                                    if (nfds < 0) {
                                        perror("epoll_wait");
                                        sprintf_f(rs->logs, "nonblock send %d / %d failed, errno: %d\n", num, expectSz, errno);
                                        print_f(rs->plogs, "P7", rs->logs);         
                                        break;
                                    } else if (nfds == 0) {
                                        socketfailed = 1;
                                    } else {
                                        num = write(consfd, addr, expectSz);
#if LOG_P7_TX_EN
                                        sprintf_f(rs->logs, "epoll nonblock send %d / %d, n: %d\n", num, expectSz, nfds);
                                        print_f(rs->plogs, "P7", rs->logs);         
#endif
                                    }
                                } else {
                                    num = len;
                                }

                                expectSz -= num;
                                addr += num;
                            }
#endif
                            
#else
                            #if DBG_WIFI_REAL
                            num = write(rs->psocket_n->connfd, addr, len);
                            #else
                            num = len;
                            #endif
#endif
                            //printf("socket tx %d %d\n", rs->psocket_r->connfd, num);
                            //sprintf_f(rs->logs, "%c socket tx %d %d %d \n", ch, rs->psocket_n->connfd, num, tx);
                            //print_f(rs->plogs, "P7", rs->logs);         
#if MSP_P7_SAVE_DAT
                            msync(addr, len, MS_SYNC);   
                            fwrite(addr, 1, len, rs->fdat_s[3]);
                            fflush(rs->fdat_s[3]);
#endif
                        }
                    } else {
                        sprintf_f(rs->logs, "%c socket tx %d %d %d- end\n", ch, rs->psocket_n->connfd, num, tx);
                        print_f(rs->plogs, "P7", rs->logs);         
                        break;
                    }

                    if (ch != 'D') {
                        ch = 0;
                        rs_ipc_get(rs, &ch, 1);
                    }
                }
                while (ch != 'D') {
                    sprintf_f(rs->logs, "%c clr\n", ch);
                    print_f(rs->plogs, "P7", rs->logs);         
                    ch = 0;
                    rs_ipc_get(rs, &ch, 1);
                }

                rs_ipc_put(rs, "D", 1);
                sprintf_f(rs->logs, "%c socket tx %d - end\n", ch, tx);
                print_f(rs->plogs, "P7", rs->logs);         
#if MSP_P7_SAVE_DAT
                fclose(rs->fdat_s[3]);
#endif
                break;
            }
            else if (cmode == 4) {                
                secStr = c->opinfo;
                secLen = p->opinfo;
                datLen = secLen * 512;
                minLen = 16 * 512;

                sprintf_f(rs->logs, "ready for tx %d/%d\n", datLen, minLen);
                print_f(rs->plogs, "P7", rs->logs);

                if (datLen < minLen) {
                    datLen = minLen;
                }
#if SOCKET_EPOLL_EN
                event.data.fd = consfd;
                event.events = EPOLLOUT | EPOLLLT;
                ret = epoll_ctl (epollfd, EPOLL_CTL_ADD, consfd, &event);
                if (ret == -1)
                {
                    perror ("epoll_ctl");
                    sprintf_f(rs->logs, "spoll set ctl failed errno: %ds\n", errno);
                    print_f(rs->plogs, "P4", rs->logs);                         
                    break;
                }
#endif

                rs_ipc_get(rs, &ch, 1);

                memset(chbuf, 0, 32);
                sprintf_f(chbuf, "%d%c", datLen, '\0');
#if SOCKET_NON_BLOCK_TX 
#if SOCKET_EPOLL_EN
                len = strlen(chbuf);
                expectSz = len;
                while (expectSz > 0) {
                    if (!socketfailed) {
                        nfds = epoll_wait (epollfd, events, MAX_EVENTS, 5000);
                        if (nfds < 0) {
                            perror("epoll_wait");
                            sprintf_f(rs->logs, "nonblock send %d / %d failed, errno: %d\n", num, expectSz, errno);
                            print_f(rs->plogs, "P7", rs->logs);         
                            break;
                        } else if (nfds == 0) {
                            socketfailed = 1;
                        } else {
                            num = write(consfd, chbuf, expectSz);
#if LOG_P7_TX_EN
                            sprintf_f(rs->logs, "epoll nonblock send %d / %d, n: %d\n", num, expectSz, nfds);
                            print_f(rs->plogs, "P7", rs->logs);         
#endif
                        }
                    } else {
                        num = len;
                    }

                    expectSz -= num;
                    addr += num;
                }
#else // #if SOCKET_EPOLL_EN
                len = strlen(chbuf);
                expectSz = len;
                while (expectSz > 0) {
                    FD_ZERO(&rfds);
                    FD_SET(rs->psocket_n->connfd, &rfds);
                    tv.tv_sec = 5;
                    tv.tv_usec = 0;
                    if (!socketfailed) {
                        ret = select(rs->psocket_n->connfd+1, NULL, &rfds, NULL, &tv);
                        if (ret == -1) {
                            perror("select()");
                        } else if (ret) {
                            num = write(rs->psocket_n->connfd, chbuf, expectSz);
#if LOG_P7_TX_EN
                            sprintf_f(rs->logs, "nonblock send %d / %d \n", num, expectSz);
                            print_f(rs->plogs, "P7", rs->logs);         
#endif
                        } else {
                            socketfailed = 1;
                        }
                    } else {
                        num = len;
                    }
                    expectSz -= num;
                    addr += num;
                }
#endif // #if SOCKET_EPOLL_EN
#else //#if SOCKET_NON_BLOCK_TX 
                ret = write(rs->psocket_n->connfd, chbuf, strlen(chbuf));
#endif // #if SOCKET_NON_BLOCK_TX 
                sprintf_f(rs->logs, "get %c socket tx [%s], ret:%d\n", ch, chbuf, ret);
                print_f(rs->plogs, "P7", rs->logs);       
                
                while (1) {
                    rs_ipc_get(rs, &ch, 1);
                    if (ch == 'U') break;
                }
                
                rs_ipc_put(rs, "U", 1);
                sprintf_f(rs->logs, "%c socket tx %d - end\n", ch, tx);
                print_f(rs->plogs, "P7", rs->logs);       
                
                if (!pftb->c) {
                    memset(chbuf, 0, 32);
                    sprintf(chbuf, "%c%c", ch, '\0');
#if SOCKET_NON_BLOCK_TX 
#if SOCKET_EPOLL_EN
                len = strlen(chbuf);
                expectSz = len;
                while (expectSz > 0) {
                    if (!socketfailed) {
                        nfds = epoll_wait (epollfd, events, MAX_EVENTS, 5000);
                        if (nfds < 0) {
                            perror("epoll_wait");
                            sprintf_f(rs->logs, "nonblock send %d / %d failed, errno: %d\n", num, expectSz, errno);
                            print_f(rs->plogs, "P7", rs->logs);         
                            break;
                        } else if (nfds == 0) {
                            socketfailed = 1;
                        } else {
                            num = write(consfd, chbuf, expectSz);
#if LOG_P7_TX_EN
                            sprintf_f(rs->logs, "epoll nonblock send %d / %d, n: %d\n", num, expectSz, nfds);
                            print_f(rs->plogs, "P7", rs->logs);         
#endif
                        }
                    } else {
                        num = len;
                    }

                    expectSz -= num;
                    addr += num;
                }
#else // #if SOCKET_EPOLL_EN
                len = strlen(chbuf);
                expectSz = len;
                while (expectSz > 0) {
                    FD_ZERO(&rfds);
                    FD_SET(rs->psocket_n->connfd, &rfds);
                    tv.tv_sec = 5;
                    tv.tv_usec = 0;
                    if (!socketfailed) {
                        ret = select(rs->psocket_n->connfd+1, NULL, &rfds, NULL, &tv);
                        if (ret == -1) {
                            perror("select()");
                        } else if (ret) {
                            num = write(rs->psocket_n->connfd, chbuf, expectSz);
#if LOG_P7_TX_EN
                            sprintf_f(rs->logs, "nonblock send %d / %d \n", num, expectSz);
                            print_f(rs->plogs, "P7", rs->logs);         
#endif
                        } else {
                            socketfailed = 1;
                        }
                    } else {
                        num = len;
                    }
                    expectSz -= num;
                    addr += num;
                }
#endif // #if SOCKET_EPOLL_EN
#else
#if DBG_WIFI_REAL
                    ret = write(rs->psocket_n->connfd, chbuf, strlen(chbuf));
#else
                    ret = strlen(chbuf);
#endif
#endif
                    sprintf_f(rs->logs, "send %c to APP to notice the end, ret:%d\n", ch, ret);
                    print_f(rs->plogs, "P7", rs->logs);       
                
                    sprintf_f(rs->logs, "connect break \n");
                    print_f(rs->plogs, "P7", rs->logs);       

                    break;
                }
            }
            else {
                sprintf_f(rs->logs, "cmode: %d - 7\n", cmode);
                print_f(rs->plogs, "P7", rs->logs);
                error_handle(rs->logs, 5141);
            }
            
        }

        socketEnd:
        close(rs->psocket_n->connfd);
        rs->psocket_n->connfd = 0;
    }

    p7_end(rs);
    return 0;
}

void *get_in_addr(struct sockaddr *sa){
    if (sa->sa_family == AF_INET) {
        return &(((struct sockaddr_in*)sa)->sin_addr);
    }	
    return &(((struct sockaddr_in6*)sa)->sin6_addr);
}

int get_in_port(struct sockaddr *sa){
    if (sa->sa_family == AF_INET) {
        return ntohs(((struct sockaddr_in*)sa)->sin_port);
    }	
    return ntohs(((struct sockaddr_in6*)sa)->sin6_port);
}

int getaddoffset(char *na, char *lstn) 
{
    char dot = '.';
    int len=0, cnt=0, id=0, lsn=0;
    
    if ((!na) || (!lstn)) return -1;

    len = strlen(na);

    if (len > 16) return -2;

    //printf("input: %s \n", na);

    while (id < len) {
        if (na[id] == dot) {
            cnt++;
        }

        if (cnt == 3) {
            lsn = atoi(&na[id+1]);
            *lstn = lsn;

            //printf("offset: %d, last number: %d \n", id, lsn);
            break;
        }

        id++;
    }

    return id;
}

#define LOG_P8_EN (0)
static int p8(struct procRes_s *rs)
{
#define RECVLEN 1024
#define MYPORT "8000"
    int ret=0, n=0, tot=0, len=0, cltport=0, rpcnt=0, offset=0, neql=0;
    char *recvbuf=0, *sendbuf=0;
    char ack[8] = "ack\n\0";
    char *cltaddr=0;
    char syscmd[256];

    struct addrinfo hints, *servinfo, *p;
    struct addrinfo clients, *clintinfo, *c;
    struct sockaddr_in *saddr, *haddr;
    const struct sockaddr_storage their_addr;
    char s[INET_ADDRSTRLEN];
    char d[INET_ADDRSTRLEN];
    char port[8];
    int rv, sockfd, sockback;
    struct modersp_s tmpModersp;
    
    struct ifaddrs *ifaddr, *ifa;
    char ifname[128], lastnum=0;
    int family=0;
    struct rtnl_link_stats *stats = 0;
    
    prctl(PR_SET_NAME, "msp-p8");
    //sprintf(argv[0], "msp-p8-udp-listen");
    
    memset(&hints, 0, sizeof(hints));
    memset(ifname, 0, 128);

    sprintf_f(rs->logs, "p8\n");
    print_f(rs->plogs, "P8", rs->logs);

    p8_init(rs);

    /* test */
    dbgShowTimeStamp("CONFIG ETH0 USB_MODESWITCH", NULL, rs, 2, NULL);
    
    recvbuf = aspMemalloc(RECVLEN, 8);
    if (!recvbuf) {
        sprintf(rs->logs, "p8 get memory alloc falied");
        error_handle(rs->logs, 24043);
    }

    sendbuf = aspMemalloc(RECVLEN, 8);
    if (!sendbuf) {
        sprintf(rs->logs, "p8 get memory alloc falied");
        error_handle(rs->logs, 24179);
    }

    #if 1//AP_CLR_STATUS
    /* clear status */
    sprintf(syscmd, "kill -9 $(ps aux | grep 'wlan0' | awk '{print $1}')");
    ret = doSystemCmd(syscmd);

    sprintf(syscmd, "kill -9 $(ps aux | grep 'wlan1' | awk '{print $1}')");
    ret = doSystemCmd(syscmd);

    //sprintf(syscmd, "kill -9 $(ps aux | grep 'mothership' | awk '{print $1}')");
    //ret = doSystemCmd(syscmd);

    sprintf(syscmd, "kill -9 $(ps aux | grep 'hostapd' | awk '{print $1}')");
    ret = doSystemCmd(syscmd);

    sprintf(syscmd, "/root/script/connect.sh > /dev/null 2>&1");
    ret = doSystemCmd(syscmd);

    //sprintf(syscmd, "ifconfig uap0 down");
    //ret = doSystemCmd(syscmd);

    sprintf(syscmd, "kill -9 $(ps aux | grep '%s' | awk '{print $1}')", WIRELESS_INT);
    ret = doSystemCmd(syscmd);

    sprintf(syscmd, "kill -9 $(ps aux | grep '%s' | awk '{print $1}')", WIRELESS_INT_WPA);
    ret = doSystemCmd(syscmd);
        
    sprintf(syscmd, "kill -9 $(ps aux | grep 'wpa_supplicant' | awk '{print $1}')");
    ret = doSystemCmd(syscmd);

    sprintf(syscmd, "ifconfig %s down", WIRELESS_INT);
    ret = doSystemCmd(syscmd);

    sprintf(syscmd, "ifconfig %s down", WIRELESS_INT_WPA);
    ret = doSystemCmd(syscmd);
        
    sprintf_f(rs->logs, "AP network interface: %s \n", rs->pnetIntfs);
    print_f(rs->plogs, "P8", rs->logs);

    sprintf_f(rs->logs, "WPA network interface: %s \n", rs->pnetIntwpa);
    print_f(rs->plogs, "P8", rs->logs);

    //sprintf(syscmd, "rm /home/root/scan_in/cv_det_tw.txt");
    //ret = doSystemCmd(syscmd);

    //sprintf(syscmd, "dk2_ocr_scanin");
    //ret = doSystemCmd(syscmd);
    
    //sprintf(syscmd, "cat /home/root/scan_in/cv_det_tw.txt");
    //ret = doSystemCmd(syscmd);

    //dbgShowTimeStamp("s7s-2", NULL, rs, 2, NULL);
    
    //sleep(1);
    #endif

    #if AP_AUTO
    /* AP mode launch or not */
    int isLaunch = 0;
    struct aspConfig_s* ctb = 0;
    FILE *faptpe=0;
    char aptypestr[32] = WIRELESS_INT;
    int itypelen=0, addroffset=0;
    struct apWifiConfig_s *pwfc=0;

    pwfc = rs->pwifconf;
    ctb = &rs->pcfgTable[ASPOP_AP_MODE];
    if (ctb->opCode != OP_AP_MODEN) {        
        sprintf_f(rs->logs, " WARNING!!! get wrong opcode value 0x%x", ctb->opCode);
        print_f(rs->plogs, "P8", rs->logs);
    }

    sprintf_f(rs->logs, "opc: 0x%x, status: 0x%x, value: %d \n", ctb->opCode, ctb->opStatus, ctb->opValue);
    print_f(rs->plogs, "P8", rs->logs);

    if (ctb->opValue) {
        /* launch AP  */
        //sprintf(syscmd, "/root/script/clr_all.sh");
        //ret = doSystemCmd(syscmd);
        //sleep(1);

        memset(aptypestr, 0, 32);
        memset(rs->pnetIntfs, 0, 16);
        
        faptpe = fopen("/root/config/aptype", "r");
        if (faptpe) {
            itypelen = fread(aptypestr, 1, 16, faptpe);
            if ((itypelen > 0) && (itypelen < 16)) {
                aptypestr[itypelen] = '\0';
                if (aptypestr[itypelen-1] == '\n') {
                    aptypestr[itypelen-1] = '\0';
                }
                if (aptypestr[itypelen-1] == '\r') {
                    aptypestr[itypelen-1] = '\0';
                }
                sprintf(rs->pnetIntfs, "%s", aptypestr);
            } else {
                memset(rs->pnetIntfs, 0, 16);
                sprintf(rs->pnetIntfs, WIRELESS_INT);
            }
            fclose(faptpe);
        } else {
            memset(rs->pnetIntfs, 0, 16);
            sprintf(rs->pnetIntfs, WIRELESS_INT);
        }
        
        //sprintf(syscmd, "/root/script/launchAP_now.sh > /dev/null 2>&1");
        sprintf(syscmd, "/root/script/launchAP_now.sh");
        ret = doSystemCmd(syscmd);
        
        sprintf_f(rs->logs, "AP interface = [%s] \n", rs->pnetIntfs);
        print_f(rs->plogs, "P8", rs->logs);

        sprintf(rs->logs, "DIRECT MODE CONFIG IF = %s ", rs->pnetIntfs);
        dbgShowTimeStamp(rs->logs, NULL, rs, 2, NULL);

        //shmem_dump(pmrs->netIntfs, 16);
        //shmem_dump(aptypestr, 16);
    }
  
    if (ctb->opValue == APM_AP) {
        dbgShowTimeStamp("AP MODE CONFIG", NULL, rs, 2, NULL);
        /* launch wpa connect */

        if ((pwfc->wfpskLen > 0) && (pwfc->wfsidLen > 0)) {
            sprintf_f(rs->logs, "launch AP mode ... ssid: %s, psk: %s\n", pwfc ->wfssid, pwfc->wfpsk);
            print_f(rs->plogs, "P8", rs->logs);

            sprintf(rs->logs, "AP MODE CONFIG SSID: %s, PSK: %s\n", pwfc ->wfssid, pwfc->wfpsk);
            dbgShowTimeStamp(rs->logs, NULL, rs, 2, NULL);

            faptpe = 0;
            memset(aptypestr, 0, 32);
            memset(rs->pnetIntwpa, 0, 16);
            faptpe = fopen("/root/config/wpatype", "r");
            if (faptpe) {
                itypelen = fread(aptypestr, 1, 16, faptpe);
                if ((itypelen > 0) && (itypelen < 16)) {
                    aptypestr[itypelen] = '\0';
                    if (aptypestr[itypelen-1] == '\n') {
                        aptypestr[itypelen-1] = '\0';
                    }

                    if (aptypestr[itypelen-1] == '\r') {
                        aptypestr[itypelen-1] = '\0';
                    }
                    sprintf(rs->pnetIntwpa, "%s", aptypestr);
                } else {
                    memset(rs->pnetIntwpa, 0, 16);
                    sprintf(rs->pnetIntwpa, WIRELESS_INT_WPA);
                }
                fclose(faptpe);
                faptpe = 0;
            } else {
                memset(rs->pnetIntwpa, 0, 16);
                sprintf(rs->pnetIntwpa, WIRELESS_INT_WPA);
            }
        
            /* launch wpa connect */
            sprintf(syscmd, "/root/script/wpa_conf.sh \\\"%s\\\" \\\"%s\\\" /etc/wpa_supplicant.conf ", pwfc ->wfssid, pwfc->wfpsk);
            ret = doSystemCmd(syscmd);

            //sprintf(syscmd, "cp /root/script/interfaces_8723bu_wpa /etc/network/interfaces");
            //ret = doSystemCmd(syscmd);

            sprintf(syscmd, "wpa_supplicant -B -c /etc/wpa_supplicant.conf -i%s -Dnl80211 -dd", rs->pnetIntwpa);
            ret = doSystemCmd(syscmd);

            sleep(1);

            sprintf(syscmd, "udhcpc -i %s -b", rs->pnetIntwpa);
            ret = doSystemCmd(syscmd);

            sprintf_f(rs->logs, "exec [%s]...\n", syscmd);
            print_f(rs->plogs, "P8", rs->logs);

            sprintf_f(rs->logs, "WPA interface: [%s]\n", rs->pnetIntwpa);
            print_f(rs->plogs, "P8", rs->logs);

            ret = getifaddrs(&ifaddr);
            if (ret == -1) {
                perror("getifaddrs");        
                //exit(EXIT_FAILURE);    
            } 
            else {
                for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
                    if (ifa->ifa_addr == NULL)
                        continue;

                    ret=getnameinfo(ifa->ifa_addr, sizeof(struct sockaddr_in),s, INET_ADDRSTRLEN, NULL, 0, NI_NUMERICHOST);
                    if (ret != 0) {
                        //printf("[%s] getnameinfo() failed: %s\n", ifa->ifa_name, gai_strerror(ret));
                        //exit(EXIT_FAILURE);
                        continue;
                    }
                    
                    if((strcmp(ifa->ifa_name, rs->pnetIntwpa)==0) && (ifa->ifa_addr->sa_family == AF_INET)) {

                        printf("\tInterface : <%s>\n",ifa->ifa_name );
                        printf("\t  Address : <%s>\n", s);

                        sprintf_f(rs->logs, "iface: %s addr: %s", rs->pnetIntwpa, s);
                        print_f(rs->plogs, "P8", rs->logs);

                        addroffset = getaddoffset(s, &lastnum);
                        memset(d, 0, INET_ADDRSTRLEN);

                        memcpy(d, s, addroffset);
                        sprintf(&d[addroffset], "%d", 1);

                        sprintf_f(rs->logs, "ping gatway ip: %s \n", d);
                        print_f(rs->plogs, "P8", rs->logs);

                        sprintf(syscmd, "ping %s -w 3", d);
                        ret = doSystemCmd(syscmd);

                        isLaunch = 1;
                    }
                }

                freeifaddrs(ifaddr);
            }

            if (!isLaunch) {
                sprintf(rs->logs, "AP MODE CONFIG IF = %s ", rs->pnetIntwpa);
                dbgShowTimeStamp(rs->logs, NULL, rs, 2, NULL);
            }

            #if 0 /* always connect */
            if (!isLaunch) {
                ctb->opValue = APM_DIRECT;
                fs109rs(rs);
            }
            #endif
        }
        else {
            sprintf_f(rs->logs, "failed to launch AP mode, no ssid and psk ...\n");
            print_f(rs->plogs, "P8", rs->logs);
        }
    }

    //dbgShowTimeStamp("s7s-3", NULL, rs, 2, NULL);

    if ((pwfc->wfsidLen > 0) && (pwfc->wfpskLen > 0)) {
        sprintf_f(rs->logs, " get ssid: [%s] size: %d, psk: [%s] size: %d\n", pwfc->wfssid, pwfc->wfsidLen, pwfc->wfpsk, pwfc->wfpskLen);
        print_f(rs->plogs, "P8", rs->logs);
    } else {
        sprintf_f(rs->logs, " ssid and psk are unavilable!!\n");
        print_f(rs->plogs, "P8", rs->logs);
    }    

    dbgShowTimeStamp("WIRELESS CONFIG FINISH", NULL, rs, 2, NULL);

    #endif
    
#if 1
    hints.ai_family = AF_INET; // set to AF_INET to force IPv4
    hints.ai_socktype = SOCK_DGRAM;
    hints.ai_flags = AI_PASSIVE; // use my IP

    while (1) {
        usleep(100000);

        #if 0
        if (getifaddrs(&ifaddr) == -1) {
            perror("getifaddrs");        
            //exit(EXIT_FAILURE);    
            continue;
        }

        memset(sendbuf, 0, RECVLEN);
        for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
            if (ifa->ifa_addr == NULL)
                continue;

            ret=getnameinfo(ifa->ifa_addr,sizeof(struct sockaddr_in),s, INET_ADDRSTRLEN, NULL, 0, NI_NUMERICHOST);

            if((strcmp(ifa->ifa_name, rs->pnetIntfs)==0)&&(ifa->ifa_addr->sa_family==AF_INET)) {
                if (ret != 0) {
                    printf("getnameinfo() failed: %s\n", gai_strerror(ret));
                    //exit(EXIT_FAILURE);
                    continue;
                }
#if LOG_P8_EN
                printf("\tInterface : <%s>\n",ifa->ifa_name );
                printf("\t  Address : <%s>\n", s);
#endif
                sprintf(rs->logs, "_M_IP_%s_ ", s);
                dbgShowTimeStamp(rs->logs, NULL, rs, 8, NULL);
                
                sprintf(sendbuf, "iface: %s addr: %s port: %d", rs->pnetIntfs, s, 8000);

                break;
            }
        }
        freeifaddrs(ifaddr);

        if (strlen(sendbuf) == 0) {
            continue;
        }
        #endif
        
        if ((rv = getaddrinfo(NULL, MYPORT, &hints, &servinfo)) != 0) {
            fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));	
            return 1;	
        }
        for(p = servinfo; p != NULL; p = p->ai_next) {
            if ((sockfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) == -1) {
                perror("listener: socket");
                continue;
            }
            if (bind(sockfd, p->ai_addr, p->ai_addrlen) == -1) {

                //perror("listener: bind");
                ret = -1;
                if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &ret, sizeof(int)) == -1) {
                    perror("setsockopt");    
                    close(sockfd);
                    continue;
                }
            }
            
            break;
        }

        if (p == NULL) {
            fprintf(stderr, "listener: failed to bind socket\n");
            freeaddrinfo(servinfo);
            continue;
        }

#if LOG_P8_EN
        printf("listener: waiting to recvfrom...\n");
#endif
        memset(recvbuf, 0, RECVLEN);
        len = sizeof(their_addr);
        if ((n = recvfrom(sockfd, recvbuf, RECVLEN-1 , 0, (struct sockaddr *)&their_addr, &len)) == -1) {
            perror("recvfrom");
            freeaddrinfo(servinfo);
            close(sockfd);
            continue;
        }

        //haddr = (struct sockaddr_in *)p->ai_addr;
        //sprintf(sendbuf, "addr: %s port: %d", inet_ntop(AF_INET, &(haddr->sin_addr), s, INET_ADDRSTRLEN), get_in_port((struct sockaddr *)&(haddr->sin_addr)));

        inet_ntop(their_addr.ss_family, get_in_addr((struct sockaddr *)&their_addr), d, sizeof(d));
        memset(port, 0, 8);

        sprintf(port, "%d", get_in_port((struct sockaddr *)&their_addr));
#if LOG_P8_EN
        printf("listener: got packet from %s : %s\n", d, port);
        printf("listener: packet is %d bytes long\n", n);	
#endif
        recvbuf[n] = '\0';	
#if LOG_P8_EN
        printf("listener: packet contains \"%s\"\n", recvbuf);	
#endif
        freeaddrinfo(servinfo);
        close(sockfd);

        sprintf(rs->logs, "_A_IP_%s_ ", d);
        dbgShowTimeStamp(rs->logs, NULL, rs, 8, NULL);

        memset(&clients, 0, sizeof(clients));
        clients.ai_family = AF_INET; // set to AF_INET to force IPv4
        clients.ai_socktype = SOCK_DGRAM;

        if ((rv = getaddrinfo(d, port, &clients, &clintinfo)) != 0) {
            fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));	
            close(sockfd);
            freeaddrinfo(clintinfo);
            continue;
        }

        for(c = clintinfo; c != NULL; c = c->ai_next) {
            if ((sockback = socket(c->ai_family, c->ai_socktype, c->ai_protocol)) == -1) {
                perror("listener: socket");
                continue;
            }
            break;
        }

        if (c == NULL) {
            fprintf(stderr, "listener: failed to bind socket\n");
            freeaddrinfo(clintinfo);
            continue;
        }

        #if 1
        if (getifaddrs(&ifaddr) == -1) {
            perror("getifaddrs");        
            //exit(EXIT_FAILURE);    
            continue;
        }
        
        offset = getaddoffset(d, &lastnum);

        memset(sendbuf, 0, RECVLEN);
        tot = 0;
        for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
            if (ifa->ifa_addr == NULL)
                continue;

               #if 0
               family = ifa->ifa_addr->sa_family;

               /* Display interface name and family (including symbolic
                  form of the latter for the common families) */
               printf("%-8s %s (%d)\n",
                      ifa->ifa_name,
                      (family == AF_PACKET) ? "AF_PACKET" :
                      (family == AF_INET) ? "AF_INET" :
                      (family == AF_INET6) ? "AF_INET6" : "???",
                      family);

               /* For an AF_INET* interface address, display the address */

               if (family == AF_INET || family == AF_INET6) {
                   ret = getnameinfo(ifa->ifa_addr,
                           (family == AF_INET) ? sizeof(struct sockaddr_in) :
                                                 sizeof(struct sockaddr_in6),
                           s, NI_MAXHOST,
                           NULL, 0, NI_NUMERICHOST);
                   if (ret != 0) {
                       printf("getnameinfo() failed: %s\n", gai_strerror(ret));
                       //exit(EXIT_FAILURE);
                   }

                   printf("\t\taddress: <%s>\n", s);

               } else if (family == AF_PACKET && ifa->ifa_data != NULL) {
                   stats = (struct rtnl_link_stats *)ifa->ifa_data;
                   
                   printf("\t\ttx_packets = %10u; rx_packets = %10u\n"
                          "\t\ttx_bytes   = %10u; rx_bytes   = %10u\n",
                          stats->tx_packets, stats->rx_packets,
                          stats->tx_bytes, stats->rx_bytes);
                   
               }
               #endif

            ret=getnameinfo(ifa->ifa_addr,sizeof(struct sockaddr_in),s, INET_ADDRSTRLEN, NULL, 0, NI_NUMERICHOST);

            memset(ifname, 0, 128);
            strcpy(ifname, rs->pnetIntfs);
            if((strcmp(ifa->ifa_name, ifname)==0)&&(ifa->ifa_addr->sa_family==AF_INET)) {
                if (ret != 0) {
                    printf("getnameinfo() failed: %s\n", gai_strerror(ret));
                    //exit(EXIT_FAILURE);
                    continue;
                }
#if LOG_P8_EN
                printf("\tInterface : <%s> (%s)\n",ifa->ifa_name, ifname);
                printf("\t  Address : <%s>\n", s);
#endif
                sprintf(rs->logs, "_M_IP_%s_ ", s);
                dbgShowTimeStamp(rs->logs, NULL, rs, 8, NULL);
                
                n = getaddoffset(s, &lastnum);
                if ((n > 0) && (n == offset)) {
                    neql = strncmp(d, s, n);
                    if (neql == 0) {
                        sprintf(&sendbuf[tot], "iface: %s addr: %s port: %d, \n", ifname, s, 8000);
                        tot = strlen(sendbuf);
                    }
                }

                //break;
            }

            memset(ifname, 0, 128);
            strcpy(ifname, WIRELESS_INT);
            if((strcmp(ifa->ifa_name, ifname)==0)&&(ifa->ifa_addr->sa_family==AF_INET)) {
                if (ret != 0) {
                    printf("getnameinfo() failed: %s\n", gai_strerror(ret));
                    //exit(EXIT_FAILURE);
                    continue;
                }
#if LOG_P8_EN
                printf("\tInterface : <%s> (%s)\n",ifa->ifa_name, ifname);
                printf("\t  Address : <%s>\n", s);
#endif
                sprintf(rs->logs, "_M_IP_%s_ ", s);
                dbgShowTimeStamp(rs->logs, NULL, rs, 8, NULL);
                
                n = getaddoffset(s, &lastnum);
                if ((n > 0) && (n == offset)) {
                    neql = strncmp(d, s, n);
                    if (neql == 0) {
                        sprintf(&sendbuf[tot], "iface: %s addr: %s port: %d, \n", ifname, s, 8000);
                        tot = strlen(sendbuf);
                    }
                }
                //break;
            }
            
            memset(ifname, 0, 128);
            strcpy(ifname, WIRELESS_INT_WPA);
            if((strcmp(ifa->ifa_name, ifname)==0)&&(ifa->ifa_addr->sa_family==AF_INET)) {
                if (ret != 0) {
                    printf("getnameinfo() failed: %s\n", gai_strerror(ret));
                    //exit(EXIT_FAILURE);
                    continue;
                }
#if LOG_P8_EN
                printf("\tInterface : <%s> (%s)\n",ifa->ifa_name, ifname);
                printf("\t  Address : <%s>\n", s);
#endif
                sprintf(rs->logs, "_M_IP_%s_ ", s);
                dbgShowTimeStamp(rs->logs, NULL, rs, 8, NULL);
                
                n = getaddoffset(s, &lastnum);
                if ((n > 0) && (n == offset)) {
                    neql = strncmp(d, s, n);
                    if (neql == 0) {
                        sprintf(&sendbuf[tot], "iface: %s addr: %s port: %d, \n", ifname, s, 8000);
                        tot = strlen(sendbuf);
                    }
                }
                //break;
            }


        }
        freeifaddrs(ifaddr);

        if (strlen(sendbuf) == 0) {
            continue;
        }
        #endif
        
        n = strlen(sendbuf);
        sendbuf[n] = '\0';
        saddr = (struct sockaddr_in *)c->ai_addr;

#if LOG_P8_EN
        printf("listener: sendto packet contains \"%s\", size: %d, addr: %s \n", sendbuf, n, inet_ntop(AF_INET, &(saddr->sin_addr), d, INET_ADDRSTRLEN));	
#endif

        rpcnt = 0;
        while (rpcnt < 1) {
            n = sendto(sockback, sendbuf, n+1 , 0, c->ai_addr, c->ai_addrlen);
            if (n <= 0) {
                perror("sendto");
                break;
            }
            usleep(30000);
            rpcnt ++;
        }

        printf("listener: repeat cnt %d \n", rpcnt);	
        
        freeaddrinfo(clintinfo);
        close(sockback);
        close(sockfd);
    }

#else
    rs->psocket_v->listenfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (rs->psocket_v->listenfd < 0) { 
        sprintf(rs->logs, "p8 get socket ret: %d", rs->psocket_v->listenfd);
        error_handle(rs->logs, 24025);
    }

    memset(&rs->psocket_v->serv_addr, '0', sizeof(struct sockaddr_in));

    rs->psocket_v->serv_addr.sin_family = AF_INET;
    rs->psocket_v->serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    rs->psocket_v->serv_addr.sin_port = htons(8000); 

    ret = bind(rs->psocket_v->listenfd, (struct sockaddr*)&rs->psocket_v->serv_addr, sizeof(struct sockaddr_in));
    if (ret < 0) {
        perror("bind:");
        sprintf(rs->logs, "p8 get bind ret: %d", ret);
        error_handle(rs->logs, 24037);
    }

    ret = listen(rs->psocket_v->listenfd, 10); 
    if (ret < 0) {
        sprintf(rs->logs, "p8 get listen ret: %d", ret);
        error_handle(rs->logs, 24043);
    }

    while (1) {
        sprintf_f(rs->logs, "#\n");
        print_f(rs->plogs, "P8", rs->logs);
        
        sprintf_f(rs->logs, "START \n");
        print_f(rs->plogs, "P8", rs->logs);


        len = sizeof(struct sockaddr_in);
        memset(&rs->psocket_v->clint_addr, 0, len);
        rs->psocket_v->connfd = accept(rs->psocket_v->listenfd, (struct sockaddr*)&rs->psocket_v->clint_addr, &len); 
        if (rs->psocket_v->connfd < 0) {
            sprintf(rs->logs, "P8 get connect failed ret:%d", rs->psocket_v->connfd);
            error_handle(rs->logs, 24053);
            goto socketEnd;
        } else {
            cltaddr = inet_ntoa(rs->psocket_v->clint_addr.sin_addr);
            //cltaddr = rs->psocket_v->clint_addr.sa_data;
            cltport = ntohs(rs->psocket_v->clint_addr.sin_port);
            sprintf_f(rs->logs, "get connection id: %d [%s:%d]\n", rs->psocket_v->connfd, cltaddr, cltport);
            print_f(rs->plogs, "P8", rs->logs);
        }

        n = 0; tot = 0;
        n = recv(rs->psocket_v->connfd, recvbuf, 1024, 0);
        while (n) {
            tot += n;
            ret = send(rs->psocket_v->connfd, ack, 4, 0);
            
            sprintf_f(rs->logs, "get and send back %d bytes [%s] \n", n, recvbuf);
            print_f(rs->plogs, "P8", rs->logs);
            
            //shmem_dump(recvbuf, n);
            n = 0;
            n = recv(rs->psocket_v->connfd, recvbuf, 1024, 0);

        }

        sprintf_f(rs->logs, "END total: %d\n", tot);
        print_f(rs->plogs, "P8", rs->logs);

        socketEnd:
        close(rs->psocket_v->connfd);
        rs->psocket_v->connfd = 0;
    }
#endif
    p8_end(rs);
    return 0;

}
#define DUMP_FLASH (0)
#define DBG_USB_HS (0)
#define DBG_USB_FLW (0)
#define USB_POLLTIME_US (1000)
static int usbhostd(struct procRes_s *rs, char *sp, int dlog)
{
    struct pollfd ptfd[1];
    char ptrecv[32];
    int ptret=0, recvsz=0, acusz=0, wrtsz=0, usbrun=0, currun=0, mtlen=0;
    int usbdist=0, usbthrhld=0, usbuffed=0, usbavg=0, usbufmax=0, buffstep=0;
    int upa=0, ufr=0, ure=0, ufo=0;
    uint32_t usbfolw=0;
    int cntRecv=0, usCost=0, bufsize=0;
    int bufmax=0, idx=0, printlog=0, idlecnt=0;
    CFLOAT throughput=0.0, thrimgsize=0.0, thrtimecost=0.0;;
    struct timespec tstart, tend;
    struct aspMetaData_s meta, *pmeta=0;
    int len=0, pieRet=0, ret=0, err=0;
    char *ptm=0, *pcur=0, *addr=0, *pt=0;
    char chr=0, opc=0, dat=0, chq=0, ch=0;
    char cplls[8];
    char CBW[32] = {0x55, 0x53, 0x42, 0x43, 0x11, 0x22, 0x33, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    char *pkcbw=0;
    int usbid=0;
    
    #if USB_HS_SAVE_RESULT
    FILE *fsave=0;
    char *pImage=0;
    static char ptfileSave[] = "/mnt/mmc2/usb/image_RX_%.3d.jpg";
    char ptfilepath[128];
    #endif
    
    char cmdMtx[24][2] = {{'m', 0x01},{'d', 0x02},{'a', 0x03},{'s', 0x02},{'p', 0x03},
    					    {'q', 0x02},{'r', 0x04},{'g', 0x05},{'e', 0x06},{'f', 0x07},
    					    {'b', 0x08},{'h', 0x07}, {'c', 0x02}, {'k', 0x04}, {'o', 0x07},
    					    {'i', 0x09}, {'w', 0x10}, {'y', 0x11}, {'z', 0x12}, {'t', 0x13},
    					    {'v', 0x14}, {'j', 0x15}, {'u', 0x16}, {'0', 0x17}}; /* j l n */
    uint8_t cmdchr=0;
    struct shmem_s *pTx=0;
    char *pMta=0;
    int *pPtx=0, *pPrx=0;
    struct timespec utstart, utend;
    int tcnt=0, polcnt=0;
    int bitset=0, ix=0;
    char cswst=0, pllst=0, csworg=0;
    uint32_t *virtbl;
    char *chvaddr=0;
    struct usbhost_s *puhs=0;
    struct info16Bit_s *uubs=0;
    struct usbCBWopc_s *dcbwopc=0;
    struct usbCBWpram_s *dcbwpram=0;
    struct usbCBWfile_s *dcbwfile=0, *dcpyfile=0;
    char *cubsBuff=0, *dubsBuff=0, *dcswBuff=0, *erasBuff=0, *cbwcpy=0, *erendBuff=0, *rchbnBuff=0, *rchedBuff=0;
    char *actbuff=0;
    int pidvid[2];
    struct usbHostmem_s *puhsinfom[2], *puhsinfo=0, *puhsinfrd=0;
    uint32_t ut32=0, vt32=0, tagtaddr=0, erasaddr=0, actaddr=0, tgendaddr=0, erendaddr=0;
    int eraslen=0, erasoffset=0, actlen=0, txlen=0, erendoffset=0, fixlen=64, errcnt=0;
    int memfd=0;
    char *chvir=0;
    struct shmem_s *usbTx=0, *gateTx=0;
    uint32_t *tbl0=0, *phytbl=0;
    char **ppt=0;
     

    uubs = &rs->pmch->ubs;
    dubsBuff = &rs->pmch->mshmem[32];
    cubsBuff = rs->pmch->mshmem;
    dcswBuff = dubsBuff + 1024;
    dcbwopc = (struct usbCBWopc_s *)cubsBuff;
    dcbwpram = (struct usbCBWpram_s *)cubsBuff;
    dcbwfile = (struct usbCBWfile_s *)cubsBuff;
    
    erasBuff = dcswBuff + 16;
    erendBuff = erasBuff + 4096;
    rchbnBuff = erendBuff + 4096;
    rchedBuff = rchbnBuff + 4096;
    cbwcpy = rchedBuff + 4096;
    
    dcpyfile = (struct usbCBWfile_s *)cbwcpy;

    sprintf_f(rs->logs, "enter usbhostd \n");
    print_f(rs->plogs, sp, rs->logs);

#if 1
    puhsinfom[0] = rs->pusbmh[0];
    if (!puhsinfom[0]) {
        sprintf_f(rs->logs, "Error!!! usb host 0 info not available !!! \n");
        print_f(rs->plogs, sp, rs->logs);
        goto end;
    }

    puhsinfom[1] = rs->pusbmh[1];
    if (!puhsinfom[1]) {
        sprintf_f(rs->logs, "Error!!! usb host 1 info not available !!! \n");
        print_f(rs->plogs, sp, rs->logs);
        goto end;
    }
    
    puhs = rs->pusbhost;
    if (!puhs) {
        sprintf_f(rs->logs, "Error!!! usb host not available !!! \n");
        print_f(rs->plogs, sp, rs->logs);
        goto end;
    }

    #if SMP_EN
    virtbl = malloc(RING_BUFF_NUM_USB * sizeof(int));
    if (!virtbl) {
        sprintf_f(rs->logs, "allocate memory for virtual mem table failed!!! size: %d \n", RING_BUFF_NUM_USB * sizeof(int));
        print_f(rs->plogs, sp, rs->logs);
    }

    memset(virtbl, 0, RING_BUFF_NUM_USB * sizeof(int));
    #endif

    pkcbw = malloc(192);
    if (!pkcbw) {
        sprintf_f(rs->logs, "allocate memory for kernel cbw failed!!! \n");
        print_f(rs->plogs, sp, rs->logs);
    }

    pTx = puhs->pgatring;

    gateTx = puhs->pgatring;
    usbTx = puhs->pushring;
    
    pMta = puhs->puhsmeta;
    pPtx = puhs->pgattx;
    pPrx = puhs->pgatrx;

    idx = puhs->ushid;
    if (idx > 1) {
        sprintf_f(rs->logs, "Error!!! usb idx == %d not match \n", idx);
        print_f(rs->plogs, sp, rs->logs);
        goto end;
    }

    puhsinfo = puhsinfom[idx];
    puhsinfrd = puhsinfom[((idx+1) % 2)];
        
    usbid = puhsinfo->ushostid;

    sprintf_f(rs->logs, "USB device[%s] usbid: %d \n", puhsinfo->ushostname, usbid); 
    print_f(rs->plogs, sp, rs->logs);

    if (usbid) {
        pidvid[0] = 0;
        pidvid[1] = 0;
        ret = USB_IOCT_GET_VID_PID(usbid, pidvid);
        if (ret < 0) {
            perror("usb get vid pid");
            sprintf_f(rs->logs, "get pid vid failed ret: %d, errno: %d expect vid: 0x%x pid: 0x%x\n", ret, errno, puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1]);
            print_f(rs->plogs, sp, rs->logs);

            #if 0
            ptret = RING_BUFF_NUM_USB;
            err = USB_IOCT_LOOP_BUFF_RELEASE(usbid, &ptret);
            sprintf_f(rs->logs, "release usb buffer errno:%d ret: %d \n", errno, err);
            print_f(rs->plogs, sp, rs->logs);
            #endif

            err = close(usbid);
            usbid = 0;
            
            sprintf_f(rs->logs, "close usb errno:%d ret: %d \n", errno, err);
            print_f(rs->plogs, sp, rs->logs);

            usbid = open(puhsinfo->ushostname, O_RDWR);

            if (usbid <= 0) {
                sprintf_f(rs->logs, "can't open device[%s]\n", puhsinfo->ushostname); 
                print_f(rs->plogs, sp, rs->logs);

                usbid = 0;
                
                //goto end;
            } else {

                sprintf_f(rs->logs, "open device[%s] usbid: %d \n", puhsinfo->ushostname, usbid); 
                print_f(rs->plogs, sp, rs->logs);

                pidvid[0] = 0;
                pidvid[1] = 0;
                ret = USB_IOCT_GET_VID_PID(usbid, pidvid);
                if (ret < 0) {
                    sprintf_f(rs->logs,  "can't get vid pid for [%s]\n", puhsinfo->ushostname); 
                    print_f(rs->plogs, sp, rs->logs);
                    close(usbid);
                    usbid = 0;
                    
                    //goto end;
                }

                if (((pidvid[0] != 0) && (pidvid[0] != puhsinfo->ushostpidvid[0])) || 
                    ((pidvid[1] != 0) && (pidvid[1] != puhsinfo->ushostpidvid[1]))) {
                    sprintf_f(rs->logs,  "vid pid for [%s] not match vid: 0x%.4x pid: 0x%.4x expect 0x%.4x 0x%.4x\n", 
                                                   puhsinfo->ushostname, pidvid[0], pidvid[1], puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1]); 
                    print_f(rs->plogs, sp, rs->logs);

                    close(usbid);
                    usbid = 0;

                    usbid = open(puhsinfo->ushostname, O_RDWR);

                    if (usbid <= 0) {
                        sprintf_f(rs->logs, "can't open device[%s]\n", puhsinfo->ushostname); 
                        print_f(rs->plogs, sp, rs->logs);

                        usbid = 0;
                        
                        //goto end;
                    } else {

                        sprintf_f(rs->logs, "open device[%s] usbid: %d - 2\n", puhsinfo->ushostname, usbid); 
                        print_f(rs->plogs, sp, rs->logs);

                        pidvid[0] = 0;
                        pidvid[1] = 0;
                        ret = USB_IOCT_GET_VID_PID(usbid, pidvid);
                        if (ret < 0) {
                            sprintf_f(rs->logs,  "can't get vid pid for [%s]\n", puhsinfo->ushostname); 
                            print_f(rs->plogs, sp, rs->logs);
                            close(usbid);
                            usbid = 0;
                            //goto end;
                        }

                        if ((pidvid[0] != 0) && (pidvid[1] != 0)) {
                            sprintf_f(rs->logs,  "vid pid for [%s] new vid: 0x%.4x pid: 0x%.4x old 0x%.4x 0x%.4x - 2\n", 
                                                           puhsinfo->ushostname, pidvid[0], pidvid[1], puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1]); 
                            print_f(rs->plogs, sp, rs->logs);

                            puhsinfo->ushostpidvid[0] = pidvid[0];
                            puhsinfo->ushostpidvid[1] = pidvid[1];

                            sprintf(rs->logs, "__USB_DEV_ VIDPID_[0x%.4x][0x%.4x][%s][%s]__", pidvid[0], pidvid[1], sp, puhsinfo->ushostname); 
                            dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);

                            if (puhsinfo->ushostpidvid[1] == 0x0a01) {
                                fixlen = 64;
                            } else {
                                fixlen = 512;
                            }
                        } else {
                            sprintf_f(rs->logs,  "vid pid for [%s] unknown vid: 0x%.4x pid: 0x%.4x old 0x%.4x 0x%.4x - 2\n", 
                                                           puhsinfo->ushostname, pidvid[0], pidvid[1], puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1]); 
                            print_f(rs->plogs, sp, rs->logs);
                            close(usbid);
                            usbid = 0;
                        }
                    }
                }
                else {
                    sprintf_f(rs->logs,  "vid pid for [%s] match vid: 0x%.4x pid: 0x%.4x (0x%.4x 0x%.4x) \n", 
                                                           puhsinfo->ushostname, pidvid[0], pidvid[1], puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1]); 
                    print_f(rs->plogs, sp, rs->logs);

                    sprintf(rs->logs, "__USB_DEV_ VIDPID_[0x%.4x][0x%.4x][%s][%s]__", pidvid[0], pidvid[1], sp, puhsinfo->ushostname); 
                    dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);

                    if (puhsinfo->ushostpidvid[1] == 0x0a01) {
                        fixlen = 64;
                    } else {
                        fixlen = 512;
                    }
                }
                
                #if 0
                memfd = open(MODULE_NAME , O_RDWR);
                if(memfd < 0) {
                    perror("/dev/mem open failed");
                    close(usbid);
                    goto end;
                } else {
                    sprintf_f(rs->logs,  "open [%s] succeed!!!! \n", MODULE_NAME);
                    print_f(rs->plogs, sp, rs->logs);
                } 
                #endif

                #if 1
                bitset = RING_BUFF_NUM_USB;
                
                if (puhsinfo->ushostid)
                ret = USB_IOCT_LOOP_BUFF_PRESET(usbid, &bitset);
                if (ret < 0) {
                    sprintf_f(rs->logs,  "can't pre-set buff failed, size: %d [%s]\n", RING_BUFF_NUM_USB, puhsinfo->ushostname); 
                    print_f(rs->plogs, sp, rs->logs);
                    close(usbid);
                    usbid = 0;
                    //goto end;
                }
                #else
                bitset = RING_BUFF_NUM_USB;
                ret = USB_IOCT_LOOP_BUFF_CREATE(usbid, &bitset);
                if (ret < 0) {
                    sprintf_f(rs->logs,  "can't create buff failed, size: %d [%s]\n", RING_BUFF_NUM_USB, puhsinfo->ushostname); 
                    print_f(rs->plogs, sp, rs->logs);
                    close(usbid);
                    goto end;
                }
                #endif
                
                if (puhsinfo->ushostid)
                if ((!puhsinfo->ushostblvir) || (!puhsinfo->ushostblphy)) {
                    sprintf_f(rs->logs,  "no vir table and phy table \n"); 
                    print_f(rs->plogs, sp, rs->logs);
                    close(usbid);
                    usbid = 0;
                    //goto end;
                }

                #if 1
                if (puhsinfo->ushostid)
                ret = USB_IOCT_LOOP_BUFF_SET(usbid, puhsinfo->ushostblphy);
                if (ret < 0) {
                    sprintf_f(rs->logs,  "can't set phy addr, size: %d [%s]\n", RING_BUFF_NUM_USB, puhsinfo->ushostname); 
                    print_f(rs->plogs, sp, rs->logs);
                    close(usbid);
                    usbid = 0;
                    //goto end;
                }

                #if SMP_EN
                memfd = open(MODULE_NAME , O_RDWR);
                if(memfd < 0) {
                    perror("/dev/mem open failed");
                    //close(usbid);
                    //goto end;
                } else {
                    sprintf_f(rs->logs,  "open [%s] succeed!!!! \n", MODULE_NAME);
                    print_f(rs->plogs, sp, rs->logs);
                }
                
                sprintf_f(rs->logs,  "[%s] table size: %d, addr0: (begin) \n", puhsinfo->ushostname, RING_BUFF_NUM_USB);
                print_f(rs->plogs, sp, rs->logs);
                for (ix=0; ix < RING_BUFF_NUM_USB; ix++) {
                    ut32 = puhsinfo->ushostblphy[ix];

                    #if 0//LOG_PHY_MEM
                    if ((ix % 4) == 0) {
                        sprintf_f(rs->logs,  "%d: ", ix);
                        print_f(rs->plogs, sp, rs->logs);
                    }
                    #endif

                    ret = phy2vir(&vt32, ut32, USB_BUF_SIZE, memfd);
                    if (ret < 0) {
                        sprintf_f(rs->logs,  "addr0 phy 2 vir error!!! ret: %d \n", ret);
                        print_f(rs->plogs, sp, rs->logs);
                        close(usbid);
                        goto end;
                    }

                    //puhsinfo->ushostblvir[ix] = vt32;
                    virtbl[ix] = vt32;
                    memset((char *)vt32, 0xaa, USB_BUF_SIZE);

                    #if 0//LOG_PHY_MEM
                    if ((ix % 4) == 3) {
                        sprintf_f(rs->logs,  "p:0x%.8x v:0x%.8x \n", ut32, vt32);
                        print_f(rs->plogs, sp, rs->logs);
                    } else {
                        sprintf_f(rs->logs,  "p:0x%.8x v:0x%.8x ", ut32, vt32);
                        print_f(rs->plogs, sp, rs->logs);
                    }        
                    #endif
                }

                close(memfd);
                #endif
                
                #else
                ret = USB_IOCT_LOOP_BUFF_PROBE(usbid, puhsinfo->ushostblphy);
                if (ret < 0) {
                    sprintf_f(rs->logs,  "can't probe phy addr, size: %d [%s]\n", RING_BUFF_NUM_USB, puhsinfo->ushostname); 
                    print_f(rs->plogs, sp, rs->logs);
                    close(usbid);
                    goto end;
                }
                
                sprintf_f(rs->logs,  "[%s] table size: %d, addr0: \n", puhsinfo->ushostname, RING_BUFF_NUM_USB);
                print_f(rs->plogs, sp, rs->logs);
                for (ix=0; ix < RING_BUFF_NUM_USB; ix++) {
                    ut32 = puhsinfo->ushostblphy[ix];

                    #if 0//LOG_PHY_MEM
                    if ((ix % 4) == 0) {
                        sprintf_f(rs->logs,  "%d: ", ix);
                        print_f(rs->plogs, sp, rs->logs);
                    }
                    #endif

                    ret = phy2vir(&vt32, ut32, USB_BUF_SIZE, memfd);
                    if (ret < 0) {
                        sprintf_f(rs->logs,  "addr0 phy 2 vir error!!! ret: %d \n", ret);
                        print_f(rs->plogs, sp, rs->logs);
                        close(usbid);
                        goto end;
                    }

                    puhsinfo->ushostblvir[ix] = vt32;

                    #if 0//LOG_PHY_MEM
                    if ((ix % 4) == 3) {
                        sprintf_f(rs->logs,  "p:0x%.8x v:0x%.8x \n", ut32, vt32);
                        print_f(rs->plogs, sp, rs->logs);
                    } else {
                        sprintf_f(rs->logs,  "p:0x%.8x v:0x%.8x ", ut32, vt32);
                        print_f(rs->plogs, sp, rs->logs);
                    }        
                    #endif
                }

                close(memfd);
                
                sprintf_f(rs->logs,  "\n test \n");
                print_f(rs->plogs, sp, rs->logs);

                for (ix=0; ix < RING_BUFF_NUM_USB; ix++) {
                    chvir = (char *) puhsinfo->ushostblvir[ix];

                    #if 0
                    printf(" %d: \n", ix);            
                    shmem_dump(chvir, 16);
                    #endif

                    if (chvir[0] != (ix & 0xff)) {
                        printf("[DVF] 0e: %d-0x%.2x ", ix, chvir[0]);            
                    }   
                }
                #endif
                
                sprintf_f(rs->logs,  "setup complete usbid: %d, get vid: 0x%x, pid: 0x%x [%s]\n", puhsinfo->ushostid, puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1], puhsinfo->ushostname);
                print_f(rs->plogs, sp, rs->logs);
            }

            #if 0
            tbl0 = puhsinfo->ushostblvir;
            
            if (usbTx->pp) {
                ppt = memory_init_vtable(usbTx->pp, RING_BUFF_NUM_USB * TABLE_SLOT_SIZE, TABLE_SLOT_SIZE, tbl0);
                if (ppt != usbTx->pp) {
                    sprintf_f(rs->logs,  "Error!!! memory_init_vtable failed ret: 0x%.8x should be 0x%.8x \n", ppt, usbTx->pp);
                    print_f(rs->plogs, sp, rs->logs);
                    close(usbid);
                    goto end;
                }
            }
            else {
                usbTx->pp = memory_init_vtable(usbTx->pp, RING_BUFF_NUM_USB * TABLE_SLOT_SIZE, TABLE_SLOT_SIZE, tbl0);  
            }

            if (!usbTx->pp) {
                close(usbid);
                goto end;
            }
            
            if (gateTx->pp) {
                ppt = memory_init_vtable(gateTx->pp, RING_BUFF_NUM_USB * TABLE_SLOT_SIZE, TABLE_SLOT_SIZE, tbl0);
                if (ppt != gateTx->pp) {
                    sprintf_f(rs->logs,  "Error!!! memory_init_vtable failed ret: 0x%.8x should be 0x%.8x \n", ppt, gateTx->pp);
                    print_f(rs->plogs, sp, rs->logs);
                    close(usbid);
                    goto end;
                }
            }
            else {
                gateTx->pp = memory_init_vtable(gateTx->pp, RING_BUFF_NUM_USB * TABLE_SLOT_SIZE, TABLE_SLOT_SIZE, tbl0);  
            }

            if (!gateTx->pp) {
                close(usbid);
                goto end;
            }
            #endif

        }
        
        sprintf_f(rs->logs, "usb host info [%s] vid: 0x%x pid: 0x%x!!! usbid: %d \n", puhsinfo->ushostname, puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1], usbid);
        print_f(rs->plogs, sp, rs->logs);

        
    }
    else {
        sprintf_f(rs->logs, "Error!!! device id not available !!! \n");
        print_f(rs->plogs, sp, rs->logs);
        //goto end;
    }

    sprintf_f(rs->logs, "get usbid:[%d]\n", usbid); 
    print_f(rs->plogs, sp, rs->logs);
    
    //usb_nonblock_set(usbid);

    while(1) {

        tcnt = 0;
        ptfd[0].fd = pPtx[0];
        ptfd[0].events = POLLIN;
        while(1) {
            tcnt++;
            ptret = poll(ptfd, 1, 100);

            #if DBG_USB_HS
            sprintf_f(rs->logs, "poll id:%d evt: 0x%.2x ret: %d - %d [0x%.2x 0x%.2x 0x%.8x]\n", ptfd[0].fd ,ptfd[0].revents, ptret, tcnt, uubs->opcode, uubs->data, uubs->opinfo);
            print_f(rs->plogs, sp, rs->logs);
            #endif
            
            if (ptret > 0) {
                //sleep(2);
                polcnt = 0;
                read(pPtx[0], &chr, 1);
                if (dlog) {
                    sprintf_f(rs->logs, "pipe%d get chr: %c(0x%.2x) \n", pPtx[0], chr, chr);
                    print_f(rs->plogs, sp, rs->logs);
                }
                break;
            }

            #if USB_ALIVE_POLLING 
            else {
                polcnt ++;
                if (polcnt % 12) {
                    continue;
                }
                
                if (!puhsinfo) {
                    sprintf_f(rs->logs, "Error!!! usbid: %d, puhsinfo == NULL \n", usbid); 
                    print_f(rs->plogs, sp, rs->logs);
                }

                #if 0
                sprintf_f(rs->logs, "USB device[%s] id: %d vid: 0x%.2x pid: 0x%.2x usbid: %d \n", puhsinfo->ushostname, 
                               puhsinfo->ushostid, puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1], usbid); 
                print_f(rs->plogs, sp, rs->logs);
                #endif

                if (!usbid) {
                    #if 1
                    sprintf_f(rs->logs, "open device[%s] id: %d  usbid: %d \n", puhsinfo->ushostname, puhsinfo->ushostid, usbid); 
                    print_f(rs->plogs, sp, rs->logs);

                    usbid = open(puhsinfo->ushostname, O_RDWR);
                    if (usbid <= 0) {
                        sprintf_f(rs->logs, "can't open device[%s]\n", puhsinfo->ushostname); 
                        print_f(rs->plogs, sp, rs->logs);
                        
                        usbid = 0;

                        continue;
                    } else {
                        sprintf_f(rs->logs, "open device[%s] usbid: %d \n", puhsinfo->ushostname, usbid); 
                        print_f(rs->plogs, sp, rs->logs);

                        pidvid[0] = 0;
                        pidvid[1] = 0;
                        ret = USB_IOCT_GET_VID_PID(usbid, pidvid);
                        if (ret < 0) {
                            sprintf_f(rs->logs,  "can't get vid pid for [%s]\n", puhsinfo->ushostname); 
                            print_f(rs->plogs, sp, rs->logs);
                            
                            close(usbid);
                            usbid = 0;
                            
                            continue;
                        }

                        sprintf_f(rs->logs, "poll usb alive vid: 0x%.2x pid: 0x%.2x (usbid:%d)\n", pidvid[0], pidvid[1], usbid);
                        print_f(rs->plogs, sp, rs->logs);
                        
                        puhsinfo->ushostpidvid[0] = pidvid[0];
                        puhsinfo->ushostpidvid[1] = pidvid[1];

                        sprintf(rs->logs, "__USB_DEV_ VIDPID_[0x%.4x][0x%.4x][%s][%s]__", pidvid[0], pidvid[1], sp, puhsinfo->ushostname); 
                        dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);

                        if (puhsinfo->ushostpidvid[1] == 0x0a01) {
                            fixlen = 64;
                        } else {
                            fixlen = 512;
                        }

                        ret = -1;
                    }
                    #endif
                }
                else {
                    ret = USB_IOCT_GET_VID_PID(usbid, pidvid);
                }
                
                if (ret < 0) {
                    perror("usb get vid pid");
                    sprintf_f(rs->logs, "get pid vid failed ret: %d, errno: %d expect vid: 0x%x pid: 0x%x\n", ret, errno, puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1]);
                    print_f(rs->plogs, sp, rs->logs);
                    
                    err = close(usbid);
                    usbid = 0;
                    
                    sprintf_f(rs->logs, "close usb errno:%d ret: %d \n", errno, err);
                    print_f(rs->plogs, sp, rs->logs);
                
                    usbid = open(puhsinfo->ushostname, O_RDWR);
                    
                    if (usbid <= 0) {
                        sprintf_f(rs->logs, "can't open device[%s]\n", puhsinfo->ushostname); 
                        print_f(rs->plogs, sp, rs->logs);

                        usbid = -1;

                        continue;
                    } else {
                    
                        sprintf_f(rs->logs, "open device[%s] usbid: %d \n", puhsinfo->ushostname, usbid); 
                        print_f(rs->plogs, sp, rs->logs);

                        pidvid[0] = 0;
                        pidvid[1] = 0;
                        ret = USB_IOCT_GET_VID_PID(usbid, pidvid);
                        if (ret < 0) {
                            sprintf_f(rs->logs,  "can't get vid pid for [%s]\n", puhsinfo->ushostname); 
                            print_f(rs->plogs, sp, rs->logs);
                            close(usbid);
                            usbid = -1;
                            
                            continue;
                        }
                    
                        if (((pidvid[0] != 0) && (pidvid[0] != puhsinfo->ushostpidvid[0])) || 
                            ((pidvid[1] != 0) && (pidvid[1] != puhsinfo->ushostpidvid[1]))) {
                            sprintf_f(rs->logs,  "vid pid for [%s] not match vid: 0x%.4x pid: 0x%.4x expect 0x%.4x 0x%.4x\n", 
                                                           puhsinfo->ushostname, pidvid[0], pidvid[1], puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1]); 
                            print_f(rs->plogs, sp, rs->logs);
                
                            close(usbid);
                            usbid = 0;
                            
                            chvir = puhsinfom[0]->ushostname;
                            puhsinfom[0]->ushostname = puhsinfom[1]->ushostname;
                            puhsinfom[1]->ushostname = chvir;
                            
                            usbid = open(puhsinfo->ushostname, O_RDWR);
                    
                            if (usbid <= 0) {
                                sprintf_f(rs->logs, "can't open device[%s]\n", puhsinfo->ushostname); 
                                print_f(rs->plogs, sp, rs->logs);

                                usbid = -1;
                                
                                continue;
                            } else {
                    
                                sprintf_f(rs->logs, "open device[%s] usbid: %d - 2\n", puhsinfo->ushostname, usbid); 
                                print_f(rs->plogs, sp, rs->logs);

                                pidvid[0] = 0;
                                pidvid[1] = 0;
                                ret = USB_IOCT_GET_VID_PID(usbid, pidvid);
                                if (ret < 0) {
                                    sprintf_f(rs->logs,  "can't get vid pid for [%s]\n", puhsinfo->ushostname); 
                                    print_f(rs->plogs, sp, rs->logs);
                                    close(usbid);
                                    usbid = -1;
                                    
                                    continue;
                                }
                    
                                if ((pidvid[0] == 0) || (pidvid[1] == 0)) {
                                    sprintf_f(rs->logs,  "vid pid for [%s] unknown vid: 0x%.4x pid: 0x%.4x expect 0x%.4x 0x%.4x - 2\n", 
                                                                   puhsinfo->ushostname, pidvid[0], pidvid[1], puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1]); 
                                    print_f(rs->plogs, sp, rs->logs);
                                    
                                    close(usbid);
                                    usbid = -1;
                                    
                                    continue;
                                }

                                puhsinfo->ushostpidvid[0] = pidvid[0];
                                puhsinfo->ushostpidvid[1] = pidvid[1];

                                sprintf(rs->logs, "__USB_DEV_ VIDPID_[0x%.4x][0x%.4x][%s][%s]__", pidvid[0], pidvid[1], sp, puhsinfo->ushostname); 
                                dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);

                                if (puhsinfo->ushostid) {
                                    puhsinfo->ushostid = usbid;
                                }

                                if (puhsinfo->ushostpidvid[1] == 0x0a01) {
                                    fixlen = 64;
                                } else {
                                    fixlen = 512;
                                }

                            }
                        }
                        else {
                            sprintf_f(rs->logs,  "vid pid for [%s] match vid: 0x%.4x pid: 0x%.4x (0x%.4x 0x%.4x) \n", 
                                                           puhsinfo->ushostname, pidvid[0], pidvid[1], puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1]); 
                            print_f(rs->plogs, sp, rs->logs);

                            sprintf(rs->logs, "__USB_DEV_ VIDPID_[0x%.4x][0x%.4x][%s][%s]__", pidvid[0], pidvid[1], sp, puhsinfo->ushostname); 
                            dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);
                        }
                
                        bitset = RING_BUFF_NUM_USB;
                        if (puhsinfo->ushostid)
                        ret = USB_IOCT_LOOP_BUFF_PRESET(usbid, &bitset);
                        if (ret < 0) {
                            sprintf_f(rs->logs,  "can't pre-set buff failed, size: %d [%s]\n", RING_BUFF_NUM_USB, puhsinfo->ushostname); 
                            print_f(rs->plogs, sp, rs->logs);
                            close(usbid);
                            usbid = -1;
                            continue;
                        }

                        if (puhsinfo->ushostid)
                        if ((!puhsinfo->ushostblvir) || (!puhsinfo->ushostblphy)) {
                            sprintf_f(rs->logs,  "no vir table and phy table \n"); 
                            print_f(rs->plogs, sp, rs->logs);
                            close(usbid);
                            usbid = -1;
                            continue;
                        }

                        if (puhsinfo->ushostid)
                        ret = USB_IOCT_LOOP_BUFF_SET(usbid, puhsinfo->ushostblphy);
                        if (ret < 0) {
                            sprintf_f(rs->logs,  "can't set phy addr, size: %d [%s]\n", RING_BUFF_NUM_USB, puhsinfo->ushostname); 
                            print_f(rs->plogs, sp, rs->logs);
                            close(usbid);
                            usbid = -1;
                            continue;
                        }

                        #if SMP_EN
                        memfd = open(MODULE_NAME , O_RDWR);
                        if(memfd < 0) {
                            perror("/dev/mem open failed");
                            //close(usbid);
                            //goto end;
                        } else {
                            sprintf_f(rs->logs,  "open [%s] succeed!!!! \n", MODULE_NAME);
                            print_f(rs->plogs, sp, rs->logs);
                        }
                        
                        sprintf_f(rs->logs,  "[%s] table size: %d, addr0: (recon) \n", puhsinfo->ushostname, RING_BUFF_NUM_USB);
                        print_f(rs->plogs, sp, rs->logs);
                        for (ix=0; ix < RING_BUFF_NUM_USB; ix++) {
                            ut32 = puhsinfo->ushostblphy[ix];
                        
                            #if 0//LOG_PHY_MEM
                            if ((ix % 4) == 0) {
                                sprintf_f(rs->logs,  "%d: ", ix);
                                print_f(rs->plogs, sp, rs->logs);
                            }
                            #endif
                        
                            ret = phy2vir(&vt32, ut32, USB_BUF_SIZE, memfd);
                            if (ret < 0) {
                                sprintf_f(rs->logs,  "addr0 phy 2 vir error!!! ret: %d \n", ret);
                                print_f(rs->plogs, sp, rs->logs);
                                close(usbid);
                                goto end;
                            }
                        
                            //puhsinfo->ushostblvir[ix] = vt32;
                            virtbl[ix] = vt32;
                            memset((char *)vt32, 0xaa, USB_BUF_SIZE);
                        
                            #if 0//LOG_PHY_MEM
                            if ((ix % 4) == 3) {
                                sprintf_f(rs->logs,  "p:0x%.8x v:0x%.8x \n", ut32, vt32);
                                print_f(rs->plogs, sp, rs->logs);
                            } else {
                                sprintf_f(rs->logs,  "p:0x%.8x v:0x%.8x ", ut32, vt32);
                                print_f(rs->plogs, sp, rs->logs);
                            }        
                            #endif
                        }
                        
                        close(memfd);
                        #endif
                
                        /*reconnect suceed here*/
                        sprintf_f(rs->logs,  "setup complete usbid: %d, get vid: 0x%x, pid: 0x%x [%s]\n", puhsinfo->ushostid, puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1], puhsinfo->ushostname);
                        print_f(rs->plogs, sp, rs->logs);

                        if ((puhsinfo->ushostpidvid[1] != 0x0a01) && (puhsinfo->ushostpidvid[1] != 0x0a02)) {
                            insert_cbw(CBW, CBW_CMD_SEND_OPCODE, 0x4e, 0x00);
                            ret = usb_send(CBW, usbid, 31);
                            if (ret < 0) {
                                sprintf_f(rs->logs, "send CBW for meta failed ret: %d !!!\n", ret);
                                print_f(rs->plogs, sp, rs->logs);
                                continue;
                            }
                        
                            shmem_dump(CBW, 31);
                        
                            ret = usb_read(ptrecv, usbid, 13);
                            if (ret < 0) {
                                sprintf_f(rs->logs, "read 13 byte for meta csw failed ret: %d !!!\n", ret);
                                print_f(rs->plogs, sp, rs->logs);
                                continue;
                            }

                            #if 1 //DBG_USB_HS            
                            sprintf_f(rs->logs, "dump 13 bytes");
                            print_f(rs->plogs, sp, rs->logs);
                            shmem_dump(ptrecv, 13);
                            #endif
                        } 
                        
                    }
                    
                }
                #if DBG_USB_HS
                else {
                    sprintf_f(rs->logs, "poll usb alive vid: 0x%.2x pid: 0x%.2x (usbid:%d)\n", puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1], usbid);
                    print_f(rs->plogs, sp, rs->logs);
                }
                #endif
            }
            #endif // #if USB_ALIVE_POLLING 
            
        }
        
        memset(ptrecv, 0, 32);

        #if DBG_USB_HS
        for (idx=0; idx < 5; idx++) {
            sprintf_f(rs->logs, "%d. %c - %d \n", idx, cmdMtx[idx][0], cmdMtx[idx][1]);
            print_f(rs->plogs, sp, rs->logs);
        }
        #endif
        
        cmdchr = 0;
        
        switch (chr) {
        case 'm':
            cmdchr = cmdMtx[0][1];
            break;
        /* simplex */
        case 'd':
            cmdchr = cmdMtx[1][1];
            break;
        case 'a':
            opc = OP_SINGLE;
            dat = OPSUB_USB_Scan;
            cmdchr = cmdMtx[2][1];
            break;
        /* duplex */
        case 's':
            cmdchr = cmdMtx[3][1];
            break;
        case 'p':
            opc = OP_DOUBLE;
            dat = OPSUB_USB_Scan;
            cmdchr = cmdMtx[4][1];
            break;
        /* multiple duplex */
        case 'q':
            cmdchr = cmdMtx[5][1];
            break;
        case 'r':
            //opc = OP_Multi_DUPLEX;
            //dat = OPSUB_USB_Scan;
            
            opc = dcbwopc->opcOpcode;
            dat = dcbwopc->opcSubOPCode;
            
            //sprintf_f(rs->logs, "(OP_Multi_DUPLEX) target opc: 0x%.2x 0x%.2x get cmd: 0x%.2x opc: 0x%.2x dat: 0x%.2x \n", opc, dat, dcbwopc->opcType, dcbwopc->opcOpcode, dcbwopc->opcSubOPCode);
            //print_f(rs->plogs, sp, rs->logs);
            
            cmdchr = cmdMtx[6][1];
            break;
        /* stop loop procedure */
        case 'g':
            cmdchr = cmdMtx[7][1];
            break;
        case 'e':
            cmdchr = cmdMtx[8][1];
            break;
        case 'f':
            cmdchr = cmdMtx[9][1];
            break;
        /* stop loop by host */
        case 'b':
            cmdchr = cmdMtx[10][1];
            break;
        case 'h':
            cmdchr = cmdMtx[11][1];
            break;
        /* multiple simplex */
        case 'c':
            cmdchr = cmdMtx[12][1];
            break;
        case 'k':
            //opc = OP_Multi_Single;
            //dat = OPSUB_USB_Scan;

            opc = dcbwopc->opcOpcode;
            dat = dcbwopc->opcSubOPCode;
            
            //sprintf_f(rs->logs, "(OP_Multi_Single) target opc: 0x%.2x 0x%.2x get cmd: 0x%.2x opc: 0x%.2x dat: 0x%.2x \n", opc, dat, dcbwopc->opcType, dcbwopc->opcOpcode, dcbwopc->opcSubOPCode);
            //print_f(rs->plogs, sp, rs->logs);

            cmdchr = cmdMtx[13][1];
            break;
        case 'o':
            cmdchr = cmdMtx[14][1];
            break;
        case 'i':
            cmdchr = cmdMtx[15][1];
            break;
        case 'w':
            cmdchr = cmdMtx[16][1];
            break;
        case 'y':
            cmdchr = cmdMtx[17][1];
            break;
        case 'z':
            cmdchr = cmdMtx[18][1];
            break;
        case 't':
            cmdchr = cmdMtx[19][1];
            break;
        case 'v':
            cmdchr = cmdMtx[20][1];
            break;
        case 'j':
            cmdchr = cmdMtx[21][1];

            #if 1
            //tagtaddr = msb2lsb32(&dcbwfile->pramAddress);
            
            ret = read(pPtx[0], cplls, 8);
            if (ret == 8) {
                eraslen = cplls[3];
                eraslen |= cplls[2] << 8;
                eraslen |= cplls[1] << 16;
                eraslen |= cplls[0] << 24;

                tagtaddr = cplls[4];
                tagtaddr |= cplls[5] << 8;
                tagtaddr |= cplls[6] << 16;
                tagtaddr |= cplls[7] << 24;
                
                sprintf_f(rs->logs, "get target address: 0x%.8x eraslen: %d \n", tagtaddr, eraslen);
                print_f(rs->plogs, sp, rs->logs);

            } else {
                sprintf_f(rs->logs, "get target eraslen failed ret: %d \n", ret);
                print_f(rs->plogs, sp, rs->logs);
            }
            #else
            ret = read(pPtx[0], cplls, 4);
            if (ret == 4) {
                tagtaddr = (cplls[0] << 24) & 0xff;
                tagtaddr |= (cplls[1] << 16) & 0xff;
                tagtaddr |= (cplls[2] << 8) & 0xff;
                tagtaddr |= (cplls[3] << 0) & 0xff;
                
                sprintf_f(rs->logs, "get target address: 0x%.8x \n", tagtaddr);
                print_f(rs->plogs, sp, rs->logs);
                
            } else {
                sprintf_f(rs->logs, "error!! get target address failed!! ret: %d \n", ret);
                print_f(rs->plogs, sp, rs->logs);
            }
            #endif
            
            break;
        case 'u':
            cmdchr = cmdMtx[22][1];
            break;
        case '0':
            cmdchr = cmdMtx[23][1];
            break;
        default:
            //goto end;
            sprintf_f(rs->logs, "default chr: 0x%.2x (%c) \n", chr, chr);
            print_f(rs->plogs, sp, rs->logs);

            break;
        }

        #if DBG_USB_HS
        sprintf_f(rs->logs, "cmdchr: 0x%.2x \n", cmdchr);
        print_f(rs->plogs, sp, rs->logs);
        #endif

        if (cmdchr == 0x01) {
            pmeta = &meta;
            ptm = (char *)pmeta;
            
            msync(pMta, USB_META_SIZE, MS_SYNC);
            memcpy(ptm, pMta, sizeof(struct aspMetaData_s));
            
            if (dlog) {
                sprintf_f(rs->logs, "get meta magic number: 0x%.2x, 0x%.2x !!!\n", meta.ASP_MAGIC[0], meta.ASP_MAGIC[1]);
                print_f(rs->plogs, sp, rs->logs);

                //dbgMeta(msb2lsb32(&meta.FUNC_BITS), &meta);
            }

            pllst = 0;

            ret = USB_IOCT_GET_VID_PID(usbid, pidvid);
            if (ret < 0) {
                perror("usb get vid pid");
                sprintf_f(rs->logs, "get pid vid failed ret: %d, errno: %d expect vid: 0x%x pid: 0x%x\n", ret, errno, puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1]);
                print_f(rs->plogs, sp, rs->logs);

                #if 0
                ptret = RING_BUFF_NUM_USB;
                err = USB_IOCT_LOOP_BUFF_RELEASE(usbid, &ptret);
                sprintf_f(rs->logs, "release usb buffer errno:%d ret: %d \n", errno, err);
                print_f(rs->plogs, sp, rs->logs);
                #endif
                
                err = close(usbid);
                usbid = 0;
                sprintf_f(rs->logs, "close usb errno:%d ret: %d \n", errno, err);
                print_f(rs->plogs, sp, rs->logs);

                usbid = open(puhsinfo->ushostname, O_RDWR);
                
                if (usbid <= 0) {
                    sprintf_f(rs->logs, "can't open device[%s]\n", puhsinfo->ushostname); 
                    print_f(rs->plogs, sp, rs->logs);
                    usbid = -1;

                    pllst = CSW_STATUS_USB_FAIL;
                    //continue;
                } else {
                
                    sprintf_f(rs->logs, "open device[%s] usbid: %d \n", puhsinfo->ushostname, usbid); 
                    print_f(rs->plogs, sp, rs->logs);
                
                    ret = USB_IOCT_GET_VID_PID(usbid, pidvid);
                    if (ret < 0) {
                        sprintf_f(rs->logs,  "can't get vid pid for [%s]\n", puhsinfo->ushostname); 
                        print_f(rs->plogs, sp, rs->logs);
                        close(usbid);
                        usbid = -1;
                        
                        pllst = CSW_STATUS_USB_FAIL;
                        //continue;
                    }
                
                    if ((pidvid[0] != puhsinfo->ushostpidvid[0]) || (pidvid[1] != puhsinfo->ushostpidvid[1])) {
                        sprintf_f(rs->logs,  "vid pid for [%s] not match vid: 0x%.4x pid: 0x%.4x expect 0x%.4x 0x%.4x\n", 
                                                       puhsinfo->ushostname, pidvid[0], pidvid[1], puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1]); 
                        print_f(rs->plogs, sp, rs->logs);

                        close(usbid);
                        usbid = -1;
                        
                        if (puhsinfo->ushostid == puhsinfom[0]->ushostid) {
                            chvir = puhsinfom[0]->ushostname;
                            puhsinfom[0]->ushostname = puhsinfom[1]->ushostname;
                            puhsinfom[1]->ushostname = chvir;
                        } else {
                            chvir = puhsinfom[1]->ushostname;
                            puhsinfom[1]->ushostname = puhsinfom[0]->ushostname;
                            puhsinfom[0]->ushostname = chvir;
                        }
                
                        usbid = open(puhsinfo->ushostname, O_RDWR);
                
                        if (usbid <= 0) {
                            sprintf_f(rs->logs, "can't open device[%s]\n", puhsinfo->ushostname); 
                            print_f(rs->plogs, sp, rs->logs);
                            usbid = -1;

                            pllst = CSW_STATUS_USB_FAIL;
                            //continue;
                        } else {
                
                            sprintf_f(rs->logs, "open device[%s] usbid: %d - 2\n", puhsinfo->ushostname, usbid); 
                            print_f(rs->plogs, sp, rs->logs);
                
                            ret = USB_IOCT_GET_VID_PID(usbid, pidvid);
                            if (ret < 0) {
                                sprintf_f(rs->logs,  "can't get vid pid for [%s]\n", puhsinfo->ushostname); 
                                print_f(rs->plogs, sp, rs->logs);
                                close(usbid);
                                usbid = -1;

                                pllst = CSW_STATUS_USB_FAIL;
                                //continue;
                            }
                
                            if ((pidvid[0] != puhsinfo->ushostpidvid[0]) || (pidvid[1] != puhsinfo->ushostpidvid[1])) {
                                sprintf_f(rs->logs,  "vid pid for [%s] not match vid: 0x%.4x pid: 0x%.4x expect 0x%.4x 0x%.4x - 2\n", 
                                                               puhsinfo->ushostname, pidvid[0], pidvid[1], puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1]); 
                                print_f(rs->plogs, sp, rs->logs);
                                
                                close(usbid);
                                usbid = -1;

                                pllst = CSW_STATUS_USB_FAIL;
                                //continue;
                            }
                        }
                    }

                    #if 0
                    memfd = open(MODULE_NAME , O_RDWR);
                    if(memfd < 0) {
                        perror("/dev/mem open failed");
                        close(usbid);
                        continue;
                    } else {
                        sprintf_f(rs->logs,  "open [%s] succeed!!!! \n", MODULE_NAME);
                        print_f(rs->plogs, sp, rs->logs);
                    } 
                    #endif

                    #if 1
                    bitset = RING_BUFF_NUM_USB;
                    ret = USB_IOCT_LOOP_BUFF_PRESET(usbid, &bitset);
                    if (ret < 0) {
                        sprintf_f(rs->logs,  "can't pre-set buff failed, size: %d [%s]\n", RING_BUFF_NUM_USB, puhsinfo->ushostname); 
                        print_f(rs->plogs, sp, rs->logs);
                        close(usbid);
                        usbid = -1;

                        pllst = CSW_STATUS_USB_FAIL;
                        //continue;
                    }
                    #else
                    bitset = RING_BUFF_NUM_USB;
                    ret = USB_IOCT_LOOP_BUFF_CREATE(usbid, &bitset);
                    if (ret < 0) {
                        sprintf_f(rs->logs,  "can't create buff failed, size: %d [%s]\n", RING_BUFF_NUM_USB, puhsinfo->ushostname); 
                        print_f(rs->plogs, sp, rs->logs);
                        close(usbid);
                        continue;
                    }
                    #endif
                
                    if ((!puhsinfo->ushostblvir) || (!puhsinfo->ushostblphy)) {
                        sprintf_f(rs->logs,  "no vir table and phy table \n"); 
                        print_f(rs->plogs, sp, rs->logs);
                        close(usbid);
                        usbid = -1;

                        pllst = CSW_STATUS_USB_FAIL;
                        //continue;
                    }
                    
                    #if 1
                    ret = USB_IOCT_LOOP_BUFF_SET(usbid, puhsinfo->ushostblphy);
                    if (ret < 0) {
                        sprintf_f(rs->logs,  "can't set phy addr, size: %d [%s]\n", RING_BUFF_NUM_USB, puhsinfo->ushostname); 
                        print_f(rs->plogs, sp, rs->logs);
                        close(usbid);
                        usbid = -1;

                        pllst = CSW_STATUS_USB_FAIL;
                        //continue;
                    }

                    #if SMP_EN
                    memfd = open(MODULE_NAME , O_RDWR);
                    if(memfd < 0) {
                        perror("/dev/mem open failed");
                        //close(usbid);
                        //goto end;
                    } else {
                        sprintf_f(rs->logs,  "open [%s] succeed!!!! \n", MODULE_NAME);
                        print_f(rs->plogs, sp, rs->logs);
                    }
                    
                    sprintf_f(rs->logs,  "[%s] table size: %d, addr0: (scan) \n", puhsinfo->ushostname, RING_BUFF_NUM_USB);
                    print_f(rs->plogs, sp, rs->logs);
                    for (ix=0; ix < RING_BUFF_NUM_USB; ix++) {
                        ut32 = puhsinfo->ushostblphy[ix];
                    
                        #if 0//LOG_PHY_MEM
                        if ((ix % 4) == 0) {
                            sprintf_f(rs->logs,  "%d: ", ix);
                            print_f(rs->plogs, sp, rs->logs);
                        }
                        #endif
                    
                        ret = phy2vir(&vt32, ut32, USB_BUF_SIZE, memfd);
                        if (ret < 0) {
                            sprintf_f(rs->logs,  "addr0 phy 2 vir error!!! ret: %d \n", ret);
                            print_f(rs->plogs, sp, rs->logs);
                            close(usbid);
                            goto end;
                        }
                    
                        //puhsinfo->ushostblvir[ix] = vt32;
                        virtbl[ix] = vt32;
                        memset((char *)vt32, 0xaa, USB_BUF_SIZE);
                    
                        #if 0//LOG_PHY_MEM
                        if ((ix % 4) == 3) {
                            sprintf_f(rs->logs,  "p:0x%.8x v:0x%.8x \n", ut32, vt32);
                            print_f(rs->plogs, sp, rs->logs);
                        } else {
                            sprintf_f(rs->logs,  "p:0x%.8x v:0x%.8x ", ut32, vt32);
                            print_f(rs->plogs, sp, rs->logs);
                        }        
                        #endif
                    }
                    
                    close(memfd);
                    #endif
                
                    #else
                    ret = USB_IOCT_LOOP_BUFF_PROBE(usbid, puhsinfo->ushostblphy);
                    if (ret < 0) {
                        sprintf_f(rs->logs,  "can't probe phy addr, size: %d [%s]\n", RING_BUFF_NUM_USB, puhsinfo->ushostname); 
                        print_f(rs->plogs, sp, rs->logs);
                        close(usbid);
                        continue;
                    }
                
                    sprintf_f(rs->logs,  "[%s] table size: %d, addr0: \n", puhsinfo->ushostname, RING_BUFF_NUM_USB);
                    print_f(rs->plogs, sp, rs->logs);
                    for (ix=0; ix < RING_BUFF_NUM_USB; ix++) {
                        ut32 = puhsinfo->ushostblphy[ix];
                
                        #if 0//LOG_PHY_MEM
                        if ((ix % 4) == 0) {
                            sprintf_f(rs->logs,  "%d: ", ix);
                            print_f(rs->plogs, sp, rs->logs);
                        }
                        #endif
                
                        ret = phy2vir(&vt32, ut32, USB_BUF_SIZE, memfd);
                        if (ret < 0) {
                            sprintf_f(rs->logs,  "addr0 phy 2 vir error!!! ret: %d \n", ret);
                            print_f(rs->plogs, sp, rs->logs);
                            close(usbid);
                            continue;
                        }
                
                        puhsinfo->ushostblvir[ix] = vt32;
                
                        #if 0//LOG_PHY_MEM
                        if ((ix % 4) == 3) {
                            sprintf_f(rs->logs,  "p:0x%.8x v:0x%.8x \n", ut32, vt32);
                            print_f(rs->plogs, sp, rs->logs);
                        } else {
                            sprintf_f(rs->logs,  "p:0x%.8x v:0x%.8x ", ut32, vt32);
                            print_f(rs->plogs, sp, rs->logs);
                        }        
                        #endif
                    }

                    close(memfd);
                    
                    sprintf_f(rs->logs,  "test ...\n");
                    print_f(rs->plogs, sp, rs->logs);
                
                    for (ix=0; ix < RING_BUFF_NUM_USB; ix++) {
                        chvir = (char *) puhsinfo->ushostblvir[ix];
                
                        #if 0
                        printf(" %d: \n", ix);            
                        shmem_dump(chvir, 16);
                        #endif
                
                        if (chvir[0] != (ix & 0xff)) {
                            printf("[DVF] 0e: %d-0x%.2x ", ix, chvir[0]);            
                        }   
                    }
                    #endif
                
                    sprintf_f(rs->logs,  "send meta setup complete usbid: %d, get vid: 0x%x, pid: 0x%x [%s]\n", puhsinfo->ushostid, puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1], puhsinfo->ushostname);
                    print_f(rs->plogs, sp, rs->logs);
                }

                #if 0
                tbl0 = puhsinfo->ushostblvir;
                
                if (usbTx->pp) {
                    ppt = memory_init_vtable(usbTx->pp, RING_BUFF_NUM_USB * TABLE_SLOT_SIZE, TABLE_SLOT_SIZE, tbl0);
                    if (ppt != usbTx->pp) {
                        sprintf_f(rs->logs,  "Error!!! memory_init_vtable failed ret: 0x%.8x should be 0x%.8x \n", ppt, usbTx->pp);
                        print_f(rs->plogs, sp, rs->logs);
                        close(usbid);
                        continue;
                    }
                }
                else {
                    usbTx->pp = memory_init_vtable(usbTx->pp, RING_BUFF_NUM_USB * TABLE_SLOT_SIZE, TABLE_SLOT_SIZE, tbl0);  
                }
                
                if (!usbTx->pp) {
                    close(usbid);
                    continue;
                }

                if (gateTx->pp) {
                    ppt = memory_init_vtable(gateTx->pp, RING_BUFF_NUM_USB * TABLE_SLOT_SIZE, TABLE_SLOT_SIZE, tbl0);
                    if (ppt != gateTx->pp) {
                        sprintf_f(rs->logs,  "Error!!! memory_init_vtable failed ret: 0x%.8x should be 0x%.8x \n", ppt, gateTx->pp);
                        print_f(rs->plogs, sp, rs->logs);
                        close(usbid);
                        continue;
                    }
                }
                else {
                    gateTx->pp = memory_init_vtable(gateTx->pp, RING_BUFF_NUM_USB * TABLE_SLOT_SIZE, TABLE_SLOT_SIZE, tbl0);  
                }
                
                if (!gateTx->pp) {
                    close(usbid);
                    continue;
                }
                #endif
                
            }
            
            #if 0 /* remove ready */    
            insert_cbw(CBW, CBW_CMD_READY, OP_Hand_Scan, OPSUB_USB_Scan);
            usb_send(CBW, usbid, 31);
            #endif

            if (usbid > 0) {

            sprintf(rs->logs, "__USB_DEV_ META_[%s][%s]__", sp, puhsinfo->ushostname); 
            dbgShowTimeStamp(rs->logs,  NULL, rs, 8, rs->logs);

            insert_cbw(CBW, CBW_CMD_SEND_OPCODE, OP_META, OP_META_Sub1);
            ret = usb_send(CBW, usbid, 31);
            if (ret < 0) {
                sprintf_f(rs->logs, "send CBW for meta failed ret: %d !!!\n", ret);
                print_f(rs->plogs, sp, rs->logs);

                pllst = CSW_STATUS_USB_FAIL;
            }
    
            ret = usb_send(ptm, usbid, USB_META_SIZE);
            if (ret < 0) {
                sprintf_f(rs->logs, "send 512 byte for meta failed ret: %d !!!\n", ret);
                print_f(rs->plogs, sp, rs->logs);

                pllst = CSW_STATUS_USB_FAIL;
            }

            //shmem_dump(ptm, USB_META_SIZE);
                
            ret = usb_read(ptrecv, usbid, 13);
            if (ret < 0) {
                sprintf_f(rs->logs, "read 13 byte for meta csw failed ret: %d !!!\n", ret);
                print_f(rs->plogs, sp, rs->logs);

                memset(ptrecv, 0, 13);
                memcpy(ptrecv, CBW, 8);                
                ptrecv[12] = CSW_STATUS_USB_FAIL;

                pllst = CSW_STATUS_USB_FAIL;
            }
            
            memcpy(dcswBuff, ptrecv, 13);
            
            #if DBG_USB_HS
            sprintf_f(rs->logs, "dump 13 bytes");
            print_f(rs->plogs, sp, rs->logs);
            shmem_dump(ptrecv, 13);
            #endif

            //chr = 'M';
            //pieRet = write(pPrx[1], &chr, 1);
            if (!pllst) {
                pllst = ptrecv[12];
            }
            
            }

            usbfolw = 0;
            
            puhs->pushcnt = 0;
            puhs->pushrmcnt = 0;
            puhs->pushcswerr = -1;

            buffstep = 0;
            
            //sprintf_f(rs->logs, "poll status: 0x%.2x \n", pllst); 
            //print_f(rs->plogs, sp, rs->logs);

            cplls[0] = 'J';
            cplls[1] = pllst;
            pieRet = write(pPrx[1], &cplls, 2);
        }
        else if (cmdchr == 0x17) {
            sprintf_f(rs->logs, "ENT reset to rom vid: 0x%.2x pid: 0x%.2x\n", puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1]);
            print_f(rs->plogs, sp, rs->logs);
            
            sprintf(rs->logs, "__USB_DEV_ ROM_RESET_[%s][%s]__", sp, puhsinfo->ushostname); 
            dbgShowTimeStamp(rs->logs,  NULL, rs, 8, rs->logs);

            usleep(1000000);

            if (usbid > 0) {
                close(usbid);
                usbid = 0;
            }
            
            errcnt = 0;
            while (usbid <= 0) {
                pllst = 0;
                usbid = open(puhsinfo->ushostname, O_RDWR);
                if (usbid <= 0) {
                    sprintf_f(rs->logs, "can't open device[%s]\n", puhsinfo->ushostname); 
                    print_f(rs->plogs, sp, rs->logs);
                        
                    pllst = CSW_STATUS_USB_FAIL;
                    usbid = 0;
                
                    //cplls[0] = 'J';
                    //cplls[1] = pllst;
                    //pieRet = write(pPrx[1], &cplls, 2);
                    usleep(500000);

                    #if 0
                    errcnt++;
                    if (errcnt > 6) {
                        chvir = puhsinfom[0]->ushostname;
                        puhsinfom[0]->ushostname = puhsinfom[1]->ushostname;
                        puhsinfom[1]->ushostname = chvir;
                    } 
                    #endif

                    #if 1
                    errcnt++;
                    if (errcnt > 6) {
                        //cplls[0] = 'J';
                        //cplls[1] = pllst;
                        //pieRet = write(pPrx[1], &cplls, 2);
                        break;
                    } 
                    #endif
                    
                    continue;
                }
                
                sprintf_f(rs->logs, "get usb vid: 0x%.2x pid: 0x%.2x\n", puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1]);
                print_f(rs->plogs, sp, rs->logs);
                
                pidvid[0] = 0;
                pidvid[1] = 0;
                
                ret = USB_IOCT_GET_VID_PID(usbid, pidvid);
                if (ret < 0) {
                    perror("usb get vid pid");
                    sprintf_f(rs->logs, " rom get pid vid failed ret: %d, errno: %d expect vid: 0x%x pid: 0x%x\n", ret, errno, puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1]);
                    print_f(rs->plogs, sp, rs->logs);
                    
                    err = close(usbid);
                    usbid = 0;
                    
                    sprintf_f(rs->logs, "rom close usb errno:%d ret: %d \n", errno, err);
                    print_f(rs->plogs, sp, rs->logs);
                
                    usbid = open(puhsinfo->ushostname, O_RDWR);
                    
                    if (usbid <= 0) {
                        sprintf_f(rs->logs, "can't open device[%s]\n", puhsinfo->ushostname); 
                        print_f(rs->plogs, sp, rs->logs);
                        
                        pllst = CSW_STATUS_USB_FAIL;
                        usbid = 0;
                        
                        //cplls[0] = 'J';
                        //cplls[1] = pllst;
                        //pieRet = write(pPrx[1], &cplls, 2);
                
                        continue;
                    } else {
                        sprintf_f(rs->logs, "open device[%s] usbid: %d \n", puhsinfo->ushostname, usbid); 
                        print_f(rs->plogs, sp, rs->logs);
                
                        pidvid[0] = 0;
                        pidvid[1] = 0;
                        ret = USB_IOCT_GET_VID_PID(usbid, pidvid);
                        if (ret < 0) {
                            sprintf_f(rs->logs,  "can't get vid pid for [%s]\n", puhsinfo->ushostname); 
                            print_f(rs->plogs, sp, rs->logs);
                            
                            close(usbid);
                            usbid = 0;
                            
                            pllst = CSW_STATUS_USB_FAIL;
                
                            //cplls[0] = 'J';
                            //cplls[1] = pllst;
                            //pieRet = write(pPrx[1], &cplls, 2);
                
                            continue;
                        }
                                            
                        if ((pidvid[0] != 0) && (pidvid[1] != 0)) {
                            sprintf_f(rs->logs,  "rom set vid pid for [%s] vid: 0x%.4x pid: 0x%.4x expect 0x%.4x 0x%.4x\n", 
                                                           puhsinfo->ushostname, pidvid[0], pidvid[1], puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1]); 
                            print_f(rs->plogs, sp, rs->logs);

                            sprintf(rs->logs, "__USB_DEV_ ROM_RESET_GETVIDPID[0x%.4x][0x%.4x][%s][%s]__", pidvid[0], pidvid[1], sp, puhsinfo->ushostname); 
                            dbgShowTimeStamp(rs->logs,  NULL, rs, 8, rs->logs);

                            puhsinfo->ushostpidvid[0] = pidvid[0];
                            puhsinfo->ushostpidvid[1] = pidvid[1];
                            if (puhsinfo->ushostid) {
                                puhsinfo->ushostid = usbid;
                            }
                
                            if (puhsinfo->ushostpidvid[1] == 0x0a01) {
                                fixlen = 64;
                            } else {
                                fixlen = 512;
                            }
                
                            if (pidvid[1] == 0x0a01) {
                                pllst = 0xa1;
                            } else {
                                pllst = pidvid[1] & 0xff;
                            }
                        }
                    }                
                }
                else {
                    if ((pidvid[0] != 0) && (pidvid[1] != 0)) {
                        sprintf_f(rs->logs,  "rom set vid pid for [%s] vid: 0x%.4x pid: 0x%.4x expect 0x%.4x 0x%.4x - 2\n", 
                                                           puhsinfo->ushostname, pidvid[0], pidvid[1], puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1]); 
                        print_f(rs->plogs, sp, rs->logs);

                        sprintf(rs->logs, "__USB_DEV_ ROM_RESET_GETVIDPID[0x%.4x][0x%.4x][%s][%s]__", pidvid[0], pidvid[1], sp, puhsinfo->ushostname); 
                        dbgShowTimeStamp(rs->logs,  NULL, rs, 8, rs->logs);
                        
                        puhsinfo->ushostpidvid[0] = pidvid[0];
                        puhsinfo->ushostpidvid[1] = pidvid[1];
                        if (puhsinfo->ushostid) {
                            puhsinfo->ushostid = usbid;
                        }
                
                        if (puhsinfo->ushostpidvid[1] == 0x0a01) {
                            fixlen = 64;
                        } else {
                            fixlen = 512;
                        }
                
                        if (pidvid[1] == 0x0a01) {
                            pllst = 0xa1;
                        }
                        else {
                            pllst = pidvid[1] & 0xff;
                        }
                    }         
                    else {
                        err = close(usbid);
                        usbid = 0;
                    }
                }
            }
            
            if (pllst == 0xa1) {
                sprintf_f(rs->logs,  "END reset to rom usbid: %d, get vid: 0x%x, pid: 0x%x [%s]\n", puhsinfo->ushostid, puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1], puhsinfo->ushostname);
                print_f(rs->plogs, sp, rs->logs);
            } else {
                sprintf_f(rs->logs,  "END reset to ram pllst: 0x%.2x usbid: %d, get vid: 0x%x, pid: 0x%x [%s]\n", pllst, puhsinfo->ushostid, puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1], puhsinfo->ushostname);
                print_f(rs->plogs, sp, rs->logs);
            }

            if (puhsinfo->ushostid) {
                bitset = RING_BUFF_NUM_USB;
                ret = USB_IOCT_LOOP_BUFF_PRESET(usbid, &bitset);
                if (ret < 0) {
                    sprintf_f(rs->logs,  "can't pre-set buff failed, size: %d [%s]\n", RING_BUFF_NUM_USB, puhsinfo->ushostname); 
                    print_f(rs->plogs, sp, rs->logs);
                    close(usbid);
                    usbid = 0;
                
                    pllst = CSW_STATUS_USB_FAIL;
            
                    //cplls[0] = 'J';
                    //cplls[1] = pllst;
                    //pieRet = write(pPrx[1], &cplls, 2);
            
                    //continue;
                }
            
                if ((!puhsinfo->ushostblvir) || (!puhsinfo->ushostblphy)) {
                    sprintf_f(rs->logs,  "no vir table and phy table \n"); 
                    print_f(rs->plogs, sp, rs->logs);
                    close(usbid);
                    usbid = 0;
                
                    pllst = CSW_STATUS_USB_FAIL;
                    
                    //cplls[0] = 'J';
                    //cplls[1] = pllst;
                    //pieRet = write(pPrx[1], &cplls, 2);
            
                    //continue;
                }
            
                ret = USB_IOCT_LOOP_BUFF_SET(usbid, puhsinfo->ushostblphy);
                if (ret < 0) {
                    sprintf_f(rs->logs,  "can't set phy addr, size: %d [%s]\n", RING_BUFF_NUM_USB, puhsinfo->ushostname); 
                    print_f(rs->plogs, sp, rs->logs);
                    close(usbid);
                    usbid = 0;
                
                    pllst = CSW_STATUS_USB_FAIL;
                    
                    //cplls[0] = 'J';
                    //cplls[1] = pllst;
                    //pieRet = write(pPrx[1], &cplls, 2);
            
                    //continue;
                }  

                #if SMP_EN
                memfd = open(MODULE_NAME , O_RDWR);
                if(memfd < 0) {
                    perror("/dev/mem open failed");
                    //close(usbid);
                    //goto end;
                } else {
                    sprintf_f(rs->logs,  "open [%s] succeed!!!! \n", MODULE_NAME);
                    print_f(rs->plogs, sp, rs->logs);
                }
                
                sprintf_f(rs->logs,  "[%s] table size: %d, addr0: (reset) \n", puhsinfo->ushostname, RING_BUFF_NUM_USB);
                print_f(rs->plogs, sp, rs->logs);
                for (ix=0; ix < RING_BUFF_NUM_USB; ix++) {
                    ut32 = puhsinfo->ushostblphy[ix];

                    #if 0//LOG_PHY_MEM
                    if ((ix % 4) == 0) {
                        sprintf_f(rs->logs,  "%d: ", ix);
                        print_f(rs->plogs, sp, rs->logs);
                    }
                    #endif

                    ret = phy2vir(&vt32, ut32, USB_BUF_SIZE, memfd);
                    if (ret < 0) {
                        sprintf_f(rs->logs,  "addr0 phy 2 vir error!!! ret: %d \n", ret);
                        print_f(rs->plogs, sp, rs->logs);
                        close(usbid);
                        goto end;
                    }

                    //puhsinfo->ushostblvir[ix] = vt32;
                    virtbl[ix] = vt32;
                    memset((char *)vt32, 0xaa, USB_BUF_SIZE);

                    #if 0//LOG_PHY_MEM
                    if ((ix % 4) == 3) {
                        sprintf_f(rs->logs,  "p:0x%.8x v:0x%.8x \n", ut32, vt32);
                        print_f(rs->plogs, sp, rs->logs);
                    } else {
                        sprintf_f(rs->logs,  "p:0x%.8x v:0x%.8x ", ut32, vt32);
                        print_f(rs->plogs, sp, rs->logs);
                    }        
                    #endif
                }

                close(memfd);
                #endif
            }
            
            memset(ptrecv, 0x0, 13);
            memcpy(ptrecv, cubsBuff, 8);
            ptrecv[12] = pllst;
            
            cplls[0] = 'J';
            cplls[1] = pllst;
            pieRet = write(pPrx[1], &cplls, 2);
        
        }
        else if (cmdchr == 0x16) {

            if (erasoffset) {
            
                lsb2Msb32(&dcpyfile->pramID, msb2lsb32(&dcbwfile->pramID));
                lsb2Msb32(&dcpyfile->pramTag, msb2lsb32(&dcbwfile->pramTag));
                dcpyfile->pramDirect = 1;
                dcpyfile->pramType = 1;
                
                actlen = erasoffset;
                if (actlen % 64) {
                    len = actlen % 64;
                    actlen -= len;
                }

                actaddr = erasaddr;
                actbuff = erasBuff;

                while (actlen) {

                    if (actlen < fixlen) {
                        sprintf_f(rs->logs, "warnning!! actlen is not muplex of %d (%d) \n", fixlen, actlen);
                        print_f(rs->plogs, sp, rs->logs);
                        
                        txlen = actlen;
                        if (txlen < 64) {
                            txlen = 64;
                        }
                        actlen = 0;
                    } else {
                        txlen = fixlen;
                        actlen -= txlen;                    
                    }


                    lsb2Msb32(&dcpyfile->pramAddress, actaddr);
                    lsb2Msb32(&dcpyfile->pramDataLength, txlen);                          

                    msync(cbwcpy, 32, MS_SYNC);

                    #if DBG_USB_HS
                    sprintf_f(rs->logs, "dump 31 bytes");
                    print_f(rs->plogs, sp, rs->logs);
                    shmem_dump(cbwcpy, 31);
                    #endif

                    usb_send(cbwcpy, usbid, 31);

                    //shmem_dump(actbuff, txlen);
                    
                    usb_send(actbuff, usbid, txlen);
                    
                    #if DUMP_FLASH
                    shmem_dump(actbuff, txlen);
                    #endif

                    ptret = usb_read(ptrecv, usbid, 13);
                    if (ptret > 0) {
                        memcpy(dcswBuff, ptrecv, 13);

                        #if DBG_USB_HS
                        sprintf_f(rs->logs, "dump 13 bytes");
                        print_f(rs->plogs, sp, rs->logs);
                        shmem_dump(ptrecv, 13);
                        #endif
            
                        pllst = ptrecv[12];
                    
                        if (pllst) break;
                
                        #if DBG_USB_HS
                        sprintf_f(rs->logs, "0x16 poll status: 0x%.2x \n", pllst); 
                        print_f(rs->plogs, sp, rs->logs);
                        #endif
                    } else {
                        sprintf_f(rs->logs, "0x16 read 13 bytes failed, ret: %d\n", ptret); 
                        print_f(rs->plogs, sp, rs->logs);

                        memcpy(dcswBuff, cbwcpy, 8);      
                        dcswBuff[12] = CSW_STATUS_USB_FAIL;
                        pllst = dcswBuff[12];

                        break;
                    }
                    
                    actaddr += txlen;
                    actbuff += txlen;
                
                }
                
                if ((actlen) || (pllst)) {
                    sprintf_f(rs->logs, "error!!! 0x16 write failed size, pllst: %d eraslen: %d erasaddr: 0x%.8x\n", pllst, actlen, (uint32_t)actaddr); 
                    print_f(rs->plogs, sp, rs->logs);
                    
                    cplls[0] = 'U';
                    cplls[1] = pllst;
                    pieRet = write(pPrx[1], &cplls, 2);

                    eraslen = 0;
                }
                
            }

            actlen = eraslen;
            actaddr = tagtaddr;

            lsb2Msb32(&dcpyfile->pramID, msb2lsb32(&dcbwfile->pramID));
            lsb2Msb32(&dcpyfile->pramTag, msb2lsb32(&dcbwfile->pramTag));
            dcpyfile->pramDirect = 1;
            dcpyfile->pramType = 1;
            
            while (actlen) {                

                len = ring_buf_cons(rs->pcmdRx, &addr);
                while (len <= 0) {
                    sprintf_f(rs->logs, "PENDING 0x16 cons ring get len: %d \n", len);
                    print_f(rs->plogs, sp, rs->logs);

                    usleep(100000);
                    len = ring_buf_cons(rs->pcmdRx, &addr);
                }

                #if DUMP_FLASH
                sprintf_f(rs->logs, "0x16 cons ring get len: %d / %d \n", len, actlen);
                print_f(rs->plogs, sp, rs->logs);
                #endif

                if (len < SPI_TRUNK_SZ) {
                    len = actlen;
                    actlen = 0;
                } else {
                    if (actlen >= len) {
                        actlen -= len;
                    } else {
                        sprintf_f(rs->logs, "WARNNING !! 0x16 last len not match %d / %d \n", len, actlen);
                        print_f(rs->plogs, sp, rs->logs);

                        len = actlen;
                        actlen = 0;
                    }
                }

                while (len) {

                    if (len < fixlen) {
                        txlen = len;
                        if (txlen < 64) {
                            txlen = 64;
                        }
                        len = 0;
                    } else {
                        txlen = fixlen;
                        len -= txlen;
                    }

                    lsb2Msb32(&dcpyfile->pramAddress, actaddr);
                    lsb2Msb32(&dcpyfile->pramDataLength, txlen);
                    
                    msync(cbwcpy, 32, MS_SYNC);
                
                    #if DBG_USB_HS
                    sprintf_f(rs->logs, "dump 31 bytes");
                    print_f(rs->plogs, sp, rs->logs);
                    shmem_dump(cbwcpy, 31);
                    #endif
            
                    usb_send(cbwcpy, usbid, 31);

                    usb_send(addr, usbid, txlen);
                    
                    #if DUMP_FLASH
                    sprintf_f(rs->logs, "dump memory %d bytes", txlen);
                    print_f(rs->plogs, sp, rs->logs);
                    shmem_dump(addr, txlen);
                    #endif

                    ptret = usb_read(ptrecv, usbid, 13);
            
                    if (ptret > 0) {
                        memcpy(dcswBuff, ptrecv, 13);

                        #if DBG_USB_HS
                        sprintf_f(rs->logs, "dump 13 bytes");
                        print_f(rs->plogs, sp, rs->logs);
                        shmem_dump(ptrecv, 13);
                        #endif
            
                        pllst = ptrecv[12];
                    
                        if (pllst) break;
                
                        #if DBG_USB_HS
                        sprintf_f(rs->logs, "0x16 poll status: 0x%.2x \n", pllst); 
                        print_f(rs->plogs, sp, rs->logs);
                        #endif
                    } else {
                        sprintf_f(rs->logs, "0x16 read 13 bytes failed, ret: %d\n", ptret); 
                        print_f(rs->plogs, sp, rs->logs);

                        memcpy(dcswBuff, cbwcpy, 8);      
                        dcswBuff[12] = CSW_STATUS_USB_FAIL;
                        pllst = dcswBuff[12];
                        
                        break;
                    }
            
                    actaddr += txlen;
                    addr += txlen;
                
                }

                if ((len) || (pllst)) {
                    sprintf_f(rs->logs, "error!!! 0x16 erase failed size, pllst: %d eraslen: %d erasaddr: 0x%.8x\n", pllst, actlen, (uint32_t)actaddr); 
                    print_f(rs->plogs, sp, rs->logs);
                    
                    cplls[0] = 'U';
                    cplls[1] = pllst;
                    pieRet = write(pPrx[1], &cplls, 2);

                    actlen = 0;
                    eraslen = 0;
                }

            }

            if ((eraslen) && (erendoffset)) {
            
                lsb2Msb32(&dcpyfile->pramID, msb2lsb32(&dcbwfile->pramID));
                lsb2Msb32(&dcpyfile->pramTag, msb2lsb32(&dcbwfile->pramTag));
                dcpyfile->pramDirect = 1;
                dcpyfile->pramType = 1;

                actlen = (0x1000 - erendoffset);
                if (actlen % 64) {
                    actlen = actlen % 64;
                    actlen = (0x1000 - erendoffset) - actlen;
                }
                
                actaddr = erendaddr - actlen;
                //actaddr = erendaddr - erendoffset;
                actbuff = erendBuff;

                while (actlen) {

                    if (actlen < fixlen) {
                        sprintf_f(rs->logs, "warnning!! end actlen is not muplex of %d (%d) \n", fixlen, actlen);
                        print_f(rs->plogs, sp, rs->logs);

                        txlen = actlen;
                        if (txlen < 64) {
                            txlen = 64;
                        }
                        actlen = 0;
                    } else {
                        txlen = fixlen;
                        actlen -= txlen;
                    }

                    
                    lsb2Msb32(&dcpyfile->pramAddress, actaddr);
                    lsb2Msb32(&dcpyfile->pramDataLength, txlen);                          

                    msync(cbwcpy, 32, MS_SYNC);

                    #if DBG_USB_HS
                    sprintf_f(rs->logs, "dump 31 bytes");
                    print_f(rs->plogs, sp, rs->logs);
                    shmem_dump(cbwcpy, 31);
                    #endif

                    usb_send(cbwcpy, usbid, 31);

                    //shmem_dump(actbuff, txlen);
                    
                    usb_send(actbuff, usbid, txlen);
                    
                    #if DUMP_FLASH
                    shmem_dump(actbuff, txlen);
                    #endif

                    ptret = usb_read(ptrecv, usbid, 13);
                    if (ptret > 0) {
                        memcpy(dcswBuff, ptrecv, 13);

                        #if DBG_USB_HS
                        sprintf_f(rs->logs, "dump 13 bytes");
                        print_f(rs->plogs, sp, rs->logs);
                        shmem_dump(ptrecv, 13);
                        #endif
            
                        pllst = ptrecv[12];
                    
                        if (pllst) break;
                
                        #if DBG_USB_HS
                        sprintf_f(rs->logs, "0x16 poll status: 0x%.2x \n", pllst); 
                        print_f(rs->plogs, sp, rs->logs);
                        #endif
                    } else {
                        sprintf_f(rs->logs, "0x16 read 13 bytes failed, ret: %d\n", ptret); 
                        print_f(rs->plogs, sp, rs->logs);

                        memcpy(dcswBuff, cbwcpy, 8);      
                        dcswBuff[12] = CSW_STATUS_USB_FAIL;
                        pllst = dcswBuff[12];

                        break;
                    }
                    
                    actaddr += txlen;
                    actbuff += txlen;
                
                }
                
                if ((actlen) || (pllst)) {
                    sprintf_f(rs->logs, "error!!! 0x16 write failed size, pllst: %d eraslen: %d erasaddr: 0x%.8x\n", pllst, actlen, (uint32_t)actaddr); 
                    print_f(rs->plogs, sp, rs->logs);
                    
                    cplls[0] = 'U';
                    cplls[1] = pllst;
                    pieRet = write(pPrx[1], &cplls, 2);

                    eraslen = 0;
                }
                
            }

            if (eraslen) {
                cplls[0] = 'U';
                cplls[1] = pllst;
                pieRet = write(pPrx[1], &cplls, 2);

                eraslen = 0;
            }
        }
        else if (cmdchr == 0x15) {
            pllst = 0;
            erasoffset = 0;
            erendoffset = 0;
            tgendaddr = tagtaddr + eraslen;            
            
            #if DUMP_FLASH
            sprintf_f(rs->logs, "tagtaddr: 0x%.8x eraslen: %d endaddr: 0x%.8x \n", tagtaddr, eraslen, (uint32_t)tgendaddr);
            print_f(rs->plogs, sp, rs->logs);
            #endif
            
            if ((tagtaddr) ||(tgendaddr)) {
                erasoffset = tagtaddr % 0x1000;
                erendoffset = tgendaddr % 0x1000;
                
                if (erasoffset) {
                    if (erasoffset % 64) {
                        sprintf_f(rs->logs, "warnning!! the erasoffset not multiplex of 64 %d \n", erasoffset);
                        print_f(rs->plogs, sp, rs->logs);
                    }
                    
                    erasaddr = tagtaddr - erasoffset;
                } else {
                    erasaddr = tagtaddr;
                }

                if (erendoffset) {
                    if (erendoffset % 64) {
                        sprintf_f(rs->logs, "warnning!! the erendoffset not multiplex of 64 %d \n", erendoffset);
                        print_f(rs->plogs, sp, rs->logs);
                    }

                    erendaddr = tgendaddr + (0x1000 - erendoffset);
                } else {
                    erendaddr = tgendaddr;
                }
            }
            
            #if DUMP_FLASH
            sprintf_f(rs->logs, "erasaddr: 0x%.8x erasoffset: %d \n", erasaddr, erasoffset);
            print_f(rs->plogs, sp, rs->logs);
            sprintf_f(rs->logs, "erendaddr: 0x%.8x erendoffset: %d \n", erendaddr, erendoffset);
            print_f(rs->plogs, sp, rs->logs);
            #endif

            memset(erasBuff, 0, 4096);
            memset(erendBuff, 0, 4096);
            memset(cbwcpy, 0, 32);

            #if DUMP_FLASH
            sprintf_f(rs->logs, "erasoffset: 0x%.8x  \n", erasoffset);
            print_f(rs->plogs, sp, rs->logs);
            #endif
            
            if (erasoffset) {

                lsb2Msb32(&dcpyfile->pramID, msb2lsb32(&dcbwfile->pramID));
                lsb2Msb32(&dcpyfile->pramTag, msb2lsb32(&dcbwfile->pramTag));
                lsb2Msb32(&dcpyfile->pramDataLength, 512);      
                dcpyfile->pramDirect = 2;
                //lsb2Msb32(&dcpyfile->pramAddress, erasaddr);

                actlen = erasoffset;
                if (actlen % 64) {
                    len = actlen % 64;
                    actlen -= len;
                }
                
                actaddr = erasaddr;
                actbuff = erasBuff;

                while (actlen) {
                    lsb2Msb32(&dcpyfile->pramAddress, actaddr);

                    msync(cbwcpy, 32, MS_SYNC);

                    if (actlen < fixlen) {
                        txlen = actlen;
                        if (txlen < 64) {
                            txlen = 64;
                        }
                        actlen = 0;

                    } else {
                        txlen = fixlen;
                        actlen -= txlen;
                    }

                    lsb2Msb32(&dcpyfile->pramDataLength, txlen);      
                    
                    #if DBG_USB_HS
                    sprintf_f(rs->logs, "dump 31 bytes");
                    print_f(rs->plogs, sp, rs->logs);
                    shmem_dump(cbwcpy, 31);
                    #endif

                    usb_send(cbwcpy, usbid, 31);
                    
                    //shmem_dump(actbuff, txlen);
                    
                    usb_read(actbuff, usbid, txlen);
                    
                    #if DUMP_FLASH
                    shmem_dump(actbuff, txlen);
                    #endif
                    
                    ptret = usb_read(ptrecv, usbid, 13);
                    if (ptret > 0) {
                        memcpy(dcswBuff, ptrecv, 13);

                        #if DBG_USB_HS
                        sprintf_f(rs->logs, "dump 13 bytes");
                        print_f(rs->plogs, sp, rs->logs);
                        shmem_dump(ptrecv, 13);
                        #endif
            
                        pllst = ptrecv[12];
                    
                        if (pllst) break;
                
                        #if DBG_USB_HS
                        sprintf_f(rs->logs, "0x15 poll status: 0x%.2x \n", pllst); 
                        print_f(rs->plogs, sp, rs->logs);
                        #endif
                    } else {
                        sprintf_f(rs->logs, "0x15 read 13 bytes failed, ret: %d\n", ptret); 
                        print_f(rs->plogs, sp, rs->logs);

                        memcpy(dcswBuff, cbwcpy, 8);      
                        dcswBuff[12] = CSW_STATUS_USB_FAIL;
                        pllst = dcswBuff[12];

                        break;
                    }
                    
                    actaddr += txlen;
                    actbuff += txlen;
                 
                }
                
                if ((actlen) || (pllst)) {
                    sprintf_f(rs->logs, "error!!! 0x15 READ B4 erase failed size, pllst: %d eraslen: %d erasaddr: 0x%.8x\n", pllst, actlen, (uint32_t)actaddr); 
                    print_f(rs->plogs, sp, rs->logs);
                    
                    cplls[0] = 'X';
                    cplls[1] = pllst;
                    pieRet = write(pPrx[1], &cplls, 2);

                    eraslen = 0;
                }
            }

            #if DUMP_FLASH
            sprintf_f(rs->logs, "eraslen, erendoffset: %d, 0x%.8x  \n", eraslen, erendoffset);
            print_f(rs->plogs, sp, rs->logs);
            #endif
            
            if ((eraslen) && (erendoffset)) {

                lsb2Msb32(&dcpyfile->pramID, msb2lsb32(&dcbwfile->pramID));
                lsb2Msb32(&dcpyfile->pramTag, msb2lsb32(&dcbwfile->pramTag));
                lsb2Msb32(&dcpyfile->pramDataLength, 512);      
                dcpyfile->pramDirect = 2;
                
                actlen = (0x1000 - erendoffset);
                if (actlen % 64) {
                    actlen = actlen % 64;
                    actlen = (0x1000 - erendoffset) - actlen;
                }

                actaddr = erendaddr - actlen;
                actbuff = erendBuff;

                while (actlen) {
                    lsb2Msb32(&dcpyfile->pramAddress, actaddr);

                    msync(cbwcpy, 32, MS_SYNC);

                    if (actlen < fixlen) {
                        txlen = actlen;
                        if (txlen < 64) {
                            txlen = 64;
                        }
                        actlen = 0;

                    } else {
                        txlen = fixlen;
                        actlen -= txlen;
                    }

                    lsb2Msb32(&dcpyfile->pramDataLength, txlen);      

                    #if DBG_USB_HS
                    sprintf_f(rs->logs, "dump 31 bytes");
                    print_f(rs->plogs, sp, rs->logs);
                    shmem_dump(cbwcpy, 31);
                    #endif

                    usb_send(cbwcpy, usbid, 31);

                    //shmem_dump(actbuff, txlen);
                    
                    usb_read(actbuff, usbid, txlen);

                    #if DUMP_FLASH
                    shmem_dump(actbuff, txlen);
                    #endif

                    ptret = usb_read(ptrecv, usbid, 13);
                    if (ptret > 0) {
                        memcpy(dcswBuff, ptrecv, 13);

                        #if DBG_USB_HS
                        sprintf_f(rs->logs, "dump 13 bytes");
                        print_f(rs->plogs, sp, rs->logs);
                        shmem_dump(ptrecv, 13);
                        #endif
            
                        pllst = ptrecv[12];
                    
                        if (pllst) break;
                
                        #if DBG_USB_HS
                        sprintf_f(rs->logs, "0x15 poll status: 0x%.2x \n", pllst); 
                        print_f(rs->plogs, sp, rs->logs);
                        #endif
                    } else {
                        sprintf_f(rs->logs, "0x15 read 13 bytes failed, ret: %d\n", ptret); 
                        print_f(rs->plogs, sp, rs->logs);

                        memcpy(dcswBuff, cbwcpy, 8);      
                        dcswBuff[12] = CSW_STATUS_USB_FAIL;
                        pllst = dcswBuff[12];

                        break;
                    }
                    
                    actaddr += txlen;
                    actbuff += txlen;
                
                }
                
                if ((actlen) || (pllst)) {
                    sprintf_f(rs->logs, "error!!! 0x15 READ B4 erase failed size, pllst: %d eraslen: %d erasaddr: 0x%.8x\n", pllst, actlen, (uint32_t)actaddr); 
                    print_f(rs->plogs, sp, rs->logs);
                    
                    cplls[0] = 'X';
                    cplls[1] = pllst;
                    pieRet = write(pPrx[1], &cplls, 2);

                    eraslen = 0;
                }
                
            }

            #if DUMP_FLASH
            sprintf_f(rs->logs, "eraslen %d  \n", eraslen);
            print_f(rs->plogs, sp, rs->logs);
            #endif
            
            if (eraslen) {
                //insert_filecbw(cbwcpy, dcbwfile);
                memset(cbwcpy, 0, 32);

                lsb2Msb32(&dcpyfile->pramID, msb2lsb32(&dcbwfile->pramID));
                lsb2Msb32(&dcpyfile->pramTag, msb2lsb32(&dcbwfile->pramTag));
                dcpyfile->pramType = 0x05;

                actlen = erendaddr - erasaddr;
                actaddr = erasaddr;

                while (actlen) {
                    lsb2Msb32(&dcpyfile->pramAddress, actaddr);

                    msync(cbwcpy, 32, MS_SYNC);
                    
                    if (actlen < 0x1000) {
                        sprintf_f(rs->logs, "warnning!!! actlen: %d != 0x1000 \n", actlen); 
                        print_f(rs->plogs, sp, rs->logs);

                        actlen = 0;
                    } else {
                        actlen -= 0x1000;
                    }
                    
                    #if DBG_USB_HS
                    sprintf_f(rs->logs, "dump 31 bytes");
                    print_f(rs->plogs, sp, rs->logs);
                    shmem_dump(cbwcpy, 31);
                    #endif
            
                    usb_send(cbwcpy, usbid, 31);

                    ptret = usb_read(ptrecv, usbid, 13);
            
                    if (ptret > 0) {
                        memcpy(dcswBuff, ptrecv, 13);

                        #if DBG_USB_HS
                        sprintf_f(rs->logs, "dump 13 bytes");
                        print_f(rs->plogs, sp, rs->logs);
                        shmem_dump(ptrecv, 13);
                        #endif
            
                        pllst = ptrecv[12];
                    
                        if (pllst) break;
                
                        #if DBG_USB_HS
                        sprintf_f(rs->logs, "0x15 poll status: 0x%.2x \n", pllst); 
                        print_f(rs->plogs, sp, rs->logs);
                        #endif
                    } else {
                        sprintf_f(rs->logs, "0x15 read 13 bytes failed, ret: %d\n", ptret); 
                        print_f(rs->plogs, sp, rs->logs);

                        memcpy(dcswBuff, cbwcpy, 8);      
                        dcswBuff[12] = CSW_STATUS_USB_FAIL;
                        pllst = dcswBuff[12];

                        break;
                    }
            
                    actaddr += 0x1000;
                }

                if ((actlen) || (pllst)) {
                    sprintf_f(rs->logs, "error!!! 0x15 erase failed size, pllst: %d eraslen: %d erasaddr: 0x%.8x\n", pllst, actlen, (uint32_t)actaddr); 
                    print_f(rs->plogs, sp, rs->logs);
                }

                cplls[0] = 'X';
                cplls[1] = pllst;
                pieRet = write(pPrx[1], &cplls, 2);
            }
        }
        else if (cmdchr == 0x09) { 
            pllst = 0;
            usbfolw = 0;
            
            if (uubs) {
                msync(uubs, sizeof(struct info16Bit_s), MS_SYNC);

                dat = uubs->opinfo & 0xff;
                opc = (uubs->opinfo >> 8) & 0xff;
                
                //sprintf_f(rs->logs, "opc: 0x%.2x dat: 0x%.2x \n",opc, dat);
                //print_f(rs->plogs, sp, rs->logs);

            } else {
                sprintf_f(rs->logs, "cur is null \n!!!");
                print_f(rs->plogs, sp, rs->logs);
            }
            
            //insert_cbw(CBW, CBW_CMD_SEND_OPCODE, opc, dat);
            //usb_send(CBW, usbid, 31);
            
            #if 1//DBG_USB_HS
            sprintf_f(rs->logs, "dump 31 bytes");
            print_f(rs->plogs, sp, rs->logs);
            shmem_dump(cubsBuff, 31);
            #endif

            msync(cubsBuff, SPI_TRUNK_SZ, MS_SYNC);
            usb_send(cubsBuff, usbid, 31);

                
            ptret = usb_read(ptrecv, usbid, 13);
            
            if (ptret > 0) {
                memcpy(dcswBuff, ptrecv, 13);

                #if 1//DBG_USB_HS
                sprintf_f(rs->logs, "dump 13 bytes");
                print_f(rs->plogs, sp, rs->logs);
                shmem_dump(ptrecv, 13);
                #endif
            
                pllst = ptrecv[12];
                
                #if DBG_USB_HS
                sprintf_f(rs->logs, "poll status: 0x%.2x \n", pllst); 
                print_f(rs->plogs, sp, rs->logs);
                #endif
            } else {
                sprintf_f(rs->logs, "read 13 bytes failed, ret: %d\n", ptret); 
                print_f(rs->plogs, sp, rs->logs);

                memcpy(dcswBuff, cubsBuff, 8);      
                dcswBuff[12] = CSW_STATUS_USB_FAIL;
                pllst = dcswBuff[12];
            }

            sprintf(rs->logs, "__USB_DEV_ CBW[0x%.2x][0x%.2x]CSW[0x%.2x][0x%.2x][%s][%s]__", cubsBuff[15], cubsBuff[16], ptrecv[11], ptrecv[12], sp, puhsinfo->ushostname); 
            dbgShowTimeStamp(rs->logs,  NULL, rs, 8, rs->logs);
            
            cplls[0] = 'J';
            cplls[1] = pllst;
            pieRet = write(pPrx[1], &cplls, 2);
        }
        else if (cmdchr == 0x08) {
            sprintf(rs->logs, "__USB_DEV_ STOPSCAN[%s][%s]__", sp, puhsinfo->ushostname); 
            dbgShowTimeStamp(rs->logs,  NULL, rs, 8, rs->logs);

            ptret = USB_IOCT_LOOP_STOP(usbid, &bitset);
            //sprintf_f(rs->logs, "conti read stop ret: %d \n", ptret);
            //print_f(rs->plogs, sp, rs->logs);
            
            buffstep = 0;
            
            chq = 'B';
            pieRet = write(pPrx[1], &chq, 1);
        }
        else if (cmdchr == 0x07) {
                    
            #if USB_HS_SAVE_RESULT
            fsave = find_save(ptfilepath, ptfileSave);
            if (!fsave) {
                goto end;    
            }

            bufmax = 8*1024*1024;
            pImage = malloc(bufmax);
            pcur = pImage;
            #endif

            recvsz = 0;
            acusz = 0;
            tcnt = 0;
            cswst = 0;
            usbufmax = puhsinfo->ushostbmax;
            
            len = ring_buf_get(pTx, &addr);    
            while (len <= 0) {
                sleep(1);
                sprintf_f(rs->logs, "buffer full!!! ret:%d !!", len);
                print_f(rs->plogs, sp, rs->logs);
                len = ring_buf_get(pTx, &addr);            
            }
            
            while(1) {
                usbrun = -1;
                
                #if USB_POLLTIME_MS /* test drop line */
                usleep(USB_POLLTIME_MS);
                #endif
                
                #if USB_CALLBACK_LOOP 

                
                recvsz = USB_IOCT_LOOP_CONTI_READ(usbid, &usbfolw);
                //smp_mb();

                
                #else
                recvsz = usb_read(addr, usbid, len);
                #endif

                //sprintf_f(rs->logs, "usb read 0x%.8x : %d - 0x07 \n", recvsz, usbrun);
                //print_f(rs->plogs, sp, rs->logs);
                
                if (recvsz > len) {
                    //sprintf_f(rs->logs, "last trunk size: %d 0x%x\n", recvsz, recvsz);
                    //print_f(rs->plogs, sp, rs->logs);

                    cswst = 0;
                    if (recvsz > 0xfffff) {

                        cswst = (recvsz >> 20) & 0xff;
                        
                        if (cswst == 0x80) {
                            cswst = 0x7f;
                        }
                        
                        csworg = cswst;

                        #if 1 /* pause status */
                        if ((cswst & 0x7f) == 0x22) {
                            cswst = 0x7f;
                            //cswst = 0x21;                        
                            //puhs->pushcswerr = cswst;
                        }
                        else if ((cswst & 0x7f) == 0x23) {
                            cswst = 0x7f;
                            //cswst = 0x21;                        
                            //puhs->pushcswerr = cswst;
                        } else 
                        #endif
                        #if 1 /* stop scan if get error status */
                        if ((cswst & 0x7f) && (cswst != 0x7f)) {
                        
                            puhs->pushcswerr = cswst;

                            sprintf(rs->logs, "__USB_DEV_ STATUS[0x%.2x][%s][%s]__", cswst & 0x7f, sp, puhsinfo->ushostname); 
                            dbgShowTimeStamp(rs->logs,  NULL, rs, 8, rs->logs);

                            chr = 'R';                        
                        }
                        #endif

                        //sprintf_f(rs->logs, "get the error status: 0x%.2x (org: 0x%.2x)\n", cswst, csworg & 0x7f);
                        //print_f(rs->plogs, sp, rs->logs);

                        #if 0 /* stop scan if get error status */
                        if ((cswst & 0x7f) && (cswst != 0x7f)) {
                        
                            puhs->pushcswerr = cswst;
                            
                            chr = 'R';                        
                        }
                        #endif
                    } 

                    if (recvsz & 0x20000) {
                        sprintf_f(rs->logs, "get the end signal 0x20000 \n");
                        print_f(rs->plogs, sp, rs->logs);

                        sprintf(rs->logs, "__USB_DEV_ END[0x%.5x][%s][%s]__", 0x20000, sp, puhsinfo->ushostname); 
                        dbgShowTimeStamp(rs->logs,  NULL, rs, 8, rs->logs);

                        #if USB_CALLBACK_LOOP 
                        chr = 'R';
                        #else
                        chr = 0;
                        #endif

                        recvsz = recvsz  & 0x1ffff;
                        usbrun = -1;

                        #if 1 /* stop scan by default status */
                        if (cswst == 0x7f) {
                            cswst = 0x21;                        
                            puhs->pushcswerr = cswst;
                        }
                        #endif
                        
                        //sprintf_f(rs->logs, "use the error status: 0x%.2x recv: %d\n", cswst, recvsz);
                        //print_f(rs->plogs, sp, rs->logs);
                    }
                    else if (recvsz & 0x40000) {
                        recvsz = recvsz  & 0x1ffff;
                        usbrun = 0;
                    }
                    else if (recvsz & 0x80000) {
                        recvsz = recvsz  & 0x1ffff;
                        usbrun = -1;
                    }
                    else {
                        usbrun = recvsz  & 0xfff;
                        recvsz = len;

                        #if 1//DBG_USB_HS
                        sprintf_f(rs->logs, "recvsz: %d, usbrun: %d - m1\n", recvsz, usbrun);
                        print_f(rs->plogs, sp, rs->logs);
                        #endif
                    }
                }
                else {
                    if (recvsz > 0) {
                        usbrun = recvsz  & 0xffff;
                        recvsz = len;


                        #if 1//DBG_USB_HS
                        sprintf_f(rs->logs, "recvsz: %d, usbrun: %d - m2\n", recvsz, usbrun);
                        print_f(rs->plogs, sp, rs->logs);
                        #endif
                    }
                }

                if (recvsz > 0) {
                    
                    #if USB_HS_SAVE_RESULT
                    memcpy(pcur, addr, recvsz);
                    #endif

                    #if SMP_EN
                    ix = buffstep % RING_BUFF_NUM_USB;
                    ptm = (char *)virtbl[ix];

                    msync(ptm, USB_BUF_SIZE, MS_SYNC);
                    asp_mem_barrier();
                    
                    memcpy(addr, ptm, USB_BUF_SIZE);

                    asp_mem_barrier();
                    msync(addr, USB_BUF_SIZE, MS_SYNC);

                    #if DBG_USB_FLW /* debug dump */
                    sprintf_f(rs->logs, "memcpy out %d - 0x07 [0x%.8x] \n", ix, (uint32_t)addr);
                    print_f(rs->plogs, sp, rs->logs);
                    shmem_dump(addr, 16);
                    #endif

                    buffstep += 1;
                    #endif

                    ring_buf_prod_u(pTx, recvsz);      
                    usbfolw = ring_buf_prod_tag(pTx, usbrun);

                    if (usbrun > 0) {
                        puhsinfo->ushostbtrktot = usbrun;
                    }
                    puhsinfo->ushostbtrkcms = usbfolw;
                    puhsinfo->ushostbtrkbuffed = puhsinfo->ushostbtrktot - usbfolw;
                    usbdist = puhsinfo->ushostbmax - puhsinfo->ushostbtrkbuffed;

                    #if 0//USB_AUTO_PAUSE
                    msync(puhsinfo, sizeof(struct usbHostmem_s), MS_SYNC);
                    msync(puhsinfrd, sizeof(struct usbHostmem_s), MS_SYNC);
                    
                    upa = puhsinfo->ushostpause;
                    ufr = puhsinfrd->ushostpause;
                    
                    ure = puhsinfo->ushostresume;
                    ufo = puhsinfrd->ushostresume;
                    
                    //sprintf_f(rs->logs, "pause info buffed: %d avg: %d cnt: %d p:%d r:%d fp:%d fr:%d m\n", puhsinfo->ushostbtrkbuffed, puhsinfo->ushostbtrkpageavg, puhsinfo->ushostbpagecnt, upa, ure, ufr, ufo);
                    //print_f(rs->plogs, sp, rs->logs);
                    
                    if (!upa) {
                        ix = upa;
                        
                        if (ufr == 1) {
                            USB_IOCT_LOOP_READ_PAUSE(usbid, &ix);
                                
                            puhsinfo->ushostpause = 1;
                    
                            #if DBG_PAUSE_RESUME
                            sprintf_f(rs->logs, "PAUSE remain: %d thrshold: %d, pagecnt: %d u:%d f:%d- m0\n", usbdist, puhsinfo->ushostbthrshold, puhsinfo->ushostbpagecnt, upa, ufr);
                            print_f(rs->plogs, sp, rs->logs);
                            #endif
                        }
                        else if (puhsinfo->ushostbpagecnt == 0) {
                            if (puhsinfo->ushostbtrktot > puhsinfo->ushostbthrshold) {
                                USB_IOCT_LOOP_READ_PAUSE(usbid, &ix);
                                
                                puhsinfo->ushostpause = 1;
                    
                                #if DBG_PAUSE_RESUME
                                sprintf_f(rs->logs, "PAUSE remain: %d thrshold: %d, pagecnt: %d - m1\n", usbdist, puhsinfo->ushostbthrshold, puhsinfo->ushostbpagecnt);
                                print_f(rs->plogs, sp, rs->logs);
                                #endif
                            }
                        } else {
                            usbuffed = puhsinfo->ushostbtrkbuffed;
                            usbavg = puhsinfo->ushostbtrkpageavg;
                            usbdist = usbufmax - usbuffed;
                            usbthrhld = usbavg * 2 + 50;
                            if (usbavg) {
                                if (usbavg > puhsinfo->ushostbthrshold) {
                                    USB_IOCT_LOOP_READ_PAUSE(usbid, &ix);
                                    
                                    puhsinfo->ushostpause = 1;
                                    #if DBG_PAUSE_RESUME
                                    sprintf_f(rs->logs, "PAUSE remain: %d system thrshold: %d, avgpage: %d - m2.1\n", usbdist, puhsinfo->ushostbthrshold, puhsinfo->ushostbtrkpageavg);
                                    print_f(rs->plogs, sp, rs->logs);
                                    #endif
                                }             
                                else if (usbdist < usbthrhld) {
                                    USB_IOCT_LOOP_READ_PAUSE(usbid, &ix);
                                    
                                    puhsinfo->ushostpause = 1;
                                    
                                    #if DBG_PAUSE_RESUME
                                    sprintf_f(rs->logs, "PAUSE remain: %d avg thrshold: %d, avgpage: %d - m2.2\n", usbdist, usbthrhld, puhsinfo->ushostbtrkpageavg);
                                    print_f(rs->plogs, sp, rs->logs);
                                    #endif
                                }                
                            }
                            else {
                                if (puhsinfo->ushostbtrktot > puhsinfo->ushostbthrshold) {
                                    USB_IOCT_LOOP_READ_PAUSE(usbid, &ix);
                                
                                    puhsinfo->ushostpause = 1;
                    
                                    #if DBG_PAUSE_RESUME
                                    sprintf_f(rs->logs, "PAUSE remain: %d thrshold: %d, pagecnt: %d - m1\n", usbdist, puhsinfo->ushostbthrshold, puhsinfo->ushostbpagecnt);
                                    print_f(rs->plogs, sp, rs->logs);
                                    #endif
                                }
                                else if (usbdist < (puhsinfo->ushostbthrshold * 2)) {
                                    USB_IOCT_LOOP_READ_PAUSE(usbid, &ix);
                                    
                                    puhsinfo->ushostpause = 1;
                                    
                                    #if DBG_PAUSE_RESUME
                                    sprintf_f(rs->logs, "PAUSE remain: %d thrshold/2: %d - m3\n", usbdist, (puhsinfo->ushostbthrshold / 2));
                                    print_f(rs->plogs, sp, rs->logs);
                                    #endif
                                }
                            }
                        }
                    }
                    else if (upa == 2) {
                        USB_IOCT_LOOP_READ_PAUSE(usbid, &ix);
                                
                        puhsinfo->ushostpause += 1;
                    
                        #if DBG_PAUSE_RESUME
                        sprintf_f(rs->logs, "PAUSE remain: %d thrshold: %d, pagecnt: %d u:%d f:%d- m3\n", usbdist, puhsinfo->ushostbthrshold, puhsinfo->ushostbpagecnt, upa, ufr);
                        print_f(rs->plogs, sp, rs->logs);
                        #endif
                    }
                    #endif // #if USB_AUTO_PAUSE
                    
                    #if DBG_USB_FLW
                    usbdist = usbrun - usbfolw;
                    sprintf_f(rs->logs, "show index [%d] usbfolw: %d, usbrun: %d, usbdist: %d [0x%.8x]\n", recvsz, usbfolw, usbrun, usbdist, (uint32_t)addr);
                    print_f(rs->plogs, sp, rs->logs);
                    #endif
                }

                #if 0//USB_AUTO_RESUME
                msync(puhsinfo, sizeof(struct usbHostmem_s), MS_SYNC);
                msync(puhsinfrd, sizeof(struct usbHostmem_s), MS_SYNC);

                upa = puhsinfo->ushostpause;
                ufr = puhsinfrd->ushostpause;

                ure = puhsinfo->ushostresume;
                ufo = puhsinfrd->ushostresume;

                if (((upa) || (ufr)) && ((ure) || (ufo))) {
                
                    #if 0
                    if ((upa == 0) || (ufr == 0)) {
                        sprintf_f(rs->logs, "update pause info buffed: %d avg: %d cnt: %d p:%d r:%d fp:%d fr:%d - m0\n", puhsinfo->ushostbtrkbuffed, puhsinfo->ushostbtrkpageavg, puhsinfo->ushostbpagecnt, upa, ure, ufr, ufo);
                        print_f(rs->plogs, sp, rs->logs);
                    }
                    #endif
                    puhsinfo->ushostpause = 0;
                    puhsinfrd->ushostpause = 0;

                }
                else if (ure == 2) {
                    ix = puhsinfo->ushostresume;
                    pieRet = USB_IOCT_LOOP_READ_RESTART(usbid, &ix);
                    
                    puhsinfo->ushostresume += 1;
                
                    #if DBG_PAUSE_RESUME
                    sprintf_f(rs->logs, "RESUME remain: %d ure:%d ufo:%d ret: %d - m0.1\n", usbdist, ure, ufo, pieRet);
                    print_f(rs->plogs, sp, rs->logs);
                    #endif
                    
                    //usleep(500000);
                    //sprintf_f(rs->logs, "RESUME remain: %d ure:%d ufo:%d ret: %d - 0.2\n", usbdist, ure, ufo, pieRet);
                    //print_f(rs->plogs, sp, rs->logs);
                    
                    if (ufo) {
                        puhsinfrd->ushostresume += 1;
                    }
                    else {
                        puhsinfrd->ushostresume = 3;
                    }
                }
                
                if ((ure > 2) && (ufo > 2)) {
                    puhsinfo->ushostresume = 0;
                    puhsinfrd->ushostresume = 0;
                    puhsinfo->ushostpause = 0;
                    puhsinfrd->ushostpause = 0;
                    //sprintf_f(rs->logs, "RESUME reset remain: %d m\n", usbdist);
                    //print_f(rs->plogs, sp, rs->logs);
                }
                #endif // #if USB_AUTO_RESUME
                
                if (recvsz < 0) {
                    sprintf_f(rs->logs, "usb read ret: %d \n", recvsz);
                    print_f(rs->plogs, sp, rs->logs);

                    sleep(1);
                    continue;
                    //break;
                }
                else if (recvsz == 0) {
                    msync(puhsinfo, sizeof(struct usbHostmem_s), MS_SYNC);
                    msync(puhsinfrd, sizeof(struct usbHostmem_s), MS_SYNC);
                    
                    upa = puhsinfo->ushostpause;
                    ufr = puhsinfrd->ushostpause;
                    
                    ure = puhsinfo->ushostresume;
                    ufo = puhsinfrd->ushostresume;
                    
                    idlecnt ++;
                    if ((idlecnt % 0x10000) == 0) {
                        sprintf_f(rs->logs, "idle meta warnning!!! meta usbfolw: %d, usbrun: %d recvsz: %d tcnt: 0x%x meta (%d, %d, %d, %d) \n", usbfolw, usbrun, recvsz, idlecnt, upa, ufr, ure, ufo);
                        print_f(rs->plogs, sp, rs->logs);
                    }
                    
                    #if USB_RECVLEN_ZERO_HANDLE

                    if (usbrun == 0) {
                        ring_buf_prod_u(pTx, recvsz);      
                        usbfolw = ring_buf_prod_tag(pTx, usbrun);

                        #if 1 //DBG_USB_HS
                        sprintf_f(rs->logs, "usbfolw: %d, usbrun: %d recvsz: %d\n", usbfolw, usbrun, recvsz);
                        print_f(rs->plogs, sp, rs->logs);
                        #endif
                    } else {
                        continue;
                    }
                    
                    #else
                    continue;
                    #endif
                }
                else {
                    /*do nothing*/
                }
                
                #if DBG_USB_HS
                sprintf_f(rs->logs, "usb read %d / %d!!(0x%.2x)\n ", recvsz, len, cmdchr);
                print_f(rs->plogs, sp, rs->logs);
                #endif
                
                //sprintf_f(rs->logs, "usb read %d / %d!!\n", recvsz, len);
                //print_f(rs->plogs, sp, rs->logs);
                
                //sprintf_f(rs->logs, "[HS] dump 32 - 0 \n");
                //msync(addr, recvsz, MS_SYNC);
                //shmem_dump(addr, 32);

                tcnt ++;

                /*
                if (tcnt == 1) {
                    clock_gettime(CLOCK_REALTIME, &utstart);
                    //sprintf_f(rs->logs, "start ... \n");
                    //print_f(rs->plogs, sp, rs->logs);
                }
                */
                
                #if USB_HS_SAVE_RESULT        
                pcur += recvsz;
                #endif
                
                acusz += recvsz;

                if (((recvsz > 0) && (recvsz < len)) && (usbrun < 0)) {
                    //clock_gettime(CLOCK_REALTIME, &utend);
                    
                    ring_buf_set_last(pTx, recvsz);
                    //sprintf_f(rs->logs, "loop last ret: %d, the last size: %d avg: %d tot: %d cnt: %d\n", ptret, recvsz, puhsinfo->ushostbtrkpageavg, puhsinfo->ushostbtrkpage, puhsinfo->ushostbpagecnt);
                    //print_f(rs->plogs, sp, rs->logs);

                    sprintf(rs->logs, "__USB_DEV_ EXTRA_META[%d][%s][%s]__", acusz, sp, puhsinfo->ushostname); 
                    thrimgsize += (CFLOAT)acusz;
                    ret = dbgShowTimeStamp(rs->logs,  NULL, rs, 8, rs->logs);
                    /*
                    thrtimecost = (CFLOAT)ret - thrtimecost;
                    throughput = thrimgsize / thrtimecost;
                    sprintf_f(rs->logs, "__USB_DEV_ THROUGHPUT[%.2lf][%s][%s]__", throughput, sp, puhsinfo->ushostname); 
                    ret = dbgShowTimeStamp(rs->logs,  NULL, rs, 8, rs->logs);
                    thrtimecost = (CFLOAT)ret;
                    */
                    break;
                } else {
                    chq = 'D';
                    pieRet = write(pPrx[1], &chq, 1);
                }
                
                #if USB_HS_SAVE_RESULT               
                if (acusz > bufmax) {
                    sprintf_f(rs->logs, "save image error due to buffer size not enough!!!");
                    print_f(rs->plogs, sp, rs->logs);
                    break;
                }
                #endif

                len = ring_buf_get(pTx, &addr);
                while (len <= 0) {
                    sleep(1);
                    sprintf_f(rs->logs, "buffer full!!! ret:%d !!\n", len);
                    print_f(rs->plogs, sp, rs->logs);
                    len = ring_buf_get(pTx, &addr);            
                }
            }

            //puhs->pushcnt = tcnt;
            if (puhs->pushcswerr > 0) {
                puhs->pushcnt += 1;
            }

            if (cswst) {

                cplls[0] = 'I';
                cplls[1] = cswst;
                cplls[2] = 'E';
                
                pieRet = write(pPrx[1], &cplls, 3);
            } else {
                chq = 'E';
                pieRet = write(pPrx[1], &chq, 1);
            }            
            
            if (chr == 'h') {
                //chq = 'H';
                //pieRet = write(pPrx[1], &chq, 1);
            }
            else if (chr == 'o') {
                chq = 'O';
                pieRet = write(pPrx[1], &chq, 1);
            } else if (chr == 'f') {
                chq = 'F';
                pieRet = write(pPrx[1], &chq, 1);
            } else if (chr == 'R') {                
                chq = 'R';
                pieRet = write(pPrx[1], &chq, 1);
            } else {
                sprintf_f(rs->logs, "Error!!! unknown chr: %c \n", chr);
                print_f(rs->plogs, sp, rs->logs);
            }
    
            #if USB_HS_SAVE_RESULT
            wrtsz = fwrite(pImage, 1, acusz, fsave);
            #endif
            
            //usCost = time_diff(&utstart, &utend, 1000);
            //throughput = acusz*8.0 / usCost*1.0;

            //sprintf_f(rs->logs, "last size: %d\n", acusz);
            //print_f(rs->plogs, sp, rs->logs);
            
            #if USB_HS_SAVE_RESULT
            sync();
            fclose(fsave);
            free(pImage);
            #endif

        }
        else if (cmdchr == 0x06) {
            //sprintf_f(rs->logs, "conti already stop !!!! \n");
            //print_f(rs->plogs, sp, rs->logs);
            chq = 'G';
            pieRet = write(pPrx[1], &chq, 1);
        }
        else if (cmdchr == 0x05) {
            
        }
        else if (cmdchr == 0x04) {

            usbfolw = 0;

            #if 1 /* test code before MCU ready */
            if (opc == 0x0f) {
                //opc = 0x0a;
                opc = 0x0e;
            }
            #endif
            
            insert_cbw(CBW, CBW_CMD_SEND_OPCODE, opc, dat);
            memcpy(&pkcbw[0], CBW, 32);

            insert_cbw(CBW, CBW_CMD_START_SCAN, opc, dat);
            memcpy(&pkcbw[32], CBW, 32);            

            insert_cbw(CBW, CBW_CMD_STOP_SCAN, opc, dat);
            memcpy(&pkcbw[64], CBW, 32);            

#if 0
            insert_cbw(CBW, 0x13, opc, dat);
            memcpy(&pkcbw[96], CBW, 32);            

            insert_cbw(CBW, 0x11, opc, dat);
            memcpy(&pkcbw[128], CBW, 32);            
#else
            insert_cbw(CBW, 0x14, opc, dat);
            memcpy(&pkcbw[96], CBW, 32);            

            insert_cbw(CBW, 0x15, opc, dat);
            memcpy(&pkcbw[128], CBW, 32);            
#endif

            /* start loop */
            ptret = USB_IOCT_LOOP_RESET(usbid, &bitset);
            //sprintf_f(rs->logs, "conti read reset ret: %d \n", ptret);
            //print_f(rs->plogs, sp, rs->logs);

            ptret = USB_IOCT_LOOP_START(usbid, pkcbw);
            //sprintf_f(rs->logs, "conti read start ret: %d \n", ptret);
            //print_f(rs->plogs, sp, rs->logs);

            sprintf(rs->logs, "__USB_DEV_ SCAN_START[%s][%s]__", sp, puhsinfo->ushostname); 
            ret = dbgShowTimeStamp(rs->logs,  NULL, rs, 8, rs->logs);
            thrtimecost = (CFLOAT)ret;
                    
            puhsinfo->ushostbtrktot = 0;
            puhsinfo->ushostbtrkcms = 0;
            puhsinfo->ushostbtrkbuffed = 0;
            puhsinfo->ushostbtrkpage = 0;
            puhsinfo->ushostbtrkpageavg = 0;
            puhsinfo->ushostbpagecnt = 0;
            puhsinfo->ushostresume = 0;
            puhsinfo->ushostpause = 0;
            
            chq = 'S';
            pieRet = write(pPrx[1], &chq, 1);
        }
        else if (cmdchr == 0x03) {

            usbfolw = 0;
            
            insert_cbw(CBW, CBW_CMD_SEND_OPCODE, opc, dat);
            memcpy(&pkcbw[0], CBW, 32);

            insert_cbw(CBW, CBW_CMD_START_SCAN, opc, dat);
            memcpy(&pkcbw[32], CBW, 32);            

            insert_cbw(CBW, CBW_CMD_STOP_SCAN, opc, dat);
            memcpy(&pkcbw[64], CBW, 32);

#if 0
            insert_cbw(CBW, 0x13, opc, dat);
            memcpy(&pkcbw[96], CBW, 32);            

            insert_cbw(CBW, 0x11, opc, dat);
            memcpy(&pkcbw[128], CBW, 32);            

#else
            insert_cbw(CBW, 0x14, opc, dat);
            memcpy(&pkcbw[96], CBW, 32);            

            insert_cbw(CBW, 0x15, opc, dat);
            memcpy(&pkcbw[128], CBW, 32);            
#endif

            /* start loop */
            
            ptret = USB_IOCT_LOOP_RESET(usbid, &bitset);
            //sprintf_f(rs->logs, "conti read reset ret: %d \n", ptret);
            //print_f(rs->plogs, sp, rs->logs);

            ptret = USB_IOCT_LOOP_ONCE(usbid, pkcbw);
            //sprintf_f(rs->logs, "conti read once ret: %d \n", ptret);
            //print_f(rs->plogs, sp, rs->logs);

            sprintf(rs->logs, "__USB_DEV_ START[%s][%s]__", sp, puhsinfo->ushostname); 
            dbgShowTimeStamp(rs->logs,  NULL, rs, 8, rs->logs);

            puhsinfo->ushostbtrktot = 0;
            puhsinfo->ushostbtrkcms = 0;
            puhsinfo->ushostbtrkbuffed = 0;
            puhsinfo->ushostbtrkpage = 0;
            puhsinfo->ushostbtrkpageavg = 0;
            puhsinfo->ushostbpagecnt = 0;
            puhsinfo->ushostresume = 0;
            puhsinfo->ushostpause = 0;
            
            chq = 'S';
            pieRet = write(pPrx[1], &chq, 1);
        }
        else if (cmdchr == 0x02) {

            #if USB_HS_SAVE_RESULT
            fsave = find_save(ptfilepath, ptfileSave);
            if (!fsave) {
                goto end;    
            }

            bufmax = 8*1024*1024;
            pImage = malloc(bufmax);
            pcur = pImage;
            #endif

            recvsz = 0;
            acusz = 0;
            tcnt = 0;
            idlecnt = 0;
            usbufmax = puhsinfo->ushostbmax;
            
            len = ring_buf_get(pTx, &addr);    
            while (len <= 0) {
                sleep(1);
                sprintf_f(rs->logs, "buffer full!!! ret:%d !!", len);
                print_f(rs->plogs, sp, rs->logs);
                len = ring_buf_get(pTx, &addr);            
            }
            
            while(1) {

                usbrun = -1;
                
                #if USB_POLLTIME_US /* test drop line */
                usleep(USB_POLLTIME_US);
                #endif
                
                #if USB_CALLBACK_LOOP 
                recvsz = USB_IOCT_LOOP_CONTI_READ(usbid, &usbfolw);
                #else
                recvsz = usb_read(addr, usbid, len);
                //recvsz = len;
                #endif

                //sprintf_f(rs->logs, "usb read 0x%.8x : %d - 0x02\n", recvsz, usbrun);
                //print_f(rs->plogs, sp, rs->logs);
                
                #if 0                
                if (tcnt) {
                    clock_gettime(CLOCK_REALTIME, &utend);
                    //usCost = test_time_diff(&utstart, &utend, 1000);
                }
                #endif 

                if (recvsz & 0x10000000) {
                    if (recvsz > 0) {
                        usbrun = recvsz  & 0xfffffff;
                        recvsz = len;

                        #if DBG_USB_HS
                        sprintf_f(rs->logs, "recvsz: %d, usbrun: %d - 0\n", recvsz, usbrun);
                        print_f(rs->plogs, sp, rs->logs);
                        #endif
                    }
                } else if (recvsz > len) {
                    cswst = 0;
                    if (recvsz > 0xfffff) {
                        cswst = (recvsz >> 20) & 0xff;
                        
                        /*should not be here*/
                        sprintf_f(rs->logs, "Error!!! get status: 0x%.2x recv:%d\n", cswst, recvsz);
                        print_f(rs->plogs, sp, rs->logs);

                        //chr = 'I';
                    }

                    if (recvsz & 0x20000) {
                        recvsz = recvsz  & 0x1ffff;
                        usbrun = -1;
                        //printf("[%s] Error!!! data get the end signal 0x20000 recvsz: %d\n", strpath, recvsz);
                    }
                    else if (recvsz & 0x40000) {
                        recvsz = recvsz  & 0x1ffff;
                        usbrun = 0;
                    }
                    else if (recvsz & 0x80000) {
                        recvsz = recvsz  & 0x1ffff;
                        usbrun = -1;
                    }
                    else {
                        usbrun = recvsz  & 0xfff;
                        recvsz = len;

                        #if DBG_USB_HS
                        sprintf_f(rs->logs, "recvsz: %d, usbrun: %d - 1\n", recvsz, usbrun);
                        print_f(rs->plogs, sp, rs->logs);
                        #endif
                    }
                    //sprintf_f(rs->logs, "last trunk size: %d \n", recvsz);
                }
                else {
                    if (recvsz > 0) {
                        usbrun = recvsz  & 0xfff;
                        recvsz = len;

                        #if DBG_USB_HS
                        sprintf_f(rs->logs, "recvsz: %d, usbrun: %d - 2\n", recvsz, usbrun);
                        print_f(rs->plogs, sp, rs->logs);
                        #endif
                    }
                }
                
                if (recvsz > 0) {
                    
                    #if USB_HS_SAVE_RESULT
                    memcpy(pcur, addr, recvsz);
                    #endif
                    
                    if (usbrun > 0) {
                        puhsinfo->ushostbtrktot = usbrun;
                        currun = usbrun;
                    } else {
                        currun += 1;
                    }
                    
                    #if SMP_EN
                    ix = buffstep % RING_BUFF_NUM_USB;
                    ptm = (char *)virtbl[ix];

                    mtlen = (recvsz % 512);
                    mtlen = recvsz - mtlen;

                    msync(ptm, USB_BUF_SIZE, MS_SYNC);
                    asp_mem_barrier();
                    
                    memcpy(addr, ptm, USB_BUF_SIZE);

                    asp_mem_barrier();
                    msync(addr, USB_BUF_SIZE, MS_SYNC);

                    #if DBG_USB_FLW /* debug dump */
                    sprintf_f(rs->logs, "memcpy out %d 0x02 [0x%.8x]\n", ix, (uint32_t)addr);
                    print_f(rs->plogs, sp, rs->logs);
                    shmem_dump(addr, 16);
                    #endif
                    
                    if (mtlen < recvsz) {
                        pt = ptm + mtlen;

                        #if DBG_USB_FLW /* debug dump */
                        shmem_dump(pt, 48);
                        #endif
                        
                        if ((pt[0] != 'A') || (pt[1] != 'S') || (pt[2] != 'P') || (pt[3] != 'C')) {
                            sprintf_f(rs->logs, "memcpy dump for error meta last: %d metaoffset: %d \n", recvsz, mtlen);
                            print_f(rs->plogs, sp, rs->logs);
                            
                            shmem_dump(pt, recvsz-mtlen);                             
                        }
                    }

                    buffstep += 1;
                    #endif

                    ring_buf_prod_u(pTx, recvsz);
                    usbfolw = ring_buf_prod_tag(pTx, usbrun);

                    puhsinfo->ushostbtrkcms = usbfolw;
                    puhsinfo->ushostbtrkbuffed = puhsinfo->ushostbtrktot - usbfolw;
                    usbdist = puhsinfo->ushostbmax - puhsinfo->ushostbtrkbuffed;
                    
                    #if DBG_USB_FLW
                    usbdist = usbrun - usbfolw;
                    sprintf_f(rs->logs, "show index [%d-%d] usbfolw: %d, usbrun: %d, usbdist: %d [0x%.8x] -3\n", recvsz, mtlen, usbfolw, usbrun, usbdist, (uint32_t)addr);
                    print_f(rs->plogs, sp, rs->logs);
                    #endif
                }

                #if USB_AUTO_PAUSE
                
                //puhsinfo->ushostbtrkbuffed = puhsinfo->ushostbtrktot - puhsinfo->ushostbtrkcms;
                usbdist = puhsinfo->ushostbmax - puhsinfo->ushostbtrkbuffed;
                    
                msync(puhsinfo, sizeof(struct usbHostmem_s), MS_SYNC);
                msync(puhsinfrd, sizeof(struct usbHostmem_s), MS_SYNC);
                
                upa = puhsinfo->ushostpause;
                ufr = puhsinfrd->ushostpause;
                
                ure = puhsinfo->ushostresume;
                ufo = puhsinfrd->ushostresume;
                
                
                if (!upa) {
                    ix = upa;
                    
                    #if DBG_PAUSE_RESUME
                    sprintf_f(rs->logs, "pause info buffed: %d avg: %d cnt: %d p:%d r:%d fp:%d fr:%d\n", puhsinfo->ushostbtrkbuffed, puhsinfo->ushostbtrkpageavg, puhsinfo->ushostbpagecnt, upa, ure, ufr, ufo);
                    print_f(rs->plogs, sp, rs->logs);
                    #endif
                    
                    if (ufr == 1) {
                        USB_IOCT_LOOP_READ_PAUSE(usbid, &ix);
                            
                        puhsinfo->ushostpause = 1;
                
                        #if DBG_PAUSE_RESUME
                        sprintf_f(rs->logs, "PAUSE remain: %d thrshold: %d, pagecnt: %d u:%d f:%d- 0\n", usbdist, puhsinfo->ushostbthrshold, puhsinfo->ushostbpagecnt, upa, ufr);
                        print_f(rs->plogs, sp, rs->logs);
                        #endif
                    }
                    else if (puhsinfo->ushostbpagecnt == 0) {
                        if (puhsinfo->ushostbtrktot > puhsinfo->ushostbthrshold) {
                            USB_IOCT_LOOP_READ_PAUSE(usbid, &ix);
                            
                            puhsinfo->ushostpause = 1;
                
                            #if DBG_PAUSE_RESUME
                            sprintf_f(rs->logs, "PAUSE remain: %d thrshold: %d, pagecnt: %d - 1\n", usbdist, puhsinfo->ushostbthrshold, puhsinfo->ushostbpagecnt);
                            print_f(rs->plogs, sp, rs->logs);
                            #endif
                        }
                    } else {
                        usbuffed = puhsinfo->ushostbtrkbuffed;
                        usbavg = puhsinfo->ushostbtrkpageavg;
                        usbdist = usbufmax - usbuffed;
                        usbthrhld = usbavg * 2 + 50;
                        if (usbavg) {
                            if (usbavg > puhsinfo->ushostbthrshold) {
                                if (usbdist < usbavg) {
                                    USB_IOCT_LOOP_READ_PAUSE(usbid, &ix);
                                
                                    puhsinfo->ushostpause = 1;
                                    #if DBG_PAUSE_RESUME
                                    sprintf_f(rs->logs, "PAUSE remain: %d system thrshold: %d, avgpage: %d - 2.1\n", usbdist, puhsinfo->ushostbthrshold, puhsinfo->ushostbtrkpageavg);
                                    print_f(rs->plogs, sp, rs->logs);
                                    #endif
                                }
                            }             
                            else if (usbdist < usbthrhld) {
                                USB_IOCT_LOOP_READ_PAUSE(usbid, &ix);
                                
                                puhsinfo->ushostpause = 1;
                                
                                #if DBG_PAUSE_RESUME
                                sprintf_f(rs->logs, "PAUSE remain: %d avg thrshold: %d, avgpage: %d - 2.2\n", usbdist, usbthrhld, puhsinfo->ushostbtrkpageavg);
                                print_f(rs->plogs, sp, rs->logs);
                                #endif
                            }                
                        }
                        else {
                            if (puhsinfo->ushostbtrktot > puhsinfo->ushostbthrshold) {
                                USB_IOCT_LOOP_READ_PAUSE(usbid, &ix);
                            
                                puhsinfo->ushostpause = 1;
                
                                #if DBG_PAUSE_RESUME
                                sprintf_f(rs->logs, "PAUSE remain: %d thrshold: %d, pagecnt: %d - 3.1\n", usbdist, puhsinfo->ushostbthrshold, puhsinfo->ushostbpagecnt);
                                print_f(rs->plogs, sp, rs->logs);
                                #endif
                            }
                            else if (usbdist < (puhsinfo->ushostbthrshold * 2)) {
                                USB_IOCT_LOOP_READ_PAUSE(usbid, &ix);
                                
                                puhsinfo->ushostpause = 1;
                                
                                #if DBG_PAUSE_RESUME
                                sprintf_f(rs->logs, "PAUSE remain: %d thrshold/2: %d - 3.2\n", usbdist, (puhsinfo->ushostbthrshold / 2));
                                print_f(rs->plogs, sp, rs->logs);
                                #endif
                            }
                        }
                    }
                }
                else if (upa == 2) {
                    USB_IOCT_LOOP_READ_PAUSE(usbid, &ix);
                            
                    puhsinfo->ushostpause += 1;
                    
                    #if DBG_PAUSE_RESUME                                        
                    sprintf_f(rs->logs, "PAUSE remain: %d thrshold: %d, pagecnt: %d u:%d f:%d- 3\n", usbdist, puhsinfo->ushostbthrshold, puhsinfo->ushostbpagecnt, upa, ufr);
                    print_f(rs->plogs, sp, rs->logs);
                    #endif
                }
                #endif // #if USB_AUTO_PAUSE
                
                #if USB_AUTO_RESUME
                msync(puhsinfo, sizeof(struct usbHostmem_s), MS_SYNC);
                msync(puhsinfrd, sizeof(struct usbHostmem_s), MS_SYNC);

                upa = puhsinfo->ushostpause;
                ufr = puhsinfrd->ushostpause;
                
                ure = puhsinfo->ushostresume;
                ufo = puhsinfrd->ushostresume;
                
                if (((upa) || (ufr)) && ((ure > 0) || (ufo > 0))) {

                    #if 0
                    if ((upa == 0) || (ufr == 0)) {
                        sprintf_f(rs->logs, "update pause info buffed: %d avg: %d cnt: %d p:%d r:%d fp:%d fr:%d - 0\n", puhsinfo->ushostbtrkbuffed, puhsinfo->ushostbtrkpageavg, puhsinfo->ushostbpagecnt, upa, ure, ufr, ufo);
                        print_f(rs->plogs, sp, rs->logs);
                    }
                    #endif
                    
                    //puhsinfo->ushostresume = 0;
                    //puhsinfrd->ushostresume = 0;

                }
                else if (ure == 2) {
                    ix = puhsinfo->ushostresume;
                    
                    pieRet = USB_IOCT_LOOP_READ_RESTART(usbid, &ix);
                    while (pieRet == 0) {
                        #if 1//DBG_PAUSE_RESUME
                        sprintf_f(rs->logs, "RESUME remain: %d ure:%d ufo:%d ret: %d resume faied!! - 0.1 \n", usbdist, ure, ufo, pieRet);
                        print_f(rs->plogs, sp, rs->logs);
                        #endif
                        pieRet = USB_IOCT_LOOP_READ_RESTART(usbid, &ix);
                    }

                    puhsinfo->ushostresume += 1;
                
                    #if 1//DBG_PAUSE_RESUME
                    sprintf_f(rs->logs, "RESUME remain: %d ure:%d ufo:%d ret: %d succeed!! - 0.1\n", usbdist, ure, ufo, pieRet);
                    print_f(rs->plogs, sp, rs->logs);
                    #endif
                    
                    msync(puhsinfrd, sizeof(struct usbHostmem_s), MS_SYNC);
                    ufo = puhsinfrd->ushostresume;
                    
                    if (ufo) {
                        puhsinfrd->ushostresume += 1;
                    }
                    else {
                        puhsinfrd->ushostresume = 3;
                    }

                }
                else if ((ure > 2) && (!ufo)) {
                    puhsinfo->ushostresume = 0;
                }
                else {
                    if ((ure > 2) && (ufo > 2)) {
                        puhsinfo->ushostresume = 0;
                        puhsinfrd->ushostresume = 0;
                        puhsinfo->ushostpause = 0;
                        puhsinfrd->ushostpause = 0;
                        //sprintf_f(rs->logs, "RESUME reset remain: %d \n", usbdist);
                        //print_f(rs->plogs, sp, rs->logs);
                    }
                }

                #if 0
                msync(puhsinfo, sizeof(struct usbHostmem_s), MS_SYNC);
                msync(puhsinfrd, sizeof(struct usbHostmem_s), MS_SYNC);

                upa = puhsinfo->ushostpause;
                ufr = puhsinfrd->ushostpause;
                
                ure = puhsinfo->ushostresume;
                ufo = puhsinfrd->ushostresume;
                #endif
                

                #endif // #if USB_AUTO_RESUME
                if (recvsz < 0) {
                    sprintf_f(rs->logs, "usb read ret: %d \n", recvsz);
                    print_f(rs->plogs, sp, rs->logs);

                    sleep(1);
                    continue;
                    //break;
                }
                else if (recvsz == 0) {
                    msync(puhsinfo, sizeof(struct usbHostmem_s), MS_SYNC);
                    msync(puhsinfrd, sizeof(struct usbHostmem_s), MS_SYNC);
                
                    upa = puhsinfo->ushostpause;
                    ufr = puhsinfrd->ushostpause;
                    
                    ure = puhsinfo->ushostresume;
                    ufo = puhsinfrd->ushostresume;
                    
                    idlecnt ++;
                    if ((idlecnt % 0x10000) == 0) {
                        sprintf_f(rs->logs, "idle warnning!!! usbfolw: %d, usbrun: %d recvsz: %d tcnt: 0x%x (%d, %d, %d, %d) \n", usbfolw, usbrun, recvsz, idlecnt, upa, ufr, ure, ufo);
                        print_f(rs->plogs, sp, rs->logs);
                    }

                    
                    #if 0 /* recover if the pause didn't be resume */
                    if (idlecnt == 0x120000) {
                        ix = puhsinfo->ushostresume;
                        pieRet = USB_IOCT_LOOP_READ_RESTART(usbid, &ix);

                        #if 1//DBG_PAUSE_RESUME
                        sprintf_f(rs->logs, " timeout RESUME remain: %d ure:%d ufo:%d ret: %d - 0.2\n", usbdist, ure, ufo, pieRet);
                        print_f(rs->plogs, sp, rs->logs);
                        #endif
                    }
                    #endif

                    //sprintf_f(rs->logs, "usb read ret: %d \n", recvsz);
                    #if USB_RECVLEN_ZERO_HANDLE
                    
                    if (usbrun == 0) {

                        buffstep += 1;
                        
                        ring_buf_prod_u(pTx, recvsz);      
                        usbfolw = ring_buf_prod_tag(pTx, usbrun);

                        #if 1 //DBG_USB_HS
                        sprintf_f(rs->logs, "usbfolw: %d, usbrun: %d recvsz: %d\n", usbfolw, usbrun, recvsz);
                        print_f(rs->plogs, sp, rs->logs);
                        #endif
                    } else {
                        continue;
                    }
                    
                    #else
                    
                    continue;
                    
                    #endif
                }
                else {
                    /*do nothing*/
                    idlecnt = 0;
                }
                
                #if DBG_USB_HS
                sprintf_f(rs->logs, "usb read %d / %d!!(0x%.2x)\n ", recvsz, len, cmdchr);
                print_f(rs->plogs, sp, rs->logs);
                #endif
                
                //sprintf_f(rs->logs, "[HS] dump 32 - 0 \n");
                //msync(addr, recvsz, MS_SYNC);
                //shmem_dump(addr, 32);

                tcnt ++;

                if (tcnt == 1) {
                    clock_gettime(CLOCK_REALTIME, &utstart);
                    //sprintf_f(rs->logs, "start ... \n");
                    //print_f(rs->plogs, sp, rs->logs);
                }
                
                #if USB_HS_SAVE_RESULT        
                pcur += recvsz;
                #endif
                
                acusz += recvsz;

                if (((recvsz > 0) && (recvsz < len)) && (usbrun < 0)) {
                    clock_gettime(CLOCK_REALTIME, &utend);

                    puhsinfo->ushostbtrkpage += tcnt+1;
                    puhsinfo->ushostbpagecnt += 1;
                    
                    puhsinfo->ushostbtrkpageavg = puhsinfo->ushostbtrkpage / puhsinfo->ushostbpagecnt;
                    
                    ring_buf_set_last(pTx, recvsz);
                    //sprintf_f(rs->logs, "loop last ret: %d, the last size: %d avg: %d tot: %d cnt: %d\n", ptret, recvsz, puhsinfo->ushostbtrkpageavg, puhsinfo->ushostbtrkpage, puhsinfo->ushostbpagecnt);
                    //print_f(rs->plogs, sp, rs->logs);

                    sprintf(rs->logs, "__USB_DEV_IMG_SIZE[%d][%s][%s]__", acusz, sp, puhsinfo->ushostname); 
                    thrimgsize = acusz;
                    dbgShowTimeStamp(rs->logs,  NULL, rs, 8, rs->logs);
                    
                    break;
                } else {
                    chq = 'D';
                    pieRet = write(pPrx[1], &chq, 1);
                }
                
                #if USB_HS_SAVE_RESULT               
                if (acusz > bufmax) {
                    sprintf_f(rs->logs, "save image error due to buffer size not enough!!!");
                    print_f(rs->plogs, sp, rs->logs);
                    break;
                }
                #endif
                
                len = ring_buf_get(pTx, &addr);
                while (len <= 0) {
                    sleep(1);
                    sprintf_f(rs->logs, "buffer full!!! ret:%d !!\n", len);
                    print_f(rs->plogs, sp, rs->logs);
                    len = ring_buf_get(pTx, &addr);            
                }
            }

#if 1
            switch (chr) {
            case 'd':
                chq = 'Q';
                pieRet = write(pPrx[1], &chq, 1);
                break;
            case 's':
                chq = 'Q';
                pieRet = write(pPrx[1], &chq, 1);
                break;
            case 'q':
                chq = 'Q';
                pieRet = write(pPrx[1], &chq, 1);
                break;
            case 'c':
                chq = 'Q';
                pieRet = write(pPrx[1], &chq, 1);
                break;
            case 'R':
                chq = 'R';
                pieRet = write(pPrx[1], &chq, 1);
                break;
            default:
                sprintf_f(rs->logs, "Error!!! data unknown chr: %c \n", chr);
                print_f(rs->plogs, sp, rs->logs);
                break;
            }
#else
            if (chr == 'd') {
                chq = 'Q';
                pieRet = write(pPrx[1], &chq, 1);
            }
            else if (chr == 's') {
                chq = 'Q';
                pieRet = write(pPrx[1], &chq, 1);
            }
            else if (chr == 'q') {
                chq = 'Q';
                pieRet = write(pPrx[1], &chq, 1);
            } 
            else if (chr == 'c') {
                chq = 'Q';
                pieRet = write(pPrx[1], &chq, 1);
            } else if (chr == 'R') {
                chq = 'R';
                pieRet = write(pPrx[1], &chq, 1);
            }
#endif

            //puhs->pushcnt = tcnt;

            chq = 'E';
            pieRet = write(pPrx[1], &chq, 1);
            
            
            #if USB_HS_SAVE_RESULT
            wrtsz = fwrite(pImage, 1, acusz, fsave);
            #endif
            
            usCost = time_diff(&utstart, &utend, 1000);
            throughput = acusz*8.0 / usCost*1.0;

            sprintf_f(rs->logs, "read size: %d, timecost: %d us, throughput: %lf Mbits \n", acusz, usCost, throughput);
            print_f(rs->plogs, sp, rs->logs);
            
            #if USB_HS_SAVE_RESULT
            sync();
            fclose(fsave);
            free(pImage);
            #endif

        }
        else if (cmdchr == 0x10) {
            #if DBG_USB_HS
            sprintf_f(rs->logs, "0x10 len:%d addr:0x%.8x direct:%d \n",msb2lsb32(&dcbwpram->pramDataLength), msb2lsb32(&dcbwpram->pramAddress), dcbwpram->pramDirect);
            print_f(rs->plogs, sp, rs->logs);
            #endif
            
            pllst = 0;
            
            //insert_cbw(CBW, CBW_CMD_SEND_OPCODE, opc, dat);
            msync(cubsBuff, SPI_TRUNK_SZ, MS_SYNC);
            ret = usb_send(cubsBuff, usbid, 31);
            if (ret <= 0) {
                sprintf_f(rs->logs, "usb send cbw error ret: %d \n", ret);
                print_f(rs->plogs, sp, rs->logs);

                pllst = CSW_STATUS_USB_FAIL;
            }

            if (!pllst) {
                ret = usb_send(dubsBuff, usbid, msb2lsb32(&dcbwpram->pramDataLength));
                if (ret <= 0) {
                    sprintf_f(rs->logs, "usb read data size %d error ret: %d \n", msb2lsb32(&dcbwpram->pramDataLength), ret);
                    print_f(rs->plogs, sp, rs->logs);

                    pllst = CSW_STATUS_USB_FAIL;
                }
            }
            
            //sprintf_f(rs->logs, "send size: %d dump: \n", ret);
            //print_f(rs->plogs, sp, rs->logs);
            //shmem_dump(dubsBuff, msb2lsb32(&dcbwpram->pramDataLength));
            if (!pllst) {            
                ret = usb_read(ptrecv, usbid, 13);
                if (ret <= 0) {
                    sprintf_f(rs->logs, "usb read csw size %d error ret: %d \n", 13, ret);
                    print_f(rs->plogs, sp, rs->logs);

                    pllst = CSW_STATUS_USB_FAIL;
                }
            }

            if (pllst) {
                memcpy(dcswBuff, cubsBuff, 8);      
                dcswBuff[12] = pllst;
            }
            else {
                memcpy(dcswBuff, ptrecv, 13);
                pllst = ptrecv[12];
            }
            
            //chvaddr = dubsBuff + ret;
            //memcpy(chvaddr, ptrecv, 13);

            #if DBG_USB_HS
            sprintf_f(rs->logs, "dump 13 bytes");
            print_f(rs->plogs, sp, rs->logs);
            shmem_dump(ptrecv, 13);
            #endif
            
            //sprintf_f(rs->logs, "poll status: 0x%.2x \n", pllst); 
            //print_f(rs->plogs, sp, rs->logs);

            cplls[0] = 'J';
            cplls[1] = pllst;
            pieRet = write(pPrx[1], &cplls, 2);
        }
        else if (cmdchr == 0x11) {
            #if DBG_USB_HS
            sprintf_f(rs->logs, "0x11 len:%d addr:0x%.8x direct:%d\n",msb2lsb32(&dcbwpram->pramDataLength), msb2lsb32(&dcbwpram->pramAddress), dcbwpram->pramDirect);
            print_f(rs->plogs, sp, rs->logs);
            #endif
            pllst = 0;

            msync(cubsBuff, SPI_TRUNK_SZ, MS_SYNC);
            //insert_cbw(CBW, CBW_CMD_SEND_OPCODE, opc, dat);
            ret = usb_send(cubsBuff, usbid, 31);
            if (ret <= 0) {
                sprintf_f(rs->logs, "usb send error ret: %d \n", ret);
                print_f(rs->plogs, sp, rs->logs);

                pllst = CSW_STATUS_USB_FAIL;
            }

            if (!pllst) {
                ret = usb_read(dubsBuff, usbid, msb2lsb32(&dcbwpram->pramDataLength));
                if (ret <= 0) {
                    sprintf_f(rs->logs, "usb read size %d error ret: %d \n", msb2lsb32(&dcbwpram->pramDataLength), ret);
                    print_f(rs->plogs, sp, rs->logs);

                    pllst = CSW_STATUS_USB_FAIL;
                }
            }
            
            //sprintf_f(rs->logs, "read size: %d dump: \n", ret);
            //print_f(rs->plogs, sp, rs->logs);
            //shmem_dump(dubsBuff, msb2lsb32(&dcbwpram->pramDataLength));
            
            if (!pllst) {
                ret = usb_read(ptrecv, usbid, 13);
                if (ret <= 0) {
                    sprintf_f(rs->logs, "usb read size %d error ret: %d \n", 13, ret);
                    print_f(rs->plogs, sp, rs->logs);

                    pllst = CSW_STATUS_USB_FAIL;
                }
            }

            if (pllst) {
                memcpy(dcswBuff, cubsBuff, 8);      
                dcswBuff[12] = pllst;
            }
            else {
                memcpy(dcswBuff, ptrecv, 13);        
                pllst = ptrecv[12];
            }

            #if DBG_USB_HS
            sprintf_f(rs->logs, "dump 13 bytes");
            print_f(rs->plogs, sp, rs->logs);
            shmem_dump(ptrecv, 13);
            #endif
            
            //sprintf_f(rs->logs, "poll status: 0x%.2x \n", pllst); 
            //print_f(rs->plogs, sp, rs->logs);

            cplls[0] = 'J';
            cplls[1] = pllst;
            pieRet = write(pPrx[1], &cplls, 2);
        }
        else if (cmdchr == 0x12) {
            sprintf_f(rs->logs, "check usb alive vid: 0x%.2x pid: 0x%.2x\n", puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1]);
            print_f(rs->plogs, sp, rs->logs);

            pllst = 0;

            pidvid[0] = 0;
            pidvid[1] = 0;

            ret = USB_IOCT_GET_VID_PID(usbid, pidvid);
            if (ret < 0) {
                perror("usb get vid pid");
                sprintf_f(rs->logs, "alive get pid vid failed ret: %d, errno: %d expect vid: 0x%x pid: 0x%x\n", ret, errno, puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1]);
                print_f(rs->plogs, sp, rs->logs);
                
                err = close(usbid);
                usbid = 0;
                
                sprintf_f(rs->logs, "alive close usb errno:%d ret: %d \n", errno, err);
                print_f(rs->plogs, sp, rs->logs);

                usbid = open(puhsinfo->ushostname, O_RDWR);
                
                if (usbid <= 0) {
                    sprintf_f(rs->logs, "can't open device[%s]\n", puhsinfo->ushostname); 
                    print_f(rs->plogs, sp, rs->logs);
                    
                    pllst = CSW_STATUS_USB_FAIL;
                    usbid = 0;
                    
                    //continue;
                } else {
                
                    sprintf_f(rs->logs, "open device[%s] usbid: %d \n", puhsinfo->ushostname, usbid); 
                    print_f(rs->plogs, sp, rs->logs);

                    pidvid[0] = 0;
                    pidvid[1] = 0;
                    ret = USB_IOCT_GET_VID_PID(usbid, pidvid);
                    if (ret < 0) {
                        sprintf_f(rs->logs,  "can't get vid pid for [%s]\n", puhsinfo->ushostname); 
                        print_f(rs->plogs, sp, rs->logs);
                        
                        close(usbid);
                        usbid = 0;
                        
                        pllst = CSW_STATUS_USB_FAIL;
                        
                        //continue;
                    }
                                        
                    if ((usbid != 0) && (pidvid[0] != 0) && (pidvid[1] != 0)) {
                        sprintf_f(rs->logs,  "check alive vid pid for [%s] vid: 0x%.4x pid: 0x%.4x expect 0x%.4x 0x%.4x\n", 
                                                       puhsinfo->ushostname, pidvid[0], pidvid[1], puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1]); 
                        print_f(rs->plogs, sp, rs->logs);

                        sprintf(rs->logs, "__USB_DEV_ VIDPID[0x%.4x][0x%.4x][%s][%s]__", pidvid[0], pidvid[1], sp, puhsinfo->ushostname); 
                        dbgShowTimeStamp(rs->logs,  NULL, rs, 8, rs->logs);
                    
                        puhsinfo->ushostpidvid[0] = pidvid[0];
                        puhsinfo->ushostpidvid[1] = pidvid[1];
                        if (puhsinfo->ushostid) {
                            puhsinfo->ushostid = usbid;
                        }
                        
                        if (puhsinfo->ushostpidvid[1] == 0x0a01) {
                            fixlen = 64;
                        } else {
                            fixlen = 512;
                        }
                        
                        #if 0
                        close(usbid);
                        usbid = 0;
                        
                        if (puhsinfo->ushostid == puhsinfom[0]->ushostid) {
                            chvir = puhsinfom[0]->ushostname;
                            puhsinfom[0]->ushostname = puhsinfom[1]->ushostname;
                            puhsinfom[1]->ushostname = chvir;
                        } else {
                            chvir = puhsinfom[1]->ushostname;
                            puhsinfom[1]->ushostname = puhsinfom[0]->ushostname;
                            puhsinfom[0]->ushostname = chvir;
                        }
                
                        usbid = open(puhsinfo->ushostname, O_RDWR);
                
                        if (usbid < 0) {
                            sprintf_f(rs->logs, "can't open device[%s]\n", puhsinfo->ushostname); 
                            print_f(rs->plogs, sp, rs->logs);

                            pllst = CSW_STATUS_USB_FAIL;
                            usbid = 0;
                            
                            //continue;
                        } else {
                
                            sprintf_f(rs->logs, "open device[%s] usbid: %d - 2\n", puhsinfo->ushostname, usbid); 
                            print_f(rs->plogs, sp, rs->logs);
                
                            ret = USB_IOCT_GET_VID_PID(usbid, pidvid);
                            if (ret < 0) {
                                sprintf_f(rs->logs,  "can't get vid pid for [%s]\n", puhsinfo->ushostname); 
                                print_f(rs->plogs, sp, rs->logs);
                                close(usbid);
                                usbid = 0;

                                pllst = CSW_STATUS_USB_FAIL;
                                
                                //continue;
                            }
                
                            if ((pidvid[0] != puhsinfo->ushostpidvid[0]) || (pidvid[1] != puhsinfo->ushostpidvid[1])) {
                                sprintf_f(rs->logs,  "vid pid for [%s] not match vid: 0x%.4x pid: 0x%.4x expect 0x%.4x 0x%.4x - 2\n", 
                                                               puhsinfo->ushostname, pidvid[0], pidvid[1], puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1]); 
                                print_f(rs->plogs, sp, rs->logs);
                                
                                close(usbid);

                                pllst = CSW_STATUS_USB_FAIL;
                                
                                //continue;
                            }
                        }
                        #endif
                    }

                    if (!pllst) {
                        bitset = RING_BUFF_NUM_USB;
                        ret = USB_IOCT_LOOP_BUFF_PRESET(usbid, &bitset);
                        if (ret < 0) {
                            sprintf_f(rs->logs,  "can't pre-set buff failed, size: %d [%s]\n", RING_BUFF_NUM_USB, puhsinfo->ushostname); 
                            print_f(rs->plogs, sp, rs->logs);
                            close(usbid);
                            usbid = 0;
                        
                            pllst = CSW_STATUS_USB_FAIL;
                            
                            //continue;
                        }
                    }

                    if (!pllst) {
                        if ((!puhsinfo->ushostblvir) || (!puhsinfo->ushostblphy)) {
                            sprintf_f(rs->logs,  "no vir table and phy table \n"); 
                            print_f(rs->plogs, sp, rs->logs);
                            close(usbid);
                            usbid = 0;
                        
                            pllst = CSW_STATUS_USB_FAIL;
                            
                            //continue;
                        }
                    }

                    if (!pllst) {
                        ret = USB_IOCT_LOOP_BUFF_SET(usbid, puhsinfo->ushostblphy);
                        if (ret < 0) {
                            sprintf_f(rs->logs,  "can't set phy addr, size: %d [%s]\n", RING_BUFF_NUM_USB, puhsinfo->ushostname); 
                            print_f(rs->plogs, sp, rs->logs);
                            close(usbid);
                            usbid = 0;
                        
                            pllst = CSW_STATUS_USB_FAIL;
                            
                            //continue;
                        }

                        #if SMP_EN
                        memfd = open(MODULE_NAME , O_RDWR);
                        if(memfd < 0) {
                            perror("/dev/mem open failed");
                            //close(usbid);
                            //goto end;
                        } else {
                            sprintf_f(rs->logs,  "open [%s] succeed!!!! \n", MODULE_NAME);
                            print_f(rs->plogs, sp, rs->logs);
                        }
                        
                        sprintf_f(rs->logs,  "[%s] table size: %d, addr0: (poll) \n", puhsinfo->ushostname, RING_BUFF_NUM_USB);
                        print_f(rs->plogs, sp, rs->logs);
                        for (ix=0; ix < RING_BUFF_NUM_USB; ix++) {
                            ut32 = puhsinfo->ushostblphy[ix];
                        
                            #if 0//LOG_PHY_MEM
                            if ((ix % 4) == 0) {
                                sprintf_f(rs->logs,  "%d: ", ix);
                                print_f(rs->plogs, sp, rs->logs);
                            }
                            #endif
                        
                            ret = phy2vir(&vt32, ut32, USB_BUF_SIZE, memfd);
                            if (ret < 0) {
                                sprintf_f(rs->logs,  "addr0 phy 2 vir error!!! ret: %d \n", ret);
                                print_f(rs->plogs, sp, rs->logs);
                                close(usbid);
                                goto end;
                            }
                        
                            //puhsinfo->ushostblvir[ix] = vt32;
                            virtbl[ix] = vt32;
                            memset((char *)vt32, 0xaa, USB_BUF_SIZE);
                        
                            #if 0//LOG_PHY_MEM
                            if ((ix % 4) == 3) {
                                sprintf_f(rs->logs,  "p:0x%.8x v:0x%.8x \n", ut32, vt32);
                                print_f(rs->plogs, sp, rs->logs);
                            } else {
                                sprintf_f(rs->logs,  "p:0x%.8x v:0x%.8x ", ut32, vt32);
                                print_f(rs->plogs, sp, rs->logs);
                            }        
                            #endif
                        }

                        close(memfd);
                        #endif
                    }

                    if (!pllst) {
                        sprintf_f(rs->logs,  "check alive setup complete usbid: %d, get vid: 0x%x, pid: 0x%x [%s]\n", puhsinfo->ushostid, puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1], puhsinfo->ushostname);
                        print_f(rs->plogs, sp, rs->logs);
                    } else {
                        sprintf_f(rs->logs,  "usb check alive !!pllst: 0x%.2x usbid: %d, get vid: 0x%x, pid: 0x%x [%s]\n", pllst, puhsinfo->ushostid, puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1], puhsinfo->ushostname);
                        print_f(rs->plogs, sp, rs->logs);
                    }
                }

                #if 0
                tbl0 = puhsinfo->ushostblvir;
                
                if (usbTx->pp) {
                    ppt = memory_init_vtable(usbTx->pp, RING_BUFF_NUM_USB * TABLE_SLOT_SIZE, TABLE_SLOT_SIZE, tbl0);
                    if (ppt != usbTx->pp) {
                        sprintf_f(rs->logs,  "Error!!! memory_init_vtable failed ret: 0x%.8x should be 0x%.8x \n", ppt, usbTx->pp);
                        print_f(rs->plogs, sp, rs->logs);
                        close(usbid);
                        continue;
                    }
                }
                else {
                    usbTx->pp = memory_init_vtable(usbTx->pp, RING_BUFF_NUM_USB * TABLE_SLOT_SIZE, TABLE_SLOT_SIZE, tbl0);  
                }
                
                if (!usbTx->pp) {
                    close(usbid);
                    continue;
                }

                if (gateTx->pp) {
                    ppt = memory_init_vtable(gateTx->pp, RING_BUFF_NUM_USB * TABLE_SLOT_SIZE, TABLE_SLOT_SIZE, tbl0);
                    if (ppt != gateTx->pp) {
                        sprintf_f(rs->logs,  "Error!!! memory_init_vtable failed ret: 0x%.8x should be 0x%.8x \n", ppt, gateTx->pp);
                        print_f(rs->plogs, sp, rs->logs);
                        close(usbid);
                        continue;
                    }
                }
                else {
                    gateTx->pp = memory_init_vtable(gateTx->pp, RING_BUFF_NUM_USB * TABLE_SLOT_SIZE, TABLE_SLOT_SIZE, tbl0);  
                }
                
                if (!gateTx->pp) {
                    close(usbid);
                    continue;
                }
                #endif
                
            }
            else {
                if ((usbid != 0) && (pidvid[0] != 0) && (pidvid[1] != 0)) {
                    sprintf_f(rs->logs,  "check alive vid pid for [%s] vid: 0x%.4x pid: 0x%.4x expect 0x%.4x 0x%.4x - 2\n", 
                                                       puhsinfo->ushostname, pidvid[0], pidvid[1], puhsinfo->ushostpidvid[0], puhsinfo->ushostpidvid[1]); 
                    print_f(rs->plogs, sp, rs->logs);

                    puhsinfo->ushostpidvid[0] = pidvid[0];
                    puhsinfo->ushostpidvid[1] = pidvid[1];
                    if (puhsinfo->ushostid) {
                        puhsinfo->ushostid = usbid;
                    }

                    if (puhsinfo->ushostpidvid[1] == 0x0a01) {
                        fixlen = 64;
                    } else {
                        fixlen = 512;
                    }
                        
                }                        
            }

            #if 0 /* forward opc: 0x4f to ASIC */
            pllst = 0;
            
            msync(cubsBuff, SPI_TRUNK_SZ, MS_SYNC);
            usb_send(cubsBuff, usbid, 31);
                
            ptret = usb_read(ptrecv, usbid, 13);

            sprintf_f(rs->logs, "usb_read 13 bytes usbid: %d ret: %d \n", usbid, ptret); 
            print_f(rs->plogs, sp, rs->logs);

            if (ptret > 0) {
                memcpy(dcswBuff, ptrecv, 13);

                #if 0//DBG_USB_HS
                sprintf_f(rs->logs, "dump 13 bytes");
                print_f(rs->plogs, sp, rs->logs);
                shmem_dump(ptrecv, 13);
                #endif
            
                pllst = ptrecv[12];
                
                #if DBG_USB_HS
                sprintf_f(rs->logs, "poll status: 0x%.2x \n", pllst); 
                print_f(rs->plogs, sp, rs->logs);
                #endif
            } else {
                sprintf_f(rs->logs, "read 13 bytes failed, ret: %d\n", ptret); 
                print_f(rs->plogs, sp, rs->logs);

                memset(ptrecv, 0xff, 13);
                ptrecv[12] = CSW_STATUS_USB_FAIL;
            }
            
            memcpy(dcswBuff, ptrecv, 13);

            #if DBG_USB_HS
            sprintf_f(rs->logs, "dump 13 bytes");
            print_f(rs->plogs, sp, rs->logs);
            shmem_dump(ptrecv, 13);
            #endif
            
            pllst = ptrecv[12];
            
            //sprintf_f(rs->logs, "poll status: 0x%.2x \n", pllst); 
            //print_f(rs->plogs, sp, rs->logs);

            cplls[0] = 'J';
            cplls[1] = pllst;
            pieRet = write(pPrx[1], &cplls, 2);
            #else


            memset(ptrecv, 0x0, 13);
            memcpy(ptrecv, cubsBuff, 8);
            ptrecv[12] = pllst;

            //sprintf_f(rs->logs,  "0x4f check alive dump csw: \n"); 
            //print_f(rs->plogs, sp, rs->logs);

            //shmem_dump(ptrecv, 13);
            

            cplls[0] = 'J';
            cplls[1] = pllst;
            pieRet = write(pPrx[1], &cplls, 2);
            #endif
        }
        else if (cmdchr == 0x13) {
            sprintf(rs->logs, "__USB_DEV_ PAUSE[%s][%s]__", sp, puhsinfo->ushostname); 
            dbgShowTimeStamp(rs->logs,  NULL, rs, 8, rs->logs);

            ix = puhsinfo->ushostpause;
            USB_IOCT_LOOP_READ_PAUSE(usbid, &ix);
            puhsinfo->ushostresume = 0;
            sprintf_f(rs->logs, "conti read pause ret: %d \n", ptret);
            print_f(rs->plogs, sp, rs->logs);
        }
        else if (cmdchr == 0x14) {
            sprintf(rs->logs, "__USB_DEV_ RESUME[%s][%s]__", sp, puhsinfo->ushostname); 
            dbgShowTimeStamp(rs->logs,  NULL, rs, 8, rs->logs);

            ix = puhsinfo->ushostresume;
            pieRet = USB_IOCT_LOOP_READ_RESTART(usbid, &ix);
            puhsinfo->ushostpause = 0;
            
            sprintf_f(rs->logs, "conti read resume ret: %d \n", ptret);
            print_f(rs->plogs, sp, rs->logs);

            chq = 'V';
            pieRet = write(pPrx[1], &chq, 1);
        }
        else {
            sprintf_f(rs->logs, "unknown cmd chr: 0x%.2x \n", cmdchr);
            print_f(rs->plogs, sp, rs->logs);
        }
    }


    end:        
    
    if (usbid) close(usbid);
    
#endif

    while (1) {
        ret = rs_ipc_get_ms(rs, &ch, 1, 5000);

        if (ret > 0) {
            sprintf_f(rs->logs, "break loop!!! get ch[0x%.2x] \n", ch);
            print_f(rs->plogs, sp, rs->logs);
        } else {
            sprintf_f(rs->logs, "USB [%s] not available !!\n", puhsinfo->ushostname);
            print_f(rs->plogs, sp, rs->logs);
        }
    }

    return 0;
}

#define LOG_P9_EN (0)
static int p9(struct procRes_s *rs)
{
    int ret=0;
    char ch=0;
    
    sprintf_f(rs->logs, "enter p9\n");
    print_f(rs->plogs, "P9", rs->logs);

    p9_init(rs);

    prctl(PR_SET_NAME, "msp-p9");

    while (1) {
        ret = usbhostd(rs, "P9", LOG_P9_EN);
        if (ret) {
            break;
        }
    }


    p9_end(rs);
    return 0;
}

#define LOG_P10_EN (0)
static int p10(struct procRes_s *rs)
{
    int ret=0;
    char ch=0;
    
    sprintf_f(rs->logs, "enter p10\n");
    print_f(rs->plogs, "P10", rs->logs);

    p10_init(rs);

    prctl(PR_SET_NAME, "msp-p10");

    while (1) {
        usbhostd(rs, "P10", LOG_P10_EN);
    }


    p10_end(rs);
    return 0;
}

#define LOG_FLASH  (0)
#define LOG_P11_EN (0)
#define DBG_27_EPOL (0)
#define DBG_27_DV (0)
#define DBG_USB_TIME_MEASURE (0)
#if ONLY_ONE_USB
#define BYPASS_TWO  (0)
#else
#define BYPASS_TWO  (1)
#endif
#define OP_WRITE_FILE (0x0b)
#define DUMP_JPG_ROT (0)
#define CROP_TEST_EN (1)

#if GHP_EN
#define SCAN_BNOTE_EN (1)
#else
#define SCAN_BNOTE_EN (0)
#endif
static int p11(struct procRes_s *rs, struct procRes_s *rsd, struct procRes_s *rcmd)
{
    int ret=0;
    char ch='a';
    char fileidpoll[64] = "/root/scaner/fileidpll.bin";
    char *fileidbuff=0;
    FILE *fdpll=0, *fdrd=0;
    char syscmd11[256] = "ls -al";
    struct epoll_event eventRx, eventTx, getevents[MAX_EVENTS];
    struct epoll_event evtrs, evtrsd, evtrcmd, evtpipr, evtpiprd;
    struct pollfd ptfd[1];
    struct pollfd ptfdc[2];
    
    int udevfd=0, epollfd=0, uret=0, ifx=0, rxfd=0, txfd=0, cntTx=0, lastsz=0;
    #if 1 /* save meta */
    char ptfilepath[128];
    static char ptfileSaveMeta[] = "/mnt/mmc2/usb/meta_%.3d.bin";
    static char ptfileSaveWifiMeta[] = "/mnt/mmc2/usb/wmeta_%.3d.bin";
    static char ptfileSavejpg[] = "/home/root/rot_%.3d.jpg";
    FILE *fsmeta=0;
    #endif
    char elfhead[4] = {0x7f, 0x45, 0x4c, 0x46};
    char cbw[32] = {0x55, 0x53, 0x42, 0x43, 0x20, 0x14, 0x20, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11,
                             0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff};
    char csw[16] = {0x55, 0x53, 0x42, 0x43, 0x11, 0x22, 0x33, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff};
    char cswDefault[16] = {0x55, 0x53, 0x42, 0x43, 0x11, 0x22, 0x33, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff};
    char emptyLine[4] = {0x59, 0x4c, 0x03, 0x10};
    char emptyLast[4] = {0x41, 0x53, 0x50, 0x43};
    char msgcmd[16];
    char msgret[64];
    char endTran[64] = {};
    char *changename=0;
    char *ptrecv=0, *metaPt=0;
    uint8_t cmd=0, opc=0, dat=0;
    uint32_t usbentsRx=0, usbentsTx=1, getents=0;
    int usbfd=0;
    char *addrd=0, *palloc=0, *addrb=0;
    int uimCylcnt=0, datCylcnt=0, distCylcnt=0, maxCylcnt=0;
    struct usbIndex_s *puimCnTH=0, *puimTmp=0, *puimUse=0, *puimCur=0, *puimGet=0, *puimNxt=0, *puimCud=0;
    char *endf=0, *endm=0;
    char endstr[] = "usb_conti_stop";
    int seqtx=0, lens=0, maxsz=0, pipRet=0, idlet=0, ix=0, waitCylen=0, chr=0, cindex=0, lastCylen=0, pagecnt=0, rlen=0;
    char chq=0, chd=0, mindexfo[2], cindexfo[2], cinfo[12], chn=0, chm=0, chw=0, chy=0;
    char cmdprisec=0, cswerr=0, pagerst=2, che=0, cswstatus[2];
    int *piptx=0, *piprx=0, *pipm=0, *pipn=0;
    int sendsz=0, errcnt=0, acusz=0, tmCost=0, wrtsz=0, retry=0, rwaitCylen=0, recvsz=0, lastflag=0, filesz=0;
    int *pipeRx, *pipeRxd, *pipeTx, *pipeTxd;
    int *gateUpTx, *gateUpRx, *gateDnTx, *gateDnRx;
    struct timespec tidleS, tidleE;
    struct usbhost_s *pushost=0, *pushostd=0, *puscur=0;
    struct shmem_s *usbTx=0, *usbTxd=0, *usbCur=0;
    struct shmem_s *gateTx=0, *gateTxd=0;
    struct timespec tstart, tend;
#if DBG_USB_TIME_MEASURE
    struct timespec intvalS[2], intvalE[2], *pintval=0;
    int fintvalS[2], fintvalE[2];
#endif
    struct aspMetaData_s *metaRx = 0;
    CFLOAT throughput=0.0, thrdatasize=0.0, thrtimeconsu=0.0, thrtimebegin=0.0;
    struct info16Bit_s *iubs=0;
    struct usbCBWopc_s *ucbwopc=0;
    struct usbCBWpram_s *ucbwpram=0;
    struct usbCBWfile_s *ucbwfile=0;
    char *iubsBuff=0, *vubsBuff=0, *vcswBuff=0;
    struct aspMetaData_s *ptmetaout=0, *ptmetain=0;
    struct aspMetaData_s *ptmetainduo=0;
    char *addrs=0;
    int lenrs=0, act=0, val=0, lenflh=0, err=0, fsrcv=0, idlcnt=0, pollcnt=0, loopcnt=0, tmp=0;
    struct aspConfig_s *pct=0, *pdt=0;
    struct aspMetaMass_s *pmass=0, *pmassduo=0;
    int usbid01=0, usbid02=0;
    struct aspMetaDataviaUSB_s *ptmetausb=0, *ptmetausbduo=0;
    int lenbs=0, shfmeta=0;
    char *pshfmeta=0;
    char wfcmd[8][2] = {{'p', 0x01}, {'m', 0x02}, {'s', 0x03}, {'r', 0x04}, {'t', 0x05}, {'n', 0x06}, {'q', 0x07}, {'o', 0x08}};
    uint32_t fformat=0;
    int opsz=0, lrst=0;
    struct usbHostmem_s *pinfushost=0, *pinfushostd=0, *pinfcur=0, *pinfcurd=0;
    int udist=0, uthrhld=0, upas=0, ursm=0, upasd=0, ursmd=0, udistd=0;
    struct usbFileidAccess_s *pubf=0;
    struct usbFileidContent_s *pubfidc=0, *pubfidnxt=0;
    int bmplen=0, cpylen=0, rawlen=0, rotlen=0, rotlast=0, bdeg=0, bret=0, blen=0, colr=0, bmpw=0, bmph=0, bdpi=0, bdpp=0, bhlen=0;
    char *bmpbuff=0, *bmpbufc=0, *bmpcpy=0, *bmpcolrtb=0, *ph=0, *bmprot=0;
    char *jpgout=0, *exmtaout=0;
    unsigned char *jpgrlt=0;
    int jpgetW=0, jpgetH=0, jpgLen=0, cntsent=0;
    struct sdParseBuff_s *pabuff=0;
    struct bitmapHeader_s *bheader = 0;
    struct timespec jpgS, jpgE;
    int cutcnt=0, cutnum=0, *cutsides=0, *cutlayers=0;
    int sides[2]={0}, mreal[2]={0}, prisec=0, updn=0;
    int pipepc[2]={0}, pipeusb[2]={0}, pid=-1;
    int pids[128] = {0}, pscnt=0;
    int pipesup[2]={0}, pipesdn[2]={0};
    int mbufidx=-1, mbstats=0;
    struct bitmapDecodeMfour_s *pmbf=0;
    char *bfs[8]={0}, *bfmt=0, *bfex=0, *pbf=0;
    int bflens[8]={0}, mtlen=0, exlen=0;
    
    //pipe2(pipeusb, O_NONBLOCK);
    //pipe2(pipepc, O_NONBLOCK);

    pubf = rs->pusbfile;
    fileidbuff = malloc(32768 + 12);
    if (!fileidbuff) {
        sprintf_f(rs->logs, "Error!!! file id buff memory allocate failed  !!! \n");
        print_f(rs->plogs, "P11", rs->logs);
    }
    
    pinfushost = rs->pusbmh[0];
    if (!pinfushost) {
        sprintf_f(rs->logs, "Error!!! usb host 0 info not available !!! \n");
        print_f(rs->plogs, "P11", rs->logs);
    } else {
        sprintf_f(rs->logs, "usb host 0 info name:[%s] vidpid:[0x%.2x:0x%.2x] \n", pinfushost->ushostname, pinfushost->ushostpidvid[0], pinfushost->ushostpidvid[1]);
        print_f(rs->plogs, "P11", rs->logs);
    }

    pinfushostd = rs->pusbmh[1];
    if (!pinfushostd) {
        sprintf_f(rs->logs, "Error!!! usb host 1 info not available !!! \n");
        print_f(rs->plogs, "P11", rs->logs);
    } else {
        sprintf_f(rs->logs, "usb host 0 info name:[%s] vidpid:[0x%.2x:0x%.2x] \n", pinfushostd->ushostname, pinfushostd->ushostpidvid[0], pinfushostd->ushostpidvid[1]);
        print_f(rs->plogs, "P11", rs->logs);
    }

    pabuff = &rs->psFat->parBuf;
    bheader = rs->pbheader;
    
    pct = rs->pcfgTable;
    pmass = rs->pmetaMass;
    ptmetausb = rs->pmetausb;
    ptmetausbduo = rs->pmetausbduo;
    ptmetain = rs->pmetain;
    pmassduo = rs->pmetaMassduo;
    ptmetainduo = rs->pmetainduo;
    ptmetaout = rs->pmetaout;
    iubs = &rs->pmch->ubs;
    vubsBuff = &rs->pmch->mshmem[32];
    iubsBuff = rs->pmch->mshmem;
    vcswBuff = vubsBuff + 1024;
    ucbwopc = (struct usbCBWopc_s *)iubsBuff;
    ucbwpram = (struct usbCBWpram_s *)iubsBuff;
    ucbwfile = (struct usbCBWfile_s *)iubsBuff;
    
    sprintf_f(rs->logs, "p11\n");
    print_f(rs->plogs, "P11", rs->logs);

    p11_init(rs, rsd, rcmd);

    prctl(PR_SET_NAME, "msp-p11");

    pushost = rs->pusbhost;
    //usbid01 = pushost->ushid;
    usbid01 = pinfushost->ushostid;
    pushostd = rsd->pusbhost;
    //usbid02 = pushostd->ushid;
    usbid02 = pinfushostd->ushostid;

    usbid01 = 1;
    usbid02 = 1;
    sprintf_f(rs->logs, "USBID 01: %d, 02: %d \n", usbid01, usbid02);
    print_f(rs->plogs, "P11", rs->logs);
    
    metaPt = pushost->puhsmeta;
    metaRx = (struct aspMetaData_s *)metaPt;

    pipeRx = pushost->pushrx;
    pipeTx = pushost->pushtx;
    gateUpTx = pushost->pgattx;
    gateUpRx = pushost->pgatrx;

    pipeRxd = pushostd->pushrx;
    pipeTxd = pushostd->pushtx;
    gateDnTx = pushostd->pgattx;
    gateDnRx = pushostd->pgatrx;

    ptfdc[0].fd = pipeRx[0];
    ptfdc[0].events = POLLIN;

    ptfdc[1].fd = pipeRxd[0];
    ptfdc[1].events = POLLIN;
                            
    epollfd = epoll_create1(O_CLOEXEC);
    if (epollfd < 0) {
        perror("epoll_create1");
        sprintf_f(rs->logs, "epoll create failed, errno: %d\n", errno);
        print_f(rs->plogs, "P11", rs->logs);
    } else {
        sprintf_f(rs->logs, "epoll create succeed, epollfd: %d, errno: %d\n", epollfd, errno);
        print_f(rs->plogs, "P11", rs->logs);
    }

    usbfd = rs->usbdvid;
    getents = 0xffff;
    ret = GADGET_IOCT_GET_STATUS(usbfd, getents);
    sprintf_f(rs->logs, "Test gadget usbfd: %d ioctl send: 0x%.8x ret: %d\n", usbfd, getents, ret);
    print_f(rs->plogs, "P11", rs->logs);


    if (usbfd) {
        usb_nonblock_set(usbfd);

        eventRx.data.fd = usbfd;
        //eventRx.events = EPOLLIN |EPOLLOUT | EPOLLLT;
        eventRx.events = EPOLLIN | EPOLLLT;
        ret = epoll_ctl (epollfd, EPOLL_CTL_ADD, usbfd, &eventRx);
        if (ret == -1) {
            perror ("epoll_ctl");
            sprintf_f(rs->logs, "rs usb spoll set ctl failed errno: %ds\n", errno);
            print_f(rs->plogs, "P11", rs->logs);
        }
    }
    
    evtrs.data.fd = rs->ppipedn->rt[0];
    evtrs.events = EPOLLIN | EPOLLLT;
    ret = epoll_ctl (epollfd, EPOLL_CTL_ADD, rs->ppipedn->rt[0], &evtrs);
    if (ret == -1) {
        perror ("epoll_ctl");
        sprintf_f(rs->logs, "rs pipe spoll set ctl failed errno: %ds\n", errno);
        print_f(rs->plogs, "P11", rs->logs);
    }

    evtrsd.data.fd = rsd->ppipedn->rt[0];
    evtrsd.events = EPOLLIN | EPOLLLT;
    ret = epoll_ctl (epollfd, EPOLL_CTL_ADD, rsd->ppipedn->rt[0], &evtrsd);
    if (ret == -1) {
        perror ("epoll_ctl");
        sprintf_f(rs->logs, "rsd pipe spoll set ctl failed errno: %ds\n", errno);
        print_f(rs->plogs, "P11", rs->logs);
    }
    
    evtrcmd.data.fd = rcmd->ppipedn->rt[0];
    evtrcmd.events = EPOLLIN | EPOLLLT;
    ret = epoll_ctl (epollfd, EPOLL_CTL_ADD, rcmd->ppipedn->rt[0], &evtrcmd);
    if (ret == -1) {
        perror ("epoll_ctl");
        sprintf_f(rs->logs, "rcmd pipe spoll set ctl failed errno: %ds\n", errno);
        print_f(rs->plogs, "P11", rs->logs);
    }

    ptrecv = malloc(USB_BUF_SIZE);
    if (ptrecv) {
        sprintf_f(rs->logs, " recv buff alloc succeed! size: %d \n", USB_BUF_SIZE);
        print_f(rs->plogs, "P11", rs->logs);
    } else {
        sprintf_f(rs->logs, " recv buff alloc failed! size: %d break !!\n", USB_BUF_SIZE);
        print_f(rs->plogs, "P11", rs->logs);
        while(1);
    }

    ptfd[0].fd = pipeRx[0];
    ptfd[0].events = POLLIN;

#if DBG_USB_TIME_MEASURE
    memset(fintvalS, 0, sizeof(int) * 2);
    memset(fintvalE, 0, sizeof(int) * 2);
#endif

    cntTx = 0;
    ifx = 0;
    while (1) {
        
        rxfd = 0;
        uret = epoll_wait(epollfd, getevents, MAX_EVENTS, 100);
        if (uret < 0) {
            perror("epoll_wait");
            sprintf_f(rs->logs, "[ePol] failed errno: %d ret: %d\n", errno, uret);
            print_f(rs->plogs, "P11", rs->logs);
        } else if (uret == 0) {
            
            #if 1
            if (!usbfd) {
                rs->usbdvid = open(rs->usvdvname, O_RDWR);
                if (rs->usbdvid <= 0) {
                    printf("can't open device[%s]!!\n", rs->usvdvname); 
                    close(rs->usbdvid);
                    rs->usbdvid = 0;
                    idlcnt ++;
                }
                else {
                    //printf("open device[%s]\n", rs->usvdvname); 
                    #if 0
                    sprintf_f(rs->logs, "open device[%s]\n", rs->usvdvname);
                    print_f(rs->plogs, "P11", rs->logs);
                    #endif
                }
            
                if (rs->usbdvid) {
                    usb_nonblock_set(rs->usbdvid);
                    recvsz = read(rs->usbdvid, ptrecv, 31);
                    if (recvsz < 0) {
                        close(rs->usbdvid);
                        rs->usbdvid = 0;
                        //printf("close device[%s]\n", rs->usvdvname); 
                        idlcnt ++;
                    } else {
                        if (recvsz == 31) {

                            idlcnt = 0;
                            
                            usbfd = rs->usbdvid;
                            fsrcv = recvsz;
                            usbentsRx = 1;
                            usbentsTx = 1;
            
                            usb_nonblock_set(usbfd);

                            getents = 0xffff;
                            ret = GADGET_IOCT_GET_STATUS(usbfd, getents);
                            sprintf_f(rs->logs, "Test gadget usbfd: %d ioctl send: 0x%.8x ret: %d - 2\n", usbfd, getents, ret);
                            print_f(rs->plogs, "P11", rs->logs);
    
                            eventRx.data.fd = usbfd;
                            //eventRx.events = EPOLLIN | EPOLLOUT | EPOLLLT;
                            eventRx.events = EPOLLIN | EPOLLLT;
                            ret = epoll_ctl (epollfd, EPOLL_CTL_ADD, usbfd, &eventRx);
                            if (ret == -1) {
                                perror ("epoll_ctl");
                                sprintf_f(rs->logs, "rs usb spoll set ctl failed errno: %ds\n", errno);
                                print_f(rs->plogs, "P11", rs->logs);
                            }
                        } else {
                            close(rs->usbdvid);
                            rs->usbdvid = 0;
                            printf("close device[%s] recvsz: %d\n", rs->usvdvname, recvsz); 
                        }
                    }
                }

                #if USB_PC_IDLE_CHK
                if ((idlcnt > 16) && (!usbfd)) {
                    sprintf_f(rs->logs, "open device[%s] re-launch idlcnt: %d \n", rs->usvdvname, idlcnt);
                    print_f(rs->plogs, "P11", rs->logs);

                    sprintf(syscmd11, "/root/module/gadgetRemove.sh");
                    ret = doSystemCmd(syscmd11);
                    if (!ret) {
                        sprintf(syscmd11, "/root/module/gadgetLaunch.sh");
                        ret = doSystemCmd(syscmd11);
            
                        usleep(2000000);
                    }
                    
                    idlcnt = 0;            
                }
                #endif
            
            }
            #endif
        
            #if USB_PC_IDLE_CHK /* idle disconnect */
            if (usbfd) {
                idlcnt++;

                if (idlcnt > 120) {
                    
                    ret = epoll_ctl (epollfd, EPOLL_CTL_DEL, usbfd, NULL);
                    if (ret == -1) {
                        perror ("epoll_ctl");
                        sprintf_f(rs->logs, "rs usb spoll del ctl failed errno: %ds\n", errno);
                        print_f(rs->plogs, "P11", rs->logs);
                    }

                    close(rs->usbdvid);
                    rs->usbdvid = 0;
                    usbfd = 0;
                    idlcnt = 0;
                    usbentsRx = 0;
                    usbentsTx = 0;
                    //sprintf_f(rs->logs, "close device[%s] idle \n", rs->usvdvname); 
                    //print_f(rs->plogs, "P11", rs->logs);

                    sprintf(syscmd11, "/root/module/gadgetRemove.sh");
                    ret = doSystemCmd(syscmd11);
                    if (!ret) {
                        sprintf(syscmd11, "/root/module/gadgetLaunch.sh");
                        ret = doSystemCmd(syscmd11);

                        usleep(2000000);
                    }

                    continue;
                }
                else {
                    #if 0 
                    sprintf_f(rs->logs, "pc usb idle cnt: %d\n", idlcnt);
                    print_f(rs->plogs, "P11", rs->logs);
                    #endif
                }
            }
            #endif

            if ((pinfushost) && (pinfushostd)) {
                if (pollcnt == 0) {
                    if (((pinfushost->ushostpidvid[1] != 0) && 
                         (pinfushost->ushostpidvid[1] != 0x0a01) && 
                         (pinfushost->ushostpidvid[1] != 0x0a02)) &&
                         ((pinfushostd->ushostpidvid[1] != 0) && 
                         (pinfushostd->ushostpidvid[1] != 0x0a01) && 
                         (pinfushostd->ushostpidvid[1] != 0x0a02))) {
                        #if USB_BOOTUP_SYNC
                        cmd = 0x11;
                        opc = 0x4e;
                        dat = 0x00;
                        
                        iubs->opinfo = opc << 8 | dat;
                        memcpy(iubsBuff, cbw, 31);
                        iubsBuff[15] = cmd;
                        iubsBuff[16] = opc;
                        iubsBuff[17] = dat;
                        
                        sprintf_f(rs->logs, "[DVl] BOOT-UP sync opc: 0x4e dump \n");
                        print_f(rs->plogs, "P11", rs->logs);
                        
                        shmem_dump(iubsBuff, 31);
                        
                        puscur = pushost;      
                        pinfcur = pinfushost;
                        
                        if (strcmp(msgcmd, "usbscan") != 0) {
                            sprintf(msgcmd, "usbscan");
                            rs_ipc_put(rcmd, msgcmd, strlen(msgcmd));
                            chq = 'n';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }      
                        
                        chq = 'i';
                        if (usbid01) {
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV] Error!! pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                        
                        #if BYPASS_TWO
                        chd = 'i';
                        if (usbid02) {
                            pipRet = write(pipeTxd[1], &chd, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                        #endif
                        #endif //#if USB_BOOTUP_SYNC
                    }
                    #if 0
                    if ((pinfushostd->ushostpidvid[1] != 0) && 
                         (pinfushostd->ushostpidvid[1] != 0x0a01) && 
                         (pinfushostd->ushostpidvid[1] != 0x0a02)) {
                        #if USB_BOOTUP_SYNC
                        #if BYPASS_TWO
                        cmd = 0x11;
                        opc = 0x4e;
                        dat = 0x00;
                        
                        iubs->opinfo = opc << 8 | dat;
                        memcpy(iubsBuff, cbw, 31);
                        iubsBuff[15] = cmd;
                        iubsBuff[16] = opc;
                        iubsBuff[17] = dat;
                        
                        sprintf_f(rs->logs, "[DVl] BOOT-UP sync opc: 0x4e dump \n");
                        print_f(rs->plogs, "P11", rs->logs);
                        
                        shmem_dump(iubsBuff, 31);
                        
                        puscur = pushost;      
                        pinfcur = pinfushost;
                        
                        if (strcmp(msgcmd, "usbscan") != 0) {
                            sprintf(msgcmd, "usbscan");
                            rs_ipc_put(rcmd, msgcmd, strlen(msgcmd));
                            chq = 'n';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }      
                        
                        #if 0
                        chq = 'i';
                        if (usbid01) {
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV] Error!! pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                        #endif
                        
                        chd = 'i';
                        if (usbid02) {
                            pipRet = write(pipeTxd[1], &chd, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                        #endif
                        #endif //#if USB_BOOTUP_SYNC
                    }
                    #endif
                    pollcnt ++;
                }
                else {
                    pollcnt ++;
                }
            }
            //continue;
        }
        else {

            rxfd = 0;
            for (ix = 0; ix < uret; ix++) {
                if (getevents[ix].data.fd == usbfd) {
                
                    getents = getevents[ix].events;

                    if (getents & EPOLLIN) {
                        usbentsRx = 1;
                    }

                    if (getents & EPOLLOUT) {
                        usbentsTx = 1;
                    }
                    
                    rxfd = getevents[ix].data.fd;

                    idlcnt = 0;
                    break;
                }
                else if (getevents[ix].data.fd == rcmd->ppipedn->rt[0]) {
                    memset(msgret, 0, 64);
                    ret = rs_ipc_get_ms(rcmd, msgret, 64, 10);
                    while (ret > 0) {
                        sprintf_f(rs->logs, "get cmd retrun msg: <%s> ret: %d\n", msgret, ret);
                        print_f(rs->plogs, "P11", rs->logs);

                        memset(msgret, 0, 64);
                        ret = rs_ipc_get_ms(rcmd, msgret, 64, 10);
                    }
                } 
                else if (getevents[ix].data.fd == rs->ppipedn->rt[0]) {

                    sprintf_f(rs->logs, "[ePol] timeout errno: %d ret: %d\n", errno, uret);
                    print_f(rs->plogs, "P11", rs->logs);

                    chw = 0;
                    ret = rs_ipc_get_ms(rs, &chw, 1, 10);
                    while (ret < 0) {
                        sprintf_f(rs->logs, "pget cmd: %c ret: %d\n", chw, ret);
                        print_f(rs->plogs, "P11", rs->logs);

                        ret = rs_ipc_get_ms(rs, &chw, 1, 10);
                    }

                    sprintf_f(rs->logs, "pget cmd: %c ret: %d\n", chw, ret);
                    print_f(rs->plogs, "P11", rs->logs);
                    
                    switch (chw) {
                    case 'p':
                        cmd = 0x11;
                        opc = 0x4d;
                        dat = 0x00;

                        iubs->opinfo = opc << 8 | dat;
                        memcpy(iubsBuff, cbw, 31);
                        iubsBuff[15] = cmd;
                        iubsBuff[16] = opc;
                        iubsBuff[17] = dat;

                        puscur = pushost;                    
                        pinfcur = pinfushost;

                        #if 1
                        sprintf(msgcmd, "usbscan");
                        #else
                        if (strcmp(msgcmd, "usbscan") != 0) {
                            sprintf(msgcmd, "usbscan");
                            rs_ipc_put(rcmd, msgcmd, strlen(msgcmd));
                            chq = 'n';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }      
                        #endif

                        chq = 'n';
                        pipRet = write(pipeTx[1], &chq, 1);
                        if (pipRet < 0) {
                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                            print_f(rs->plogs, "P11", rs->logs);
                            continue;
                        }

                        chq = 'i';
                        if (usbid01) {
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV] Error!! pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }

                        #if BYPASS_TWO
                        chd = 'i';
                        if (usbid02) {
                            pipRet = write(pipeTxd[1], &chd, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                        #endif

                        usbCur = puscur->pushring;

                        piptx = puscur->pushtx;
                        piprx = puscur->pushrx; 
                        
                        break;
                    case 'm':

                        cmd = 0x11;
                        opc = 0x4c;
                        dat = 0x01;
                        
                        iubs->opinfo = opc << 8 | dat;
                        memcpy(iubsBuff, cbw, 31);
                        iubsBuff[15] = cmd;
                        iubsBuff[16] = opc;
                        iubsBuff[17] = dat;
                        
                        aspMetaBuild(ASPMETA_FUNC_CONF, 0, rs);
                        //dbgMeta(msb2lsb32(&ptmetaout->FUNC_BITS), ptmetaout);

                        #if DBG_27_DV
                        shmem_dump((char*)ptmetaout, 512);
                        #endif
                
                        #if 0 /* save meta */
                        fsmeta = find_save(ptfilepath, ptfileSaveWifiMeta);
                        if (fsmeta) {
                            sprintf_f(rs->logs, "[DV] find save wifi meta [%s] succeed!!! \n", ptfilepath);
                            print_f(rs->plogs, "P11", rs->logs);
                
                            wrtsz = fwrite((char*)ptmetaout, 1, 512, fsmeta);
                            sync();
                            fclose(fsmeta);
                        }
                        #endif
                    
                        memcpy(metaPt, (char*)ptmetaout, 512);
                        msync(metaPt, 512, MS_SYNC);
                
                        if ((metaRx->ASP_MAGIC[0] != 0x20) || (metaRx->ASP_MAGIC[1] != 0x14)) {
                            break;
                        }

                        //dbgMeta(msb2lsb32(&metaRx->FUNC_BITS), metaRx);
                        
                        #if 1
                        sprintf(msgcmd, "usbscan");
                        #else
                        if (strcmp(msgcmd, "usbscan") != 0) {
                            sprintf(msgcmd, "usbscan");
                            rs_ipc_put(rcmd, msgcmd, strlen(msgcmd));
                            chq = 'n';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }      
                        #endif
                        
                        //sprintf_f(rs->logs, "[DV] clean start \n");
                        //print_f(rs->plogs, "P11", rs->logs);
                        
                        #if 1  /* clean msg queue */
                        while (1) {
                            chq = 0;
                            pipRet = read(pipeRx[0], &chq, 1);
                            if (pipRet < 0) {
                                break;
                            }
                            else {
                                sprintf_f(rs->logs, "[DV] clean pipe get chq: (0x%.2x) \n", chq);
                                print_f(rs->plogs, "P11", rs->logs);
                            }
                        }
                
                        while (1) {
                            chd = 0;
                            pipRet = read(pipeRxd[0], &chd, 1);
                            if (pipRet < 0) {
                                break;
                            }
                            else {
                                sprintf_f(rs->logs, "[DV] clean pipe get chd: (0x%.2x) \n", chd);
                                print_f(rs->plogs, "P11", rs->logs);
                            }
                        }
                    
                        //sprintf_f(rs->logs, "[DV] clean middle - 1 \n");
                        //print_f(rs->plogs, "P11", rs->logs);

                        if (puimCnTH) {
                            ix=0;
                            puimTmp = puimCnTH;
                            while(puimTmp) {
                                sprintf_f(rs->logs, "[DV] clean H %d - 0x%.2x %d:%d \n", ix, puimTmp->uimIdex, puimTmp->uimGetCnt, puimTmp->uimCount);
                                print_f(rs->plogs, "P11", rs->logs);
                                puimUse = puimTmp;
                                puimTmp = puimUse->uimNxt;
                                ix++;
                
                                free(puimUse);
                            }
                            puimCnTH = 0;
                            puimCur = 0;
                            puimGet = 0;
                            puimCud = 0;
                        }
                
                        if (puimGet) {
                            ix=0;
                            puimTmp = puimGet;
                            while(puimTmp) {
                                sprintf_f(rs->logs, "[DV] clean G %d - 0x%.2x %d:%d \n", ix, puimTmp->uimIdex, puimTmp->uimGetCnt, puimTmp->uimCount);
                                print_f(rs->plogs, "P11", rs->logs);
                                puimUse = puimTmp;
                                puimTmp = puimUse->uimNxt;
                                ix++;
                
                                free(puimUse);
                            }
                
                            puimGet = 0;
                        }
                
                        endf = 0;
                        endm = 0;
                
                        distCylcnt = 0;
                        uimCylcnt = 0;
                        datCylcnt = 0;
                        lastCylen = 0;
                        waitCylen = 0;
                        rwaitCylen = 0;
                        maxCylcnt = 0;
                
                        cswerr = 0;
                        pagerst = 2;
                        #endif
                    
                        //sprintf_f(rs->logs, "[DV] clean end \n");
                        //print_f(rs->plogs, "P11", rs->logs);
                        
                        chq = 'n';
                        pipRet = write(pipeTx[1], &chq, 1);
                        if (pipRet < 0) {
                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                            print_f(rs->plogs, "P11", rs->logs);
                            continue;
                        }

                        #if 1
                        if (usbid01) {
                            chq = 'm';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                        #endif
                        
                        #if 0 // do it at tx
                        if (usbid01) {
                        while(1) {
                            ret = poll(ptfd, 1, 10);
                        
                            if (ret > 0) {
                                chq = 0;
                                pipRet = read(pipeRx[0], &chq, 1);
                        
                                if (pipRet > 0) {
                                    sprintf_f(rs->logs, "[DV] cmd:0x%.2x opc:0x%.2x get chr:0x%.2x \n", cmd, opc, chq);
                                    print_f(rs->plogs, "P11", rs->logs);
                        
                                    break;
                                }
                            }
                        }
                        
                        if (chq != 'J') {
                            sprintf_f(rs->logs, "[DV] poll status unknown result, ret: %c (0x%.2x) \n", chq, chq);
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                        
                        while(1) {
                            ret = poll(ptfd, 1, 10);
                        
                            if (ret > 0) {
                                chn = 0;
                                pipRet = read(pipeRx[0], &chn, 1);
                        
                                if (pipRet > 0) {
                                    sprintf_f(rs->logs, "[DV] cmd:0x%.2x opc:0x%.2x get chr:0x%.2x \n", cmd, opc, chn);
                                    print_f(rs->plogs, "P11", rs->logs);
                        
                                    break;
                                }
                            }
                        }
                        
                        if (chn) {
                            sprintf_f(rs->logs, "[DV] poll status : (0x%.2x) \n", chn);
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                        }
                        #endif

                        #if 0
                        if (usbid02) {
                            chd = 'm';
                            pipRet = write(pipeTxd[1], &chd, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                        #endif

                        #if 0
                        //chq = 'x';
                        msgret[0] = 'x';
                        msgret[1] = 0x01;
                        pipRet = write(pipeTx[1], &msgret, 2);
                        if (pipRet < 0) {
                            printf("[DV] Error!!! pipe send scan stop ret: %d \n", pipRet);
                        }
                        
                        sprintf(msgcmd, "usbidle");
                        
                        ret = rs_ipc_get_ms(rcmd, rcmd->logs, 4096, 500);
                        if (ret > 0) {
                            rcmd->logs[ret] = '\n';

                            sprintf_f(rs->logs, "[DV]  get usbscan result ret: %d\n", ret);
                            print_f(rs->plogs, "P11", rs->logs);   

                            print_f(rcmd->plogs, "C11", rcmd->logs);
                        }
                        #endif

                        break;
                    case 's':
                    
                        cmd = 0x12;
                        opc = 0x04;
                        dat = 0x85;

                        iubs->opinfo = opc << 8 | dat;
                        memcpy(iubsBuff, cbw, 31);
                        iubsBuff[15] = cmd;
                        iubsBuff[16] = opc;
                        iubsBuff[17] = dat;
                        
                        endf = 0;
                        endm = 0;

                        distCylcnt = 0;
                        uimCylcnt = 0;
                        datCylcnt = 0;
                        lastCylen = 0;
                        waitCylen = 0;
                        rwaitCylen = 0;
                        maxCylcnt = 0;
                        
                        cswerr = 0;
                        cswstatus[0] = 0;
                        cswstatus[1] = 0;
                        pagerst = 2;
                        
                        clock_gettime(CLOCK_REALTIME, &tidleS);
                        clock_gettime(CLOCK_REALTIME, &tidleE);                            

                        puscur = pushost;                    
                        pinfcur = pinfushost;
                        
                        usbCur = puscur->pushring;

                        piptx = puscur->pushtx;
                        piprx = puscur->pushrx; 

                        acusz = 0;

                        ring_buf_init(rs->pcmdRx);
                        rs_ipc_put(rs, "s", 1);
                        
                        #if 1
                        sprintf(msgcmd, "usbscan");
                        #else
                        if (strcmp(msgcmd, "usbscan") != 0) {
                            sprintf(msgcmd, "usbscan");
                            rs_ipc_put(rcmd, msgcmd, strlen(msgcmd));
                            chq = 'n';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }      
                        #endif
                        
                        chq = 'n';
                        pipRet = write(pipeTx[1], &chq, 1);
                        if (pipRet < 0) {
                            sprintf_f(rs->logs, "[DV] Error!!! pipe send meta ret: %d \n", pipRet);
                            print_f(rs->plogs, "P11", rs->logs);
                            continue;
                        }
                        if (usbid01) {
                            chq = 'm';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }

                        if (usbid01) {
                        while(1) {
                            ret = poll(ptfd, 1, 10);
                        
                            if (ret > 0) {
                                chq = 0;
                                pipRet = read(pipeRx[0], &chq, 1);
                        
                                if (pipRet > 0) {
                                    sprintf_f(rs->logs, "[DV] cmd:0x%.2x opc:0x%.2x get chr:0x%.2x \n", cmd, opc, chq);
                                    print_f(rs->plogs, "P11", rs->logs);
                        
                                    break;
                                }
                            }
                        }
                        
                        if (chq != 'J') {
                            sprintf_f(rs->logs, "[DV] poll status unknown result, ret: %c (0x%.2x) \n", chq, chq);
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                        
                        while(1) {
                            ret = poll(ptfd, 1, 10);
                        
                            if (ret > 0) {
                                chn = 0;
                                pipRet = read(pipeRx[0], &chn, 1);
                        
                                if (pipRet > 0) {
                                    sprintf_f(rs->logs, "[DV] cmd:0x%.2x opc:0x%.2x get chr:0x%.2x \n", cmd, opc, chn);
                                    print_f(rs->plogs, "P11", rs->logs);
                        
                                    break;
                                }
                            }
                        }
                        
                        if (chn) {
                            sprintf_f(rs->logs, "[DV] poll status : (0x%.2x) \n", chn);
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                        }

                        #if 1
                        if (usbid02) {
                            chd = 'm';
                            pipRet = write(pipeTxd[1], &chd, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                        #endif
                        
                        #if BYPASS_TWO
                        if (usbid02) {
                            while (1) {
                                chd = 0;
                                pipRet = read(pipeRxd[0], &chd, 1);
                                if (pipRet > 0) {
                                    break;
                                }
                            }
                            
                            if (chd != 'J') {
                                sprintf_f(rs->logs, "[DV] polld status unknown result, ret: %c (0x%.2x) \n", chd, chd);
                                print_f(rs->plogs, "P11", rs->logs);
                            }
                            
                            chm = 0;
                            while (1) {
                                pipRet = read(pipeRxd[0], &chm, 1);
                                if (pipRet < 0) {
                                    break;
                                }
                            }
                            
                            if (chm) {
                                sprintf_f(rs->logs, "[DV] polld status : (0x%.2x) \n", chm);
                                print_f(rs->plogs, "P11", rs->logs);
                            }
                        }
                        #endif

                        if (usbid01) {
                            chq = 'a';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  Error!!! pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
    
                            chq = 'd';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  Error!!! pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                        
                        break;
                    case 'r':

                        cmd = 0x12;
                        opc = 0x09;
                        dat = 0x85;
                        
                        iubs->opinfo = opc << 8 | dat;
                        memcpy(iubsBuff, cbw, 31);
                        iubsBuff[15] = cmd;
                        iubsBuff[16] = opc;
                        iubsBuff[17] = dat;
                        
                        endf = 0;
                        endm = 0;

                        distCylcnt = 0;
                        uimCylcnt = 0;
                        datCylcnt = 0;
                        lastCylen = 0;
                        waitCylen = 0;
                        rwaitCylen = 0;
                        maxCylcnt = 0;
                        
                        cswerr = 0;
                        cswstatus[0] = 0;
                        cswstatus[1] = 0;

                        pagerst = 2;
                        
                        clock_gettime(CLOCK_REALTIME, &tidleS);
                        clock_gettime(CLOCK_REALTIME, &tidleE);                            

                        puscur = pushost;                    
                        pinfcur = pinfushost;
                        
                        usbCur = puscur->pushring;

                        piptx = puscur->pushtx;
                        piprx = puscur->pushrx; 

                        acusz = 0;

                        ring_buf_init(rs->pcmdRx);
                        rs_ipc_put(rs, "s", 1);
                        
                        #if 1
                        sprintf(msgcmd, "usbscan");
                        #else
                        if (strcmp(msgcmd, "usbscan") != 0) {
                            sprintf(msgcmd, "usbscan");
                            rs_ipc_put(rcmd, msgcmd, strlen(msgcmd));
                            chq = 'n';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }      
                        #endif
                        
                        chq = 'n';
                        pipRet = write(pipeTx[1], &chq, 1);
                        if (pipRet < 0) {
                            sprintf_f(rs->logs, "[DV] Error!!! pipe send meta ret: %d \n", pipRet);
                            print_f(rs->plogs, "P11", rs->logs);
                            continue;
                        }
                        if (usbid01) {
                            chq = 'm';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }

                        #if 0
                        if (usbid02) {
                            chd = 'm';
                            pipRet = write(pipeTxd[1], &chd, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                        #endif

                        if (usbid01) {
                            while(1) {
                                ret = poll(ptfd, 1, 10);
                            
                                if (ret > 0) {
                                    chq = 0;
                                    pipRet = read(pipeRx[0], &chq, 1);
                            
                                    if (pipRet > 0) {
                                        sprintf_f(rs->logs, "[DV] cmd:0x%.2x opc:0x%.2x get chr:0x%.2x \n", cmd, opc, chq);
                                        print_f(rs->plogs, "P11", rs->logs);
                            
                                        break;
                                    }
                                }
                            }
                            
                            if (chq != 'J') {
                                sprintf_f(rs->logs, "[DV] poll status unknown result, ret: %c (0x%.2x) \n", chq, chq);
                                print_f(rs->plogs, "P11", rs->logs);
                            }
                            
                            while(1) {
                                ret = poll(ptfd, 1, 10);
                            
                                if (ret > 0) {
                                    chn = 0;
                                    pipRet = read(pipeRx[0], &chn, 1);
                            
                                    if (pipRet > 0) {
                                        sprintf_f(rs->logs, "[DV] cmd:0x%.2x opc:0x%.2x get chr:0x%.2x \n", cmd, opc, chn);
                                        print_f(rs->plogs, "P11", rs->logs);
                            
                                        break;
                                    }
                                }
                            }
                            
                            if (chn) {
                                sprintf_f(rs->logs, "[DV] poll status : (0x%.2x) \n", chn);
                                print_f(rs->plogs, "P11", rs->logs);
                            }
                        }

                        #if 1
                        if (usbid02) {
                            chd = 'm';
                            pipRet = write(pipeTxd[1], &chd, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                        #endif
                        
                        #if BYPASS_TWO
                        if (usbid02) {
                            while (1) {
                                chd = 0;
                                pipRet = read(pipeRxd[0], &chd, 1);
                                if (pipRet > 0) {
                                    break;
                                }
                            }
                            
                            if (chd != 'J') {
                                sprintf_f(rs->logs, "[DV] polld status unknown result, ret: %c (0x%.2x) \n", chd, chd);
                                print_f(rs->plogs, "P11", rs->logs);
                            }
                            
                            chm = 0;
                            while (1) {
                                pipRet = read(pipeRxd[0], &chm, 1);
                                if (pipRet < 0) {
                                    break;
                                }
                            }
                            
                            if (chm) {
                                sprintf_f(rs->logs, "[DV] polld status : (0x%.2x) \n", chm);
                                print_f(rs->plogs, "P11", rs->logs);
                            }
                        }
                        #endif
                        
                        if (usbid01) {
                            chq = 'k';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
    
                            chq = 'c';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }

                        break;
                    case 't':
                        cmd = 0x12;
                        opc = 0x09;
                        dat = 0x85;
                        
                        iubs->opinfo = opc << 8 | dat;
                        memcpy(iubsBuff, cbw, 31);
                        iubsBuff[15] = cmd;
                        iubsBuff[16] = opc;
                        iubsBuff[17] = dat;
                        
                        distCylcnt = 0;
                        uimCylcnt = 0;
                        datCylcnt = 0;
                        lastCylen = 0;
                        waitCylen = 0;
                        maxCylcnt = 0;
                        
                        clock_gettime(CLOCK_REALTIME, &tidleS);
                        clock_gettime(CLOCK_REALTIME, &tidleE);                            

                        puscur = pushost;                    
                        pinfcur = pinfushost;
                        
                        usbCur = puscur->pushring;

                        piptx = puscur->pushtx;
                        piprx = puscur->pushrx; 

                        ring_buf_init(rs->pcmdRx);
                        rs_ipc_put(rs, "s", 1);

                        break;
                    case 'n':

                        cmd = 0x12;
                        opc = 0x05;
                        dat = 0x85;
                        
                        iubs->opinfo = opc << 8 | dat;
                        memcpy(iubsBuff, cbw, 31);
                        iubsBuff[15] = cmd;
                        iubsBuff[16] = opc;
                        iubsBuff[17] = dat;
                        
                        endf = 0;
                        endm = 0;

                        distCylcnt = 0;
                        uimCylcnt = 0;
                        datCylcnt = 0;
                        lastCylen = 0;
                        waitCylen = 0;
                        rwaitCylen = 0;
                        maxCylcnt = 0;
                        
                        cswerr = 0;
                        cswstatus[0] = 0;
                        cswstatus[1] = 0;

                        pagerst = 2;
                        
                        clock_gettime(CLOCK_REALTIME, &tidleS);
                        clock_gettime(CLOCK_REALTIME, &tidleE);                            
                        
                        #if 1
                        if ((puimGet) && ((opc == 0x05) || (opc == 0x0a))) {
                            sprintf_f(rs->logs, "[DV] q app duo puimGet index: 0x%.3x \n", puimGet->uimIdex);
                            print_f(rs->plogs, "P11", rs->logs);

                            if ((puimGet->uimIdex & 0x400) == 0) {
                                puscur = pushost;
                                pinfcur = pinfushost;
                                usbCur = puscur->pushring;
                                piptx = puscur->pushtx;
                                piprx = puscur->pushrx; 
                            } else {
                                puscur = pushostd;
                                pinfcur = pinfushostd;
                                usbCur = puscur->pushring;
                                piptx = puscur->pushtx;
                                piprx = puscur->pushrx; 
                            }
                        } else {
                            puscur = pushostd;
                            pinfcur = pinfushostd;
                            usbCur = puscur->pushring;
                            piptx = puscur->pushtx;
                            piprx = puscur->pushrx; 
                            
                            sprintf_f(rs->logs, "[DV] q app duo puimGet is null get next \n");
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                        #else   
                        puscur = pushost;                    
                        pinfcur = pinfushost;
                        
                        usbCur = puscur->pushring;

                        piptx = puscur->pushtx;
                        piprx = puscur->pushrx; 
                        #endif
                        
                        ring_buf_init(rs->pcmdRx);
                        rs_ipc_put(rsd, "s", 1);

                        #if 1
                        sprintf(msgcmd, "usbscan");
                        #else
                        if (strcmp(msgcmd, "usbscan") != 0) {
                            sprintf(msgcmd, "usbscan");
                            rs_ipc_put(rcmd, msgcmd, strlen(msgcmd));
                            chq = 'n';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }      
                        #endif
                        
                        acusz = 0;
                        
                        chq = 'n';
                        pipRet = write(pipeTx[1], &chq, 1);
                        if (pipRet < 0) {
                            sprintf_f(rs->logs, "[DV] Error!!! pipe send meta ret: %d \n", pipRet);
                            print_f(rs->plogs, "P11", rs->logs);
                            continue;
                        }
                        
                        if (usbid01) {
                            chq = 'm';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }

                        #if 0
                        if (usbid02) {
                            chd = 'm';
                            pipRet = write(pipeTxd[1], &chd, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                        #endif

                        if (usbid01) {
                            while(1) {
                                ret = poll(ptfd, 1, 10);
                            
                                if (ret > 0) {
                                    chq = 0;
                                    pipRet = read(pipeRx[0], &chq, 1);
                            
                                    if (pipRet > 0) {
                                        sprintf_f(rs->logs, "[DV] cmd:0x%.2x opc:0x%.2x get chr:0x%.2x \n", cmd, opc, chq);
                                        print_f(rs->plogs, "P11", rs->logs);
                            
                                        break;
                                    }
                                }
                            }
                            
                            if (chq != 'J') {
                                sprintf_f(rs->logs, "[DV] poll status unknown result, ret: %c (0x%.2x) \n", chq, chq);
                                print_f(rs->plogs, "P11", rs->logs);
                            }
                            
                            while(1) {
                                ret = poll(ptfd, 1, 10);
                            
                                if (ret > 0) {
                                    chn = 0;
                                    pipRet = read(pipeRx[0], &chn, 1);
                            
                                    if (pipRet > 0) {
                                        sprintf_f(rs->logs, "[DV] cmd:0x%.2x opc:0x%.2x get chr:0x%.2x \n", cmd, opc, chn);
                                        print_f(rs->plogs, "P11", rs->logs);
                            
                                        break;
                                    }
                                }
                            }
                            
                            if (chn) {
                                sprintf_f(rs->logs, "[DV] poll status : (0x%.2x) \n", chn);
                                print_f(rs->plogs, "P11", rs->logs);
                            }
                        }

                        #if 1
                        if (usbid02) {
                            chd = 'm';
                            pipRet = write(pipeTxd[1], &chd, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                        #endif
                        
                        #if BYPASS_TWO
                        if (usbid02) {
                            while (1) {
                                chd = 0;
                                pipRet = read(pipeRxd[0], &chd, 1);
                                if (pipRet > 0) {
                                    break;
                                }
                            }
                            
                            if (chd != 'J') {
                                sprintf_f(rs->logs, "[DV] polld status unknown result, ret: %c (0x%.2x) \n", chd, chd);
                                print_f(rs->plogs, "P11", rs->logs);
                            }
                            
                            chm = 0;
                            while (1) {
                                pipRet = read(pipeRxd[0], &chm, 1);
                                if (pipRet < 0) {
                                    break;
                                }
                            }
                            
                            if (chm) {
                                sprintf_f(rs->logs, "[DV] polld status : (0x%.2x) \n", chm);
                                print_f(rs->plogs, "P11", rs->logs);
                            }
                        }
                        #endif
                        if (usbid01) {
                            chq = 's';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  Error!!! pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                        
                        if (usbid02) {
                            chd = 's';
                            pipRet = write(pipeTxd[1], &chd, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  Error!!! pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                        
                        if (usbid01) {
                            chq = 'p';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV] Error!!! pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }

                        if (usbid02) {
                            chd = 'p';
                            pipRet = write(pipeTxd[1], &chd, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV] Error!!! pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }

                        break;
                    case 'q':
                    
                        cmd = 0x12;
                        opc = 0x0a;
                        dat = 0x85;

                        iubs->opinfo = opc << 8 | dat;
                        memcpy(iubsBuff, cbw, 31);
                        iubsBuff[15] = cmd;
                        iubsBuff[16] = opc;
                        iubsBuff[17] = dat;
                        
                        endf = 0;
                        endm = 0;

                        distCylcnt = 0;
                        uimCylcnt = 0;
                        datCylcnt = 0;
                        lastCylen = 0;
                        waitCylen = 0;
                        rwaitCylen = 0;
                        maxCylcnt = 0;
                        
                        cswerr = 0;
                        cswstatus[0] = 0;
                        cswstatus[1] = 0;

                        pagerst = 2;
                        
                        clock_gettime(CLOCK_REALTIME, &tidleS);
                        clock_gettime(CLOCK_REALTIME, &tidleE);                            
                        
                        #if 1
                        puscur = pushost;                    
                        pinfcur = pinfushost;
                        
                        usbCur = puscur->pushring;

                        piptx = puscur->pushtx;
                        piprx = puscur->pushrx; 
                        
                        ring_buf_init(rs->pcmdRx);
                        rs_ipc_put(rsd, "s", 1);
                        #endif

                        #if 1
                        sprintf(msgcmd, "usbscan");
                        #else
                        if (strcmp(msgcmd, "usbscan") != 0) {
                            sprintf(msgcmd, "usbscan");
                            rs_ipc_put(rcmd, msgcmd, strlen(msgcmd));
                            chq = 'n';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }      
                        #endif
                        
                        acusz = 0;
                        
                        chq = 'n';
                        pipRet = write(pipeTx[1], &chq, 1);
                        if (pipRet < 0) {
                            sprintf_f(rs->logs, "[DV] Error!!! pipe send meta ret: %d \n", pipRet);
                            print_f(rs->plogs, "P11", rs->logs);
                            continue;
                        }
                        
                        if (usbid01) {
                            chq = 'm';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }

                        #if 0
                        if (usbid02) {
                            chd = 'm';
                            pipRet = write(pipeTxd[1], &chd, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                        #endif

                        if (usbid01) {
                            while(1) {
                                ret = poll(ptfd, 1, 10);
                            
                                if (ret > 0) {
                                    chq = 0;
                                    pipRet = read(pipeRx[0], &chq, 1);
                            
                                    if (pipRet > 0) {
                                        sprintf_f(rs->logs, "[DV] usbid01 1st cmd:0x%.2x opc:0x%.2x get chr:0x%.2x \n", cmd, opc, chq);
                                        print_f(rs->plogs, "P11", rs->logs);
                            
                                        break;
                                    }
                                }
                            }
                            
                            if (chq != 'J') {
                                sprintf_f(rs->logs, "[DV] usbid01 1st poll status unknown result, chq: %c (0x%.2x) \n", chq, chq);
                                print_f(rs->plogs, "P11", rs->logs);
                            }
                            
                            while(1) {
                                ret = poll(ptfd, 1, 10);
                            
                                if (ret > 0) {
                                    chn = 0;
                                    pipRet = read(pipeRx[0], &chn, 1);
                            
                                    if (pipRet > 0) {
                                        sprintf_f(rs->logs, "[DV] usbid01 2nd cmd:0x%.2x opc:0x%.2x get chr:0x%.2x \n", cmd, opc, chn);
                                        print_f(rs->plogs, "P11", rs->logs);
                            
                                        break;
                                    }
                                }
                            }
                            
                            if (chn) {
                                sprintf_f(rs->logs, "[DV] usbid01 2nd poll status : (0x%.2x) \n", chn);
                                print_f(rs->plogs, "P11", rs->logs);
                            }
                        }

                        #if 1
                        if (usbid02) {
                            chd = 'm';
                            pipRet = write(pipeTxd[1], &chd, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                        #endif
                        
                        #if BYPASS_TWO
                        if (usbid02) {
                            while (1) {
                                chd = 0;
                                pipRet = read(pipeRxd[0], &chd, 1);
                                if (pipRet > 0) {
                                    break;
                                }
                            }
                            
                            if (chd != 'J') {
                                sprintf_f(rs->logs, "[DV] polld status unknown result, ret: %c (0x%.2x) \n", chd, chd);
                                print_f(rs->plogs, "P11", rs->logs);
                            }
                            
                            chm = 0;
                            while (1) {
                                pipRet = read(pipeRxd[0], &chm, 1);
                                if (pipRet < 0) {
                                    break;
                                }
                            }
                            
                            if (chm) {
                                sprintf_f(rs->logs, "[DV] polld status : (0x%.2x) \n", chm);
                                print_f(rs->plogs, "P11", rs->logs);
                            }
                        }
                        #endif
                        
                        if (usbid01) {
                            chq = 'r';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }

                        if (usbid02) {
                            chd = 'r';
                            pipRet = write(pipeTxd[1], &chd, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                        
                        if (usbid01) {
                            chq = 'q';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }

                        if (usbid02) {
                            chd = 'q';
                            pipRet = write(pipeTxd[1], &chd, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }

                        break;
                    case 'e':

                        sprintf_f(rs->logs, "stop usb transmitting now!!! \n");
                        print_f(rs->plogs, "P11", rs->logs);
                        
                        if (usbid01) {
                            chq = 'b';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                        
                        if (usbid02) {
                            chd = 'b';
                            pipRet = write(pipeTxd[1], &chd, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }

                        cmd = 0;
                        opc = 0;
                        dat = 0;
                        
                        break;
                    case 'o':
                        
                        cmd = 0x12;
                        opc = 0x0a;
                        dat = 0x85;
                        
                        iubs->opinfo = opc << 8 | dat;
                        memcpy(iubsBuff, cbw, 31);
                        iubsBuff[15] = cmd;
                        iubsBuff[16] = opc;
                        iubsBuff[17] = dat;
                        
                        distCylcnt = 0;
                        uimCylcnt = 0;
                        datCylcnt = 0;
                        lastCylen = 0;
                        waitCylen = 0;
                        maxCylcnt = 0;
                        
                        clock_gettime(CLOCK_REALTIME, &tidleS);
                        clock_gettime(CLOCK_REALTIME, &tidleE);                            
                        
                        #if 1
                        if ((puimGet) && ((opc == 0x05) || (opc == 0x0a))) {
                            sprintf_f(rs->logs, "[DV] app puimGet index: 0x%.3x \n", puimGet->uimIdex);
                            print_f(rs->plogs, "P11", rs->logs);

                            if ((puimGet->uimIdex & 0x400) == 0) {
                                puscur = pushost;
                                pinfcur = pinfushost;
                                usbCur = puscur->pushring;
                                piptx = puscur->pushtx;
                                piprx = puscur->pushrx; 
                            } else {
                                puscur = pushostd;
                                pinfcur = pinfushostd;
                                usbCur = puscur->pushring;
                                piptx = puscur->pushtx;
                                piprx = puscur->pushrx; 
                            }
                        } else {
                            puscur = pushost;                    
                            pinfcur = pinfushost;
                        
                            usbCur = puscur->pushring;

                            piptx = puscur->pushtx;
                            piprx = puscur->pushrx;  
                        
                            sprintf_f(rs->logs, "[DV] app puimGet is null get next \n");
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                        #else
                        puscur = pushost;                    
                        pinfcur = pinfushost;
                        
                        usbCur = puscur->pushring;

                        piptx = puscur->pushtx;
                        piprx = puscur->pushrx;                         
                        #endif
                        ring_buf_init(rs->pcmdRx);
                        rs_ipc_put(rsd, "s", 1);

                        break;
                    default:
                        break;
                    }

                    rxfd = rs->ppipedn->rt[0];
                    idlcnt = 0;
                    break;
                }
                else if (getevents[ix].data.fd == rsd->ppipedn->rt[0]) {

                    sprintf_f(rs->logs, "[ePol] timeout errno: %d ret: %d\n", errno, uret);
                    print_f(rs->plogs, "P11", rs->logs);

                    chy = 0;
                    ret = rs_ipc_get_ms(rsd, &chy, 1, 10);
                    while (ret < 0) {
                        sprintf_f(rs->logs, "sget duo cmd: %c ret: %d\n", chy, ret);
                        print_f(rs->plogs, "P11", rs->logs);

                        ret = rs_ipc_get_ms(rsd, &chy, 1, 10);
                    }

                    sprintf_f(rs->logs, "sget duo cmd: %c ret: %d\n", chy, ret);
                    print_f(rs->plogs, "P11", rs->logs);
                    
                    switch (chy) {
                    case 'b':

                        sprintf_f(rs->logs, "stop usb now!!! \n");
                        print_f(rs->plogs, "P11", rs->logs);
                        
                        if (usbid01) {
                            chq = 'b';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                        
                        if (usbid02) {
                            chd = 'b';
                            pipRet = write(pipeTxd[1], &chd, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }

                        //chq = 'x';
                        msgret[0] = 'x';
                        msgret[1] = 0x02;
                        pipRet = write(pipeTx[1], msgret, 2);
                        if (pipRet < 0) {
                            printf("[DV] Error!!! pipe send scan stop ret: %d \n", pipRet);
                        }
                        
                        sprintf(msgcmd, "usbidle");
                        
                        ret = rs_ipc_get_ms(rcmd, rcmd->logs, 4096, 10);
                        if (ret > 0) {
                            rcmd->logs[ret] = '\n';

                            sprintf_f(rs->logs, "[DV]  get usbscan result ret: %d\n", ret);
                            print_f(rs->plogs, "P11", rs->logs);   

                            print_f(rcmd->plogs, "C11", rcmd->logs);
                        }
                        
                        break;
                    case 'n':
                        
                        cmd = 0x12;
                        opc = 0x05;
                        dat = 0x85;
                        
                        endf = 0;
                        endm = 0;

                        distCylcnt = 0;
                        uimCylcnt = 0;
                        datCylcnt = 0;
                        lastCylen = 0;
                        waitCylen = 0;
                        rwaitCylen = 0;
                        maxCylcnt = 0;
                        
                        cswerr = 0;
                        cswstatus[0] = 0;
                        cswstatus[1] = 0;

                        //pagerst = 2;
                        
                        clock_gettime(CLOCK_REALTIME, &tidleS);
                        clock_gettime(CLOCK_REALTIME, &tidleE);     
                        
                        #if 1
                        if ((puimGet) && ((opc == 0x05) || (opc == 0x0a))) {
                            sprintf_f(rs->logs, "[DV] n app duo puimGet index: 0x%.3x \n", puimGet->uimIdex);
                            print_f(rs->plogs, "P11", rs->logs);

                            if ((puimGet->uimIdex & 0x400) == 0) {
                                puscur = pushost;
                                pinfcur = pinfushost;
                                usbCur = puscur->pushring;
                                piptx = puscur->pushtx;
                                piprx = puscur->pushrx; 
                            } else {
                                puscur = pushostd;
                                pinfcur = pinfushostd;
                                usbCur = puscur->pushring;
                                piptx = puscur->pushtx;
                                piprx = puscur->pushrx; 
                            }
                        } else {
                            puscur = pushostd;
                            pinfcur = pinfushostd;
                            usbCur = puscur->pushring;
                            piptx = puscur->pushtx;
                            piprx = puscur->pushrx; 
                            
                            sprintf_f(rs->logs, "[DV] n app duo puimGet is null get next \n");
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                        #else   
                        puscur = pushostd;
                        pinfcur = pinfushostd;
                        
                        usbCur = puscur->pushring;

                        piptx = puscur->pushtx;
                        piprx = puscur->pushrx; 
                        #endif

                        ring_buf_init(rs->pcmdTx);
                        //rs_ipc_put(rsd, "s", 1);

                        acusz = 0;
                        
                        #if 1
                        sprintf(msgcmd, "usbscan");
                        #else
                        if (strcmp(msgcmd, "usbscan") != 0) {
                            sprintf(msgcmd, "usbscan");
                            rs_ipc_put(rcmd, msgcmd, strlen(msgcmd));
                            chq = 'n';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }      
                        #endif
                        
                        break;
                    case 'q':
                        cmd = 0x12;
                        opc = 0x05;
                        dat = 0x85;
                        
                        endf = 0;
                        endm = 0;

                        distCylcnt = 0;
                        uimCylcnt = 0;
                        datCylcnt = 0;
                        lastCylen = 0;
                        waitCylen = 0;
                        rwaitCylen = 0;
                        maxCylcnt = 0;
                        
                        cswerr = 0;
                        cswstatus[0] = 0;
                        cswstatus[1] = 0;

                        //pagerst = 2;
                        
                        clock_gettime(CLOCK_REALTIME, &tidleS);
                        clock_gettime(CLOCK_REALTIME, &tidleE);                            
                        #if 1
                        if ((puimGet) && ((opc == 0x05) || (opc == 0x0a))) {
                            sprintf_f(rs->logs, "[DV] q app duo puimGet index: 0x%.3x \n", puimGet->uimIdex);
                            print_f(rs->plogs, "P11", rs->logs);

                            if ((puimGet->uimIdex & 0x400) == 0) {
                                puscur = pushost;
                                pinfcur = pinfushost;
                                usbCur = puscur->pushring;
                                piptx = puscur->pushtx;
                                piprx = puscur->pushrx; 
                            } else {
                                puscur = pushostd;
                                pinfcur = pinfushostd;
                                usbCur = puscur->pushring;
                                piptx = puscur->pushtx;
                                piprx = puscur->pushrx; 
                            }
                        } else {
                            puscur = pushostd;
                            pinfcur = pinfushostd;
                            usbCur = puscur->pushring;
                            piptx = puscur->pushtx;
                            piprx = puscur->pushrx; 
                            
                            sprintf_f(rs->logs, "[DV] q app duo puimGet is null get next \n");
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                        #else                        
                        puscur = pushostd;
                        pinfcur = pinfushostd;
                        
                        usbCur = puscur->pushring;

                        piptx = puscur->pushtx;
                        piprx = puscur->pushrx; 
                        #endif

                        ring_buf_init(rs->pcmdTx);
                        //rs_ipc_put(rsd, "s", 1);

                        acusz = 0;
                        
                        #if 1
                        sprintf(msgcmd, "usbscan");
                        #else
                        if (strcmp(msgcmd, "usbscan") != 0) {
                            sprintf(msgcmd, "usbscan");
                            rs_ipc_put(rcmd, msgcmd, strlen(msgcmd));
                            chq = 'n';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }      
                        #endif
                        
                        break;
                    case 'o':
                        cmd = 0x12;
                        opc = 0x0a;
                        dat = 0x85;
                        
                        distCylcnt = 0;
                        uimCylcnt = 0;
                        datCylcnt = 0;
                        lastCylen = 0;
                        waitCylen = 0;
                        maxCylcnt = 0;
                        
                        clock_gettime(CLOCK_REALTIME, &tidleS);
                        clock_gettime(CLOCK_REALTIME, &tidleE);                            

                        #if 1
                        if ((puimGet) && ((opc == 0x05) || (opc == 0x0a))) {
                            sprintf_f(rs->logs, "[DV] o app duo puimGet index: 0x%.3x \n", puimGet->uimIdex);
                            print_f(rs->plogs, "P11", rs->logs);

                            if ((puimGet->uimIdex & 0x400) == 0) {
                                puscur = pushost;
                                pinfcur = pinfushost;
                                usbCur = puscur->pushring;
                                piptx = puscur->pushtx;
                                piprx = puscur->pushrx; 
                            } else {
                                puscur = pushostd;
                                pinfcur = pinfushostd;
                                usbCur = puscur->pushring;
                                piptx = puscur->pushtx;
                                piprx = puscur->pushrx; 
                            }
                        } else {
                            puscur = pushostd;
                            pinfcur = pinfushostd;
                            usbCur = puscur->pushring;
                            piptx = puscur->pushtx;
                            piprx = puscur->pushrx; 
                                
                            sprintf_f(rs->logs, "[DV] o app duo puimGet is null get next \n");
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                        #else
                        puscur = pushostd;
                        pinfcur = pinfushostd;
                        
                        usbCur = puscur->pushring;

                        piptx = puscur->pushtx;
                        piprx = puscur->pushrx; 
                        #endif
                        
                        ring_buf_init(rs->pcmdTx);
                        //rs_ipc_put(rsd, "s", 1);

                        break;
                    default:
                        break;
                    }

                    rxfd = rsd->ppipedn->rt[0];
                    idlcnt = 0;
                    break;
                }
                else if (getevents[ix].data.fd == pipeRx[0]) {
                    
                    memset(msgret, 0, 64);
                    ret = read(pipeRxd[0], msgret, 64);
                    while (ret > 0) {
                        sprintf_f(rs->logs, "get pipeRx ret: %d\n", ret);
                        print_f(rs->plogs, "P11", rs->logs);
                        shmem_dump(msgret, ret);
                        
                        memset(msgret, 0, 64);
                        ret = read(pipeRxd[0], msgret, 64);
                    }

                    rxfd = pipeRx[0];
                    break;
                }
                else if (getevents[ix].data.fd == pipeRxd[0]) {

                    memset(msgret, 0, 64);
                    ret = read(pipeRxd[0], msgret, 64);
                    while (ret > 0) {
                        sprintf_f(rs->logs, "get pipeRxd ret: %d\n", ret);
                        print_f(rs->plogs, "P11", rs->logs);
                        shmem_dump(msgret, ret);
                        
                        memset(msgret, 0, 64);
                        ret = read(pipeRxd[0], msgret, 64);
                    }

                    rxfd = pipeRxd[0];
                    break;
                }

            }

            if (!rxfd) {
                continue;
            }
        }
            
#if LOG_P11_EN
        sprintf_f(rs->logs, "[ePol] epoll rx: %d, tx: %d ret: %d rxfd: %d\n", usbentsRx, usbentsTx, uret, rxfd);
        print_f(rs->plogs, "P11", rs->logs);
#endif

        if (usbentsRx == 1) {

            #if DBG_27_EPOL
            sprintf_f(rs->logs, "[ePol] Rx cmd: 0x%.2x, opc: 0x%.2x, dat: 0x%.2x, lastsz: %d, cnt: %d \n", cmd, opc, dat, lastsz, cntTx);
            print_f(rs->plogs, "P11", rs->logs);
            #endif
            
            while (1) {
                if ((opc == 0x4c) && (dat == 0x01)) {
                    recvsz = read(usbfd, ptrecv, USB_META_SIZE);
                
                    #if DBG_27_DV
                    sprintf_f(rs->logs, "[DV] usb RX meta data size: %d / %d \n====================\n", recvsz, USB_META_SIZE);
                    print_f(rs->plogs, "P11", rs->logs);
                    #endif              
                    
                    if (recvsz < 0) {
                        //usbentsRx = 0;
                        //break;
                        continue;
                    }
                
                    dat = 0;
                    
                    if (recvsz != USB_META_SIZE) {
                        sprintf_f(rs->logs, "[DV] read meta failed, receive size: %d \n====================\n", recvsz);
                        print_f(rs->plogs, "P11", rs->logs);
                        shmem_dump(ptrecv, recvsz);                        
                
                        break;
                    }
                
                    #if DBG_27_DV
                    shmem_dump(ptrecv, recvsz);
                    #endif
                
                    #if 0 /* save meta */
                    fsmeta = find_save(ptfilepath, ptfileSaveMeta);
                    if (fsmeta) {
                        sprintf_f(rs->logs, "[DV] find save meta [%s] succeed!!! \n", ptfilepath);
                        print_f(rs->plogs, "P11", rs->logs);
                
                        wrtsz = fwrite(ptrecv, 1, recvsz, fsmeta);
                        sync();
                        fclose(fsmeta);
                    }
                    #endif
                    
                    memcpy(metaPt, ptrecv, 512);
                    msync(metaPt, 512, MS_SYNC);

                    memcpy((char*)ptmetain, ptrecv, 512);
                    msync((char*)ptmetain, 512, MS_SYNC);

                    if ((metaRx->ASP_MAGIC[0] != 0x20) || (metaRx->ASP_MAGIC[1] != 0x14)) {
                        sprintf_f(rs->logs, "[DV]  Error!!! magic number wrong 0x%.2x 0x%.2x \n", metaRx->ASP_MAGIC[0], metaRx->ASP_MAGIC[1]);
                        print_f(rs->plogs, "P11", rs->logs);
                        break;
                    }
                    
                    pipRet = aspMetaRelease(msb2lsb32(&ptmetain->FUNC_BITS), 0, rs);
                    //sprintf_f(rs->logs, "[DV]  meta release ret: %d \n", pipRet);
                    //print_f(rs->plogs, "P11", rs->logs);
                    
                    #if 0
                    shmem_dump(ptrecv, recvsz);
                    dbgMeta(msb2lsb32(&metaRx->FUNC_BITS), metaRx);
                    #endif
                    
                    chq = 'n';
                    pipRet = write(pipeTx[1], &chq, 1);
                    if (pipRet < 0) {
                        sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                        print_f(rs->plogs, "P11", rs->logs);
                        continue;
                    }

                    if (usbid01) {
                        chq = 'm';
                        pipRet = write(pipeTx[1], &chq, 1);
                        if (pipRet < 0) {
                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                            print_f(rs->plogs, "P11", rs->logs);
                            continue;
                        }
                    }

                    #if 0
                    if (usbid02) {
                        chd = 'm';
                        pipRet = write(pipeTxd[1], &chd, 1);
                        if (pipRet < 0) {
                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                            print_f(rs->plogs, "P11", rs->logs);
                            continue;
                        }
                    }
                    #endif

                    //sprintf_f(rs->logs, "[DV] clean start \n");
                    //print_f(rs->plogs, "P11", rs->logs);

                    aspMemClear(aspMemAsign, asptotMalloc, 11);
        
                    #if 1  /* clean msg queue */
                    while (1) {
                        chq = 0;
                        pipRet = read(pipeRx[0], &chq, 1);
                        if (pipRet < 0) {
                            break;
                        }
                        else {
                            sprintf_f(rs->logs, "[DV] clean pipe get chq: (0x%.2x) \n", chq);
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                    }
                
                    while (1) {
                        chd = 0;
                        pipRet = read(pipeRxd[0], &chd, 1);
                        if (pipRet < 0) {
                            break;
                        }
                        else {
                            sprintf_f(rs->logs, "[DV] clean pipe get chd: (0x%.2x) \n", chd);
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                    }
                    
                    //sprintf_f(rs->logs, "[DV] clean middle - 1 \n");
                    //print_f(rs->plogs, "P11", rs->logs);

                    if (puimCnTH) {
                        ix=0;
                        puimTmp = puimCnTH;
                        while(puimTmp) {
                            sprintf_f(rs->logs, "[DV] clean H %d - 0x%.2x %d:%d \n", ix, puimTmp->uimIdex, puimTmp->uimGetCnt, puimTmp->uimCount);
                            print_f(rs->plogs, "P11", rs->logs);
                            puimUse = puimTmp;
                            puimTmp = puimUse->uimNxt;
                            ix++;
                
                            free(puimUse);
                        }
                        puimCnTH = 0;
                        puimCur = 0;
                        puimGet = 0;
                        puimCud = 0;
                    }
                
                    if (puimGet) {
                        ix=0;
                        puimTmp = puimGet;
                        while(puimTmp) {
                            sprintf_f(rs->logs, "[DV] clean G %d - 0x%.2x %d:%d \n", ix, puimTmp->uimIdex, puimTmp->uimGetCnt, puimTmp->uimCount);
                            print_f(rs->plogs, "P11", rs->logs);
                            puimUse = puimTmp;
                            puimTmp = puimUse->uimNxt;
                            ix++;
                
                            free(puimUse);
                        }
                
                        puimGet = 0;
                    }
                
                    endf = 0;
                    endm = 0;
                
                    distCylcnt = 0;
                    uimCylcnt = 0;
                    datCylcnt = 0;
                    lastCylen = 0;
                    waitCylen = 0;
                    rwaitCylen = 0;
                    maxCylcnt = 0;
                    
                    cswerr = 0;
                    cswstatus[0] = 0;
                    cswstatus[1] = 0;

                    pagerst = 2;

                    sides[0] = 0;
                    sides[1] = 0;
                    #endif
                    
                    //sprintf_f(rs->logs, "[DV] clean end \n");
                    //print_f(rs->plogs, "P11", rs->logs);

                    if (strcmp(msgcmd, "usbscan") != 0) {
                        sprintf(msgcmd, "usbscan");
                        rs_ipc_put(rcmd, msgcmd, strlen(msgcmd));
                    }

                    break;
                }
                else if ((cmd == OP_WRITE_FILE) && (opc == 0xff) && (dat == 0)) {
                    if (!iubsBuff) {
                        sprintf_f(rs->logs, "\n[DVF] Error !!! file read iubsBuff is null!!!! cmd: 0x%.2x opc: 0x%.2x, dat: 0x%.2x  \n",cmd, opc, dat);
                        print_f(rs->plogs, "P11", rs->logs);
                        break;
                    }
                    sprintf_f(rs->logs, "[DV] file access rx filesz: %d \n", filesz);
                    print_f(rs->plogs, "P11", rs->logs);
                    
                    //lenflh = msb2lsb32(&ucbwfile->pramDataLength);
                    //filesz = lenflh;

                    while (1) {
                        lenrs = 0;
                        lenrs = ring_buf_get(rs->pcmdRx, &addrs);

                        if (lenrs > 0) {
                            if (lenrs > filesz) {
                                lenrs = filesz;
                            }

                            filesz = filesz - lenrs;

                            #if LOG_P11_EN
                            sprintf_f(rs->logs, "[DVB] usb file read recvsz: %d remain: %d  \n", lenrs, filesz);
                            print_f(rs->plogs, "P11", rs->logs);
                            #endif

                            recvsz = lenrs;
                            errcnt = 0;
                            while (recvsz) {
                                ret = read(usbfd, addrs, recvsz);
                                if (ret > 0) {
                                    //sprintf_f(rs->logs, "\n[DVB] usb file read recvsz: %d (%d)  \n",ret, recvsz);
                                    //print_f(rs->plogs, "P11", rs->logs);

                                    recvsz -= ret;
                                    addrs += ret;
                                } else {
                                    errcnt++;
                                    if (errcnt > 100) {
                                        break;
                                    }
                                    usleep(100000);
                                    continue;
                                }                        
                            }

                            ring_buf_prod(rs->pcmdRx);
                            
                            if ((lenrs < SPI_TRUNK_SZ) || (filesz == 0)) {
                                ring_buf_set_last(rs->pcmdRx, lenrs);
                                rs_ipc_put(rs, "f", 1);
                                rs_ipc_put(rs, "g", 1);

                                if (filesz != 0) {
                                    sprintf_f(rs->logs, "\n[DVB] Error !!! remain filesz: %d\n",filesz);
                                    print_f(rs->plogs, "P11", rs->logs);
                                }
                                break;
                            }

                            rs_ipc_put(rs, "f", 1);
                            
                        }
                        else {
                            sprintf_f(rs->logs, "[DVB] get buff ret:%d  (%d)\n",lenrs, filesz);
                            print_f(rs->plogs, "P11", rs->logs);

                            usleep(100000);
                        }
                    }

                    if (filesz == 0) {
                        break;
                    }
                }
                else if (((cmd >= 0x00) && (cmd <= 0x0f)) && (opc == 0xff) && (dat == 0)) {
                    if (!iubsBuff) {
                        sprintf_f(rs->logs, "\n[DVF] Error !!! iubsBuff is null!!!! cmd: 0x%.2x opc: 0x%.2x, dat: 0x%.2x  \n",cmd, opc, dat);
                        print_f(rs->plogs, "P11", rs->logs);
                        break;
                    }

                    #if LOG_FLASH /* debug flash read/write */
                    sprintf_f(rs->logs, "[DV] data flash id:0x%.8x len:%d cmd:0x%.2x addr:0x%.8x direct:%d \n", 
                                                msb2lsb32(&ucbwpram->pramID), msb2lsb32(&ucbwpram->pramDataLength), 
                                                ucbwpram->pramType, (uint32_t)msb2lsb32(&ucbwpram->pramAddress), ucbwpram->pramDirect);
                    print_f(rs->plogs, "P11", rs->logs);
                    #endif

                    lenflh = msb2lsb32(&ucbwpram->pramDataLength);
                    while (1) {
                        recvsz = read(usbfd, vubsBuff, lenflh);
                        if (recvsz == lenflh) {
                            break;
                        } else {
                        
                            #if LOG_FLASH
                            sprintf_f(rs->logs, "[DV] flash write-data size: %d recv: %d retry !!!\n", lenflh, recvsz);
                            print_f(rs->plogs, "P11", rs->logs);
                            #endif
                            
                        }
                    }

                    #if LOG_FLASH /* debug flash read/write */
                    sprintf_f(rs->logs, "[DV] flash write-data size: %d recv: %d \n",lenflh, recvsz);
                    print_f(rs->plogs, "P11", rs->logs);
                    shmem_dump(vubsBuff, lenflh);
                    #endif

                    if (ucbwpram->ASIC_sel) {
                        if (usbid02) {
                            chd = 'w';
                            pipRet = write(pipeTxd[1], &chd, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                    } else {
                        if (usbid01) {
                            chq = 'w';
                            pipRet = write(pipeTx[1], &chq, 1);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                    }
                    
                    //sprintf_f(rs->logs, "[DV] dump flash input: \n"); 
                    //print_f(rs->plogs, "P11", rs->logs);
                    //shmem_dump(vubsBuff, recvsz);

                    break;
                }
                else {
                    if (fsrcv) {
                        recvsz = fsrcv;
                        fsrcv = 0;

                        sprintf_f(rs->logs, "[DV] first usb RX size: %d / %d \n====================\n", recvsz, 31); 
                        print_f(rs->plogs, "P11", rs->logs);

                        shmem_dump(ptrecv, recvsz);
                    } else {
                        recvsz = read(usbfd, ptrecv, 31);
                    }
                    
                    #if DBG_27_DV
                    sprintf_f(rs->logs, "[DV] usb RX size: %d / %d \n====================\n", recvsz, 31); 
                    print_f(rs->plogs, "P11", rs->logs);
                    #endif
                    
                    if (recvsz < 0) {
                        usbentsRx = 0;
                        break;
                    }
                    
                    sprintf(rs->logs, "__USB_GET  CBW_[%.2x][%.2x][%.2x]__", ptrecv[15], ptrecv[16], ptrecv[17]); 
                    tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);

                    //thrtimeconsu = tmCost;
                    //thrtimeconsu = thrtimeconsu - thrtimebegin;
                    //throughput = thrdatasize / thrtimeconsu;
                    //sprintf_f(rs->logs, "__USB_TO_PC THROUGHPUT_(%.2lf / %.2lf = %.3lf_MB)__", thrdatasize, thrtimeconsu, throughput); 
                    //dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);
                    
                    thrtimebegin = tmCost;
                    
                    #if LOG_FLASH /* should close */
                    shmem_dump(ptrecv, recvsz);
                    #endif
                    
                    #if DBG_USB_TIME_MEASURE
                    if ((fintvalE[0]) && (fintvalE[1])) {
                        sprintf_f(rs->logs, "[DV] get intvalE failed, should not be here!!\n"); 
                        print_f(rs->plogs, "P11", rs->logs);
                        pintval = &intvalE[0];                        
                    } else {
                        if (fintvalE[0]) {
                            pintval = &intvalE[0];
                        } else {
                            pintval = &intvalE[1];
                        }
                    }
                    
                    if (!fintvalS[0]) {
                        clock_gettime(CLOCK_REALTIME, &intvalS[0]);
                        fintvalS[0] = 1;

                        if (fintvalS[1]) {

                            tmCost = time_diff(pintval, &intvalS[0], 1000);
                            
                            #if LOG_FLASH
                            sprintf_f(rs->logs, "[DV] TX-RX interval end: %llu ms start: %llu ms diff: %d us - 1\n", time_get_ms(&intvalS[0]), time_get_ms(pintval), tmCost);
                            print_f(rs->plogs, "P11", rs->logs);
                            #endif
                            
                            tmCost = time_diff(&intvalS[1], &intvalS[0], 1000);
                            
                            #if LOG_FLASH
                            sprintf_f(rs->logs, "[DV] RX interval end: %llu ms start: %llu ms diff: %d us - 1\n", time_get_ms(&intvalS[0]), time_get_ms(&intvalS[1]), tmCost);
                            print_f(rs->plogs, "P11", rs->logs);
                            #endif

                            fintvalS[1] = 0;
                        }
                        else {
                            sprintf_f(rs->logs, "[DVF] RX interval should not be here !!! - 1\n");
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                    }
                    else {
                    
                        if (!fintvalS[1]) {
                            clock_gettime(CLOCK_REALTIME, &intvalS[1]);
                            fintvalS[1] = 1;

                            tmCost = time_diff(pintval, &intvalS[1], 1000);
                            sprintf_f(rs->logs, "[DV] TX-RX interval end: %llu ms start: %llu ms diff: %d us - 2\n", time_get_ms(&intvalS[1]), time_get_ms(pintval), tmCost);
                            print_f(rs->plogs, "P11", rs->logs);
                            
                            tmCost = time_diff(&intvalS[0], &intvalS[1], 1000);
                            sprintf_f(rs->logs, "[DV] RX interval end: %llu ms start: %llu ms diff: %d us - 2\n", time_get_ms(&intvalS[1]), time_get_ms(&intvalS[0]), tmCost);
                            print_f(rs->plogs, "P11", rs->logs);

                            fintvalS[0] = 0;
                        } else {
                            sprintf_f(rs->logs, "[DVF] RX interval should not be here !!! - 2\n");
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                    }
                    #endif
                    
                    if ((ptrecv[0] == 0x55) && (ptrecv[1] == 0x53) && (ptrecv[2] == 0x42)) {
                        cmd = ptrecv[15];
                        opc = ptrecv[16];
                        dat = ptrecv[17];
                        
                        if (cmd == OP_WRITE_FILE) {
                            shmem_dump(ptrecv, recvsz);
                        }
                        else if ((cmd >= 0x00) && (cmd <= 0x0f)) {
                            printf("\r");
                        } else {
                            shmem_dump(ptrecv, recvsz);
                        }

                        #if LOG_FLASH
                        sprintf_f(rs->logs, "[DVF] usb get cmd: 0x%.2x opc: 0x%.2x, dat: 0x%.2x \n",cmd, opc, dat);
                        print_f(rs->plogs, "P11", rs->logs);
                        #endif
                        
                        if (cmd == 0x11) {      
                                while (1) {
                                    chq = 0;
                                    pipRet = read(pipeRx[0], &chq, 1);
                                    if (pipRet < 0) {
                                        break;
                                    }
                                    else {
                                        
                                        #if DBG_27_DV               
                                        sprintf_f(rs->logs, "[DV] clean pipe get chq: %c(0x%.2x) \n", chq, chq);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        #endif                          
                                        
                                    }
                                }
                                
                                while (1) {
                                    chd = 0;
                                    pipRet = read(pipeRxd[0], &chd, 1);
                                    if (pipRet < 0) {
                                        break;
                                    }
                                    else {
                                
                                        #if DBG_27_DV               
                                        sprintf_f(rs->logs, "[DV] clean pipe get chd: %c(0x%.2x) \n", chd, chd);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        #endif                          
                                    }
                                }
                                
                                if ((opc == 0x4c) && (dat == 0x01)) {     
                                    clock_gettime(CLOCK_REALTIME, rs->tm[0]);
                                    pagecnt=0;
                                    
                                    #if 1
                                    if (strcmp(msgcmd, "usbscan") == 0) {

                                        //chq = 'x';
                                        msgret[0] = 'x';
                                        msgret[1] = 0x01;
                                        pipRet = write(pipeTx[1], msgret, 2);
                                        if (pipRet < 0) {
                                            printf("[DV] Error!!! pipe send scan stop ret: %d \n", pipRet);
                                        }

                                        sprintf(msgcmd, "usbidle");

                                        ret = rs_ipc_get_ms(rcmd, rcmd->logs, 4096, 10);
                                        if (ret > 0) {
                                            rcmd->logs[ret] = '\n';

                                            sprintf_f(rs->logs, "[DV]  get usbscan result ret: %d\n", ret);
                                            print_f(rs->plogs, "P11", rs->logs);   

                                            print_f(rcmd->plogs, "C11", rcmd->logs);
                                        }
                                    }
                                    #endif

                                    continue;
                                }
                                else if ((opc == 0x04) && (dat == 0x85)) {

                                    iubs->opinfo = opc << 8 | dat;
                                    memcpy(iubsBuff, ptrecv, 31);
                                    
                                    puscur = 0;
                                    pinfcur = 0;

                                    if (strcmp(msgcmd, "usbscan") != 0) {
                                        sprintf(msgcmd, "usbscan");
                                        rs_ipc_put(rcmd, msgcmd, strlen(msgcmd));
                                    }

                                    chq = 'n';
                                    pipRet = write(pipeTx[1], &chq, 1);
                                    if (pipRet < 0) {
                                        sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        continue;
                                    }
                                                                        
                                    //continue;

                                    break;
                                }
                                else if ((opc == 0x05) && (dat == 0x85)) {

                                    iubs->opinfo = opc << 8 | dat;
                                    memcpy(iubsBuff, ptrecv, 31);
                                    
                                    puscur = 0;
                                    pinfcur = 0;
                                    
                                    if (strcmp(msgcmd, "usbscan") != 0) {
                                        sprintf(msgcmd, "usbscan");
                                        rs_ipc_put(rcmd, msgcmd, strlen(msgcmd));
                                    }

                                    chq = 'n';
                                    pipRet = write(pipeTx[1], &chq, 1);
                                    if (pipRet < 0) {
                                        sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        continue;
                                    }
                                    
                                    break;
                                }
                                else if ((opc == 0x09) && (dat == 0x85)) {

                                    iubs->opinfo = opc << 8 | dat;
                                    memcpy(iubsBuff, ptrecv, 31);
                                    
                                    puscur = 0;
                                    pinfcur = 0;

                                    if (strcmp(msgcmd, "usbscan") != 0) {
                                        sprintf(msgcmd, "usbscan");
                                        rs_ipc_put(rcmd, msgcmd, strlen(msgcmd));
                                    }

                                    chq = 'n';
                                    pipRet = write(pipeTx[1], &chq, 1);
                                    if (pipRet < 0) {
                                        sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        continue;
                                    }
                                    
                                    break;
                                }
                                else if ((opc == 0x0a) && (dat == 0x85)) {

                                    iubs->opinfo = opc << 8 | dat;
                                    memcpy(iubsBuff, ptrecv, 31);
                                    
                                    puscur = 0;
                                    pinfcur = 0;
                                    
                                    if (strcmp(msgcmd, "usbscan") != 0) {
                                        sprintf(msgcmd, "usbscan");
                                        rs_ipc_put(rcmd, msgcmd, strlen(msgcmd));
                                    }

                                    chq = 'n';
                                    pipRet = write(pipeTx[1], &chq, 1);
                                    if (pipRet < 0) {
                                        sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        continue;
                                    }
                                    
                                    break;
                                }
                                else if ((opc == 0x0e) && (dat == 0x85)) {

                                    iubs->opinfo = opc << 8 | dat;
                                    memcpy(iubsBuff, ptrecv, 31);
                                    
                                    puscur = 0;
                                    pinfcur = 0;
                                    
                                    if (strcmp(msgcmd, "usbscan") != 0) {
                                        sprintf(msgcmd, "usbscan");
                                        rs_ipc_put(rcmd, msgcmd, strlen(msgcmd));
                                    }

                                    chq = 'n';
                                    pipRet = write(pipeTx[1], &chq, 1);
                                    if (pipRet < 0) {
                                        sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        continue;
                                    }
                                    
                                    break;
                                }
                                else if ((opc == 0x0f) && (dat == 0x85)) {

                                    iubs->opinfo = opc << 8 | dat;
                                    memcpy(iubsBuff, ptrecv, 31);
                                    
                                    puscur = 0;
                                    pinfcur = 0;

                                    #if SCAN_BNOTE_EN // test code
                                    if (strcmp(msgcmd, "usbbknote") != 0) {
                                        sprintf(msgcmd, "usbbknote");
                                        rs_ipc_put(rcmd, msgcmd, strlen(msgcmd));
                                    }
                                    #else
                                    if (strcmp(msgcmd, "usbscan") != 0) {
                                        sprintf(msgcmd, "usbscan");
                                        rs_ipc_put(rcmd, msgcmd, strlen(msgcmd));
                                    }
                                    #endif
                                    
                                    chq = 'n';
                                    pipRet = write(pipeTx[1], &chq, 1);
                                    if (pipRet < 0) {
                                        sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        continue;
                                    }

                                    #if 0 /* fork test code */
                                    pid = fork();
                                    
                                    if (pid < 0) {
                                        pid = fork();
                                    }

                                    sprintf_f(rs->logs, "[ISO] fork pid: %d\n", pid);
                                    print_f(rs->plogs, "P11", rs->logs);

                                    if (pid == 0) {

                                        ch = 'c';
                                        while (1) {
                                            ret = read(pipeusb[0], &ch, 1);

                                            sprintf_f(rs->logs, "[ISO] pipeusb get ch: %c, ret: %d \n", ch, ret);
                                            ret = print_f(rs->plogs, "P11", rs->logs);

                                            //printf("[ISO] test ret: %d \n", ret);

                                            sleep(1);
                                            
                                        }
                                    }
                                    
                                    ch += 1;
                                    write(pipeusb[1], &ch, 1);

                                    sprintf_f(rs->logs, "[ISO] fork pid: %d break \n", pid);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    #endif
                                    
                                    break;
                                }
                                else if ((opc == 0x4d) && (dat == 0x00)) { /* polling status */

                                    iubs->opinfo = opc << 8 | dat;
                                    memcpy(iubsBuff, ptrecv, 31);
                                    
                                    puscur = pushost;          
                                    pinfcur = pinfushost;

                                    if (strcmp(msgcmd, "usbscan") != 0) {
                                        sprintf(msgcmd, "usbscan");
                                        rs_ipc_put(rcmd, msgcmd, strlen(msgcmd));
                                        chq = 'n';
                                        pipRet = write(pipeTx[1], &chq, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }                                    

                                    if (usbid01) {
                                        chq = 'i';
                                        pipRet = write(pipeTx[1], &chq, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }
                                    
                                    #if BYPASS_TWO
                                    if (usbid02) {
                                        chd = 'i';
                                        pipRet = write(pipeTxd[1], &chd, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }
                                    #endif

                                    usbCur = puscur->pushring;

                                    piptx = puscur->pushtx;
                                    piprx = puscur->pushrx; 
                                    
                                    break;
                                }
                                else if ((opc == 0x4f) && (dat == 0x00)) { /* ASIC reset check alive */
                                    memcpy(iubsBuff, ptrecv, 31);
                                    sprintf_f(rs->logs, "[DV] check alive ASIC: %d \n", ucbwpram->ASIC_sel);
                                    print_f(rs->plogs, "P11", rs->logs);
                            
                                    puscur = pushost;
                                    pinfcur = pinfushost;

                                    if (strcmp(msgcmd, "usbscan") != 0) {
                                        sprintf(msgcmd, "usbscan");
                                        rs_ipc_put(rcmd, msgcmd, strlen(msgcmd));
                                        chq = 'n';
                                        pipRet = write(pipeTx[1], &chq, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }                                    
                                    
                                    //if (ucbwpram->ASIC_sel) {
                                    
                                        #if BYPASS_TWO
                                        //if (usbid02) {
                                            chd = 'z';
                                            pipRet = write(pipeTxd[1], &chd, 1);
                                            if (pipRet < 0) {
                                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                                print_f(rs->plogs, "P11", rs->logs);
                                                continue;
                                            }
                                        //}
                                        #endif
                                        
                                    //} else {
                                        //if (usbid01) {
                                            chq = 'z';
                                            pipRet = write(pipeTx[1], &chq, 1);
                                            if (pipRet < 0) {
                                                sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                                print_f(rs->plogs, "P11", rs->logs);
                                                continue;
                                            }
                                        //}
                                    //}

                                    usbCur = puscur->pushring;

                                    piptx = puscur->pushtx;
                                    piprx = puscur->pushrx; 
                                    
                                    break;
                                }
                                else { /* unknown opcode */
                                    sprintf_f(rs->logs, "\n[DVF] Warnning!!! unknown usb opc, cmd: 0x%.2x opc: 0x%.2x, dat: 0x%.2x \n",cmd, opc, dat);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    
                                    iubs->opinfo = opc << 8 | dat;
                                    memcpy(iubsBuff, ptrecv, 31);
                                    
                                    puscur = pushost;      
                                    pinfcur = pinfushost;

                                    if (strcmp(msgcmd, "usbscan") != 0) {
                                        sprintf(msgcmd, "usbscan");
                                        rs_ipc_put(rcmd, msgcmd, strlen(msgcmd));
                                        chq = 'n';
                                        pipRet = write(pipeTx[1], &chq, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }
                                    
                                    if (usbid01) {
                                        chq = 'i';
                                        pipRet = write(pipeTx[1], &chq, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }

                                    #if BYPASS_TWO
                                    if (usbid02) {
                                        chd = 'i';
                                        pipRet = write(pipeTxd[1], &chd, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }
                                    #endif

                                    usbCur = puscur->pushring;

                                    piptx = puscur->pushtx;
                                    piprx = puscur->pushrx; 

                                    cmd = 0;
                                    opc = 0xff;
                                    dat = 0;
                                    
                                    break;
                                }
                        }
                        else if (cmd == 0x12) {
                            distCylcnt = 0;
                            uimCylcnt = 0;
                            datCylcnt = 0;
                            lastCylen = 0;
                            waitCylen = 0;
                            maxCylcnt = 0;
                            clock_gettime(CLOCK_REALTIME, &tidleS);
                            clock_gettime(CLOCK_REALTIME, &tidleE);                            
                            
                            if ((opc == 0x04) && (dat == 0x85)) {                                    
                                if (!puscur) {
                                    puscur = pushost;      
                                    pinfcur = pinfushost;
                                    
                                    if (usbid01) {
                                        chq = 'a';
                                        pipRet = write(pipeTx[1], &chq, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                        
                                        chq = 'd';
                                        pipRet = write(pipeTx[1], &chq, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }
                
                                    #if 0
                                    usbCur = puscur->pgatring;
                                    #else
                                    usbCur = puscur->pushring;
                                    #endif
                                    
                                    piptx = puscur->pushtx;
                                    piprx = puscur->pushrx; 
                                }
                                else {
                                    /* should't be here */
                                    sprintf_f(rs->logs, "\n[DVF] Error!!! unknown state,  puscur != null usb opc, cmd: 0x%.2x opc: 0x%.2x, dat: 0x%.2x \n",cmd, opc, dat);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    continue;
                                }
                                    
                                acusz = 0;
                                break;
                            }
                            else if ((opc == 0x09) && (dat == 0x85)) {                                    
                                if (!puscur) {
                                    puscur = pushost;          
                                    pinfcur = pinfushost;
                                    
                                    if (usbid01) {
                                        chq = 'k';
                                        pipRet = write(pipeTx[1], &chq, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                        
                                        chq = 'c';
                                        pipRet = write(pipeTx[1], &chq, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }
                                    
                                    #if 0                           
                                    usbCur = puscur->pgatring;
                                    #else                           
                                    usbCur = puscur->pushring;
                                    #endif                          
                                    
                                    piptx = puscur->pushtx;
                                    piprx = puscur->pushrx; 
                                }
                                else if (puscur == pushost) {
                                    usbCur = puscur->pushring;
                                    piptx = puscur->pushtx;
                                    piprx = puscur->pushrx; 
                                    
                                    if (usbid01) {
                                        chq = 'k';
                                        pipRet = write(pipeTx[1], &chq, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                        
                                        chq = 'c';
                                        pipRet = write(pipeTx[1], &chq, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }
                
                                } else {
                                    /* should't be here */
                                    sprintf_f(rs->logs, "\n[DVF] Error!!! unknown state opc, cmd: 0x%.2x opc: 0x%.2x, dat: 0x%.2x \n",cmd, opc, dat); 
                                    print_f(rs->plogs, "P11", rs->logs);
                                    continue;
                                }
                                    
                                acusz = 0;
                                break;
                            }
                            else if ((opc == 0x05) && (dat == 0x85)) {
                                if (!puscur) {
                                    puscur = pushost;     
                                    pinfcur = pinfushost;

                                    if (usbid01) {
                                        chq = 's';
                                        pipRet = write(pipeTx[1], &chq, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }
                                    
                                    if (usbid02) {
                                        chd = 's';
                                        pipRet = write(pipeTxd[1], &chd, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }

                                    if (usbid01) {
                                        chq = 'p';
                                        pipRet = write(pipeTx[1], &chq, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }

                                    if (usbid02) {
                                        chd = 'p';
                                        pipRet = write(pipeTxd[1], &chd, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }
                                    
                                    #if 0                           
                                    usbCur = puscur->pgatring;
                                    #else                           
                                    usbCur = puscur->pushring;
                                    #endif                          
                                    
                                    piptx = puscur->pushtx;
                                    piprx = puscur->pushrx; 
                                }
                                else if (puscur == pushost) {
                                    puscur = pushostd;
                                    pinfcur = pinfushostd;
                
                                    #if 0                           
                                    usbCur = puscur->pgatring;
                                    #else                           
                                    usbCur = puscur->pushring;
                                    #endif                          
                                    
                                    piptx = puscur->pushtx;
                                    piprx = puscur->pushrx; 
                                }
                                else {
                                    /* should't be here */
                                    sprintf_f(rs->logs, "\n[DVF] Error!!! unknown state here usb opc, cmd: 0x%.2x opc: 0x%.2x, dat: 0x%.2x  \n",cmd, opc, dat);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    continue;
                                }
                                    
                                acusz = 0;
                                break;
                            }
                            else if (((opc == 0x0a) || (opc == 0x0e) || (opc == 0x0f)) && (dat == 0x85)) {
                                if (!puscur) {
                                    puscur = pushost;    
                                    pinfcur = pinfushost;

                                    if (usbid01) {
                                        chq = 'r';
                                        pipRet = write(pipeTx[1], &chq, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }

                                    if (usbid02) {
                                        chd = 'r';
                                        pipRet = write(pipeTxd[1], &chd, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }

                                    if (usbid01) {
                                        chq = 'q';
                                        pipRet = write(pipeTx[1], &chq, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }

                                    if (usbid02) {
                                        chd = 'q';
                                        pipRet = write(pipeTxd[1], &chd, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }
                                    
                                    #if 0
                                    usbCur = puscur->pgatring;
                                    #else
                                    usbCur = puscur->pushring;
                                    #endif
                                    
                                    piptx = puscur->pushtx;
                                    piprx = puscur->pushrx; 
                                }
                                else if (puscur == pushost) {
                                    puscur = pushostd;
                                    pinfcur = pinfushostd;
                
                                    #if 0                           
                                    usbCur = puscur->pgatring;
                                    #else                           
                                    usbCur = puscur->pushring;
                                    #endif                          
                                    
                                    piptx = puscur->pushtx;
                                    piprx = puscur->pushrx; 
                                }
                                else if (puscur == pushostd) {
                                    puscur = pushost;
                                    pinfcur = pinfushost;
                
                                    #if 0                           
                                    usbCur = puscur->pgatring;
                                    #else                           
                                    usbCur = puscur->pushring;
                                    #endif                          
                                    
                                    piptx = puscur->pushtx;
                                    piprx = puscur->pushrx; 

                                    if (usbid01) {
                                        chq = 'r';
                                        pipRet = write(pipeTx[1], &chq, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }

                                    if (usbid02) {
                                        chd = 'r';
                                        pipRet = write(pipeTxd[1], &chd, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }

                                    if (usbid01) {
                                        chq = 'q';
                                        pipRet = write(pipeTx[1], &chq, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }

                                    if (usbid02) {
                                        chd = 'q';
                                        pipRet = write(pipeTxd[1], &chd, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }
                                    
                                }
                                else {
                                    sprintf_f(rs->logs, "\n[DVF] Error!!! unknown puscur 0x%.8x \n", (uint32_t)puscur);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    /* should't be here */
                                }
                
                                if ((puimGet) && ((opc == 0x0f) || (opc == 0x0a) || (opc == 0x0e))) {
                                    if ((puimGet->uimIdex & 0x400) == 0) {
                                                puscur = pushost;
                                                pinfcur = pinfushost;
                                                usbCur = puscur->pushring;
                                                piptx = puscur->pushtx;
                                                piprx = puscur->pushrx; 
                                    } else {
                                                puscur = pushostd;
                                                pinfcur = pinfushostd;
                                                usbCur = puscur->pushring;
                                                piptx = puscur->pushtx;
                                                piprx = puscur->pushrx; 
                                    }
                                } else {
                                    //sprintf_f(rs->logs, "[DV] puimGet is null get next \n");
                                    //print_f(rs->plogs, "P11", rs->logs);
                                }
                                acusz = 0;
                                break;
                            }    
                            else {
                                sprintf_f(rs->logs, "\n[DVF] Error!!! unknown state for multiple duplex scan usb opc, cmd: 0x%.2x opc: 0x%.2x, dat: 0x%.2x  \n",cmd, opc, dat);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                        else if (cmd == 0x13) {
                            switch(opc) {
                            case 0x09:
                            case 0x04:
                                chq = 'b';
                                pipRet = write(pipeTx[1], &chq, 1);
                                if (pipRet < 0) {
                                    sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    continue;
                                }
                                chd = 'b';
                                pipRet = write(pipeTxd[1], &chd, 1);
                                if (pipRet < 0) {
                                    sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    continue;
                                }
                                break;
                            case 0x05:
                            case 0x0a:
                            case 0x0f:
                            
                                chq = 'b';
                                pipRet = write(pipeTx[1], &chq, 1);
                                if (pipRet < 0) {
                                    sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    continue;
                                }
                            
                                chd = 'b';
                                pipRet = write(pipeTxd[1], &chd, 1);
                                if (pipRet < 0) {
                                    sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    continue;
                                }
                
                                break;
                            default: 
                                sprintf_f(rs->logs, "\n[DV]  0x13 unknown opc: 0x%.2x \n", opc);
                                print_f(rs->plogs, "P11", rs->logs);
                                break;
                            }
                            
                            break;
                        }
                        else if (cmd == 0x14) {
                            switch(opc) {
                            case 0x09:
                            case 0x04:
                                pinfushost->ushostresume = -1;
                                pinfushostd->ushostresume = -1;

                                pinfushost->ushostpause = 2;
                                pinfushostd->ushostpause = 2;                                        
                                break;
                            case 0x05:
                            case 0x0a:
                                pinfushost->ushostresume = -1;
                                pinfushostd->ushostresume = -1;

                                pinfushost->ushostpause = 2;
                                pinfushostd->ushostpause = 2;                                        
                                break;
                            default: 
                                sprintf_f(rs->logs, "\n[DV]  0x14 unknown opc: 0x%.2x \n", opc);
                                print_f(rs->plogs, "P11", rs->logs);
                                break;
                            }
                            
                            break;
                        }
                        else if (cmd == 0x15) {
                            switch(opc) {
                            case 0x09:
                            case 0x04:
                                pinfushost->ushostresume = 2;
                                pinfushostd->ushostresume = 1;

                                pinfushost->ushostpause = 0;
                                pinfushostd->ushostpause = 0;                                        
                                break;
                            case 0x05:
                            case 0x0a:
                                pinfushost->ushostresume = 1;
                                pinfushostd->ushostresume = 2;

                                pinfushost->ushostpause = 0;
                                pinfushostd->ushostpause = 0;                                        
                                break;
                            default: 
                                sprintf_f(rs->logs, "\n[DV]  0x15 unknown opc: 0x%.2x \n", opc);
                                print_f(rs->plogs, "P11", rs->logs);
                                break;
                            }
                            
                            break;
                        }
                        else if (cmd == OP_WRITE_FILE) {
                            if (!iubsBuff) {
                                sprintf_f(rs->logs, "\n[DVF] Error !!! iubsBuff is null!!!! cmd: 0x%.2x opc: 0x%.2x, dat: 0x%.2x  \n",cmd, opc, dat);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                            
                            memcpy(iubsBuff, ptrecv, 31);
                            val = ucbwfile->pramWrtorRd[0];
                            act = (ucbwfile->pramFileId[0] << 8) | ucbwfile->pramFileId[1];
                            lenflh = msb2lsb32(&ucbwfile->pramDataLength);
                            
                            switch (val) {
                            case 1: // write
                            case 2: // read
                            case 3: // wrt trigger
                            
                                if (!pubf->usfacPt) {
                                    fdpll = fopen(fileidpoll, "r");
                                    if (fdpll) {
                                        ret = fread(msgret, 1, 4, fdpll);
                                        if (ret == 4) {
                                            msgret[4] = '\0';
                                            sprintf_f(rs->logs, "[DV] fileid poll [%s] magic: [%s] \n", fileidpoll, msgret);
                                            print_f(rs->plogs, "P11", rs->logs);                                
                                            err = strncmp(msgret, pubf->usfacMagicBegin, 4);
                                            if (err) {
                                                sprintf_f(rs->logs, "[DV] Error!! compare magic failed magic: [%s] \n", msgret);
                                                print_f(rs->plogs, "P11", rs->logs);                                
                                    
                                                fclose(fdpll);
                                                fdpll = 0;
                                            }
                                        } else {
                                            sprintf_f(rs->logs, "[DV] error read fileid poll [%s] failed ret: %d \n", fileidpoll, ret);
                                            print_f(rs->plogs, "P11", rs->logs);                                
                                    
                                            fclose(fdpll);
                                            fdpll = 0;
                                        }
                                    
                                    }
                                    else {
                                        sprintf_f(rs->logs, "[DV] fileid poll open file: [%s] failed\n", fileidpoll);
                                        print_f(rs->plogs, "P11", rs->logs);                                
                                    }
                                    
                                    if (fdpll) {
                                        pubf->usfacLength = 0;
                                        ret = fread(msgret, 1, 4, fdpll);
                                        if (ret == 4) {
                                            lens = msgret[0];
                                            lens |= msgret[1] << 8;
                                            lens |= msgret[2] << 16;
                                            lens |= msgret[3] << 24;
                                            sprintf_f(rs->logs, "[DV] read fileid poll length: %d \n", lens);
                                            print_f(rs->plogs, "P11", rs->logs); 
                                    
                                            if (lens < 32768) {
                                                if (fileidbuff) {
                                    
                                                    memset(fileidbuff, 0, 32768);
                                                    
                                                    err = fread(fileidbuff, 1, lens, fdpll);
                                                    if (err == lens) {
                                                        //sprintf_f(rs->logs, "[DV] read fileid poll data content dump \n");
                                                        //print_f(rs->plogs, "P11", rs->logs); 
                                                        //shmem_dump(fileidbuff, lens);
                                    
                                                        pubf->usfacPt = (struct usbFileidContent_s  *)fileidbuff;
                                    
                                                        ret = fread(msgret, 1, 4, fdpll);
                                                        if (ret == 4) {
                                                            msgret[4] = '\0';
                                                            err = strncmp(msgret, pubf->usfacMagicEnd, 4);
                                                            if (err) {
                                                                sprintf_f(rs->logs, "[DV] Error!! compare end magic failed magic: [%s] \n", msgret);
                                                                print_f(rs->plogs, "P11", rs->logs);                                
                                    
                                                                fclose(fdpll);
                                                                fdpll = 0;
                                                            } else {
                                                                pubf->usfacLength = lens;
                                    
                                                                sprintf_f(rs->logs, "[DV] read fileid poll succeed!! length: %d \n", pubf->usfacLength);
                                                                print_f(rs->plogs, "P11", rs->logs); 
                                                            }
                                                        } else {
                                                            sprintf_f(rs->logs, "[DV] read fileid poll end magic failed ret: %d (%d) \n", ret, 4);
                                                            print_f(rs->plogs, "P11", rs->logs); 
                                    
                                                            fclose(fdpll);
                                                            fdpll = 0;
                                                        }
                                                        
                                                    } else {
                                                        sprintf_f(rs->logs, "[DV] read fileid poll data content failed ret: %d (%d) \n", err, lens);
                                                        print_f(rs->plogs, "P11", rs->logs); 
                                    
                                                        fclose(fdpll);
                                                        fdpll = 0;
                                                    }
                                                } else {
                                                    sprintf_f(rs->logs, "[DV] Error!!! memory allocate length: %d failed!!\n", lens);
                                                    print_f(rs->plogs, "P11", rs->logs); 
                                                }
                                                
                                            }
                                        } else {
                                            sprintf_f(rs->logs, "[DV] error read fileid poll length failed ret: %d len: %d too large\n", ret, lens);
                                            print_f(rs->plogs, "P11", rs->logs);                                
                                        }
                                    }
                                    
                                    if (fdpll) {
                                        fclose(fdpll);
                                        fdpll = 0;
                                    }

                                    //sprintf_f(rs->logs, " lens = %d, fileidlen = %d - 1\n", lens, pubf->usfacLength);
                                    //print_f(rs->plogs, "P11", rs->logs);                                

                                    lens = 0;
                                    if (pubf->usfacLength) {
                                        lenrs = sizeof(struct usbFileidContent_s);
                                        err = pubf->usfacLength % lenrs;
                                    
                                        if (err) {
                                            sprintf_f(rs->logs, "[DV] error read fileid poll length failed not multiplex of %d, lens: %d \n", lenrs, pubf->usfacLength);
                                            print_f(rs->plogs, "P11", rs->logs);                                
                                            pubf->usfacLength = 0;
                                    
                                            lens = 0;
                                        } else {
                                            lens = pubf->usfacLength / lenrs;
                                        }
                                    }
                                    
                                    pubfidnxt = 0;
                                    
                                    //sprintf_f(rs->logs, " lens = %d, fileidlen = %d - 2\n", lens, pubf->usfacLength);
                                    //print_f(rs->plogs, "P11", rs->logs);                                

                                    if (lens) {
                                        pubfidc = pubf->usfacPt;
                                        
                                        for(ix=0; ix < lens; ix++) {
                                            getents = pubfidc[ix].usfdid[0] | (pubfidc[ix].usfdid[1] << 8);
                                            
                                            if (getents == act) {
                                                pubfidnxt = &pubfidc[ix];
                                            }
                                    
                                            #if 0
                                            sprintf_f(rs->logs, "    [%d] %d %c %d, addr: 0x%x size: %d getid: %d\n", ix, getents, pubfidc[ix].usfdid[2], 
                                                            pubfidc[ix].usfdid[3], pubfidc[ix].usfdAddr, pubfidc[ix].usfdsize, act);
                                            print_f(rs->plogs, "P11", rs->logs);                                
                                            #endif
                                        }
                                    } else {
                                        pubf->usfacLength = 0;
                                        pubf->usfacPt = (struct usbFileidContent_s  *)fileidbuff;
                                        sprintf_f(rs->logs, "    [empty] \n");
                                        print_f(rs->plogs, "P11", rs->logs);                                
                                    }
                                    
                                    if ((pubfidnxt == 0) && (val == 1)) {
                                        lenrs = sizeof(struct usbFileidContent_s);
                                        pubfidnxt = &pubf->usfacPt[lens];
                                        pubf->usfacLength += lenrs;
                                    }
                                }
                                else {
                                    sprintf_f(rs->logs, "[DV]  Error!! fileid access buff is not null!! \n");
                                    print_f(rs->plogs, "P11", rs->logs);
                                }

                                break;
                            case 4: // rd
                                break;
                            case 5: // clear
                                break;
                            case 6: // reset to DL mode
                                break;
                            case 7: // reset ASIC
                                break;
                            case 8: // total reset
                                break;
                            case 9: // get version
                                break;
                            default:
                                break;
                            }


                            //memset(iubsBuff, 0, SPI_TRUNK_SZ);

                            sprintf_f(rs->logs, "[DV] file access dlen: %d, fileid: %d, wrtrd: %d, addr: 0x%.8x, fsize: %d, direct: %d select: %d\n"
                                                        , msb2lsb32(&ucbwfile->pramDataLength), act, ucbwfile->pramWrtorRd[0], (uint32_t)msb2lsb32(&ucbwfile->pramAddress)
                                                        , msb2lsb32(&ucbwfile->pramFilesize) , ucbwfile->pramDirect, ucbwfile->ASIC_sel);
                            print_f(rs->plogs, "P11", rs->logs);

                            filesz = lenflh;
                    
                            if (strcmp(msgcmd, "usbscan") != 0) {
                                sprintf(msgcmd, "usbscan");
                                rs_ipc_put(rcmd, msgcmd, strlen(msgcmd));

                                chq = 'n';
                                pipRet = write(pipeTx[1], &chq, 1);
                                if (pipRet < 0) {
                                    sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    continue;
                                }
                            }

                            opc = 0xff;
                            dat = 0;

                            if (!lenflh) {
                                //ring_buf_init(rs->pcmdRx);
                                val = ucbwfile->pramWrtorRd[0];
                                act = ucbwfile->ASIC_sel;
                                sprintf_f(rs->logs, "[DV] file access data length: %d, sel: %d, wr: %d \n", lenflh, act, val);
                                print_f(rs->plogs, "P11", rs->logs);
                                                                
                                switch (val) {
                                case 1:
                                case 2:
                                    sprintf_f(rs->logs, "[DV] Error RWD field with data length == 0");
                                    print_f(rs->plogs, "P11", rs->logs);
                                    break;
                                case 3: // wrt
                                    opc = 0;
                                    dat = 0xff;

                                    pubfidc = pubf->usfacPt;
                                    lenbs = sizeof(struct usbFileidContent_s);
                                    lens = pubf->usfacLength / lenbs;
                                    pubfidnxt = 0;
                                    
                                    for(ix=0; ix < lens; ix++) {
                                        getents = pubfidc->usfdid[0] | (pubfidc->usfdid[1] << 8);
                                    
                                        #if 1
                                        sprintf_f(rs->logs, "    srhwrfstt - [%d] %d %c %d, addr: 0x%x size: %d select: %d\n", ix, (uint32_t)getents, pubfidc->usfdid[2], 
                                                       pubfidc->usfdid[3], pubfidc->usfdAddr, pubfidc->usfdsize, act);
                                        print_f(rs->plogs, "P11", rs->logs);                                
                                        #endif
                                    
                                        if ((pubfidc->usfdsize != 0) && (pubfidc->usfdid[3] == act)) {
                                            pubfidnxt = pubfidc;
                                            break;
                                        }

                                        pubfidc++;
                                    }
                                    
                                    if (pubfidnxt == 0) {
                                        break;;
                                    } 
                                    
                                    if (!act) {
                                        //if (usbid01) {
                                            endTran[0] = 'j';
                                            endTran[1] = pubfidnxt->usfdid[1];
                                            endTran[2] = pubfidnxt->usfdid[0];
                                            endTran[3] = pubfidnxt->usfdAddr & 0xff;
                                            endTran[4] = (pubfidnxt->usfdAddr >> 8) & 0xff;
                                            endTran[5] = (pubfidnxt->usfdAddr >> 16) & 0xff;
                                            endTran[6] = (pubfidnxt->usfdAddr >> 24) & 0xff;
                                            //endTran[1] = ucbwfile->pramFileId[0];
                                            //endTran[2] = ucbwfile->pramFileId[1];

                                            pipRet = write(pipeTx[1], endTran, 7);
                                            if (pipRet < 0) {
                                                sprintf_f(rs->logs, "[DV] send erase section ret: %d \n", pipRet);
                                                print_f(rs->plogs, "P11", rs->logs);
                                                continue;
                                            }
                                        //}
                                    } else {
                                        //if (usbid02) {
                                            endTran[0] = 'j';
                                            endTran[1] = pubfidnxt->usfdid[1];
                                            endTran[2] = pubfidnxt->usfdid[0];
                                            endTran[3] = pubfidnxt->usfdAddr & 0xff;
                                            endTran[4] = (pubfidnxt->usfdAddr >> 8) & 0xff;;
                                            endTran[5] = (pubfidnxt->usfdAddr >> 16) & 0xff;;
                                            endTran[6] = (pubfidnxt->usfdAddr >> 24) & 0xff;;
                                            //endTran[1] = ucbwfile->pramFileId[0];
                                            //endTran[2] = ucbwfile->pramFileId[1];
                                            
                                            pipRet = write(pipeTxd[1], endTran, 7);
                                            if (pipRet < 0) {
                                                sprintf_f(rs->logs, "[DV] send erase section ret: %d \n", pipRet);
                                                print_f(rs->plogs, "P11", rs->logs);
                                                continue;
                                            }
                                        //}
                                    }
                                    break;
                                case 4: // rd
                                    break;
                                case 5: // clear
                                    opc = 5;
                                    dat = 0xff;
                                    
                                    pubf->usfacLength = 0;
                                    
                                    sprintf_f(rs->logs, "[DV] clear bin file to ASIC !!\n");
                                    print_f(rs->plogs, "P11", rs->logs);

                                    sprintf(syscmd11, "/root/module/scanrmall.sh");
                                    ret = doSystemCmd(syscmd11);
                                    break;
                                case 6: // reset to DL mode
                                    opc = 6;
                                    dat = 0xff;
                                    
                                    sprintf_f(rs->logs, "[DV] reset ASIC to rom flash, select: %d \n"
                                                                , ucbwfile->ASIC_sel);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    
                                    act = ucbwfile->ASIC_sel;

                                    switch (act) {
                                    case 0: /* primary */
                                        sprintf(syscmd11, "/root/module/romPri.sh");
                                        ret = doSystemCmd(syscmd11);
                                        break;
                                    case 1: /* secondary */
                                        sprintf(syscmd11, "/root/module/romSec.sh");
                                        ret = doSystemCmd(syscmd11);
                                        break;
                                    default:
                                        sprintf_f(rs->logs, "[DV] Error!! unknown select %d \n", act);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        break;
                                    }
                                    
                                    pinfushost->ushostpidvid[0] = 0;
                                    pinfushost->ushostpidvid[1] = 0;
                                    
                                    endTran[0] = '0';
                                    
                                    pipRet = write(pipeTx[1], endTran, 1);
                                    if (pipRet < 0) {
                                        sprintf_f(rs->logs, "[DV] send pri reset to rom ret: %d \n", pipRet);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        continue;
                                    }


                                    pinfushostd->ushostpidvid[0] = 0;
                                    pinfushostd->ushostpidvid[1] = 0;
                                    
                                    endTran[0] = '0';
                                    
                                    pipRet = write(pipeTxd[1], endTran, 1);
                                    if (pipRet < 0) {
                                        sprintf_f(rs->logs, "[DV] send sec reset to rom ret: %d \n", pipRet);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        continue;
                                    }
                                    
                                    break;
                                case 7: // reset ASIC
                                    opc = 7;
                                    dat = 0xff;
                                    
                                    sprintf_f(rs->logs, "[DV] reset ASIC \n");
                                    print_f(rs->plogs, "P11", rs->logs);

                                    sprintf(syscmd11, "/root/module/romRst.sh");
                                    ret = doSystemCmd(syscmd11);
                                                                                                          
                                    endTran[0] = '0';
                                    
                                    pipRet = write(pipeTx[1], endTran, 1);
                                    if (pipRet < 0) {
                                        sprintf_f(rs->logs, "[DV] send pri reset to rom ret: %d \n", pipRet);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        continue;
                                    }
                                    
                                    endTran[0] = '0';
                                    
                                    pipRet = write(pipeTxd[1], endTran, 1);
                                    if (pipRet < 0) {
                                        sprintf_f(rs->logs, "[DV] send sec reset to rom ret: %d \n", pipRet);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        continue;
                                    }
                                    
                                    break;
                                case 8: // total reset
                                    sprintf_f(rs->logs, "[DV] reset all \n");
                                    print_f(rs->plogs, "P11", rs->logs);

                                    sprintf(syscmd11, "restart");
                                    ret = doSystemCmd(syscmd11);

                                    break;
                                case 9: // get version
                                    opc = 9;
                                    dat = 0xff;

                                    lens = strlen(MSP_VERSION);
                                    
                                    sprintf_f(rs->logs, "[DV] get version [%s] len: %d\n", MSP_VERSION, lens);
                                    print_f(rs->plogs, "P11", rs->logs);

                                    break;
                                default:
                                    break;
                                }

                                break;
                            }
                            else if (ucbwfile->pramDirect == 1) { // 1=output (BULK OUT)

                                /* save to fileid poll */
                                pubfidnxt->usfdAddr = msb2lsb32(&ucbwfile->pramAddress);
                                pubfidnxt->usfdid[0] = ucbwfile->pramFileId[1];
                                pubfidnxt->usfdid[1] = ucbwfile->pramFileId[0];
                                pubfidnxt->usfdid[2] = '=';
                                pubfidnxt->usfdid[3] = ucbwfile->ASIC_sel;
                                pubfidnxt->usfdsize = msb2lsb32(&ucbwfile->pramDataLength);
                            
                                ring_buf_init(rs->pcmdRx);

                                lenflh = (ucbwfile->pramFileId[0] << 8) | ucbwfile->pramFileId[1];
                                
                                endTran[0] = 'e';
                                endTran[1] = ucbwfile->pramFileId[0];
                                endTran[2] = ucbwfile->pramFileId[1];

                                sprintf_f(rs->logs, "[DVB] direct: 1 fileid: %d \n", lenflh);
                                print_f(rs->plogs, "P11", rs->logs);

                                rs_ipc_put(rs, endTran, 3);                                
                                continue;
                            }
                            else if (ucbwfile->pramDirect == 2) { // 2=input (BULK IN)
                                if (pubfidnxt) {
                                    err=0;
                                    
                                    if (pubfidnxt->usfdAddr != msb2lsb32(&ucbwfile->pramAddress)) err++;
                                    if (pubfidnxt->usfdid[0] != ucbwfile->pramFileId[1]) err++;
                                    if (pubfidnxt->usfdid[1] != ucbwfile->pramFileId[0]) err++;
                                    if (pubfidnxt->usfdid[3] != ucbwfile->ASIC_sel) err++;
                                    if (pubfidnxt->usfdsize != msb2lsb32(&ucbwfile->pramDataLength)) err++;

                                    if (err) {
                                        sprintf_f(rs->logs, "[DVB] Error!!! fileid's data is wrong err count: %d  \n", err);
                                        print_f(rs->plogs, "P11", rs->logs);

                                        cmd = 0;
                                        opc = 0xff;
                                        dat = 0;
                                        continue;
                                    }
                                
                                } else {
                                    sprintf_f(rs->logs, "[DVB] Error!!! fileid point is null  \n");
                                    print_f(rs->plogs, "P11", rs->logs);
                                    cmd = 0;
                                    opc = 0xff;
                                    dat = 0;
                                    continue;
                                }
                            
                                dat = 0xff;
                                
                                ring_buf_init(rs->pcmdRx);
                                
                                lenflh = (ucbwfile->pramFileId[0] << 8) | ucbwfile->pramFileId[1];
                                
                                endTran[0] = 'h';
                                endTran[1] = ucbwfile->pramFileId[0];
                                endTran[2] = ucbwfile->pramFileId[1];

                                sprintf_f(rs->logs, "[DVB] direct: 2 fileid: %d \n", lenflh);
                                print_f(rs->plogs, "P11", rs->logs);

                                rs_ipc_put(rs, endTran, 3);      
                                continue;;
                            }
                            else {
                                sprintf_f(rs->logs, "\n[DVF] Error!!! unknown sendfile pramDirect: %d, cmd: 0x%.2x opc: 0x%.2x, dat: 0x%.2x  \n",ucbwfile->pramDirect, cmd, opc, dat);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                        else if ((cmd >= 0x00) && (cmd <= 0x0f)) {
                            if (!iubsBuff) {
                                sprintf_f(rs->logs, "\n[DVF] Error !!! iubsBuff is null!!!! cmd: 0x%.2x opc: 0x%.2x, dat: 0x%.2x  \n",cmd, opc, dat);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                            
                            //memset(iubsBuff, 0, SPI_TRUNK_SZ);

                            memcpy(iubsBuff, ptrecv, 31);

                            #if LOG_FLASH
                            sprintf_f(rs->logs, "[DV] enty flash id:0x%.8x len:%d cmd:0x%.2x addr:0x%.8x direct:%d ASIC: %d \n", 
                                                          msb2lsb32(&ucbwpram->pramID), msb2lsb32(&ucbwpram->pramDataLength), 
                                                          ucbwpram->pramType, (uint32_t)msb2lsb32(&ucbwpram->pramAddress), ucbwpram->pramDirect, ucbwpram->ASIC_sel);
                            print_f(rs->plogs, "P11", rs->logs);
                            #else
                            switch (ucbwpram->pramDirect) {
                            case 1:
                                printf("write...");
                                break;
                            case 2:
                                printf("read...");
                                break;
                            default:
                                printf("...");
                                break;
                            }
                            #endif

                            puscur = pushost;     
                            pinfcur = pinfushost;

                            if (strcmp(msgcmd, "usbscan") != 0) {
                                sprintf(msgcmd, "usbscan");
                                rs_ipc_put(rcmd, msgcmd, strlen(msgcmd));


                                chq = 'n';
                                pipRet = write(pipeTx[1], &chq, 1);
                                if (pipRet < 0) {
                                    sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    continue;
                                }
                            }

                            usbCur = puscur->pushring;

                            piptx = puscur->pushtx;
                            piprx = puscur->pushrx; 
                                    
                            opc = 0xff;
                            dat = 0;

                            if (ucbwpram->pramDirect == 0) { // 0=no data
                                if (ucbwpram->ASIC_sel) {
                                    if (usbid02) {
                                        chd = 'i';
                                        pipRet = write(pipeTxd[1], &chd, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }
                                } else {
                                    if (usbid01) {
                                        chq = 'i';
                                        pipRet = write(pipeTx[1], &chq, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }
                                }

                                break;
                            }
                            else if (ucbwpram->pramDirect == 1) { // 1=output (BULK OUT)
                                continue;
                            }
                            else if (ucbwpram->pramDirect == 2) { // 2=input (BULK IN)
                                dat = 0xff;
                                
                                if (ucbwpram->ASIC_sel) {
                                    if (usbid02) {
                                        chd = 'y';
                                        pipRet = write(pipeTxd[1], &chd, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }
                                } else {
                                    if (usbid01) {
                                        chq = 'y';
                                        pipRet = write(pipeTx[1], &chq, 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                    }
                                }
                                
                                break;
                            }
                            else {
                                sprintf_f(rs->logs, "\n[DVF] Error!!! unknown pramDirect: %d, cmd: 0x%.2x opc: 0x%.2x, dat: 0x%.2x  \n",ucbwpram->pramDirect, cmd, opc, dat);
                                print_f(rs->plogs, "P11", rs->logs);
                                continue;
                            }
                        }
                        else {
                            sprintf_f(rs->logs, "\n[DVF] Error!!! unknown usb opc, cmd: 0x%.2x opc: 0x%.2x, dat: 0x%.2x  \n",cmd, opc, dat);
                            print_f(rs->plogs, "P11", rs->logs);
                            continue;
                        }
                    }         
                    else {
                        sprintf_f(rs->logs, "[DV] Error!!! unknown data dump size: %d \n", recvsz);
                        print_f(rs->plogs, "P11", rs->logs);
                        
                        cmd = 0;
                        opc = 0;
                        dat = 0;
                        
                        shmem_dump(ptrecv, recvsz);
                    }
                }
            }
        }
        
        while (usbentsTx == 1) { 
            #if 0
            if ((cmd == 0x12) && (opc == 0x0f) && (pid > 0)) {

                while (1) {
                    ret = read(pipepc[0], &ch, 1);
                    sprintf_f(rs->logs, "[ISO] pipepc get ch: %c ret: %d\n", ch, ret);
                    print_f(rs->plogs, "P11", rs->logs);
                    if (ret > 0) {
                        sleep(1);

                        ch = 'A';
                        write(pipeusb[1], &ch, 1);
                        sprintf_f(rs->logs, "[ISO] pipeusb send ch: %c \n", ch);
                        print_f(rs->plogs, "P11", rs->logs);
                        
                    }

                    usleep(500000);
                }
            }
            else 
            #endif
            
            #if SCAN_BNOTE_EN // test code
            if ((cmd == 0x12) && (opc == 0x0f)) { /* usbentsTx == 1*/
                //addrd = 0;
                while (addrd == 0) {
                    for (ix=0; ix < BMP_DECODE_PIC_SIZE; ix++) {
                        if (bflens[ix]) {
                            addrd = bfs[ix];
                            lens = bflens[ix];
                    
                            addrb= bfex;
                            lastCylen = exlen;
                    
                            bflens[ix] = 0;
                            break;
                        }
                    }

                    if ((addrd) && (lens) && (addrb) && (lastCylen)) {
                        break;
                    }
                    
                    while (1) {
                        pipRet = poll(ptfd, 1, 500);
                    
                        #if LOG_P11_EN
                        sprintf_f(rs->logs, "[DV] pipeRx get ch: 0x%.2x ret: %d idle: %dms\n", ch, pipRet, idlet);
                        print_f(rs->plogs, "P11", rs->logs);
                        #endif
                    
                        if (pipRet <= 0) {
                            clock_gettime(CLOCK_REALTIME, &tidleE);
                            idlet = time_diff(&tidleS, &tidleE, 1000000);
                            
                            if (idlet > 6000) {
                                clock_gettime(CLOCK_REALTIME, &tidleS);
                                // timeout
                            }
                        }
                        else {
                            mbufidx = -1;
                            pmbf = 0;
                            ret = read(pipeRx[0], &ch, 1);
                            if ((ret > 0) && (ch == 'P')) {
                                err = read(pipeRx[0], &ch, 1);
                                //sprintf_f(rs->logs, "[DV] get pipeRx sec ch == 0x%.2x ret: %d \n", ch, err);
                                //print_f(rs->plogs, "P11", rs->logs);
                    
                                if (ch == 0x80) {
                                    mbufidx = 0;
                                } else {
                                    mbufidx = ch & 0x7f;
                                }
                            } else {
                                sprintf_f(rs->logs, "[DV] Error!!! get pipeRx ch == 0x%.2x ret: %d \n", ch, ret);
                                print_f(rs->plogs, "P11", rs->logs);
                            }
                            
                            if ((mbufidx >= 0) && (mbufidx < 4)) {
                                pmbf = rs->pbDecMfour[mbufidx];
                                ret = aspBMPdecodeBuffPagerstGet(pmbf, &val);
                                ret |= aspBMPdecodeBuffStatusGet(pmbf, &mbstats);
                                if (ret) {
                                    sprintf_f(rs->logs, "[DV] Error!!! buff index == %d get status wrong == 0x%.8x wrong addr: 0x%.8x\n", mbufidx, mbstats, (uint32_t)pmbf);
                                    print_f(rs->plogs, "P11", rs->logs);
                                } else {
                                    
                                    cswerr = mbstats;
                                    pagerst = val;
                    
                                    sprintf_f(rs->logs, "[DV] get csw err and page rest: 0x%.2x, %d \n", cswerr, pagerst);
                                    print_f(rs->plogs, "P11", rs->logs);
                    
                                    err = aspBMPdecodeItemGet(&pmbf->aspDecMeta, &bfmt, &mtlen);
                                    //sprintf_f(rs->logs, "[DV] bfmt  addr: 0x%.8x len: %d ret: %d\n", (uint32_t)bfmt, mtlen, err);
                                    //print_f(rs->plogs, "P11", rs->logs);
                    
                                    for (ix=0; ix < BMP_DECODE_PIC_SIZE; ix++) {
                                        bfs[ix] = 0;
                                        bflens[ix] = 0;
                                    }
                                    for (ix=0; ix < BMP_DECODE_PIC_SIZE; ix++) {
                                        err = aspBMPdecodeItemGet(&pmbf->aspDecMfPiJpg[ix], &bfs[ix], &bflens[ix]);
                    
                                        sprintf_f(rs->logs, "[DV] output bfs %d. addr: 0x%.8x len: %d ret: %d - 1\n", ix, (uint32_t)bfs[ix], bflens[ix], err);
                                        print_f(rs->plogs, "P11", rs->logs);

                                        
                                        if ((bflens[ix] == 0) && (cswerr) && (!pagerst)) { // the last page
                                            pbf = bfs[ix] + bflens[ix];
                    
                                            memcpy(pbf, bfmt, mtlen);
                    
                                            bflens[ix] += mtlen;

                                            pagerst = ix + 1;
                    
                                            sprintf_f(rs->logs, "[DV] output bfs %d. addr: 0x%.8x len: %d ret: %d, cswerr: %d, pagerst: %d - 2\n", ix, (uint32_t)bfs[ix], bflens[ix], err, cswerr, pagerst);
                                            print_f(rs->plogs, "P11", rs->logs);

                                            chq = '1';
                                            pipRet = write(pipeTx[1], &chq, 1);
                                            if (pipRet < 0) {
                                                sprintf_f(rs->logs, "[DV] Error!!! pipe send meta ret: %d \n", pipRet);
                                                print_f(rs->plogs, "P11", rs->logs);
                                            }
                                            
                                            break;
                                        }                                        
                                        
                                    }
                    
                                    err = aspBMPdecodeItemGet(&pmbf->aspDecMetaex, &bfex, &exlen);
                                    //sprintf_f(rs->logs, "[DV] bfmtex  addr: 0x%.8x len: %d ret: %d\n", (uint32_t)bfex, exlen, err);
                                    //print_f(rs->plogs, "P11", rs->logs);                                        
                    
                                    break;
                                }
                            }
                            else {
                                sprintf_f(rs->logs, "[DV] Error!!! get buff index == %d wrong \n", mbufidx);
                                print_f(rs->plogs, "P11", rs->logs);
                            }
                        }
                    }
                }

                rlen = lens % 512;
                msync(addrd, lens, MS_SYNC);
                
                //sprintf_f(rs->logs, "[DV] the meta size: %d dump: \n", rlen);
                //print_f(rs->plogs, "P11", rs->logs);
                //shmem_dump(addrd+(lens-rlen), 16);
                
                dbgMetaUsb((struct aspMetaDataviaUSB_s *)(addrd+(lens-rlen)));
                
                if (!rlen) {
                    sprintf_f(rs->logs, "[DV] WARNING!!! the image size is multiplex of trunk size  !!!size: %d - 1 \n", lens);
                    print_f(rs->plogs, "P11", rs->logs);
                }

                cntTx = 0;
                errcnt = 0;
                while (lens) {
                    sendsz = usbc_write(usbfd, addrd, lens);
                    if (sendsz < 0) {
                        errcnt++;
                        if ((errcnt & 0x1fff) == 0) {
                            sprintf_f(rs->logs, "[DV] usb image send ret: %d [addr: 0x%.8x] szie: %d!!!\n", sendsz, (uint32_t)addrd, lens);
                            print_f(rs->plogs, "P11", rs->logs);
                            usleep(50000);
                        }
                        continue;
                    }

                    //sprintf_f(rs->logs, "[DV] usb image send ret: %d size: %d - %d\n", sendsz, lens, cntTx);
                    //print_f(rs->plogs, "P11", rs->logs);
                    

                    lens -= sendsz;
                    addrd += sendsz;
                    cntTx++;
                }

                rlen = lastCylen % 512;
                //sprintf_f(rs->logs, "[DV] the extra meta size: %d dump: \n", lastCylen);
                //print_f(rs->plogs, "P11", rs->logs);
                //shmem_dump(addrb, 16);

                if (!rlen) {
                    sprintf_f(rs->logs, "[DV] WARNING!!! the image size is multiplex of trunk size  !!!size: %d - 2 \n", lastCylen);
                    print_f(rs->plogs, "P11", rs->logs);
                }
                
                msync(addrb, lastCylen, MS_SYNC);

                cntTx = 0;
                errcnt = 0;
                while (lastCylen) {
                    sendsz = usbc_write(usbfd, addrb, lastCylen);
                    if (sendsz < 0) {
                        errcnt++;
                        if ((errcnt & 0x1fff) == 0) {
                            sprintf_f(rs->logs, "[DV] usb exmeta send ret: %d [addr: 0x%.8x] szie: %d!!!\n", sendsz, (uint32_t)addrb, lastCylen);
                            print_f(rs->plogs, "P11", rs->logs);
                            usleep(50000);
                        }
                        continue;
                    }

                    //sprintf_f(rs->logs, "[DV] usb exmeta send ret: %d size: %d - %d\n", sendsz, lastCylen, cntTx);
                    //print_f(rs->plogs, "P11", rs->logs);
                    
                    lastCylen -= sendsz;
                    addrb += sendsz;
                    cntTx++;
                }

                addrd = 0;
                lens = 0;
                addrb = 0;
                lastCylen = 0;

                for (ix=0; ix < BMP_DECODE_PIC_SIZE; ix++) {
                    if (bflens[ix]) {
                        lens = bflens[ix];
                        break;
                    }
                }

                if (lens == 0) {
                    if ((mbufidx >= 0) && (mbufidx < 4) && (pmbf)) {
                        pagerst = 0;
                        
                        //aspBMPdecodeBuffInit(pmbf);
                        //sprintf_f(rs->logs, "[DV] free the buff index: %d \n", mbufidx);
                        //print_f(rs->plogs, "P11", rs->logs);

                        aspBMPdecodeBuffStatusSet(pmbf, -2);

                        if (mbufidx == 0) {
                            ch = 0x80;
                        } else {
                            ch = mbufidx & 0x7f;
                        }
                                
                        msgret[0] = 'b';
                        msgret[1] = ch;

                        rs_ipc_put(rsd, msgret, 2);
                    } else {
                        sprintf_f(rs->logs, "[DV] Error!!! can't free the buff index: %d pmbf: 0x%.8x \n", mbufidx, (uint32_t)pmbf);
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                }

                opc = 0;
                continue;
            } 
            else if (((cmd == 0x12) && ((opc == 0x04) || (opc == 0x05) || (opc == 0x0a) || (opc == 0x09) || (opc == 0x0e))) || (pid == 0))  /* usbentsTx == 1*/
            #else //SCAN_BNOTE_EN
            if (((cmd == 0x12) && ((opc == 0x04) || (opc == 0x05) || (opc == 0x0a) || (opc == 0x09) || (opc == 0x0e) || (opc == 0x0f))) || (pid == 0))  /* usbentsTx == 1*/
            #endif //SCAN_BNOTE_EN
            {
                //ch = 'A';
                //write(pipepc[1], &ch, 1);
                //sprintf_f(rs->logs, "[ISO] pipepc send ch: %c \n", ch);
                //print_f(rs->plogs, "P11", rs->logs);

                //do {
                #if USB_HS_SAVE_RESULT_DV
                fsave = find_save(ptfilepath, ptfileSave);
                if (!fsave) {
                    sprintf_f(rs->logs, "[DV] find save [%s] failed!!! \n", ptfileSave);
                    print_f(rs->plogs, "P11", rs->logs);
                    continue;    
                }
                saveSize = 120*1024*1024;
                pImage = malloc(saveSize);
                if (pImage) {
                    ptmp = pImage;
                } else {
                    sprintf_f(rs->logs, "alloc memory failed!! size: %d \n", saveSize);
                    print_f(rs->plogs, "P11", rs->logs);
                }
                #endif

                while (1) {       
                    #if 0//DBG_27_DV
                    sprintf_f(rs->logs, "[DV] addrd: 0x%.8x cylcnt: %d:%d pipe%d\n", addrd, uimCylcnt, datCylcnt, piprx[0]);
                    print_f(rs->plogs, "P11", rs->logs);
                    #endif
                    
                    while (addrd == 0) {
                        //chr = 0;
                        while (1) {
                            if (uimCylcnt > 0) {
                                break;
                            }

                            if (endf) {
                                if (!puimCnTH) {
                                    if (endm) {
                                        addrd = endm;
                                        if (seqtx < USB_BUF_SIZE) {
                                            lens = seqtx;
                                                
                                            seqtx = maxsz;
                                            endm = palloc;
                                        } else {
                                            lens = USB_BUF_SIZE;
                                            seqtx = seqtx - lens;
                                            endm += lens;
                                        }
                                    } else {
                                        addrd = endf;
                                        lens = strlen(endf);
                                    }
                                    break;
                                }
                            }
                            
                            chq = 0;
                            chd = 0;

                            //ptfdc[0].fd = piprx[0];
                            //ptfdc[0].events = POLLIN;
                            clock_gettime(CLOCK_REALTIME, &tidleE);
                            idlet = time_diff(&tidleS, &tidleE, 1000000);

                            #if LOG_P11_EN
                            sprintf_f(rs->logs, "[DV] start poll %d ms puimGet: 0x%.8x puimCnTH: 0x%.8x rx: %d, 0: %d, 1: %d\n", idlet, (uint32_t)puimGet, (uint32_t)puimCnTH, piprx[0], ptfdc[0].fd, ptfdc[1].fd);
                            print_f(rs->plogs, "P11", rs->logs);
                            #endif

                            //ret = read(pipeusb[0], &ch, 1);
                            //sprintf_f(rs->logs, "[ISO] pipeusb get ch: %c ret: %d\n", ch, ret);
                            //print_f(rs->plogs, "P11", rs->logs);
                            
                            pipRet = poll(ptfdc, 2, 200);
                            if (pipRet <= 0) {
                                clock_gettime(CLOCK_REALTIME, &tidleE);
                                idlet = time_diff(&tidleS, &tidleE, 1000000);
                                #if LOG_P11_EN
                                sprintf_f(rs->logs, "[DV] wait for %d ms puimGet: 0x%.8x puimCnTH: 0x%.8x\n", idlet, (uint32_t)puimGet, (uint32_t)puimCnTH);
                                print_f(rs->plogs, "P11", rs->logs);
                                #endif

                                if (puimGet) {
                                    if ((puimGet->uimGetCnt == 0) && ((opc == 0x0a) || (opc == 0x05) || (opc == 0x0e) || (opc == 0x0f))) {

                                        sprintf_f(rs->logs, "[DV] wait id %d - %d \n", puimGet->uimIdex & 0x3ff, puimGet->uimCount);
                                        print_f(rs->plogs, "P11", rs->logs);

                                        //if (idlet > 60000) {
                                        if (idlet > 60000) {
                                            clock_gettime(CLOCK_REALTIME, &tidleS);

                                            if (puimCnTH == puimGet) {
                                                puimCnTH = puimGet->uimNxt;
                                                
                                                puimNxt = 0;
                                                ix=0;
                                                cindex = 0;
                                                puimTmp = puimCnTH;
                                                while (puimTmp) {
                                                    puimUse = puimTmp;

                                                    #if 1
                                                    if (cindex == 0) {
                                                        cindex = puimUse->uimIdex & 0x3ff;
                                                        puimNxt = puimUse;
                                                    } else {
                                                        if ((puimUse->uimIdex & 0x3ff) < cindex) {
                                                            cindex = puimUse->uimIdex & 0x3ff;
                                                            puimNxt = puimUse;
                                                        }
                                                    }
                                                    #else
                                                    if (puimUse->uimIdex == ((puimGet->uimIdex & 0x3ff) + 1)) {
                                                        puimNxt = puimUse;
                                                    }
                                                    #endif
                                                    
                                                    puimTmp = puimUse->uimNxt;
                                                    ix++;
                                                }
                                            }
                                            else {

                                                ix=0;
                                                puimTmp = puimCnTH;
                                                while (puimTmp) {
                                                    puimUse = puimTmp;
                                                    
                                                    #if 1
                                                    if (cindex == 0) {
                                                        cindex = puimUse->uimIdex & 0x3ff;
                                                        puimNxt = puimUse;
                                                    } else {
                                                        if ((puimUse->uimIdex & 0x3ff) < cindex) {
                                                            cindex = puimUse->uimIdex & 0x3ff;
                                                            puimNxt = puimUse;
                                                        }
                                                    }
                                                    #else
                                                    if (puimUse->uimIdex == ((puimGet->uimIdex & 0x3ff) + 1)) {
                                                        puimNxt = puimUse;
                                                    }
                                                    #endif
                                                    
                                                    puimTmp = puimUse->uimNxt;
                                                    if (puimTmp == puimGet) {
                                                        puimUse->uimNxt = puimGet->uimNxt;
                                                    }                

                                                    puimTmp = puimUse->uimNxt;
                                                    ix++;
                                                }
                                            }

                                            free(puimGet);
                                            puimGet = 0;
                                            
                                            if (puimNxt) {
                                                puimGet = puimNxt;
                                            }
                                            
                                            ix = 0;
                                            puimTmp = puimCnTH;
                                            while(puimTmp) {
                                                #if 1
                                                sprintf_f(rs->logs, "[DV] %d - 0x%.2x %d:%d timeout srh\n", ix, puimTmp->uimIdex, puimTmp->uimGetCnt, puimTmp->uimCount);
                                                print_f(rs->plogs, "P11", rs->logs);
                                                #endif

                                                if (puimTmp->uimCount > 0) {
                                                    ix++;
                                                }
                                                puimTmp = puimTmp->uimNxt;
                                            }                             

                                            waitCylen = ix;
                                            sprintf_f(rs->logs, "[DV] wait page size: %d timeout\n", waitCylen);
                                            print_f(rs->plogs, "P11", rs->logs);

                                            chr = 0;

                                            if ((puimGet) && ((opc == 0x05) || (opc == 0x0a))) {
                                                if ((puimGet->uimIdex & 0x400) == 0) {
                                                    puscur = pushost;
                                                    pinfcur = pinfushost;
                                                    usbCur = puscur->pushring;
                                                    piptx = puscur->pushtx;
                                                    piprx = puscur->pushrx; 
                                                } else {
                                                    puscur = pushostd;
                                                    pinfcur = pinfushostd;
                                                    usbCur = puscur->pushring;
                                                    piptx = puscur->pushtx;
                                                    piprx = puscur->pushrx; 
                                                }
                                            } else {
                                                sprintf_f(rs->logs, "[DV] puimGet is null timeout break\n");
                                                print_f(rs->plogs, "P11", rs->logs);

                                                memset(ptrecv, 0, 160);

                                                memcpy(ptrecv, emptyLast, 4);

                                                sendsz = usbc_write(usbfd, ptrecv, 160);
                                                while (sendsz <= 0) {
                                                    sendsz = usbc_write(usbfd, ptrecv, 160);
                                                }

                                                memcpy(ptrecv, emptyLine, 4);
                                                
                                                sendsz = usbc_write(usbfd, ptrecv, 4);
                                                while (sendsz <= 0) {
                                                    sendsz = usbc_write(usbfd, ptrecv, 4);
                                                }

                                                che = 'E';
                                                uimCylcnt = 0;
                                                lens = 0;
                                                
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            else {

                                clock_gettime(CLOCK_REALTIME, &tidleS);
                                
                                for (ix=0; ix < 2; ix++) {
                                    if ((ptfdc[ix].revents & POLLIN) == POLLIN) {
                                        if (ptfdc[ix].fd == piprx[0]) {
                                            ret = read(ptfdc[ix].fd, &chq, 1);

                                            #if LOG_P11_EN
                                            sprintf_f(rs->logs, "[DV] chq: 0x%.2x chr: 0x%.2x %d.pipe%d ret=%d \n", chq, chr, ix, ptfdc[ix].fd, ret);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            #endif

                                        } else {
                                            ret = read(ptfdc[ix].fd, &chd, 1);
                                            
                                            #if LOG_P11_EN
                                            sprintf_f(rs->logs, "[DV] extra chd: 0x%.2x chr: 0x%.2x %d.pipe%d ret=%d \n", chd, chr, ix, ptfdc[ix].fd, ret);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            #endif
                                        }

                                        if ((chd & 0xc0) == 0xc0) {
                                            cindexfo[0] = chd;
                                            pipRet = read(ptfdc[ix].fd, &chd, 1);
                                            while (pipRet < 0) {
                                                pipRet = read(ptfdc[ix].fd, &chd, 1);
                                            }

                                            #if LOG_P11_EN
                                            sprintf_f(rs->logs, "[DV] extra pre: 0x%.2x nxt: 0x%.2x pipe%d\n", cindexfo[0], chd, ptfdc[ix].fd);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            #endif

                                            if ((chd & 0xc0) == 0x40) {
                                                cindexfo[1] = chd;
                                            } else {
                                                sprintf_f(rs->logs, "[DV]  WARNNING get unknown chd: 0x%.2x \n", chd);
                                                print_f(rs->plogs, "P11", rs->logs);
                                                break;
                                            }

                                            cindex = ((cindexfo[0] & 0x3f) << 5) | (cindexfo[1] & 0x1f);

                                            #if LOG_P11_EN
                                            sprintf_f(rs->logs, "[DV] get page index extra: 0x%.3x currx: %d \n", cindex, piprx[0]);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            #endif

                                            if (!puimCnTH) {
                                                //sprintf_f(rs->logs, "extra puimCnTH is null!!! \n");
                                                //print_f(rs->plogs, "P11", rs->logs);

                                                puimCnTH = malloc(sizeof(struct usbIndex_s));
                                                if (!puimCnTH) {
                                                    sprintf_f(rs->logs, "Error!!! can't get memory for usbIndex_s\n\n\n");
                                                    print_f(rs->plogs, "P11", rs->logs);
                                                    break;
                                                }

                                                memset(puimCnTH, 0, sizeof(struct usbIndex_s));

                                                puimCnTH->uimIdex = cindex;
                                            }
                                            #if LOG_P11_EN
                                            else {
                                                act = 0;
                                                puimTmp = puimCnTH;
                                                while(puimTmp) {

                                                    sprintf_f(rs->logs, "[DV] extra page.%d - 0x%.3x %d/%d (addr: 0x%.8x) \n", act, puimTmp->uimIdex, puimTmp->uimGetCnt, puimTmp->uimCount, (uint32_t)puimTmp);
                                                    print_f(rs->plogs, "P11", rs->logs);

                                                    puimTmp = puimTmp->uimNxt;

                                                    act++;
                                                }                             
                                            }
                                            #endif

                                            if (puimCud) {
                                                if ((puimCud->uimIdex & 0x3ff) == (cindex & 0x3ff)) {
                                                    puimCud->uimCount += 1;
                                                }
                                                else {

                                                    //sprintf_f(rs->logs, "[DV] extra current puim index not mach wait:0x%.3x, get:0x%.3x chr: 0x%.3x!!!\n\n", puimCud->uimIdex, cindex, chr);
                                                    //print_f(rs->plogs, "P11", rs->logs);

                                                    puimTmp= puimCnTH;
                                                    while(puimTmp) {
                                                        puimUse = puimTmp;
                                                        if ((puimUse->uimIdex & 0x3ff) == (cindex & 0x3ff)) {
                                                            puimTmp = puimUse;
                                                            break;
                                                        }
                                                        puimTmp = puimUse->uimNxt;
                                                    }

                                                    if (puimTmp) {
                                                        puimTmp->uimCount += 1;
                                                        puimCud = puimTmp;
                                                    } else {

                                                        puimTmp = malloc(sizeof(struct usbIndex_s));
                                                        if (!puimTmp) {
                                                            sprintf_f(rs->logs, "Error!!! can't get memory for puimTmp -2 !!!\n\n\n");
                                                            print_f(rs->plogs, "P11", rs->logs);
                                                            break;
                                                        }

                                                        memset(puimTmp, 0, sizeof(struct usbIndex_s));

                                                        puimTmp->uimIdex = cindex;
                                                        puimTmp->uimCount += 1;
                                                        puimUse->uimNxt = puimTmp;

                                                        puimCud = puimTmp;
                                                    }
                                                }
                                            }
                                            else {
                                                if ((puimCnTH->uimIdex & 0x3ff) == (cindex & 0x3ff)) {
                                                    puimCnTH->uimCount += 1;
                                                    puimCud = puimCnTH;
                                                } else {

                                                    puimTmp= puimCnTH;
                                                    while(puimTmp) {
                                                        puimUse = puimTmp;
                                                        if ((puimUse->uimIdex & 0x3ff) == (cindex  & 0x3ff)) {
                                                            puimTmp = puimUse;
                                                            break;
                                                        }
                                                        puimTmp = puimUse->uimNxt;
                                                    }

                                                    if (puimTmp) {
                                                        puimTmp->uimCount += 1;                            
                                                        puimCud = puimTmp;
                                                    } else {
                                                        puimTmp = malloc(sizeof(struct usbIndex_s));
                                                        if (!puimTmp) {
                                                            sprintf_f(rs->logs, "Error!!! can't get memory for puimTmp!!! \n\n\n");
                                                            print_f(rs->plogs, "P11", rs->logs);
                                                            break;
                                                        }

                                                        memset(puimTmp, 0, sizeof(struct usbIndex_s));

                                                        puimTmp->uimIdex = cindex;
                                                        puimTmp->uimCount += 1;
                                                        puimUse->uimNxt = puimTmp;

                                                        puimCud = puimTmp;
                                                    }
                                                }
                                            }  

                                            chd = 0;
                                        }
                                    }
                                }
                            }
                            
                            if (chq == 0xff) {
                                if (chr) {
                                
                                    mindexfo[0] = ((chr >> 5) & 0x3f) | 0xc0;
                                    mindexfo[1] = (chr & 0x1f) | 0x40;
                                        
                                    pipRet = write(piptx[1], mindexfo, 2);
                                    if (pipRet < 0) {
                                        sprintf_f(rs->logs, "[DV]  pipe(%d) put chr: %d ret: %d act 0x80\n", piptx[1], chr, pipRet);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        continue;
                                    }
                                } else {
                                    sprintf_f(rs->logs, "[DV] warnning!!! chr should not be 0 !! \n");
                                    print_f(rs->plogs, "P11", rs->logs);
                                }
                            }
                            else if (chq == 0xbf) {
                                sprintf_f(rs->logs, "[DV] send redundant page size: %d\n", maxsz);
                                print_f(rs->plogs, "P11", rs->logs);
                                endf = endstr;
                                if (maxsz) {
                                    seqtx = maxsz;
                                    endm = palloc;

                                    #if 0                                                
                                    addrd = endm;
                                    if (seqtx < USB_BUF_SIZE) {
                                        lens = seqtx;
                                        seqtx = maxsz;
                                        endm = palloc;                                                    
                                    } else {
                                        lens = USB_BUF_SIZE;
                                        seqtx = seqtx - lens;
                                        endm += lens;
                                    }
                                    #endif                                                
                                }
                                
                                #if 0
                                else {
                                    addrd = endf;
                                    lens = strlen(endf);                                    
                                }
                                #endif                                                                             
                                break;
                            }
                            else if ((chq & 0xc0) == 0xc0) {
                                cindexfo[0] = chq;
                                pipRet = read(piprx[0], &chq, 1);
                                while (pipRet < 0) {
                                    pipRet = read(piprx[0], &chq, 1);
                                }

                                #if LOG_P11_EN
                                sprintf_f(rs->logs, "[DV] pre: 0x%.2x nxt: 0x%.2x pipe%d\n", cindexfo[0], chq, piprx[0]);
                                print_f(rs->plogs, "P11", rs->logs);
                                #endif

                                if ((chq & 0xc0) == 0x40) {
                                    cindexfo[1] = chq;
                                } else {
                                    sprintf_f(rs->logs, "[DV]  WARNNING get unknown chq: 0x%.2x \n", chq);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    continue;
                                }

                                cindex = ((cindexfo[0] & 0x3f) << 5) | (cindexfo[1] & 0x1f);

                                #if LOG_P11_EN
                                sprintf_f(rs->logs, "[DV] get page index: 0x%.3x currx: %d \n", cindex, piprx[0]);
                                print_f(rs->plogs, "P11", rs->logs);
                                #endif

                                if ((cindex & 0x400) == 0) {
                                    #if LOG_P11_EN
                                    sprintf_f(rs->logs, "[DV]  primary 0x%.8x \n", cindex);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    #endif

                                    puscur = pushost;
                                    pinfcur = pinfushost;
                                    usbCur = puscur->pushring;
                                    piptx = puscur->pushtx;
                                    piprx = puscur->pushrx; 
                                } else {
                                    #if LOG_P11_EN
                                    sprintf_f(rs->logs, "[DV]  secondary 0x%.8x \n", cindex);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    #endif

                                    puscur = pushostd;
                                    pinfcur = pinfushostd;
                                    usbCur = puscur->pushring;
                                    piptx = puscur->pushtx;
                                    piprx = puscur->pushrx; 
                                }
                                
                                if (!puimCnTH) {
                                    puimCnTH = malloc(sizeof(struct usbIndex_s));
                                    if (!puimCnTH) {
                                        sprintf_f(rs->logs, "\n\nError!!! can't get memory for usbIndex_s\n");
                                        print_f(rs->plogs, "P11", rs->logs);
                                    }
                                    
                                    memset(puimCnTH, 0, sizeof(struct usbIndex_s));

                                    puimCnTH->uimIdex = cindex;
                                    puimGet = puimCnTH;
                                        
                                    if (!chr) {
                                        chr = puimGet->uimIdex & 0x3ff;

                                        if (chr == (cindex & 0x3ff)) {
                                        mindexfo[0] = ((chr >> 5) & 0x3f) | 0xc0;
                                        mindexfo[1] = (chr & 0x1f) | 0x40;

                                        pipRet = write(piptx[1], mindexfo, 2);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe(%d) put chr: %d ret: %d \n", piptx[1], chr, pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                        }
                                    } else {
                                        sprintf_f(rs->logs, "[DV] warring!!! puimCnTH == 0, and chr == %d \n", chr);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        if (chr == (cindex & 0x3ff)) {
                                        mindexfo[0] = ((chr >> 5) & 0x3f) | 0xc0;
                                        mindexfo[1] = (chr & 0x1f) | 0x40;

                                        pipRet = write(piptx[1], mindexfo, 2);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe(%d) put chr: %d ret: %d \n", piptx[1], chr, pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                        }
                                    }
                                }

                                #if LOG_P11_EN
                                else {
                                    ix = 0;
                                    puimTmp = puimCnTH;
                                    while(puimTmp) {
                                    
                                        sprintf_f(rs->logs, "[DV] %d - 0x%.2x %d:%d \n", ix, puimTmp->uimIdex, puimTmp->uimGetCnt, puimTmp->uimCount);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        
                                        puimTmp = puimTmp->uimNxt;

                                        ix++;
                                    }                             
                                }
                                #endif

                                if (puimGet) {
                                    if (!chr) {
                                        if (puimGet->uimGetCnt < puimGet->uimCount) {
                                            chr = puimGet->uimIdex & 0x3ff;
                                            mindexfo[0] = ((chr >> 5) & 0x3f) | 0xc0;
                                            mindexfo[1] = (chr & 0x1f) | 0x40;

                                            pipRet = write(piptx[1], mindexfo, 2);
                                            if (pipRet < 0) {
                                                sprintf_f(rs->logs, "[DV]  pipe(%d) put chr: %d ret: %d \n", piptx[1], chr, pipRet);
                                                print_f(rs->plogs, "P11", rs->logs);
                                                continue;
                                            }
                                        } else {
                                            sprintf_f(rs->logs, "\n[DV] %d:%d wait for new data get begin \n", puimGet->uimGetCnt, puimGet->uimCount);
                                            print_f(rs->plogs, "P11", rs->logs);
                                        }
                                    } else {
                                        //sprintf_f(rs->logs, "[DV] wait for response (0x%.2x) %d:%d\n", puimGet->uimIdex, puimGet->uimGetCnt, puimGet->uimCount);
                                    }
                                }
                                else {

                                    ix = 0;
                                    puimTmp = puimCnTH;
                                    puimUse = puimCnTH;
                                    while (puimTmp) {
                                        if ((puimTmp->uimIdex & 0x3ff) > (puimUse->uimIdex & 0x3ff)) {
                                            if (puimTmp->uimCount > 0) {
                                                puimUse = puimTmp;
                                            }
                                        }
                                        ix++;
                                        puimTmp = puimTmp->uimNxt;
                                    }

                                    if (ix > 0) {
                                        puimGet = puimUse;
                                    } 
                                        
                                    if (puimGet) {
                                        sprintf_f(rs->logs, "[DV] get puim index: 0x%.2x %d:%d\n", puimGet->uimIdex, puimGet->uimGetCnt, puimGet->uimCount);
                                        print_f(rs->plogs, "P11", rs->logs);

                                        if ((puimGet->uimIdex & 0x400) == 0) {

                                            //sprintf_f(rs->logs, "[DV]  new puimGet primary 0x%.8x \n", puimGet->uimIdex);
                                            //print_f(rs->plogs, "P11", rs->logs);

                                            puscur = pushost;
                                            pinfcur = pinfushost;
                                            usbCur = puscur->pushring;
                                            piptx = puscur->pushtx;
                                            piprx = puscur->pushrx; 
                                        } else {

                                            //sprintf_f(rs->logs, "[DV]  new puimGet secondary 0x%.8x \n", puimGet->uimIdex);
                                            //print_f(rs->plogs, "P11", rs->logs);

                                            puscur = pushostd;
                                            pinfcur = pinfushostd;
                                            usbCur = puscur->pushring;
                                            piptx = puscur->pushtx;
                                            piprx = puscur->pushrx; 
                                        }
                                        
                                        if (!chr) {
                                            if (puimGet->uimGetCnt < puimGet->uimCount) {
                                                chr = puimGet->uimIdex & 0x3ff;

                                                mindexfo[0] = ((chr >> 5) & 0x3f) | 0xc0;
                                                mindexfo[1] = (chr & 0x1f) | 0x40;

                                                pipRet = write(piptx[1], mindexfo, 2);
                                                if (pipRet < 0) {
                                                    sprintf_f(rs->logs, "[DV]  pipe(%d) put chr: %d ret: %d \n", piptx[1], chr, pipRet);
                                                    print_f(rs->plogs, "P11", rs->logs);
                                                    continue;
                                                }

                                                sprintf_f(rs->logs, "[DV]  new puimGet send req 0x%.8x \n", puimGet->uimIdex);
                                                print_f(rs->plogs, "P11", rs->logs);
                                            } else {
                                                sprintf_f(rs->logs, "\n[DV] %d:%d wait for new data at begin \n", puimGet->uimGetCnt, puimGet->uimCount);
                                                print_f(rs->plogs, "P11", rs->logs);
                                                chr = 0;
                                            }
                                        }
                                        else {
                                            sprintf_f(rs->logs, "[DV] should not be here chr: (%d) \n", chr);
                                            print_f(rs->plogs, "P11", rs->logs);
                                        }
                                    }
                                    else {
                                        sprintf_f(rs->logs, "[DV] wait for more data \n");
                                        print_f(rs->plogs, "P11", rs->logs);
                                    }
                                }
                                
                                if (puimCur) {
                                    if ((puimCur->uimIdex & 0x3ff) == (cindex & 0x3ff)) {
                                        puimCur->uimCount += 1;
                                    }
                                    else {
                                        //sprintf_f(rs->logs, "\n[DV] current puim index not mach wait:0x%.3x, get:0x%.3x chr: 0x%.3x \n\n", puimCur->uimIdex, cindex, chr);
                                        //print_f(rs->plogs, "P11", rs->logs);

                                        puimTmp= puimCnTH;
                                        while(puimTmp) {
                                            puimUse = puimTmp;
                                            if ((puimUse->uimIdex & 0x3ff) == (cindex & 0x3ff)) {
                                                puimTmp = puimUse;
                                                break;
                                            }
                                            puimTmp = puimUse->uimNxt;
                                        }

                                        if (puimTmp) {
                                            puimTmp->uimCount += 1;
                                            puimCur = puimTmp;
                                        } else {
                                            puimTmp = malloc(sizeof(struct usbIndex_s));
                                            if (!puimTmp) {
                                                sprintf_f(rs->logs, "\n\nError!!! can't get memory for puimTmp -2\n");
                                                print_f(rs->plogs, "P11", rs->logs);
                                            }

                                            memset(puimTmp, 0, sizeof(struct usbIndex_s));

                                            puimTmp->uimIdex = cindex;
                                            puimTmp->uimCount += 1;
                                            puimUse->uimNxt = puimTmp;

                                            puimCur = puimTmp;
                                        }
                                    }
                                }
                                else {
                                    if ((puimCnTH->uimIdex & 0x3ff) == (cindex & 0x3ff)) {
                                        puimCnTH->uimCount += 1;
                                        puimCur = puimCnTH;
                                    } else {
                                        puimTmp= puimCnTH;
                                        while(puimTmp) {
                                            puimUse = puimTmp;
                                            if ((puimUse->uimIdex & 0x3ff) == (cindex  & 0x3ff)) {
                                                puimTmp = puimUse;
                                                break;
                                            }
                                            puimTmp = puimUse->uimNxt;
                                        }

                                        if (puimTmp) {
                                            puimTmp->uimCount += 1;                            
                                            puimCur = puimTmp;
                                        } else {
                                            puimTmp = malloc(sizeof(struct usbIndex_s));
                                            if (!puimTmp) {
                                                sprintf_f(rs->logs, "\n\nError!!! can't get memory for puimTmp\n");
                                                print_f(rs->plogs, "P11", rs->logs);
                                            }
                                            memset(puimTmp, 0, sizeof(struct usbIndex_s));
                                    
                                            puimTmp->uimIdex = cindex;
                                            puimTmp->uimCount += 1;
                                            puimUse->uimNxt = puimTmp;

                                            puimCur = puimTmp;
                                        }
                                    }
                                }  
                            }
                            else if ((chq & 0xc0) == 0x80) {
                                if (!puimGet) {
                                    sprintf_f(rs->logs, "\n[DV] Error!!! puimCur is null \n");
                                    print_f(rs->plogs, "P11", rs->logs);
                                }
                                else {

                                    if (!chr) {
                                        //sprintf_f(rs->logs, "\n[DV] Warnning !!! chr == 0 not make sense !!!\n");
                                        //print_f(rs->plogs, "P11", rs->logs);
                                    }

                                    cindexfo[0] = chq;
                                    pipRet = read(piprx[0], &chq, 1);
                                    while (pipRet < 0) {
                                        pipRet = read(piprx[0], &chq, 1);
                                    }
                                    
                                    if ((chq & 0xc0) == 0x40) {
                                        cindexfo[1] = chq;
                                    } else {
                                        sprintf_f(rs->logs, "[DV]  WARNNING get unknown chq: 0x%.2x - 3\n", chq);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        continue;
                                    }

                                    cindex = ((cindexfo[0] & 0x3f) << 5) | (cindexfo[1] & 0x1f);
                                    
                                    if ((cindex & 0x400) == 0) {
                                        #if LOG_P11_EN
                                        sprintf_f(rs->logs, "[DV]  primary 0x80 0x%.8x \n", cindex);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        #endif

                                        puscur = pushost;
                                        pinfcur = pinfushost;
                                        usbCur = puscur->pushring;
                                        piptx = puscur->pushtx;
                                        piprx = puscur->pushrx; 
                                    } else {
                                        #if LOG_P11_EN
                                        sprintf_f(rs->logs, "[DV]  secondary 0x80 0x%.8x \n", cindex);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        #endif

                                        puscur = pushostd;
                                        pinfcur = pinfushostd;
                                        usbCur = puscur->pushring;
                                        piptx = puscur->pushtx;
                                        piprx = puscur->pushrx; 
                                    }
                                    
                                    if ((puimGet->uimIdex & 0x3ff) == (cindex & 0x3ff)) {
                                        puimGet->uimGetCnt += 1;
                                        
                                        if (puimGet->uimGetCnt < puimGet->uimCount) {
                                            chr = puimGet->uimIdex & 0x3ff;

                                            mindexfo[0] = ((chr >> 5) & 0x3f) | 0xc0;
                                            mindexfo[1] = (chr & 0x1f) | 0x40;

                                            pipRet = write(piptx[1], mindexfo, 2);
                                            if (pipRet < 0) {
                                                sprintf_f(rs->logs, "[DV]  pipe(%d) put chr: %d ret: %d \n", piptx[1], chr, pipRet);
                                                print_f(rs->plogs, "P11", rs->logs);
                                                continue;
                                            }
                                        } else {
                                            chr = 0;
                                        }

                                        uimCylcnt = CYCLE_LEN;
                                        
                                        break;
                                    }
                                    else {
                                        sprintf_f(rs->logs, "\n[DV] Error!!! puimCur index is not match!! \n");
                                        print_f(rs->plogs, "P11", rs->logs);
                                    }
                                }
                            }
                            else {
                                if (chq == 0x7f) {
                                    puimGet->uimGetCnt += 1;

                                    memset(cinfo, 0, 12);
                                    pipRet = read(piprx[0], cinfo, 9);
                                    while (pipRet < 0) {
                                        pipRet = read(piprx[0], cinfo, 9);
                                    }

                                    lastCylen |= cinfo[6];
                                    
                                    lastCylen  = lastCylen << 8;
                                    lastCylen |= cinfo[5];

                                    lastCylen  = lastCylen << 8;
                                    lastCylen |= cinfo[4];
                                    
                                    lastCylen  = lastCylen << 8;
                                    lastCylen |= cinfo[3];
                                    
                                    uimCylcnt = (cinfo[0] & 0x7f) | ((cinfo[1] & 0x7f) << 7);
                                    
                                    cmdprisec = cinfo[2];

                                    cswerr = cinfo[7] & 0x7f;
                                    if (cswerr == 0x7f) {
                                        cswerr = 0;
                                    }

                                    //sprintf_f(rs->logs, "[DV] get csw err: 0x%.2x \n", cswerr);
                                    //print_f(rs->plogs, "P11", rs->logs);
                                    puimNxt = 0;

                                    pagerst = cinfo[8] & 0x7f;
                                    //sprintf_f(rs->logs, "[DV] get page rest: %d \n", pagerst);
                                    //print_f(rs->plogs, "P11", rs->logs);
                                    
                                    sprintf_f(rs->logs, "[DV] to get the last trunk read cycle: %d, lastlen: %d cswerr: 0x%.2x pagerst: %d \n", uimCylcnt, lastCylen, cswerr, pagerst);
                                    print_f(rs->plogs, "P11", rs->logs);

                                    if (uimCylcnt < 2) {
                                        sprintf_f(rs->logs, "[DV] WARNING!!!! the cycle count == %d is error!!! should bigger than 2 \n", uimCylcnt);
                                        print_f(rs->plogs, "P11", rs->logs);
                                    }
                                    
                                    bmplen = (uimCylcnt - 1) * USB_BUF_SIZE;
                                    bmplen += lastCylen;

                                    bmpbufc = 0;
                                    cpylen = 0;

                                    ret = cfgTableGetChk(pct, ASPOP_FILE_FORMAT, &fformat, ASPOP_STA_CON);    
                                    //sprintf_f(rs->logs, "[BMP] get file format ret: %d format: 0x%.2x !!!\n", ret, fformat);
                                    //print_f(rs->plogs, "P11", rs->logs);
                                    
                                    if (ret) {
                                        fformat = 0;
                                    }
                                    
                                    #if 0//GHP_EN
                                    //if (((fformat == FILE_FORMAT_RAW) || (fformat == FILE_FORMAT_JPG)) && ((opc == 0x0a) || (opc == 0x0f))) {
                                    if (((fformat == FILE_FORMAT_RAW) || (fformat == FILE_FORMAT_JPG)) && (opc == 0x0f)) {
                                        bmpbuff = aspMemalloc(bmplen, 11);

                                        if (bmpbuff) {
                                            sprintf_f(rs->logs, "[BMP] allocate bmp buffer size: %d succeed!!!\n", bmplen);
                                            print_f(rs->plogs, "P11", rs->logs);

                                            bmpbufc = bmpbuff;
                                        } else {
                                            sprintf_f(rs->logs, "[BMP] allocate bmp buffer size: %d failed!!!\n", bmplen);
                                            print_f(rs->plogs, "P11", rs->logs);
                                        }
                                    }
                                    #endif // #if GHP_EN

                                    switch (cmdprisec) {
                                    case 1:
                                        #if LOG_P11_EN
                                        sprintf_f(rs->logs, "[DV]  primary 0x7f 0x%.3x \n", puimGet->uimIdex);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        #endif

                                        puscur = pushost;
                                        pinfcur = pinfushost;
                                        usbCur = puscur->pushring;
                                        piptx = puscur->pushtx;
                                        piprx = puscur->pushrx; 
                                        break;
                                    case 2:
                                        #if LOG_P11_EN
                                        sprintf_f(rs->logs, "[DV]  secondary 0x7f 0x%.3x \n", puimGet->uimIdex);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        #endif

                                        puscur = pushostd;
                                        pinfcur = pinfushostd;
                                        usbCur = puscur->pushring;
                                        piptx = puscur->pushtx;
                                        piprx = puscur->pushrx; 
                                        break;
                                    default:
                                        sprintf_f(rs->logs, "[DV]  error!!! unknown cmdprisec: %d, at 0x7f index: 0x%.8x \n", cmdprisec, cindex);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        break;
                                    }
                                    
                                    if (puimCur == puimGet) {
                                        puimCur = 0;
                                    }

                                    puimUse = 0;
                                    
                                    if (puimCnTH == puimGet) {
                                        puimCnTH = puimGet->uimNxt;
                                        
                                        ix=0;
                                        cindex = 0;
                                        puimTmp = puimCnTH;
                                        while (puimTmp) {
                                            puimUse = puimTmp;
                                            
                                            #if 1
                                            if (cindex == 0) {
                                                cindex = puimUse->uimIdex & 0x3ff;
                                                puimNxt = puimUse;
                                            } else {
                                                if ((puimUse->uimIdex & 0x3ff) < cindex) {
                                                    cindex = puimUse->uimIdex & 0x3ff;
                                                    puimNxt = puimUse;
                                                }
                                            }
                                            #else
                                            if ((puimUse->uimIdex & 0x3ff) == ((puimGet->uimIdex + 1) & 0x3ff)) {
                                                puimNxt = puimUse;
                                            }
                                            #endif
                                            
                                            puimTmp = puimUse->uimNxt;
                                            ix++;
                                        }
                                    } else {
                                        ix=0;
                                        cindex = 0;
                                        puimTmp = puimCnTH;
                                        while (puimTmp) {
                                            puimUse = puimTmp;
                                            
                                            #if 1
                                            if (cindex == 0) {
                                                cindex = puimUse->uimIdex & 0x3ff;
                                                puimNxt = puimUse;
                                            } else {
                                                if ((puimUse->uimIdex & 0x3ff) < cindex) {
                                                    cindex = puimUse->uimIdex & 0x3ff;
                                                    puimNxt = puimUse;
                                                }
                                            }
                                            #else
                                            if ((puimUse->uimIdex & 0x3ff) == ((puimGet->uimIdex + 1) & 0x3ff)) {
                                                puimNxt = puimUse;
                                            }
                                            #endif
                                            
                                            puimTmp = puimUse->uimNxt;
                                            if (puimTmp == puimGet) {
                                                puimUse->uimNxt = puimGet->uimNxt;
                                            }                
                                            puimTmp = puimUse->uimNxt;
                                            ix++;
                                        }
                                    }

                                    free(puimGet);
                                    puimGet = 0;
                                    
                                    if (puimNxt) {
                                    
                                        puimGet = puimNxt;
                                        
                                        #if LOG_P11_EN
                                        sprintf_f(rs->logs, "[DV] puimGet: 0x%.3x %d/%d\n", puimGet->uimIdex, puimGet->uimGetCnt, puimGet->uimCount);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        #endif
                                    } else {
                                        #if LOG_P11_EN
                                        sprintf_f(rs->logs, "[DV] puimGet is null \n");
                                        print_f(rs->plogs, "P11", rs->logs);
                                        #endif
                                    }

                                    ix = 0;
                                    puimTmp = puimCnTH;
                                    while(puimTmp) {
                                    
                                        #if LOG_P11_EN
                                        sprintf_f(rs->logs, "[DV] page.%d - 0x%.2x %d:%d (addr:0x%.8x)\n", ix, puimTmp->uimIdex, puimTmp->uimGetCnt, puimTmp->uimCount, (uint32_t)puimTmp);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        #endif

                                        if (puimTmp->uimCount > 0) {
                                            ix++;
                                        }

                                        puimTmp = puimTmp->uimNxt;
                                    }                             
                                            
                                    waitCylen = ix;

                                    #if LOG_P11_EN
                                    sprintf_f(rs->logs, "[DV] wait page number: %d, wait page rest: %d\n", waitCylen, pagerst);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    #endif

                                    #if 0
                                    if ((waitCylen > 0) || (pagerst > 1)) {
                                        if (!puimNxt) {

                                            ix = (puimGet->uimIdex & 0x3ff) + 1;
                                            memset(puimGet, 0, sizeof(struct usbIndex_s));
                                            puimGet->uimIdex = ix;
                                            if (puimUse) {
                                                puimUse->uimNxt = puimGet;
                                            } else {
                                                puimCnTH = puimGet;
                                            }                                       
                                    
                                            clock_gettime(CLOCK_REALTIME, &tidleS);
                                        }
                                        
                                    } else {
                                        if (!puimNxt) {
                                            if (puimGet) {
                                                free(puimGet);
                                                puimGet = 0;
                                            }
                                        }
                                    }
                                    #endif

                                    chr = 0;
                                    
                                    break;
                                } 
                                else {
                                    #if LOG_P11_EN
                                    sprintf_f(rs->logs, "[DV] idle warning!!! chq: 0x%.2x chr: 0x%.2x puimGet: 0x%.8x puimCnTH: 0x%.8x\n", chq, chr, (uint32_t)puimGet, (uint32_t)puimCnTH);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    #endif

                                    if ((!chq) && (!chr) && (puimGet)) {
                                        if (puimGet->uimGetCnt < puimGet->uimCount) {
                                            chr = puimGet->uimIdex & 0x3ff;
                                            mindexfo[0] = ((chr >> 5) & 0x3f) | 0xc0;
                                            mindexfo[1] = (chr & 0x1f) | 0x40;

                                            pipRet = write(piptx[1], mindexfo, 2);
                                            if (pipRet < 0) {
                                                sprintf_f(rs->logs, "[DV]  pipe(%d) put chr: %d ret: %d \n", piptx[1], chr, pipRet);
                                                print_f(rs->plogs, "P11", rs->logs);
                                                continue;
                                            }
                                        }
                                    } else {
                                        if ((puimCnTH) && (!puimGet)) {
                                            ix=0;
                                            cindex = 0;
                                            puimNxt = 0;
                                            puimTmp = puimCnTH;
                                            while (puimTmp) {
                                                puimUse = puimTmp;
                                            
                                                if (cindex == 0) {
                                                    cindex = puimUse->uimIdex & 0x3ff;
                                                    puimNxt = puimUse;
                                                } else {
                                                    if ((puimUse->uimIdex & 0x3ff) < cindex) {
                                                        cindex = puimUse->uimIdex & 0x3ff;
                                                        puimNxt = puimUse;
                                                    }
                                                }

                                                #if LOG_P11_EN
                                                sprintf_f(rs->logs, "[DV] idle page.%d - 0x%.2x %d:%d (addr:0x%.8x)\n", ix, puimTmp->uimIdex, puimTmp->uimGetCnt, puimTmp->uimCount, (uint32_t)puimTmp);
                                                print_f(rs->plogs, "P11", rs->logs);
                                                #endif

                                                puimTmp = puimUse->uimNxt;
                                                ix++;
                                            }

                                            if (puimNxt) {

                                                puimGet = puimNxt;

                                                #if LOG_P11_EN
                                                sprintf_f(rs->logs, "[DV] idle get puimGet: 0x%.3x %d/%d\n", puimGet->uimIdex, puimGet->uimGetCnt, puimGet->uimCount);
                                                print_f(rs->plogs, "P11", rs->logs);
                                                #endif

                                                if ((puimGet->uimIdex & 0x400) == 0) {
                                                    #if LOG_P11_EN
                                                    sprintf_f(rs->logs, "[DV] idle primary 0x80 0x%.8x \n", puimGet->uimIdex);
                                                    print_f(rs->plogs, "P11", rs->logs);
                                                    #endif

                                                    puscur = pushost;
                                                    pinfcur = pinfushost;
                                                    usbCur = puscur->pushring;
                                                    piptx = puscur->pushtx;
                                                    piprx = puscur->pushrx; 
                                                } else {
                                                    #if LOG_P11_EN
                                                    sprintf_f(rs->logs, "[DV] idle secondary 0x80 0x%.8x \n", puimGet->uimIdex);
                                                    print_f(rs->plogs, "P11", rs->logs);
                                                    #endif

                                                    puscur = pushostd;
                                                    pinfcur = pinfushostd;
                                                    usbCur = puscur->pushring;
                                                    piptx = puscur->pushtx;
                                                    piprx = puscur->pushrx; 
                                                }
                                            } else {
                                                #if LOG_P11_EN
                                                sprintf_f(rs->logs, "[DV] idle get puimGet is null \n");
                                                print_f(rs->plogs, "P11", rs->logs);
                                                #endif
                                            }
                                        }
                                    }
                                    continue;
                                }
                            }
                        }

                        if (uimCylcnt) {
                            lens = 0;
                            lens = ring_buf_cons_up(usbCur, &addrd, &addrb);                
                            while (lens < 0) {
                                sprintf_f(rs->logs, "[DV] cons ring buff ret: %d \n", lens);
                                print_f(rs->plogs, "P11", rs->logs);

                                usleep(500);
                                lens = ring_buf_cons_up(usbCur, &addrd, &addrb);                
                            }

                            //sprintf_f(rs->logs, "[DV] cons ring buff ret: %d \n", lens);
                            //print_f(rs->plogs, "P11", rs->logs);

                            if (lens & 0x40000) {
                                lastflag = 0x40000;
                            } else {
                                lastflag = 0;
                            }
                            lens = lens & 0x1ffff;

                            uimCylcnt = uimCylcnt - 1;

                            distCylcnt = ring_buf_cons_tag(usbCur);
                            cntTx++;

                            msync(pinfcur, sizeof(struct usbHostmem_s), MS_SYNC);

                            #if 0 /*debug*/
                            shmem_dump(addrd, 64);
                            #endif
                            
                            #if 0//GHP_EN
                            if (bmpbufc) {
                            
                                bmpcpy = memcpy(bmpbufc, addrd, lens);

                                msync(bmpcpy, lens, MS_SYNC);    

                                //shmem_dump(bmpcpy, 128);
                                //sprintf_f(rs->logs, "[BMP] copy len: %d, total: %d (0x%.8x:0x%.8x)\n", lens, cpylen, (uint32_t)bmpcpy, (uint32_t)bmpbufc);
                                //print_f(rs->plogs, "P11", rs->logs);

                                cpylen += lens;
                                bmpbufc = bmpcpy + lens;
                            }
                            #endif //#if GHP_EN
                            
                            upas = pinfcur->ushostpause;
                            ursm = pinfcur->ushostresume;
                            
                            #if USB_AUTO_RESUME
                            udist = pinfcur->ushostbmax - distCylcnt;
                            pinfcur->ushostbtrkbuffed = distCylcnt;
                            //pinfcur->ushostbtrkcms = pinfcur->ushostbtrktot - distCylcnt;
                            
                            #if DBG_PAUSE_RESUME
                            sprintf_f(rs->logs, "resume info distCylcnt: %d, udist: %d, buffered: %d avg: %d thrhld:%d\n", distCylcnt, udist, pinfcur->ushostbtrkbuffed, pinfcur->ushostbtrkpageavg, pinfcur->ushostbthrshold);
                            print_f(rs->plogs, "P11", rs->logs);
                            #endif

                            #if DBG_PAUSE_RESUME
                            sprintf_f(rs->logs, "resume flag pause: %d, resume: %d udist: %d L1\n", upas, ursm, udist);
                            print_f(rs->plogs, "P11", rs->logs);
                            #endif

                            if ((upas) && (ursm >= 0)) {
                                //udist = pinfcur->ushostbmax - pinfcur->ushostbtrkbuffed;
                                
                                if (pinfcur->ushostbtrkpageavg > pinfcur->ushostbthrshold) {
                                    if (udist > pinfcur->ushostbtrkpageavg) {
                                        //USB_IOCT_LOOP_READ_RESTART(usbid, &ix);
                                        #if 0
                                        pipRet = write(piptx[1], "v", 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe(%d) put resume: %c failed!!! ret: %d \n", piptx[1], "v", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                        #endif

                                        if (pinfcur == pinfushost) {
                                            pinfcurd= pinfushostd;
                                        } else {
                                            pinfcurd= pinfushost;
                                        }
                                        
                                        msync(pinfcurd, sizeof(struct usbHostmem_s), MS_SYNC);
                                        
                                        upasd = pinfcurd->ushostpause;
                                        ursmd = pinfcurd->ushostresume;
                                        udistd = pinfcurd->ushostbmax - pinfcurd->ushostbtrkbuffed;

                                        #if DBG_PAUSE_RESUME
                                        sprintf_f(rs->logs, "resume flag pause: %d, resume: %d udistd: %d buffered: %d L2.\n", upasd, ursmd, udistd, pinfcurd->ushostbtrkbuffed);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        #endif

                                        if ((upasd) && (ursmd >= 0)) {
                                            if (pinfcurd->ushostbtrkpageavg > pinfcurd->ushostbthrshold) {
                                                if (udistd > pinfcurd->ushostbtrkpageavg) {
                                                
                                                    msync(pinfushost, sizeof(struct usbHostmem_s), MS_SYNC);
                                                    msync(pinfushostd, sizeof(struct usbHostmem_s), MS_SYNC);

                                                    pinfushost->ushostpause = 0;
                                                    pinfushostd->ushostpause = 0;  
                                                    
                                                    pinfushost->ushostresume = 1;
                                                    pinfushostd->ushostresume = 2;
                                                    
                                                    msync(pinfushost, sizeof(struct usbHostmem_s), MS_SYNC);
                                                    msync(pinfushostd, sizeof(struct usbHostmem_s), MS_SYNC);

                                                    #if 1//DBG_PAUSE_RESUME
                                                    sprintf_f(rs->logs, "RESUME distCylcnt: %d, udist: %d, avg: %d, udistd: %d, avg: %d - 1. \n", distCylcnt, udist, pinfcur->ushostbtrkpageavg, udistd, pinfcurd->ushostbtrkpageavg);
                                                    print_f(rs->plogs, "P11", rs->logs);
                                                    #endif
                                                }
                                            } 
                                        }
                                    }
                                }
                                else {
                                    uthrhld = pinfcur->ushostbtrkpageavg * 6;
                                    if (uthrhld > (pinfcur->ushostbmax - pinfcur->ushostbthrshold)) {
                                        uthrhld = pinfcur->ushostbmax - pinfcur->ushostbthrshold;
                                    }
                                    
                                    if ((uthrhld) && (udist > uthrhld)) {
                                        //USB_IOCT_LOOP_READ_RESTART(usbid, &ix);
                                        #if 0
                                        pipRet = write(piptx[1], "v", 1);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe(%d) put resume: %c failed!!! ret: %d \n", piptx[1], "v", pipRet);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            continue;
                                        }
                                        #endif
                                        
                                        if (pinfcur == pinfushost) {
                                            pinfcurd= pinfushostd;
                                        } else {
                                            pinfcurd= pinfushost;
                                        }
                                        
                                        msync(pinfcurd, sizeof(struct usbHostmem_s), MS_SYNC);
                                        
                                        upasd = pinfcurd->ushostpause;
                                        ursmd = pinfcurd->ushostresume;
                                        udistd = pinfcurd->ushostbmax - pinfcurd->ushostbtrkbuffed;

                                        #if DBG_PAUSE_RESUME
                                        sprintf_f(rs->logs, "resume flag pause: %d, resume: %d udistd: %d L3\n", upasd, ursmd, udistd);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        #endif

                                        if ((upasd) && (ursmd >= 0)) {
                                            if (pinfcurd->ushostbtrkpageavg < pinfcurd->ushostbthrshold) {
                                                uthrhld = pinfcurd->ushostbtrkpageavg * 6;

                                                if (uthrhld > (pinfcurd->ushostbmax - pinfcurd->ushostbthrshold)) {
                                                    uthrhld = pinfcurd->ushostbmax - pinfcurd->ushostbthrshold;
                                                }

                                                if ((uthrhld) && (udistd > uthrhld)) {

                                                    msync(pinfushost, sizeof(struct usbHostmem_s), MS_SYNC);
                                                    msync(pinfushostd, sizeof(struct usbHostmem_s), MS_SYNC);
                                                    
                                                    pinfushost->ushostpause = 0;
                                                    pinfushostd->ushostpause = 0;                                        
                                                
                                                    pinfushost->ushostresume = 1;
                                                    pinfushostd->ushostresume = 2;

                                                    msync(pinfushost, sizeof(struct usbHostmem_s), MS_SYNC);
                                                    msync(pinfushostd, sizeof(struct usbHostmem_s), MS_SYNC);

                                                    #if 1//DBG_PAUSE_RESUME
                                                    sprintf_f(rs->logs, "RESUME buff1: %d, buff2: %d, udist: %d, udistd: %d, avg1: %d, avg2: %d - 2.\n", distCylcnt, pinfcurd->ushostbtrkbuffed, udist, udistd, pinfcur->ushostbtrkpageavg, pinfcurd->ushostbtrkpageavg);
                                                    print_f(rs->plogs, "P11", rs->logs);
                                                    #endif
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            #endif //#if USB_AUTO_RESUME
                    
                            if ((uimCylcnt == 1) && (lastCylen > 0)){
                                lens = lastCylen;
                                lenbs = &ptmetausb->EPOINT_RESERVE1[0] - &ptmetausb->ASP_MAGIC_ASPC[0];
                                
                                shfmeta = lens % 512;
                                if (shfmeta < lenbs) {
                                    sprintf_f(rs->logs, "Error!!! usb meta len less than expected len: %d expect: %d \n", shfmeta, lenbs);
                                    print_f(rs->plogs, "P11", rs->logs);
                                }

                                //sprintf_f(rs->logs, "dume usb meta size: %d / %d \n", shfmeta, lens);
                                //print_f(rs->plogs, "P11", rs->logs);

                                pshfmeta = addrd + (lens - shfmeta);

                                #if LOG_P11_EN
                                shmem_dump(pshfmeta, shfmeta);
                                #endif

                                if (rxfd == rs->ppipedn->rt[0]) {
                                    sprintf_f(rs->logs, "usb meta cp to primary size: %d dist size: %d\n", shfmeta, lenbs);
                                    print_f(rs->plogs, "P11", rs->logs);

                                    memset(ptmetausb, 0, sizeof(struct aspMetaDataviaUSB_s));
                                    memcpy(ptmetausb, pshfmeta, shfmeta);
                                    
                                    //dbgMetaUsb(ptmetausb);
                                } else if (rxfd == rsd->ppipedn->rt[0]) {
                                    sprintf_f(rs->logs, "usb meta cp to secondary size: %d dist size: %d\n", shfmeta, lenbs);
                                    print_f(rs->plogs, "P11", rs->logs);

                                    memset(ptmetausbduo, 0, sizeof(struct aspMetaDataviaUSB_s));
                                    memcpy(ptmetausbduo, pshfmeta, shfmeta);    
                                    
                                    //dbgMetaUsb(ptmetausbduo);
                                } else {
                                    //sprintf_f(rs->logs, "usb meta forward to pc \n");
                                    //print_f(rs->plogs, "P11", rs->logs);

                                    /* deal with bmp retate */
                                    memset(ptmetausb, 0, sizeof(struct aspMetaDataviaUSB_s));
                                    memcpy(ptmetausb, pshfmeta, shfmeta);
                                    //dbgMetaUsb(ptmetausb);
                                }
                            }

                            #if LOG_P11_EN
                            sprintf_f(rs->logs, "[DV] addr: 0x%.8x lens: %d, cyclecnt: %d, lastCylen: %d dist: %d lastflag: 0x%.5x count: %d\n", (uint32_t)addrd, lens, uimCylcnt, lastCylen, distCylcnt, lastflag, cntTx);
                            print_f(rs->plogs, "P11", rs->logs);
                            #endif
                            
                            msync(addrd, lens, MS_SYNC);

                            #if DBG_DUMP_DAT32
                            sprintf_f(rs->logs, "[DV] dump 32 - 3 [0x%.8x]\n", (uint32_t)addrd);
                            print_f(rs->plogs, "P11", rs->logs);
                            shmem_dump(addrd, 32);
                            #endif
                        
#if 0                   
                            puscur->pushcnt --;

                            if (puscur->pushcnt == 0) {
                                sprintf_f(rs->logs, "[DV] the last trunk size is %d \n", lens);
                            }
#else
#endif
                        }
                        
                        if ((lens > 0) && (lens < USB_BUF_SIZE) && (!uimCylcnt) && (lastflag)) {
                            che = 'E';
                        }

                        sendsz = 0;
                        
                        if (che == 'E') break;
                    }

                    if (cntTx == 1) {
                        clock_gettime(CLOCK_REALTIME, &tstart);
                    }    

                    #if USB_HS_SAVE_RESULT_DV
                    //wrtsz = fwrite(addrd, 1, lens, fsave);
                    //sprintf_f(rs->logs, "[DV] usb write file %d / %d !!!\n", wrtsz, lens);
                    wrtsz = lens;
                    memcpy(ptmp, addrd, lens);
                    ptmp += lens;
                    #endif

                    //sprintf_f(rs->logs, "meta lens: %d, sendsz: %d - 1\n", lens, sendsz); 
                    //print_f(rs->plogs, "P11", rs->logs);
                    
                    #if 0
                    sendsz = wrtsz;
                    #else
                    if (rxfd == rs->ppipedn->rt[0]) {
                        //sprintf_f(rs->logs, "meta lens: %d, sendsz: %d - 2\n", lens, sendsz); 
                        //print_f(rs->plogs, "P11", rs->logs);

                        sendsz = lens;
                        if (che == 'E') {    
                            sprintf_f(rs->logs, "meta lens: %d, sendsz: %d, shfmeta: %d \n", lens, sendsz, shfmeta); 
                            print_f(rs->plogs, "P11", rs->logs);

                            //shmem_dump(pshfmeta, shfmeta);                            
                            act = aspMetaReleaseviaUsb(0, rs, addrd, lens);

                            if (act < 0) {
                                sprintf_f(rs->logs, "ERROR!!! wrong meta data, break!!ret: %d lens: %d sendsz: %d\n", act, lens, sendsz); 
                                print_f(rs->plogs, "P11", rs->logs);
                                shmem_dump(addrd, lens);

                                sprintf_f(rs->logs, "metamass gap:%d, start:%d, record:%d, used:%d\n", pmass->massGap, pmass->massStart, pmass->massRecd, pmass->massUsed); 
                                print_f(rs->plogs, "P11", rs->logs);

                                #if 1 /* bypass the error for impl */
                                lsb2Msb32(&ptmetain->FUNC_BITS, (ASPMETA_FUNC_CROP | ASPMETA_FUNC_IMGLEN));
                                
                                ptmetain->ASP_MAGIC[0] = 0x20;
                                ptmetain->ASP_MAGIC[1] = 0x14;
                                
                                aspMetaRelease(msb2lsb32(&ptmetain->FUNC_BITS), 0, rs);

                                pmass->massRecd = 0;
                                
                                err = cfgTableGet(pct, ASPOP_IMG_LEN, &val);
                                sprintf_f(rs->logs, "usb meta get img len: %d err: %d\n", val, err); 
                                print_f(rs->plogs, "P11", rs->logs);                     
                                
                                val = cswerr;
                                cfgTableUpd(pct, ASPOP_SCAN_STATUS, val);
                                cswstatus[0] = cswerr;
                                #endif

                            }
                            else {
                                sprintf_f(rs->logs, "release extra meta data act: %d lens: %d sendsz: %d\n", act, lens, sendsz); 
                                print_f(rs->plogs, "P11", rs->logs);
                                
                                /* mechanism to stop scan */
                                val = cswerr;
                                cfgTableUpd(pct, ASPOP_SCAN_STATUS, val);
                                cswstatus[0] = cswerr;

                                #if 0 /* test stopping multiple scan */
                                if (cswerr) {
                                    val = 0;
                                    cfgTableUpd(pct, ASPOP_IMG_LEN, val);
                                }
                                #endif

                                err = cfgTableGet(pct, ASPOP_IMG_LEN, &val);
                                sprintf_f(rs->logs, "usb meta get img len: %d err: %d, cswerr: 0x%.2x\n", val, err, cswerr); 
                                print_f(rs->plogs, "P11", rs->logs);
                                
                                cfgTableGet(pct, ASPOP_XCROP_LINREC, &val);
                                sprintf_f(rs->logs, "Yline_recorder: %d!!\n", val); 
                                print_f(rs->plogs, "P11", rs->logs);

                                sprintf_f(rs->logs, "act: %d, metamass gap:%d, start:%d, record:%d, used:%d\n", act, pmass->massGap, pmass->massStart, pmass->massRecd, pmass->massUsed); 
                                print_f(rs->plogs, "P11", rs->logs);
                            }

                            puscur->pushrmcnt += 1;
                            
                            sprintf_f(rs->logs, "usb scan cnt: %d, rm: %d, cswerr: %d (0x%.2x)\n", puscur->pushcnt, puscur->pushrmcnt, puscur->pushcswerr, puscur->pushcswerr); 
                            print_f(rs->plogs, "P11", rs->logs);                     

                            cmd = 0;

                        }
                        else {
                            while (1) {
                                lenrs = 0;
                                lenrs = ring_buf_get(rs->pcmdRx, &addrs);
                                if (lenrs > 0) {
                                    if (lenrs >= sendsz) {
                                        lenrs = sendsz;
                                        sendsz = 0;
                                    } else {
                                        sendsz -= lenrs;
                                    }
                                    memcpy(addrs, addrd, lenrs);
                                    addrd += lenrs;

                                    #if 0
                                    sprintf_f(rs->logs, "[DV] ring buff copy %d / %d!!!\n", lenrs, sendsz);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    #endif
                            
                                    ring_buf_prod(rs->pcmdRx);
                                    
                                    rs_ipc_put(rs, "p", 1);

                                    if (lenrs < SPI_TRUNK_SZ) {
                                        
                                        #if JPG_FFD9_CUT /* find 0xcffd9 in jpg */
                                        ret = cfgTableGetChk(pct, ASPOP_FILE_FORMAT, &fformat, ASPOP_STA_CON);    
                                        if (ret) {
                                            fformat = 0;
                                        }

                                        lrst = lenrs % 512;
                                        opsz = lenrs - lrst;
                                        lrst = opsz - JPG_FFD9_RANGE;

                                        if ((fformat == 0) || (fformat == FILE_FORMAT_JPG) || (fformat == FILE_FORMAT_PDF)) {

                                            /* search the offset of 0xffd9 */
                                            ret = findEOF(addrs + lrst, JPG_FFD9_RANGE);
                                            if (ret > 0) {
                                            memset(addrs + lrst + ret + 2, 0xff, JPG_FFD9_RANGE - ret - 2);
                                            } else {
                                                sprintf_f(rs->logs, "[DV] warnning!!! file format: 0x%x, ret: %d can't find ffd9\n", fformat, ret);
                                                print_f(rs->plogs, "P11", rs->logs);    
                                            }

                                            sprintf_f(rs->logs, "[DV] JPG_FFD9_CUT fformat: 0x%x, len: %d ret: %d, range: %d\n", fformat, lenrs, ret, JPG_FFD9_RANGE);
                                            print_f(rs->plogs, "P11", rs->logs);    
                                        }
                                        #endif
                                        
                                        ring_buf_set_last(rs->pcmdRx, lenrs);
                                        rs_ipc_put(rs, "d", 1);
                                    }

                                    if (sendsz == 0) {
                                        break;
                                    }                            
                            
                                }
                                else {
                                    //sprintf_f(rs->logs, "[DV] get buff ret: %d, wait for tx size: %d!!!\n", lenrs, sendsz);
                                    //print_f(rs->plogs, "P11", rs->logs);
                                    usleep(500);
                                }
                            }
                            sendsz = lens;
                        }
                        
                    }
                    else if (rxfd == rsd->ppipedn->rt[0]) {
                        sendsz = lens;
                        if (che == 'E') {
                            //shmem_dump(addrd, lens);
                            
                            //dbgMeta(msb2lsb32(&ptmetain->FUNC_BITS), ptmetain);
                            act = aspMetaReleaseviaUsbDuo(0, rs, addrd, lens);

                            if (act < 0) {
                                sprintf_f(rs->logs, "ERROR!!! wrong extra meta duo data, break!!ret: %d shfmeta: %d\n", act, shfmeta); 
                                print_f(rs->plogs, "P11", rs->logs);      
                                shmem_dump(addrd, lens);

                                sprintf_f(rs->logs, "duo metamass gap:%d, start:%d, record:%d, used:%d\n", pmassduo->massGap, pmassduo->massStart, pmassduo->massRecd, pmassduo->massUsed); 
                                print_f(rs->plogs, "P11", rs->logs);  
                                
                                #if 1 /* bypass the error for impl */
                                lsb2Msb32(&ptmetainduo->FUNC_BITS, (ASPMETA_FUNC_CROP | ASPMETA_FUNC_IMGLEN));
                                
                                ptmetainduo->ASP_MAGIC[0] = 0x20;
                                ptmetainduo->ASP_MAGIC[1] = 0x14;
                                
                                aspMetaReleaseDuo(msb2lsb32(&ptmetainduo->FUNC_BITS), 0, rs);

                                pmassduo->massRecd = 0;

                                err = cfgTableGet(pct, ASPOP_IMG_LEN_DUO, &val);                                
                                sprintf_f(rs->logs, "usb meta get duo img len: %d err: %d\n", val, err); 
                                print_f(rs->plogs, "P11", rs->logs);                     
                                
                                val = cswerr;
                                cfgTableUpd(pct, ASPOP_SCAN_STATUS_DUO, val);
                                cswstatus[1] = cswerr;
                                #endif
                            }
                            else {
                                sprintf_f(rs->logs, "release duo extra meta data act: %d\n", act); 
                                print_f(rs->plogs, "P11", rs->logs);                     

                                /* mechanism to sync primary and secondary boad to stop scan */
                                if (cswstatus[0] > 0) {
                                    val = cswstatus[0];
                                    cfgTableUpd(pct, ASPOP_SCAN_STATUS_DUO, val);
                                    cswstatus[1] = val;
                                } else {
                                    val = cswerr;
                                    cfgTableUpd(pct, ASPOP_SCAN_STATUS_DUO, val);
                                    cswstatus[1] = cswerr;
                                }
                                
                                #if 0 /* test stopping multiple scan */
                                if (cswerr) {
                                    val = 0;
                                    cfgTableUpd(pct, ASPOP_IMG_LEN_DUO, val);
                                }
                                #endif

                                err = cfgTableGet(pct, ASPOP_IMG_LEN_DUO, &val);
                                //sprintf_f(rs->logs, "usb meta get duo img len: %d err: %d, cswerr: 0x%.2x\n", val, err, cswerr); 
                                //print_f(rs->plogs, "P11", rs->logs);                     

                                cfgTableGet(pct, ASPOP_XCROP_LINREC_DUO, &val);
                                //sprintf_f(rs->logs, "Yline_recorder duo: %d!!\n", val); 
                                //print_f(rs->plogs, "P11", rs->logs);  

                                //sprintf_f(rs->logs, "act: %d, metamass duo gap:%d, start:%d, record:%d, used:%d\n", act, pmassduo->massGap, pmassduo->massStart, pmassduo->massRecd, pmassduo->massUsed); 
                                //print_f(rs->plogs, "P11", rs->logs);  
                            }

                            puscur->pushrmcnt += 1;

                            //sprintf_f(rs->logs, "usb duo scan cnt: %d, rm: %d, cswerr: %d (0x%.2x)\n", puscur->pushcnt, puscur->pushrmcnt, puscur->pushcswerr, puscur->pushcswerr); 
                            //print_f(rs->plogs, "P11", rs->logs);                     

                            cmd = 0;

                        }
                        else {
                            while (1) {
                                lenrs = 0;
                                lenrs = ring_buf_get(rs->pcmdTx, &addrs);
                                if (lenrs > 0) {
                                    if (lenrs >= sendsz) {
                                        lenrs = sendsz;
                                        sendsz = 0;
                                    } else {
                                        sendsz -= lenrs;
                                    }
                                    memcpy(addrs, addrd, lenrs);
                                    addrd += lenrs;

                                    #if 0
                                    sprintf_f(rs->logs, "[DV] duo ring buff copy %d / %d!!!\n", lenrs, sendsz);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    #endif
                                    
                                    ring_buf_prod(rs->pcmdTx);
                                    
                                    rs_ipc_put(rsd, "p", 1);
                            
                                    if (lenrs < SPI_TRUNK_SZ) {

                                        #if JPG_FFD9_CUT /* find 0xcffd9 in jpg */
                                        ret = cfgTableGetChk(pct, ASPOP_FILE_FORMAT, &fformat, ASPOP_STA_CON);    
                                        if (ret) {
                                            fformat = 0;
                                        }

                                        lrst = lenrs % 512;
                                        opsz = lenrs - lrst;
                                        lrst = opsz - JPG_FFD9_RANGE;

                                        if ((fformat == 0) || (fformat == FILE_FORMAT_JPG) || (fformat == FILE_FORMAT_PDF)) {

                                            /* search the offset of 0xffd9 */
                                            ret = findEOF(addrs + lrst, JPG_FFD9_RANGE);
                                            if (ret > 0) {
                                            memset(addrs + lrst + ret + 2, 0xff, JPG_FFD9_RANGE - ret - 2);
                                            } else {
                                                sprintf_f(rs->logs, "[DV] warnning!!! duo file format: 0x%x, ret: %d can't find ffd9\n", fformat, ret);
                                                print_f(rs->plogs, "P11", rs->logs);    
                                            }

                                            sprintf_f(rs->logs, "[DV] JPG_FFD9_CUT duo fformat: 0x%x, len: %d ret: %d, range: %d\n", fformat, lenrs, ret, JPG_FFD9_RANGE);
                                            print_f(rs->plogs, "P11", rs->logs);    
                                        }
                                        #endif
                                        
                                        ring_buf_set_last(rs->pcmdTx, lenrs);
                                        rs_ipc_put(rsd, "d", 1);
                                    }
                                    
                                    if (sendsz == 0) {
                                        break;
                                    }   
                                }
                                else {
                                    //sprintf_f(rs->logs, "[DV] get buff ret: %d, wait for tx size: %d!!!\n", lenrs, sendsz);
                                    //print_f(rs->plogs, "P11", rs->logs);
                                    usleep(500);
                                }
                            }
                            sendsz = lens;
                        }

                    }
                    else {
                        
                        if ((lens < USB_BUF_SIZE) && (che != 'E') && (sendsz == 0)) {
                            #if JPG_FFD9_CUT /* find 0xcffd9 in jpg */
                            ret = cfgTableGetChk(pct, ASPOP_FILE_FORMAT, &fformat, ASPOP_STA_CON);    
                            if (ret) {
                                fformat = 0;
                            }
                            
                            lrst = lens % 512;
                            opsz = lens - lrst;
                            lrst = opsz - JPG_FFD9_RANGE;
                            
                            if ((fformat == 0) || (fformat == FILE_FORMAT_JPG) || (fformat == FILE_FORMAT_PDF)) {
                            
                                /* search the offset of 0xffd9 */
                                ret = findEOF(addrd + lrst, JPG_FFD9_RANGE);
                                if (ret > 0) {
                                    memset(addrd + lrst + ret + 2, 0xff, JPG_FFD9_RANGE - ret - 2);
                                } else {
                                    sprintf_f(rs->logs, "[DV] warnning!!! USB file format: 0x%x, ret: %d can't find ffd9\n", fformat, ret);
                                    print_f(rs->plogs, "P11", rs->logs);    
                                }
                            
                                sprintf_f(rs->logs, "[DV] JPG_FFD9_CUT USB fformat: 0x%x, len: %d ret: %d, range: %d\n", fformat, lens, ret, JPG_FFD9_RANGE);
                                print_f(rs->plogs, "P11", rs->logs);    
                            }
                            #endif
                        }

                        #if 0//GHP_EN
                        if (bmpbufc) {
                            if (che == 'E') {
                            
                                rawlen = cpylen - lastCylen - lens;
                                
                                sprintf_f(rs->logs, "[BMP] cpylen: %d, rawlen: %d, lastlen: %d, metaex len: %d \n", cpylen, rawlen, lastCylen, lens);
                                print_f(rs->plogs, "P11", rs->logs); 

                                bmpbufc = bmpbuff;

                                act = aspMetaReleaseviaUsbdlBmp(0, rs, addrd, lens);

                                val=0;
                                ret = cfgTableGetChk(pct, ASPOP_IMG_LEN, &val, ASPOP_STA_APP);    
                                sprintf_f(rs->logs, "[BMP] image length: %d \n", val);
                                print_f(rs->plogs, "P11", rs->logs);
                                bmph = val;

                                bhlen = 0;
                                
                                if (act || (bmph == 0)) {
                                    sprintf_f(rs->logs, "[BMP] pop usb meta failed ret: %d \n", act);
                                    print_f(rs->plogs, "P11", rs->logs); 
                                } else {
                                    sprintf_f(rs->logs, "[BMP] pop usb meta succeed!! \n");
                                    print_f(rs->plogs, "P11", rs->logs); 

                                    ret = cfgTableGetChk(pct, ASPOP_COLOR_MODE, &val, ASPOP_STA_APP);    
                                    switch (val) {
                                    case COLOR_MODE_COLOR:
                                        colr = 24;
                                        break;
                                    case COLOR_MODE_GRAY:
                                    case COLOR_MODE_GRAY_DETAIL:
                                    case COLOR_MODE_BLACKWHITE:
                                        colr = 8;
                                        break;
                                    default:
                                        colr = 24;
                                        break;
                                    }
                                    sprintf_f(rs->logs, "[BMP] color mode: %d, ret: %d, bpp: %d \n", val, ret, colr);
                                    print_f(rs->plogs, "P11", rs->logs);
            
                                    ret = cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_H, &val, ASPOP_STA_APP);    
                                    sprintf_f(rs->logs, "[BMP] width high: %d, ret:%d\n", val, ret);
                                    print_f(rs->plogs, "P11", rs->logs);

                                    ret = cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_L, &tmp, ASPOP_STA_APP);    
                                    tmp = val << 8 | tmp;

                                    val = 0;
                                    ret = cfgTableGetChk(pct, ASPOP_SCAN_WIDTH, &val, ASPOP_STA_UPD);
                                    bmpw = scanWidthConvert(tmp, val);
                                    sprintf_f(rs->logs, "[BMP] defined width: %d, scan width = %d result width: %d \n", tmp, val, bmpw);
                                    print_f(rs->plogs, "P11", rs->logs);

                                    tmp = 0;
                                    ret = cfgTableGetChkDPI(pct, ASPOP_RESOLUTION, &tmp, ASPOP_STA_APP);    
                                    bdpi = tmp;
                                    sprintf_f(rs->logs, "[BMP] resulution cfg: %d, dpi: %d\n", tmp, bdpi);
                                    print_f(rs->plogs, "P11", rs->logs);

                                    jpgout = 0;

                                    if (fformat == FILE_FORMAT_JPG) {
                                        tmp = ((bmpw * colr + 31) / 32) * 4;
                                        tmp = tmp * bmph;
                                        jpgout = aspMemalloc(tmp, 11);

                                        if (jpgout) {
                                            sprintf_f(rs->logs, "[BMP] allocate memory for jpeg decode out, size: %d succeed!!!\n", tmp);
                                            print_f(rs->plogs, "P11", rs->logs);
                                        } else {
                                            sprintf_f(rs->logs, "[BMP] allocate memory for jpeg decode out, size: %d failed!!!\n", tmp);
                                            print_f(rs->plogs, "P11", rs->logs);
                                        }

                                        changeJpgLen(bmpbuff, bmph, bmplen);
                                        
                                        //grapjpg(bmpbuff, bmplen);
                                        
                                        clock_gettime(CLOCK_REALTIME, &jpgS);
                                        err = jpeg2rgb(bmpbuff, bmplen, jpgout, tmp, &jpgetW, &jpgetH, colr);
                                        //err = tj_jpeg2rgb(bmpbuff, bmplen, jpgout, tmp, &jpgetW, &jpgetH, colr==8 ? TJPF_GRAY:TJPF_RGB);
                                        clock_gettime(CLOCK_REALTIME, &jpgE);

                                        tmCost = time_diff(&jpgS, &jpgE, 1000000);
                                                                    
                                        sprintf_f(rs->logs, "[JPG] decode jpg ret: %d w: %d h: %d cost: %d ms\n", err, jpgetW, jpgetH, tmCost);
                                        print_f(rs->plogs, "P11", rs->logs);

                                        //bmpbuff = jpgout;
                                        bmpw = jpgetW;
                                        bmph = jpgetH;
                                    }

                                    bmpcolrtb = aspMemalloc(1078, 11);
                                    if (!bmpcolrtb) {
                                        sprintf_f(rs->logs, "[BMP] allocate memory failed size: %d \n", 1078);
                                        print_f(rs->plogs, "P11", rs->logs);                                
                                    }

                                    if (colr == 8) {
                                        blen = 1078;
                                        //blen = 54;
                                        bdpp = 1;
                                    } else if (colr == 24) {
                                        blen = 54;            
                                        bdpp = 3;
                                    } else {
                                        sprintf_f(rs->logs, "[BMP] error!!! unknown color bits: %d \n", colr);
                                        print_f(rs->plogs, "P11", rs->logs);   
                                    }

                                    //oldRowsz = ((bpp * oldWidth + 31) / 32) * 4;
                                    
                                    bhlen = blen;
                                    val = ((bmpw * colr + 31) / 32) * 4;
                                    val = val * bmph;

                                    sprintf_f(rs->logs, "[BMP] calcu raw size: %d, recv rawlen: %d \n", val, cpylen - lens);
                                    print_f(rs->plogs, "P11", rs->logs);   

                                    sprintf_f(rs->logs, "[BMP] bitmap info color: %d, w: %d, h: %d, dpi: %d, raw size: %d, header size: %d\n", colr, bmpw, bmph, bdpi, val, blen);
                                    print_f(rs->plogs, "P11", rs->logs);

                                    bitmapHeaderSetup(bheader, colr, bmpw, bmph, bdpi, val);

                                    ph = &rs->pbheader->aspbmpMagic[2];
                                    val = sizeof(struct bitmapHeader_s) - 2;
                                    memcpy(bmpcolrtb, ph, val);

                                    blen -= val;
                                    if (blen > 0) {
                                        bitmapColorTableSetup(bmpcolrtb+val);
                                        blen -= 1024;
                                    }

                                    if (blen) {
                                        sprintf_f(rs->logs, "[BMP] Error!!! the bitmap header's len is wrong %d\n", bhlen);
                                        print_f(rs->plogs, "P11", rs->logs);
                                    } 

                                    //dbgBitmapHeader(bheader, val);
                                }

                                #if 1 /* manually rotate the BMP */
                                if (bhlen) {

                                    if (jpgout) {
                                        bmpbuff = jpgout;
                                    }

                                    exmtaout = addrd;

                                    blen = sqrt(bmpw*bmpw + bmph*bmph);
                                    val = ((blen * colr + 31) / 32) * 4;
                                    val = val * blen;
                                    
                                    bmprot = aspMemalloc(val, 11);
                                    if (!bmprot) {
                                        sprintf_f(rs->logs, "[BMP] Error!!! allocate rot buff size: %d failed!!! \n", val);
                                        print_f(rs->plogs, "P11", rs->logs);
                                    } else {
                                        sprintf_f(rs->logs, "[BMP] allocate rot buff size: %d succeed!!! \n", val);
                                        print_f(rs->plogs, "P11", rs->logs);
                                    }
                                    
                                    #if CROP_TEST_EN
                                    prisec = ptmetausb->PRI_O_SEC;
                                    if (prisec > 1) {
                                        sprintf_f(rs->logs, "Error !! the pri sec is wrong !!! val: %d \n", prisec);
                                        print_f(rs->plogs, "P11", rs->logs);

                                        prisec = 0;
                                    }
                                    
                                    cutcnt =0;
                                    cutnum = msb2lsb16(&metaRx->BKNA_NUM);

                                    cutsides = aspMemalloc(cutnum*sizeof(int)*2, 11);
                                    memset(cutsides, 0, cutnum*sizeof(int)*2);
                                    cutlayers = aspMemalloc(cutnum*sizeof(int)*2, 11);
                                    memset(cutlayers, 0, cutnum*sizeof(int)*2);
                                    ret = 0;
                                    
                                    ret = aspMetaGetPages(metaRx, cutsides, cutlayers, cutnum);
                                    sprintf_f(rs->logs, "[CUT] get page ret: %d \n", ret);
                                    print_f(rs->plogs, "P11", rs->logs);

                                    #if 1
                                    cutsides[ret*2] = -1;
                                    cutsides[ret*2+1] = -1;
                                    cutlayers[ret*2] = 0;
                                    cutlayers[ret*2+1] = 0;
                                    
                                    ret += 1;
                                    
                                    cutsides[ret*2] = -2;
                                    cutsides[ret*2+1] = -2;
                                    cutlayers[ret*2] = 0;
                                    cutlayers[ret*2+1] = 0;
                                    
                                    ret += 1;
                                    #endif

                                    for (cutnum=0; cutnum < ret; cutnum++) {
                                        sprintf_f(rs->logs, "[CUT] %d. A:%d (%d) B:%d (%d)\n", cutnum, cutsides[cutnum*2], cutlayers[cutnum*2], cutsides[cutnum*2+1], cutlayers[cutnum*2+1]);
                                        print_f(rs->plogs, "P11", rs->logs);
                                    }

                                    mreal[0] = -1;
                                    mreal[1] = -1;
                                    
                                    while (cutcnt < cutnum) {
                                        if (cutcnt > 0) {
                                            recvsz = 0;
                                            
                                            while (recvsz <= 0) {
                                                recvsz = read(usbfd, ptrecv, 31);
                                        
                                                usleep(1000);
                                            }
                                        
                                            sprintf_f(rs->logs, " get cbw: [%.2x][%.2x][%.2x] recvsz: %d \n", ptrecv[15], ptrecv[16], ptrecv[17], recvsz); 
                                            print_f(rs->plogs, "P11", rs->logs);
                                        
                                            shmem_dump(ptrecv, recvsz);
                                        }
                                        #endif //#if CROP_TEST_EN
                                        
                                        //msync(bmpcolrtb, 1078, MS_SYNC);
                                        //memcpy(bmpbuff, bmpcolrtb, bhlen);
                                        //shmem_dump(bmpbuff, bhlen);
                                        
                                        //bdeg = 1350;
                                        //bdeg = 900;
                                        //bdeg = 450;
                                        
                                        addrd = exmtaout;
                                        
                                        #if DUMP_JPG_ROT
                                        for (bdeg = 0; bdeg <= 360000; bdeg += 5000) {
                                        //bdeg = 180000;
                                        #else
                                        bdeg = 0;
                                        #endif
                                        
                                        //bdeg = -915;
                                        
                                        memcpy(ph, bmpcolrtb, 54);
                                        
                                        sprintf_f(rs->logs, "[BMP] %d. pri or sec: %d up or down: %d (%d, %d) \n", cutcnt, prisec, sides[prisec], mreal[0], mreal[1]);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        
                                        clock_gettime(CLOCK_REALTIME, &jpgS);
                                        
                                        //grapbmp(bmpbuff, bheader, bmpcolrtb, bhlen);
                                        ret = rotateBMP(rs, &cutsides[cutcnt*2], metaRx, bmpbuff, bmpcolrtb, bhlen, bmprot, &sides[prisec], mreal, &cutlayers[cutcnt*2], 11);
                                        //grapbmp(pabuff->dirParseBuff+bheader->aspbhRawoffset, bheader, pabuff->dirParseBuff, bheader->aspbhRawoffset);
                                        
                                        //draw();
                                        //grapbmp();
                                        clock_gettime(CLOCK_REALTIME, &jpgE);
                                        
                                        sprintf_f(rs->logs, "[BMP] rotate bmp w: %d h: %d rawoffset: %d \n", bheader->aspbiWidth, bheader->aspbiHeight, bheader->aspbhRawoffset);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        
                                        tmCost = time_diff(&jpgS, &jpgE, 1000000);
                                        sprintf_f(rs->logs, "[BMP] rotate bmp cost: %d ms\n", tmCost);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        
                                        bmpbufc = pabuff->dirParseBuff;   
                                        rotlen = pabuff->dirBuffUsed;
                                        
                                        if (fformat == FILE_FORMAT_JPG) {
                                            jpgrlt = pabuff->dirParseBuff;
                                            clock_gettime(CLOCK_REALTIME, &jpgS);
                                            err = rgb2jpg(pabuff->dirParseBuff + bheader->aspbhRawoffset, jpgrlt, &jpgLen, bheader->aspbiWidth, bheader->aspbiHeight, colr);
                                            clock_gettime(CLOCK_REALTIME, &jpgE);
                                            if (err) {
                                                sprintf_f(rs->logs, "[BMP] raw encode to jpg failed ret: %d  \n", err);
                                                print_f(rs->plogs, "P11", rs->logs);
                                            }
                                        
                                            tmCost = time_diff(&jpgS, &jpgE, 1000000);
                                            sprintf_f(rs->logs, "[BMP] raw encode to jpg len: %d addr: 0x%.8x cost: %d ms\n", jpgLen, (uint32_t)jpgrlt, tmCost);
                                            print_f(rs->plogs, "P11", rs->logs);
                                            
                                            //changeJpgLen(jpgrlt, bheader->aspbiHeight, jpgLen);
                                            
                                            //shmem_dump(jpgrlt, 512);
                                            
                                            rotlen = 512 - (jpgLen % 512);
                                            rotlen = rotlen + jpgLen;
                                            bmpbufc = jpgrlt;
                                        }

                                        if (sides[prisec] > 0) {
                                            updn = (sides[prisec] - 1) % 2;
                                        } else {
                                            updn = 0;
                                        }
                                        sprintf_f(rs->logs, "[BMP] updn: %d, side: %d cutcnt: %d\n", updn, sides[prisec], cutcnt);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        
                                        aspMetaReleaseviaUsbdlBmpUpd(rs->pmetausb, bheader->aspbiWidth, bheader->aspbiHeight, cutlayers[cutcnt*2+updn], cutcnt+1);
                                        sprintf_f(rs->logs, "[BMP] update new width and height: %d, %d \n", bheader->aspbiWidth, bheader->aspbiHeight);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        
                                        lenbs = &ptmetausb->EPOINT_RESERVE1[0] - &ptmetausb->ASP_MAGIC_ASPC[0];
                                        lrst= lastCylen % 512;
                                        
                                        bmpcpy = bmpbufc + rotlen;
                                        memcpy(bmpcpy, ptmetausb, lrst);
                                        
                                        //shmem_dump(bmpbufc+rotlen-512, 1024);
                                        dbgMetaUsb(ptmetausb);
                                        
                                        sprintf_f(rs->logs, "[BMP] usb meta size check, lstlen: %d : sizeof: %d  \n", lrst, lenbs);
                                        print_f(rs->plogs, "P11", rs->logs);
                                        
                                        //bmpbufc = bmpbuff;
                                        rotlen = rotlen + lrst;
                                        
                                        #if DUMP_JPG_ROT
                                        fsmeta = find_save(ptfilepath, ptfileSavejpg);
                                        if (fsmeta) {
                                            sprintf_f(rs->logs, "[DV] find save jpg [%s] succeed!!! \n", ptfilepath);
                                            print_f(rs->plogs, "P11", rs->logs);
                                        }
                                        #endif
                                        
                                        rotlast = rotlen % USB_BUF_SIZE;
                                        rawlen = rotlen - rotlast;
                                        
                                        msync(bmpbufc, rotlen, MS_SYNC);
                                        
                                        //rawlen = rotlen;
                                        
                                        if (rawlen > USB_BUF_SIZE) {
                                            blen = USB_BUF_SIZE;
                                        } else {
                                            blen = rawlen;
                                        }
                                        cntsent = 0;
                                        while (rawlen) {                                    
                                            /*
                                            if (cntsent == 0) {
                                                memset(bmpbufc, 0xff, 512);
                                                msync(bmpbufc, 512, MS_SYNC);
                                            }
                                            */
                                        
                                            #if DUMP_JPG_ROT
                                            bret = blen;
                                            #else
                                            bret = usbc_write(usbfd, bmpbufc, blen);
                                            #endif
                                            
                                        
                                            //sprintf_f(rs->logs, "[BMP] usb send %d ret: %d - 1\n", blen, bret);
                                            //print_f(rs->plogs, "P11", rs->logs); 
                                        
                                            /*
                                            if (cntsent == 0) {
                                                shmem_dump(bmpbufc, 512);
                                            }
                                            */
                                        
                                            if (bret > 0) {
                                                cntsent ++;                                    
                                                
                                                rawlen -= bret;
                                        
                                                #if DUMP_JPG_ROT
                                                wrtsz = fwrite((char*)bmpbufc, 1, bret, fsmeta);
                                                sprintf_f(rs->logs, "[DV] write [%s] size: %d / %d !!! \n", ptfilepath, bret, wrtsz);
                                                print_f(rs->plogs, "P11", rs->logs);
                                                #endif
                                        
                                                bmpbufc += bret;
                                        
                                                if (rawlen > USB_BUF_SIZE) {
                                                    blen = USB_BUF_SIZE;
                                                } else {
                                                    blen = rawlen;
                                                }
                                            }
                                        }
                                        
                                        
                                        blen = rotlast;
                                        while (blen) {
                                        
                                            #if DUMP_JPG_ROT
                                            bret = blen;
                                            #else
                                            bret = usbc_write(usbfd, bmpbufc, blen); 
                                            #endif
                                            
                                            //sprintf_f(rs->logs, "[BMP] usb send %d ret: %d - 2\n", blen, bret);
                                            //print_f(rs->plogs, "P11", rs->logs); 
                                        
                                            if (bret > 0) {
                                                blen -= bret;
                                        
                                                #if DUMP_JPG_ROT
                                                wrtsz = fwrite((char*)bmpbufc, 1, bret, fsmeta);
                                                sprintf_f(rs->logs, "[DV] write [%s] size: %d / %d !!! \n", ptfilepath, bret, wrtsz);
                                                print_f(rs->plogs, "P11", rs->logs);
                                                #endif
                                        
                                                bmpbufc += bret;
                                            }
                                        }
                                        
                                        blen = lens;
                                        while (blen) {
                                            #if DUMP_JPG_ROT
                                            bret = blen;
                                            #else
                                            bret = usbc_write(usbfd, addrd, blen); 
                                            #endif
                                            
                                            //sprintf_f(rs->logs, "[BMP] usb send %d ret: %d -3 \n", blen, bret);
                                            //print_f(rs->plogs, "P11", rs->logs); 
                                        
                                            if (bret > 0) {
                                                blen -= bret;
                                        
                                                #if DUMP_JPG_ROT
                                                wrtsz = fwrite((char*)addrd, 1, bret, fsmeta);
                                                sprintf_f(rs->logs, "[DV] write [%s] size: %d / %d !!! \n", ptfilepath, bret, wrtsz);
                                                print_f(rs->plogs, "P11", rs->logs);
                                                #endif
                                        
                                                addrd += bret;
                                            }
                                        }
                                        
                                        #if DUMP_JPG_ROT
                                        fflush(fsmeta);
                                        fclose(fsmeta);
                                        sync();
                                        #endif
                                        
                                        #if DUMP_JPG_ROT
                                        }
                                        #endif
                                        
                                        #if CROP_TEST_EN
                                        
                                        cutcnt ++;
                                        
                                        if ((cutcnt < cutnum) && (!ret)) { 
                                            sprintf_f(rs->logs, "[DV] cutcnt: %d, cswerr: 0x%.2x !!!\n", cutcnt, cswerr); 
                                            print_f(rs->plogs, "P11", rs->logs);
                                            
                                            /*
                                            if ((cswerr) && (cswerr != 0x21) && (cswerr != 0x22) && (cswerr != 0x23)) {
                                                if ((waitCylen) || (pagerst)) {
                                                    sprintf_f(rs->logs, "[DV] Warnning!!!waitCylen || pagerst != 0 and cswerr: 0x%.2x, %d : %d !!!\n", cswerr, waitCylen, pagerst); 
                                                    print_f(rs->plogs, "P11", rs->logs);
                                            
                                                    csw[11] = 0;
                                                    csw[12] = 0;
                                                } else {
                                                    csw[11] = 0;
                                                    csw[12] = cswerr;
                                                }
                                            } else {
                                            
                                                csw[11] = 0;
                                                csw[12] = 0;
                                            }
                                            */
                                            
                                            csw[11] = 0;
                                            csw[12] = 0;
                                            
                                            wrtsz = 0;
                                            retry = 0;
                                            
                                            while (1) {
                                                wrtsz = usbc_write(usbfd, csw, 13);
                                            
                                                #if DBG_27_DV
                                                sprintf_f(rs->logs, "[DV] cmd: 0x%.2x usb TX size: %d \n====================\n", cmd, wrtsz);
                                                print_f(rs->plogs, "P11", rs->logs);
                                                #endif
                                            
                                                if (wrtsz > 0) {
                                                    break;
                                                }
                                                retry++;
                                                if (retry > 32768) {
                                                    break;
                                                }
                                            }
                                            shmem_dump(csw, wrtsz);
                                        }
                                        else {
                                            if (ret) {
                                                break;
                                            }
                                        }
                                    }

                                    #endif // #if CROP_TEST_EN
                                }
                                else {
                                    if (rawlen > USB_BUF_SIZE) {
                                        blen = USB_BUF_SIZE;
                                    } else {
                                        blen = rawlen;
                                    }
                                    
                                    while (rawlen) {                                    
                                        bret = usbc_write(usbfd, bmpbufc, blen);
                                    
                                        if (bret > 0) {
                                            //sprintf_f(rs->logs, "[BMP] usb send %d ret: %d \n", blen, bret);
                                            //print_f(rs->plogs, "P11", rs->logs); 
                                    
                                            rawlen -= bret;

                                            bmpbufc += bret;
                                    
                                            if (rawlen > USB_BUF_SIZE) {
                                                blen = USB_BUF_SIZE;
                                            } else {
                                                blen = rawlen;
                                            }
                                        }
                                    }
                                    
                                    blen = lastCylen;
                                    while (blen) {
                                        bret = usbc_write(usbfd, bmpbufc, blen); 
                                    
                                        if (bret > 0) {
                                            blen -= bret;
                                            bmpbufc += bret;
                                        }
                                    }
                                    
                                    blen = lens;
                                    while (blen) {
                                        bret = usbc_write(usbfd, addrd, blen); 
                                    
                                        if (bret > 0) {
                                            blen -= bret;
                                            addrd += bret;
                                        }
                                    }
                                }

                                #else
                                if (rawlen > USB_BUF_SIZE) {
                                    blen = USB_BUF_SIZE;
                                } else {
                                    blen = rawlen;
                                }

                                while (rawlen) {                                    
                                    bret = usbc_write(usbfd, bmpbufc, blen);

                                    if (bret > 0) {
                                        //sprintf_f(rs->logs, "[BMP] usb send %d ret: %d \n", blen, bret);
                                        //print_f(rs->plogs, "P11", rs->logs); 

                                        rawlen -= bret;
                                        bmpbufc += bret;

                                        if (rawlen > USB_BUF_SIZE) {
                                            blen = USB_BUF_SIZE;
                                        } else {
                                            blen = rawlen;
                                        }
                                    }
                                }

                                blen = lastCylen;
                                while (blen) {
                                    bret = usbc_write(usbfd, bmpbufc, blen); 

                                    if (bret > 0) {
                                        blen -= bret;
                                        bmpbufc += bret;
                                    }
                                }

                                blen = lens;
                                while (blen) {
                                    bret = usbc_write(usbfd, addrd, blen); 

                                    if (bret > 0) {
                                        blen -= bret;
                                        bmpbufc += bret;
                                    }
                                }
                                #endif
                            }
                            
                            sendsz = lens;                            
                        } else 
                        #endif //#if GHP_EN
                        {

                            #if USB_RECVLEN_ZERO_HANDLE
                            if (lens == 0) {
                                sendsz = lens;
                            } else {
                                sendsz = usbcphy_write(usbfd, addrd, addrb, lens);
                            }
                            #else
                            sendsz = usbcphy_write(usbfd, addrd, addrb, lens);
                            #endif

                        }
                        
                    }
                    #endif
                    
                    if (sendsz < 0) {
                    
                        #if DBG_27_DV
                        sprintf_f(rs->logs, "[DV] usb send ret: %d [addr: 0x%.8x]!!!\n", sendsz, (uint32_t)addrd);
                        print_f(rs->plogs, "P11", rs->logs);
                        #endif

                        #if 0 /* break and let others has cpu time */
                        usbentsTx = 0;
                        break;
                        #else
                        //usleep(5000);

                        if ((errcnt & 0x1fff) == 0) {
                            //sprintf_f(rs->logs, "[DV] usb send ret: %d [addr: 0x%.8x]!!!\n", sendsz, addrd);
                            //print_f(rs->plogs, "P11", rs->logs);
                            //usleep(50000);
                        }
                        errcnt ++;
                        continue;
                        #endif
                        
                    }
                    else {
                    
                        #if DBG_27_DV
                        sprintf_f(rs->logs, "[DV] usb TX size: %d, ret: %d \n", lens, sendsz);
                        print_f(rs->plogs, "P11", rs->logs);

                        #if 0 /*debug*/
                        shmem_dump(addrd, 64);
                        #endif

                        #endif

                        acusz += sendsz;
                        //errcnt = 0;
                        
                        if (lens == sendsz) {
                            addrd = 0;
                            lens = 0;
                            
                            #if 1
                            if (che == 'E') {
                                puscur->pushrmcnt += 1;

                                //sprintf_f(rs->logs, "zebra usb scan cnt: %d, rm: %d, cswerr: %d (0x%.2x) lens: %d\n", puscur->pushcnt, puscur->pushrmcnt, puscur->pushcswerr, puscur->pushcswerr, lens); 
                                //print_f(rs->plogs, "P11", rs->logs);    

                                break;
                            }
                            #else
                            if (puscur->pushcnt == 0) break;
                            #endif
                            
                        } else {
                            lens -= sendsz;
                            addrd += sendsz;
                            continue;
                        }
                    }
                }

                if ((che == 'E') && (addrd == 0)) {

                    clock_gettime(CLOCK_REALTIME, &tend);

                    tmCost = time_diff(&tstart, &tend, 1000);
                    //sprintf_f(rs->logs, "[DV] end time %llu ms start time %llu ms diff: %d \n", time_get_ms(&tend), time_get_ms(&tstart), tmCost);
                    //print_f(rs->plogs, "P11", rs->logs);
                    throughput = acusz / tmCost*1.0;
                    sprintf_f(rs->logs, "[DV] usb throughput: %d bytes / %d ms = %lf MB\n", acusz, tmCost > 1000 ? tmCost / 1000 : 1, throughput);
                    print_f(rs->plogs, "P11", rs->logs);

                    #if USB_HS_SAVE_RESULT_DV
                    wrtsz = fwrite(pImage, 1, cntTx*USB_BUF_SIZE, fsave);
                    sync();
                    fclose(fsave);
                    free(pImage);
                    sprintf_f(rs->logs, "[DV] save file size: %d, ret: %d \n", cntTx*USB_BUF_SIZE, wrtsz);
                    print_f(rs->plogs, "P11", rs->logs);
                    #endif

                    maxCylcnt = cntTx;
                    cntTx = 0;
                    opc = 0;
                    che = 0;

                    #if 0
                    ch = 'a';
                    ret = write(pipeusb[1], &ch, 1);
                    sprintf_f(rs->logs, "[ISO] pipeusb send ch: %c ret: %d \n", ch, ret);
                    print_f(rs->plogs, "P11", rs->logs);

                    ret = read(pipepc[0], &ch, 1);
                    sprintf_f(rs->logs, "[PC] usbpc get ch: %c ret: %d\n", ch, ret);
                    print_f(rs->plogs, "P11", rs->logs);
                    #endif

                    continue;
                }
                //} 
                //while (opc == 0x0f);
                //while (pid == 0);
            }
            else if ((cmd == 0x11) && ((opc == 0x4d) || (opc == 0x4f))) { /* usbentsTx == 1*/

                //if (ucbwpram->ASIC_sel) {
                
                    #if BYPASS_TWO
                    //if (usbid02) {
                        while (1) {
                            chd = 0;
                            pipRet = read(pipeRxd[0], &chd, 1);
                            if (pipRet > 0) {
                                break;
                            }
                        }
                    
                        if (chd != 'J') {
                            sprintf_f(rs->logs, "[DV] polld status unknown result, ret: %c (0x%.2x) \n", chd, chd);
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                        
                        chm = 0;
                        while (1) {
                            pipRet = read(pipeRxd[0], &chm, 1);
                            if (pipRet < 0) {
                                break;
                            }
                        }
                    
                        if (chm) {
                            sprintf_f(rs->logs, "[DV] polld status : (0x%.2x) \n", chm);
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                    //}
                    #endif
                    
                //} else {
                    //if (usbid01) {
                        while (1) {
                            chq = 0;
                            pipRet = read(pipeRx[0], &chq, 1);
                            if (pipRet > 0) {
                                break;
                            }
                        }
                    
                        if (chq != 'J') {
                            sprintf_f(rs->logs, "[DV] poll status unknown result, ret: %c (0x%.2x) \n", chq, chq);
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                    
                        while (1) {
                            chn = 0;
                            pipRet = read(pipeRx[0], &chn, 1);
                            if (pipRet < 0) {
                                break;
                            }
                        }
                        
                        if (chn) {
                            sprintf_f(rs->logs, "[DV] poll status : (0x%.2x) \n", chn);
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                    //}
                //}
                
                #if 1
                memcpy(csw, cswDefault, 16);
                csw[10] = 0;
                csw[11] = 0;
                csw[12] = chm | chn;
                #else
                memcpy(csw, vcswBuff, 13);
                #endif

                if ((rxfd != rs->ppipedn->rt[0]) && (rxfd != rsd->ppipedn->rt[0])) {

                    wrtsz = 0;
                    retry = 0;
                    while (1) {
                        wrtsz = usbc_write(usbfd, csw, 13);
                        
                        #if DBG_27_DV
                        sprintf_f(rs->logs, "[DV] usb TX size: %d \n====================\n", wrtsz); 
                        print_f(rs->plogs, "P11", rs->logs);
                        #endif
                        
                        if (wrtsz > 0) {
                            break;
                        }
                        retry++;
                        if (retry > 32768) {
                            break;
                        }
                    }
                    
                    if (wrtsz < 0) {
                        //usbentsTx = 0;
                        continue;
                    }

                    sprintf(rs->logs, "__USB_SEND CSW_[%.2x][%.2x][%.2x]__", csw[10], csw[11], csw[12]); 
                    dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);
                    
                    sprintf_f(rs->logs, "[DV] 0x11 0x4d 0x4f opc: (0x%.2x) dump \n", opc);
                    print_f(rs->plogs, "P11", rs->logs);
                    
                    shmem_dump(csw, wrtsz);
                }

                msgret[0] = 'x';
                if ((chm) || (chn)) {
                    msgret[1] = 0x02;
                } else {
                    msgret[1] = 0x01;
                }
                pipRet = write(pipeTx[1], msgret, 2);                
                if (pipRet < 0) {
                    printf("[DV] Error!!! pipe send scan stop ret: %d \n", pipRet);
                }
                
                sprintf(msgcmd, "usbidle");

                ret = rs_ipc_get_ms(rcmd, rcmd->logs, 4096, 10);
                if (ret > 0) {
                    rcmd->logs[ret] = '\n';

                    sprintf_f(rs->logs, "[DV]  get usbscan result ret: %d\n", ret);
                    print_f(rs->plogs, "P11", rs->logs);   

                    print_f(rcmd->plogs, "C11", rcmd->logs);
                }
                
                cmd = 0;

                #if DBG_USB_TIME_MEASURE
                if (!fintvalE[0]) {
                    clock_gettime(CLOCK_REALTIME, &intvalE[0]);
                    fintvalE[0] = 1;
                
                    if (fintvalE[1]) {
                
                        tmCost = time_diff(&intvalE[1], &intvalE[0], 1000);
                        sprintf_f(rs->logs, "[DV] TX interval end: %llu ms start: %llu ms diff: %d us - 1\n", time_get_ms(&intvalE[0]), time_get_ms(&intvalE[1]), tmCost);
                        print_f(rs->plogs, "P11", rs->logs);
                
                        fintvalE[1] = 0;
                    }
                    else {
                        sprintf_f(rs->logs, "[DVF] TX interval should not be here !!! - 1\n");
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                } else {
                
                    if (!fintvalE[1]) {
                        clock_gettime(CLOCK_REALTIME, &intvalE[1]);
                        fintvalE[1] = 1;
                
                        tmCost = time_diff(&intvalE[0], &intvalE[1], 1000);
                        sprintf_f(rs->logs, "[DV] TX interval end: %llu ms start: %llu ms diff: %d us - 2\n", time_get_ms(&intvalE[1]), time_get_ms(&intvalE[0]), tmCost);
                        print_f(rs->plogs, "P11", rs->logs);
                
                        fintvalE[0] = 0;
                    } else {
                        sprintf_f(rs->logs, "[DVF] TX interval should not be here !!! - 2\n");
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                }
                #endif
                
                break;
            }
            else if ((cmd == 0x11) && (opc == 0x4c)) { /* usbentsTx == 1*/

                if (usbid01) {
                    while (1) {
                        chq = 0;
                        pipRet = read(pipeRx[0], &chq, 1);
                        if (pipRet > 0) {
                            break;
                        }
                    }
    
                    if (chq != 'J') {
                        sprintf_f(rs->logs, "[DV] poll status unknown result, ret: %c (0x%.2x) \n", chq, chq);
                        print_f(rs->plogs, "P11", rs->logs);
                    }
    
                    while (1) {
                        chn = 0;
                        pipRet = read(pipeRx[0], &chn, 1);
                        if (pipRet < 0) {
                            break;
                        }
                    }
                    
                    if (chn) {
                        sprintf_f(rs->logs, "[DV] poll status : (0x%.2x) \n", chn);
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                }

                #if BYPASS_TWO
                if (usbid02) {
                    chd = 'm';
                    pipRet = write(pipeTxd[1], &chd, 1);
                    if (pipRet < 0) {
                        sprintf_f(rs->logs, "[DV]  pipe send meta ret: %d \n", pipRet);
                        print_f(rs->plogs, "P11", rs->logs);
                        continue;
                    }
                }
                    
                if (usbid02) {
                    while (1) {
                        chd = 0;
                        pipRet = read(pipeRxd[0], &chd, 1);
                        if (pipRet > 0) {
                            break;
                        }
                    }
    
                    if (chd != 'J') {
                        sprintf_f(rs->logs, "[DV] polld status unknown result, ret: %c (0x%.2x) \n", chd, chd);
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                    
                    chm = 0;
                    while (1) {
                        pipRet = read(pipeRxd[0], &chm, 1);
                        if (pipRet < 0) {
                            break;
                        }
                    }
    
                    if (chm) {
                        sprintf_f(rs->logs, "[DV] polld status : (0x%.2x) \n", chm);
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                }
                #endif
                
                #if 0
                csw[11] = 0;
                csw[12] = chn;
                #else
                memcpy(csw, vcswBuff, 13);
                #endif

                if ((rxfd != rs->ppipedn->rt[0]) && (rxfd != rsd->ppipedn->rt[0])) {
                    wrtsz = 0;
                    retry = 0;
                    while (1) {
                        wrtsz = usbc_write(usbfd, csw, 13);
                    
                        #if DBG_27_DV
                        sprintf_f(rs->logs, "[DV] usb TX size: %d \n====================\n", wrtsz); 
                        print_f(rs->plogs, "P11", rs->logs);
                        #endif
                    
                        if (wrtsz > 0) {
                            break;
                        }
                        retry++;
                        if (retry > 32768) {
                            break;
                        }
                    }

                    if (wrtsz < 0) {
                        //usbentsTx = 0;
                        continue;
                    }

                    sprintf(rs->logs, "__USB_SEND CSW_[%.2x][%.2x][%.2x]__", csw[10], csw[11], csw[12]); 
                    dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);

                    sprintf_f(rs->logs, "[DV] 0x11 0x4c meat cmd: (0x%.2x) opc: (0x%.2x) dump \n", cmd, opc);
                    print_f(rs->plogs, "P11", rs->logs);
                    shmem_dump(csw, wrtsz);
                }
                
                #if DBG_USB_TIME_MEASURE
                if (!fintvalE[0]) {
                    clock_gettime(CLOCK_REALTIME, &intvalE[0]);
                    fintvalE[0] = 1;
                
                    if (fintvalE[1]) {
                
                        tmCost = time_diff(&intvalE[1], &intvalE[0], 1000);
                        sprintf_f(rs->logs, "[DV] TX interval end: %llu ms start: %llu ms diff: %d us - 1\n", time_get_ms(&intvalE[0]), time_get_ms(&intvalE[1]), tmCost);
                        print_f(rs->plogs, "P11", rs->logs);
                
                        fintvalE[1] = 0;
                    }
                    else {
                        sprintf_f(rs->logs, "[DVF] TX interval should not be here !!! - 1\n");
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                } else {
                
                    if (!fintvalE[1]) {
                        clock_gettime(CLOCK_REALTIME, &intvalE[1]);
                        fintvalE[1] = 1;
                
                        tmCost = time_diff(&intvalE[0], &intvalE[1], 1000);
                        sprintf_f(rs->logs, "[DV] TX interval end: %llu ms start: %llu ms diff: %d us - 2\n", time_get_ms(&intvalE[1]), time_get_ms(&intvalE[0]), tmCost);
                        print_f(rs->plogs, "P11", rs->logs);
                
                        fintvalE[0] = 0;
                    } else {
                        sprintf_f(rs->logs, "[DVF] TX interval should not be here !!! - 2\n");
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                }
                #endif
                
                msgret[0] = 'x';
                msgret[1] = 0x01;
                pipRet = write(pipeTx[1], msgret, 2);
                if (pipRet < 0) {
                    printf("[DV] Error!!! pipe send scan stop ret: %d \n", pipRet);
                }
                opc = 0;
                
                sprintf(msgcmd, "usbidle");
                
                ret = rs_ipc_get_ms(rcmd, rcmd->logs, 4096, 10);
                if (ret > 0) {
                    rcmd->logs[ret] = '\n';

                    sprintf_f(rs->logs, "[DV]  get usbscan result ret: %d\n", ret);
                    print_f(rs->plogs, "P11", rs->logs);   

                    print_f(rcmd->plogs, "C11", rcmd->logs);
                }

                cmd = 0;
                
                break;
            }
            else if ((cmd == 0x11) && (opc == 0x4e)) { /* usbentsTx == 1*/
                chm = 0xff;
                chn = 0xff;
                if (usbid01) {
                    while (1) {
                        chq = 0;
                        pipRet = read(pipeRx[0], &chq, 1);
                        if (pipRet > 0) {
                            break;
                        }
                    }
    
                    if (chq != 'J') {
                        sprintf_f(rs->logs, "[DV] poll status unknown result, ret: %c (0x%.2x) \n", chq, chq);
                        print_f(rs->plogs, "P11", rs->logs);
                    }
    
                    while (1) {
                        chn = 0;
                        pipRet = read(pipeRx[0], &chn, 1);
                        if (pipRet < 0) {
                            break;
                        }
                    }
                    
                    if (chn) {
                        sprintf_f(rs->logs, "[DV] poll status : (0x%.2x) \n", chn);
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                }

                #if BYPASS_TWO
                if (usbid02) {
                    while (1) {
                        chd = 0;
                        pipRet = read(pipeRxd[0], &chd, 1);
                        if (pipRet > 0) {
                            break;
                        }
                    }
    
                    if (chd != 'J') {
                        sprintf_f(rs->logs, "[DV] polld status unknown result, ret: %c (0x%.2x) \n", chd, chd);
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                    
                    chm = 0;
                    while (1) {
                        pipRet = read(pipeRxd[0], &chm, 1);
                        if (pipRet < 0) {
                            break;
                        }
                    }
    
                    if (chm) {
                        sprintf_f(rs->logs, "[DV] polld status : (0x%.2x) \n", chm);
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                }
                #endif

                
                #if 1
                msgret[0] = 'x';
                if ((chm == 0xff) && (chn == 0xff)) {
                    msgret[1] = 0x03;
                }
                else {
                    if ((chm == 0) || (chn == 0)) {
                        msgret[1] = 0x01;
                    } else {
                        msgret[1] = 0x02;
                    }
                }
                
                pipRet = write(pipeTx[1], msgret, 2);                
                if (pipRet < 0) {
                    printf("[DV] Error!!! pipe send scan stop ret: %d \n", pipRet);
                }
                
                sprintf(msgcmd, "usbidle");

                ret = rs_ipc_get_ms(rcmd, rcmd->logs, 4096, 10);
                if (ret > 0) {
                    rcmd->logs[ret] = '\n';

                    sprintf_f(rs->logs, "[DV]  get usbscan result ret: %d\n", ret);
                    print_f(rs->plogs, "P11", rs->logs);   

                    print_f(rcmd->plogs, "C11", rcmd->logs);
                }
                #endif
                
                cmd = 0;
                
                break;
            }
            else if (cmd == 0x11) { /* usbentsTx == 1*/
                csw[11] = 0;
                csw[12] = 0;//seqtx;

                wrtsz = 0;
                retry = 0;
                while (1) {
                    wrtsz = usbc_write(usbfd, csw, 13);

                    #if DBG_27_DV
                    sprintf_f(rs->logs, "[DV] usb TX size: %d \n====================\n", wrtsz); 
                    print_f(rs->plogs, "P11", rs->logs);
                    #endif
                    
                    if (wrtsz > 0) {
                        break;
                    }
                    retry++;
                    if (retry > 32768) {
                        break;
                    }
                }

                #if DBG_USB_TIME_MEASURE
                if (!fintvalE[0]) {
                    clock_gettime(CLOCK_REALTIME, &intvalE[0]);
                    fintvalE[0] = 1;
                
                    if (fintvalE[1]) {
                
                        tmCost = time_diff(&intvalE[1], &intvalE[0], 1000);
                        sprintf_f(rs->logs, "[DV] TX interval end: %llu ms start: %llu ms diff: %d us - 1\n", time_get_ms(&intvalE[0]), time_get_ms(&intvalE[1]), tmCost);
                        print_f(rs->plogs, "P11", rs->logs);
                
                        fintvalE[1] = 0;
                    }
                    else {
                        sprintf_f(rs->logs, "[DVF] TX interval should not be here !!! - 1\n");
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                } else {
                
                    if (!fintvalE[1]) {
                        clock_gettime(CLOCK_REALTIME, &intvalE[1]);
                        fintvalE[1] = 1;
                
                        tmCost = time_diff(&intvalE[0], &intvalE[1], 1000);
                        sprintf_f(rs->logs, "[DV] TX interval end: %llu ms start: %llu ms diff: %d us - 2\n", time_get_ms(&intvalE[1]), time_get_ms(&intvalE[0]), tmCost);
                        print_f(rs->plogs, "P11", rs->logs);
                
                        fintvalE[0] = 0;
                    } else {
                        sprintf_f(rs->logs, "[DVF] TX interval should not be here !!! - 2\n");
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                }
                #endif
                
                if (wrtsz < 0) {
                    //usbentsTx = 0;
                    continue;
                }

                sprintf(rs->logs, "__USB_SEND CSW_[%.2x][%.2x][%.2x]__", csw[10], csw[11], csw[12]); 
                dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);
                    

                sprintf_f(rs->logs, "[DV] 0x11 cmd: 0x%.2x opc: 0x%.2x dump csw: \n", cmd, opc); 
                print_f(rs->plogs, "P11", rs->logs);
                shmem_dump(csw, wrtsz);
                
                cmd = 0;
                break;
            }
            else if (cmd == 0x12) { /* usbentsTx == 1*/

                sprintf_f(rs->logs, "[DV] cswerr: 0x%.2x, waitCylen, pagerst: %d, %d !!!\n", cswerr, waitCylen, pagerst); 
                print_f(rs->plogs, "P11", rs->logs);

                if ((cswerr) && (cswerr != 0x21) && (cswerr != 0x22) && (cswerr != 0x23)) {
                    if ((waitCylen) || (pagerst)) {
                        sprintf_f(rs->logs, "[DV] Warnning!!!waitCylen || pagerst != 0 and cswerr: 0x%.2x, %d : %d !!!\n", cswerr, waitCylen, pagerst); 
                        print_f(rs->plogs, "P11", rs->logs);

                        csw[11] = 0;
                        csw[12] = 0;
                    } else {
                        csw[11] = 0;
                        csw[12] = cswerr;
                    }
                } else {
                    csw[11] = 0;
                    csw[12] = 0;
                }

                wrtsz = 0;
                retry = 0;
                while (1) {
                    wrtsz = usbc_write(usbfd, csw, 13);

                    #if DBG_27_DV
                    sprintf_f(rs->logs, "[DV] cmd: 0x%.2x usb TX size: %d \n====================\n", cmd, wrtsz);
                    print_f(rs->plogs, "P11", rs->logs);
                    #endif
                    
                    if (wrtsz > 0) {
                        break;
                    }
                    retry++;
                    if (retry > 32768) {
                        break;
                    }
                }

                #if DBG_USB_TIME_MEASURE
                if (!fintvalE[0]) {
                    clock_gettime(CLOCK_REALTIME, &intvalE[0]);
                    fintvalE[0] = 1;
                
                    if (fintvalE[1]) {
                
                        tmCost = time_diff(&intvalE[1], &intvalE[0], 1000);
                        sprintf_f(rs->logs, "[DV] TX interval end: %llu ms start: %llu ms diff: %d us - 1\n", time_get_ms(&intvalE[0]), time_get_ms(&intvalE[1]), tmCost);
                        print_f(rs->plogs, "P11", rs->logs);
                
                        fintvalE[1] = 0;
                    }
                    else {
                        sprintf_f(rs->logs, "[DVF] TX interval should not be here !!! - 1\n");
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                } else {
                
                    if (!fintvalE[1]) {
                        clock_gettime(CLOCK_REALTIME, &intvalE[1]);
                        fintvalE[1] = 1;
                
                        tmCost = time_diff(&intvalE[0], &intvalE[1], 1000);
                        sprintf_f(rs->logs, "[DV] TX interval end: %llu ms start: %llu ms diff: %d us - 2\n", time_get_ms(&intvalE[1]), time_get_ms(&intvalE[0]), tmCost);
                        print_f(rs->plogs, "P11", rs->logs);
                
                        fintvalE[0] = 0;
                    } else {
                        sprintf_f(rs->logs, "[DVF] TX interval should not be here !!! - 2\n");
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                }
                #endif
                
                if (wrtsz < 0) {
                    //usbentsTx = 0;
                    continue;
                }
                
                sprintf(rs->logs, "__USB_SEND CSW_[%.2x][%.2x][%.2x](Page_%d_size:%d_bytes)__", csw[10], csw[11], csw[12], pagecnt++, acusz); 
                tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);
                thrdatasize = acusz;
                
                /*
                thrtimeconsu = tmCost;
                thrtimeconsu = thrtimeconsu - thrtimebegin;
                throughput = thrdatasize / thrtimeconsu;
                sprintf_f(rs->logs, "__USB_TO_PC THROUGHPUT_(%.2lf / %.2lf = %.3lf_MB)__", thrdatasize, thrtimeconsu, throughput); 
                dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);
                */

                sprintf_f(rs->logs, "[DV] 0x12 cmd: 0x%.2x opc: 0x%.2x dump csw: \n", cmd, opc); 
                print_f(rs->plogs, "P11", rs->logs);

                shmem_dump(csw, wrtsz);
                
                cmd = 0;
                break;
            }
            else if (cmd == 0x13) { /* usbentsTx == 1*/

                if ((cswerr) && (cswerr != 0x21) && (cswerr != 0x22) && (cswerr != 0x23)) {
                    csw[11] = 0;
                    csw[12] = cswerr;
                }
                else if (waitCylen) {
                    csw[11] = waitCylen & 0xff;
                    csw[12] = 0;
                } else {
                    if (pagerst > 0) {
                        csw[11] = pagerst;
                        csw[12] = 0;
                    } else {
                        if (distCylcnt > maxCylcnt) {
                            sprintf_f(rs->logs, "[DV] no csw err and page rest == 0! dist: %d > max: %d \n", distCylcnt, maxCylcnt);
                            print_f(rs->plogs, "P11", rs->logs);
                            csw[11] = 1;
                            csw[12] = 0;
                        } else if (distCylcnt > 0) {
                            sprintf_f(rs->logs, "[DV] no csw err and page rest == 0! dist: %d > 0\n", distCylcnt);
                            print_f(rs->plogs, "P11", rs->logs);
                            csw[11] = 1;
                            csw[12] = 0;
                        } else { /* should not be here */
                            sprintf_f(rs->logs, "[DV] warnning!! no csw err and page rest == 0! dist: %d \n", distCylcnt);
                            print_f(rs->plogs, "P11", rs->logs);
                            csw[11] = 0;
                            csw[12] = 0;
                        }
                    }                        
                }

                wrtsz = 0;
                retry = 0;
                while (1) {
                    wrtsz = usbc_write(usbfd, csw, 13);

                    #if DBG_27_DV
                    sprintf_f(rs->logs, "[DV] usb TX size: %d \n====================\n", wrtsz);
                    print_f(rs->plogs, "P11", rs->logs);
                    #endif
                    
                    if (wrtsz > 0) {
                        break;
                    }
                    retry++;
                    if (retry > 32768) {
                        break;
                    }
                }

                #if DBG_USB_TIME_MEASURE
                if (!fintvalE[0]) {
                    clock_gettime(CLOCK_REALTIME, &intvalE[0]);
                    fintvalE[0] = 1;
                
                    if (fintvalE[1]) {
                
                        tmCost = time_diff(&intvalE[1], &intvalE[0], 1000);
                        sprintf_f(rs->logs, "[DV] TX interval end: %llu ms start: %llu ms diff: %d us - 1\n", time_get_ms(&intvalE[0]), time_get_ms(&intvalE[1]), tmCost);
                        print_f(rs->plogs, "P11", rs->logs);
                
                        fintvalE[1] = 0;
                    }
                    else {
                        sprintf_f(rs->logs, "[DVF] TX interval should not be here !!! - 1\n");
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                } else {
                
                    if (!fintvalE[1]) {
                        clock_gettime(CLOCK_REALTIME, &intvalE[1]);
                        fintvalE[1] = 1;
                
                        tmCost = time_diff(&intvalE[0], &intvalE[1], 1000);
                        sprintf_f(rs->logs, "[DV] TX interval end: %llu ms start: %llu ms diff: %d us - 2\n", time_get_ms(&intvalE[1]), time_get_ms(&intvalE[0]), tmCost);
                        print_f(rs->plogs, "P11", rs->logs);
                
                        fintvalE[0] = 0;
                    } else {
                        sprintf_f(rs->logs, "[DVF] TX interval should not be here !!! - 2\n");
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                }
                #endif
                
                if (wrtsz < 0) {
                    //usbentsTx = 0;
                    continue;
                }

                sprintf(rs->logs, "__USB_SEND CSW_[%.2x][%.2x][%.2x]__", csw[10], csw[11], csw[12]); 
                dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);

                rwaitCylen = waitCylen;
                
                sprintf_f(rs->logs, "[DV] 0x13 cmd: 0x%.2x opc: 0x%.2x dump csw: \n", cmd, opc); 
                print_f(rs->plogs, "P11", rs->logs);

                shmem_dump(csw, wrtsz);

                chn = csw[11];

                if (chn == 0) {
                    msgret[0] = 'x';
                    msgret[1] = 0x01;
                    pipRet = write(pipeTx[1], msgret, 2);
                    if (pipRet < 0) {
                        printf("[DV] Error!!! pipe send scan stop ret: %d \n", pipRet);
                    }
                    
                    sprintf(msgcmd, "usbidle");

                    ret = rs_ipc_get_ms(rcmd, rcmd->logs, 4096, 10);
                    if (ret > 0) {
                        rcmd->logs[ret] = '\n';

                        sprintf_f(rs->logs, "[DV]  get usbscan result ret: %d\n", ret);
                        print_f(rs->plogs, "P11", rs->logs);   

                        print_f(rcmd->plogs, "C11", rcmd->logs);
                    }
                    
                }

                #if 0
                while (1) {
                    chq = 0;
                    pipRet = read(pipeRx[0], &chq, 1);
                    if (pipRet <= 0) {
                        break;
                    }

                    sprintf_f(rs->logs, "[DV] p clean get: 0x%.2x \n", chq);
                    print_f(rs->plogs, "P11", rs->logs);
                }

                while (1) {
                    chd = 0;
                    pipRet = read(pipeRxd[0], &chd, 1);
                    if (pipRet <= 0) {
                        break;
                    }

                    sprintf_f(rs->logs, "[DV] s clean get: 0x%.2x \n", chd);
                    print_f(rs->plogs, "P11", rs->logs);
                }
                #endif

                cmd = 0;
                break;
            }
            else if (cmd == 0x14) { /* usbentsTx == 1*/

                if ((cswerr) && (cswerr != 0x21) && (cswerr != 0x22) && (cswerr != 0x23)) {
                    csw[11] = 0;
                    csw[12] = cswerr;
                }
                else if (waitCylen) {
                    csw[11] = waitCylen & 0xff;
                    csw[12] = 0;
                } else {
                    if (pagerst > 0) {
                        csw[11] = pagerst;
                        csw[12] = 0;
                    } else {
                        if (distCylcnt > maxCylcnt) {
                            sprintf_f(rs->logs, "[DV] pa no csw err and page rest == 0! dist: %d > max: %d \n", distCylcnt, maxCylcnt);
                            print_f(rs->plogs, "P11", rs->logs);
                            csw[11] = 1;
                            csw[12] = 0;
                        } else if (distCylcnt > 0) {
                            sprintf_f(rs->logs, "[DV] pa no csw err and page rest == 0! dist: %d > 0\n", distCylcnt);
                            print_f(rs->plogs, "P11", rs->logs);
                            csw[11] = 1;
                            csw[12] = 0;
                        } else { /* should not be here */
                            sprintf_f(rs->logs, "[DV] pa warnning!! no csw err and page rest == 0! dist: %d \n", distCylcnt);
                            print_f(rs->plogs, "P11", rs->logs);
                            csw[11] = 0;
                            csw[12] = 0;
                        }
                    }                        
                }

                wrtsz = 0;
                retry = 0;
                while (1) {
                    wrtsz = usbc_write(usbfd, csw, 13);

                    #if DBG_27_DV
                    sprintf_f(rs->logs, "[DV] usb TX size: %d \n====================\n", wrtsz);
                    print_f(rs->plogs, "P11", rs->logs);
                    #endif
                    
                    if (wrtsz > 0) {
                        break;
                    }
                    retry++;
                    if (retry > 32768) {
                        break;
                    }
                }

                #if DBG_USB_TIME_MEASURE
                if (!fintvalE[0]) {
                    clock_gettime(CLOCK_REALTIME, &intvalE[0]);
                    fintvalE[0] = 1;
                
                    if (fintvalE[1]) {
                
                        tmCost = time_diff(&intvalE[1], &intvalE[0], 1000);
                        sprintf_f(rs->logs, "[DV] TX interval end: %llu ms start: %llu ms diff: %d us - 1\n", time_get_ms(&intvalE[0]), time_get_ms(&intvalE[1]), tmCost);
                        print_f(rs->plogs, "P11", rs->logs);
                
                        fintvalE[1] = 0;
                    }
                    else {
                        sprintf_f(rs->logs, "[DVF] TX interval should not be here !!! - 1\n");
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                } else {
                
                    if (!fintvalE[1]) {
                        clock_gettime(CLOCK_REALTIME, &intvalE[1]);
                        fintvalE[1] = 1;
                
                        tmCost = time_diff(&intvalE[0], &intvalE[1], 1000);
                        sprintf_f(rs->logs, "[DV] TX interval end: %llu ms start: %llu ms diff: %d us - 2\n", time_get_ms(&intvalE[1]), time_get_ms(&intvalE[0]), tmCost);
                        print_f(rs->plogs, "P11", rs->logs);
                
                        fintvalE[0] = 0;
                    } else {
                        sprintf_f(rs->logs, "[DVF] TX interval should not be here !!! - 2\n");
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                }
                #endif
                
                if (wrtsz < 0) {
                    //usbentsTx = 0;
                    continue;
                }

                sprintf(rs->logs, "__USB_SEND CSW_[%.2x][%.2x][%.2x]__", csw[10], csw[11], csw[12]); 
                dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);

                rwaitCylen = waitCylen;
                
                sprintf_f(rs->logs, "[DV] 0x14 cmd: 0x%.2x opc: 0x%.2x dump csw: \n", cmd, opc); 
                print_f(rs->plogs, "P11", rs->logs);

                shmem_dump(csw, wrtsz);

                chn = csw[11];
                    
                cmd = 0;
                break;
            }
            else if (cmd == 0x15) { /* usbentsTx == 1*/
                csw[11] = 0;
                csw[12] = 0;//seqtx;

                wrtsz = 0;
                retry = 0;
                while (1) {
                    wrtsz = usbc_write(usbfd, csw, 13);

                    #if DBG_27_DV
                    sprintf_f(rs->logs, "[DV] usb TX size: %d \n====================\n", wrtsz); 
                    print_f(rs->plogs, "P11", rs->logs);
                    #endif
                    
                    if (wrtsz > 0) {
                        break;
                    }
                    retry++;
                    if (retry > 32768) {
                        break;
                    }
                }

                #if DBG_USB_TIME_MEASURE
                if (!fintvalE[0]) {
                    clock_gettime(CLOCK_REALTIME, &intvalE[0]);
                    fintvalE[0] = 1;
                
                    if (fintvalE[1]) {
                
                        tmCost = time_diff(&intvalE[1], &intvalE[0], 1000);
                        sprintf_f(rs->logs, "[DV] TX interval end: %llu ms start: %llu ms diff: %d us - 1\n", time_get_ms(&intvalE[0]), time_get_ms(&intvalE[1]), tmCost);
                        print_f(rs->plogs, "P11", rs->logs);
                
                        fintvalE[1] = 0;
                    }
                    else {
                        sprintf_f(rs->logs, "[DVF] TX interval should not be here !!! - 1\n");
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                } else {
                
                    if (!fintvalE[1]) {
                        clock_gettime(CLOCK_REALTIME, &intvalE[1]);
                        fintvalE[1] = 1;
                
                        tmCost = time_diff(&intvalE[0], &intvalE[1], 1000);
                        sprintf_f(rs->logs, "[DV] TX interval end: %llu ms start: %llu ms diff: %d us - 2\n", time_get_ms(&intvalE[1]), time_get_ms(&intvalE[0]), tmCost);
                        print_f(rs->plogs, "P11", rs->logs);
                
                        fintvalE[0] = 0;
                    } else {
                        sprintf_f(rs->logs, "[DVF] TX interval should not be here !!! - 2\n");
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                }
                #endif
                
                if (wrtsz < 0) {
                    //usbentsTx = 0;
                    continue;
                }

                sprintf(rs->logs, "__USB_SEND CSW_[%.2x][%.2x][%.2x]__", csw[10], csw[11], csw[12]); 
                dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);

                sprintf_f(rs->logs, "[DV] 0x15 cmd: 0x%.2x opc: 0x%.2x dump csw: \n", cmd, opc); 
                print_f(rs->plogs, "P11", rs->logs);
                shmem_dump(csw, wrtsz);
                
                cmd = 0;
                break;
            }
            else if ((cmd == OP_WRITE_FILE) && (opc == 0xff) && (dat == 0)) { /* usbentsTx == 1*/
                sprintf_f(rs->logs, "[DV] usbentsTx 0x0b cmd: 0x%.2x opc: 0x%.2x dat: 0x%.2x \n", cmd, opc, dat); 
                print_f(rs->plogs, "P11", rs->logs);
                act = ucbwfile->ASIC_sel;
                
                chy = 0;
                ret = rs_ipc_get_ms(rs, &chy, 1, 10);
                while (ret < 0) {
                    sprintf_f(rs->logs, "[DVB] write file response: 0x%.2x ret: %d \n", chy, ret);
                    print_f(rs->plogs, "P11", rs->logs);

                    ret = rs_ipc_get_ms(rs, &chy, 1, 10);
                }

                if (chy == 'w') {
                    ret = rs_ipc_get_ms(rs, msgret, 4, 10);
                    while (ret < 0) {
                        
                        sprintf_f(rs->logs, "[DVB] write file lengh ret: %d \n", ret);
                        print_f(rs->plogs, "P11", rs->logs);

                        ret = rs_ipc_get_ms(rs, msgret, 4, 10);
                    }
                    
                    filesz = msb2lsb32(&ucbwfile->pramDataLength);

                    if (ret == 4) {
                        recvsz = msgret[3];
                        recvsz |= msgret[2] << 8;
                        recvsz |= msgret[1] << 16;
                        recvsz |= msgret[0] << 24;
                        sprintf_f(rs->logs, "[DVB] write file lengh: %d (%d)\n", recvsz, filesz);
                        print_f(rs->plogs, "P11", rs->logs);

                        if (pubfidnxt) {
                            if (pubfidnxt->usfdsize != recvsz) {
                                pubfidnxt->usfdsize = 0;
                            }

                            ret = fileid_save(fileidpoll, pubf);
                            if(!ret) {
                                sprintf_f(rs->logs, "[DVB] fileid write file succeed ret: %d\n", ret);
                                print_f(rs->plogs, "P11", rs->logs);
                            } else {
                                sprintf_f(rs->logs, "[DVB] Error!! fileid write file failed!!! ret: %d\n", ret);
                                print_f(rs->plogs, "P11", rs->logs);
                            }

                            
                            pubfidnxt = 0;
                            
                            #if 0
                            pubfidc = pubf->usfacPt;
                            val = sizeof(struct usbFileidContent_s);
                            lens = lens / val;
                            for(ix=0; ix < lens; ix++) {
                                getents = pubfidc[ix].usfdid[0] | (pubfidc[ix].usfdid[1] << 8);

                                sprintf_f(rs->logs, "    [%d] %d %c %d, addr: 0x%x size: %d \n", ix, getents, pubfidc[ix].usfdid[2], 
                                                pubfidc[ix].usfdid[3], pubfidc[ix].usfdAddr, pubfidc[ix].usfdsize);
                                print_f(rs->plogs, "P11", rs->logs);                                
                            }
                            #endif  
                        }
                    } else {
                        sprintf_f(rs->logs, "[DVB] error!!! write file lengh ret: %d != 4\n", ret);
                        print_f(rs->plogs, "P11", rs->logs);
                    }

                    pubf->usfacPt = 0;

                    memcpy(&csw[4], &iubsBuff[4], 4);
                    
                    csw[8] = msgret[0];                    
                    csw[9] = msgret[1];
                    csw[10] = msgret[2];
                    csw[11] = msgret[3];
                    
                    csw[12] = 0;//seqtx;

                    wrtsz = 0;
                    retry = 0;
                    while (1) {
                        wrtsz = usbc_write(usbfd, csw, 13);

                        #if DBG_27_DV
                        sprintf_f(rs->logs, "[DV] usb TX size: %d \n====================\n", wrtsz); 
                        print_f(rs->plogs, "P11", rs->logs);
                        #endif
                    
                        if (wrtsz > 0) {
                            break;
                        }
                        retry++;
                        if (retry > 32768) {
                            break;
                        }
                    }

                    #if DBG_USB_TIME_MEASURE
                    if (!fintvalE[0]) {
                        clock_gettime(CLOCK_REALTIME, &intvalE[0]);
                        fintvalE[0] = 1;
                
                        if (fintvalE[1]) {
                
                            tmCost = time_diff(&intvalE[1], &intvalE[0], 1000);
                            sprintf_f(rs->logs, "[DV] TX interval end: %llu ms start: %llu ms diff: %d us - 1\n", time_get_ms(&intvalE[0]), time_get_ms(&intvalE[1]), tmCost);
                            print_f(rs->plogs, "P11", rs->logs);
                
                            fintvalE[1] = 0;
                        }
                        else {
                            sprintf_f(rs->logs, "[DVF] TX interval should not be here !!! - 1\n");
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                    } else {
                
                        if (!fintvalE[1]) {
                            clock_gettime(CLOCK_REALTIME, &intvalE[1]);
                            fintvalE[1] = 1;
                
                            tmCost = time_diff(&intvalE[0], &intvalE[1], 1000);
                            sprintf_f(rs->logs, "[DV] TX interval end: %llu ms start: %llu ms diff: %d us - 2\n", time_get_ms(&intvalE[1]), time_get_ms(&intvalE[0]), tmCost);
                            print_f(rs->plogs, "P11", rs->logs);
                
                            fintvalE[0] = 0;
                        } else {
                            sprintf_f(rs->logs, "[DVF] TX interval should not be here !!! - 2\n");
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                    }
                    #endif
                
                    if (wrtsz < 0) {
                        //usbentsTx = 0;
                        sprintf_f(rs->logs, "[DV] Error!!! send csw failed for 0x0b cmd: 0x%.2x opc: 0x%.2x dump csw: \n", cmd, opc); 
                        print_f(rs->plogs, "P11", rs->logs);

                        continue;
                    }

                    sprintf(rs->logs, "__USB_SEND CSW_[%.2x][%.2x][%.2x]__", csw[10], csw[11], csw[12]); 
                    dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);

                    sprintf_f(rs->logs, "[DV] 0x0b cmd: 0x%.2x opc: 0x%.2x dump csw: \n", cmd, opc); 
                    print_f(rs->plogs, "P11", rs->logs);
                    shmem_dump(csw, wrtsz);

                    csw[8] = 0;
                    csw[9] = 0;
                    csw[10] = 0;
                    csw[11] = 0;
                    
                    cmd = 0;
                    opc = 0;
                    break;
                }
                else {
                    sprintf_f(rs->logs, "[DV] Error!!! 0x0b get write file result ch: %c cmd: 0x%.2x opc: 0x%.2x\n", chy, cmd, opc); 
                    print_f(rs->plogs, "P11", rs->logs);
                }
            }
            else if ((cmd == OP_WRITE_FILE) && (opc == 0xff) && (dat == 0xff)) { /* usbentsTx == 1*/
                lenflh = (ucbwfile->pramFileId[0] << 8) | ucbwfile->pramFileId[1];
                act = ucbwfile->ASIC_sel;
                recvsz = 0;
                
                sprintf_f(rs->logs, "[DVB] 0x0b send fileid back, fileid: %d, select: %d\n", lenflh, act);
                print_f(rs->plogs, "P11", rs->logs);
                
                rs_ipc_put(rs, "i", 1);
                
                chy = 0;
                ret = rs_ipc_get_ms(rs, &chy, 1, 10);
                while (ret < 0) {
                    sprintf_f(rs->logs, "[DVB] write file response: 0x%.2x ret: %d \n", chy, ret);
                    print_f(rs->plogs, "P11", rs->logs);

                    ret = rs_ipc_get_ms(rs, &chy, 1, 10);
                }

                if (chy == 'r') {
                    ret = rs_ipc_get_ms(rs, msgret, 4, 10);
                    while (ret < 0) {
                        
                        sprintf_f(rs->logs, "[DVB] read file lengh ret: %d \n", ret);
                        print_f(rs->plogs, "P11", rs->logs);

                        ret = rs_ipc_get_ms(rs, msgret, 4, 10);
                    }
                    
                    //filesz = msb2lsb32(&ucbwfile->pramDataLength);

                    if (ret == 4) {
                        recvsz = msgret[3];
                        recvsz |= msgret[2] << 8;
                        recvsz |= msgret[1] << 16;
                        recvsz |= msgret[0] << 24;

                        sprintf_f(rs->logs, "[DVB] read file lengh: %d (%d)\n", recvsz, filesz);
                        print_f(rs->plogs, "P11", rs->logs);

                        if (pubfidnxt) {
                            if ((pubfidnxt->usfdsize != recvsz) || (filesz != recvsz)) {
                                pubfidnxt->usfdsize = 0;
                                pubfidnxt = 0;
                            }
                        }
                    }
                    else {
                        sprintf_f(rs->logs, "[DVB] error!!! read file lengh ret: %d != 4\n", ret);
                        print_f(rs->plogs, "P11", rs->logs);
                    }

                    memcpy(&csw[4], &iubsBuff[4], 4);
                    
                    csw[8] = msgret[0];                    
                    csw[9] = msgret[1];
                    csw[10] = msgret[2];
                    csw[11] = msgret[3];
                    
                    csw[12] = 0;//seqtx;

                }

                if ((recvsz) && (pubfidnxt)) {

                    memset(msgret, 0, 64);
                    //pubf->usfacPt = 0;
                    loopcnt = 0;
                    filesz = pubfidnxt->usfdsize;
                    
                    while (filesz) {
                        lenrs = ring_buf_cons(rs->pcmdRx, &addrs);
                        while (lenrs <= 0) {
                            sprintf_f(rs->logs, "[DVB] get rbuf failed ret: %d \n", lenrs);
                            print_f(rs->plogs, "P11", rs->logs);
                    
                            usleep(1000);
                            lenrs = ring_buf_cons(rs->pcmdRx, &addrs);
                        }
                    
                        filesz -= lenrs;
                    
                        if (loopcnt == 0) {
                            memcpy(msgret, addrs, 4);
                        }

                        #if LOG_P11_EN
                        sprintf_f(rs->logs, "[DVB] %d. 0x0b rusb send %d remain: %d\n", loopcnt, lenrs, filesz);
                        print_f(rs->plogs, "P11", rs->logs);
                        #endif
                        
                        loopcnt ++;
                        
                        errcnt = 0;
                        while (lenrs) {
                            wrtsz = usbc_write(usbfd, addrs, lenrs);
                            if (wrtsz <= 0) {
                                errcnt++;
                    
                                if (errcnt > 100) {
                                    break;
                                }
                                usleep(1000);
                                continue;
                            }
                    
                            lenrs -= wrtsz;
                            addrs += wrtsz;
                        }
                    }
                    
                    if (filesz) {
                        csw[12] = 0x40;//seqtx;
                    }
                    else if ((lenflh == 1) || (lenflh == 2) || (lenflh == 3) || (lenflh == 4)) {
                        err = memcmp(msgret, elfhead, 4);
                        if (!err) {
                            csw[12] = 0;
                            
                            sprintf(syscmd11, "/root/scaner/id_%.5d.bin", lenflh);
                            fdrd = fopen(syscmd11, "r");

                            if (fdrd) {
                                ret = fseek(fdrd, 0, SEEK_END);
                                if (ret) {
                                    sprintf_f(rs->logs, " file seek failed!! ret:%d \n", ret);
                                    print_f(rs->plogs, "P11", rs->logs);

                                    fclose(fdrd);
                                    fdrd = 0;
                                }
                            }

                            if (fdrd) {
                                filesz = ftell(fdrd);
                                sprintf_f(rs->logs, " file [%s] size: %d expect: %d\n", syscmd11, filesz, recvsz);
                                print_f(rs->plogs, "P11", rs->logs);

                                ret = fseek(fdrd, 0, SEEK_SET);
                                if (ret) {
                                    sprintf_f(rs->logs, " file seek failed!! ret:%d \n", ret);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    
                                    fclose(fdrd);
                                    fdrd = 0;
                                }
                            }
                            
                            if (fdrd) {
                                memset(msgret, 0, 64);
                                if (filesz == recvsz) {
                                    lens = fread(msgret, 1, 4, fdrd);
                                    if (lens == 4) {
                                        ret = memcmp(msgret, elfhead, 4);
                                        if (ret) {
                                            csw[12] = lenflh;
                                        }
                                    }
                                    else {
                                        csw[12] = lenflh;
                                    }
                                } else {
                                    csw[12] = lenflh;
                                }

                                fclose(fdrd);
                                fdrd = 0;
                            }
                            else {
                                csw[12] = lenflh;
                            }

                            if (!csw[12]) {
                                switch (lenflh) {
                                case 1:
                                    sprintf(syscmd11, "cp /root/scaner/id_00001.bin /root/MSP_rel.bin");
                                    ret = doSystemCmd(syscmd11);
                                    
                                    sprintf(syscmd11, "chmod 777 /root/MSP_rel.bin");
                                    ret = doSystemCmd(syscmd11);
                                    break;
                                case 2:
                                    sprintf(syscmd11, "cp /lib/modules/4.4.68/kernel/drivers/usb/class/usblp.ko /lib/modules/4.4.68/kernel/drivers/usb/class/usblp_old.ko");
                                    ret = doSystemCmd(syscmd11);
                                    
                                    sprintf(syscmd11, "cp /root/scaner/id_00002.bin /lib/modules/4.4.68/kernel/drivers/usb/class/usblp.ko");
                                    ret = doSystemCmd(syscmd11);
                                    break;
                                case 3:
                                    sprintf(syscmd11, "cp /lib/modules/4.4.68/kernel/drivers/usb/gadget/legacy/g_printer.ko /lib/modules/4.4.68/kernel/drivers/usb/gadget/legacy/g_printer_old.ko");
                                    ret = doSystemCmd(syscmd11);
                                    
                                    sprintf(syscmd11, "cp /root/scaner/id_00003.bin /lib/modules/4.4.68/kernel/drivers/usb/gadget/legacy/g_printer.ko");
                                    ret = doSystemCmd(syscmd11);
                                    break;
                                case 4:
                                    sprintf(syscmd11, "cp /lib/modules/4.4.68/kernel/drivers/usb/gadget/function/usb_f_printer.ko /lib/modules/4.4.68/kernel/drivers/usb/gadget/function/usb_f_printer_old.ko");
                                    ret = doSystemCmd(syscmd11);
                                    
                                    sprintf(syscmd11, "cp /root/scaner/id_00004.bin /lib/modules/4.4.68/kernel/drivers/usb/gadget/function/usb_f_printer.ko");
                                    ret = doSystemCmd(syscmd11);
                                    break;
                                default:
                                    sprintf_f(rs->logs, "[DVB] error!!! not such id: %d\n", lenflh);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    break;
                                }

                                sync();
                                sync();
                                sync();
                            }
                        }
                        else {
                            csw[12] = lenflh;
                        }
                    }

                    if (csw[12] == 0) {
                        ret = fileid_save(fileidpoll, pubf);
                        if(!ret) {
                            sprintf_f(rs->logs, "[DVB] fileid write file succeed ret: %d\n", ret);
                            print_f(rs->plogs, "P11", rs->logs);
                        } else {
                            sprintf_f(rs->logs, "[DVB] Error!! fileid write file failed!!! ret: %d\n", ret);
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                        
                        #if 0
                        pubfidc = pubf->usfacPt;
                        lens = pubf->usfacLength;
                        val = sizeof(struct usbFileidContent_s);
                        lens = lens / val;
                        for(ix=0; ix < lens; ix++) {
                            getents = pubfidc[ix].usfdid[0] | (pubfidc[ix].usfdid[1] << 8);

                            sprintf_f(rs->logs, "    [%d] %d %c %d, addr: 0x%x size: %d \n", ix, getents, pubfidc[ix].usfdid[2], 
                                            pubfidc[ix].usfdid[3], pubfidc[ix].usfdAddr, pubfidc[ix].usfdsize);
                            print_f(rs->plogs, "P11", rs->logs);                                
                        }
                        #endif
                    }
                }
                else {
                    
                    csw[8] = 0;
                    csw[9] = 0;
                    csw[10] = 0;
                    csw[11] = 0;
                    csw[12] = CSW_STATUS_USB_FAIL;
                }
                
                pubfidnxt = 0;
                pubf->usfacPt = 0;
                
                wrtsz = 0;
                retry = 0;
                while (1) {
                    wrtsz = usbc_write(usbfd, csw, 13);

                    #if DBG_27_DV
                    sprintf_f(rs->logs, "[DV] usb TX size: %d \n====================\n", wrtsz); 
                    print_f(rs->plogs, "P11", rs->logs);
                    #endif
                    
                    if (wrtsz > 0) {
                        break;
                    }
                    retry++;
                    if (retry > 32768) {
                        break;
                    }
                }

                #if DBG_USB_TIME_MEASURE
                if (!fintvalE[0]) {
                    clock_gettime(CLOCK_REALTIME, &intvalE[0]);
                    fintvalE[0] = 1;
                
                    if (fintvalE[1]) {
                
                        tmCost = time_diff(&intvalE[1], &intvalE[0], 1000);
                        sprintf_f(rs->logs, "[DV] TX interval end: %llu ms start: %llu ms diff: %d us - 1\n", time_get_ms(&intvalE[0]), time_get_ms(&intvalE[1]), tmCost);
                        print_f(rs->plogs, "P11", rs->logs);
                
                        fintvalE[1] = 0;
                    }
                    else {
                        sprintf_f(rs->logs, "[DVF] TX interval should not be here !!! - 1\n");
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                } else {
                
                    if (!fintvalE[1]) {
                        clock_gettime(CLOCK_REALTIME, &intvalE[1]);
                        fintvalE[1] = 1;
                
                        tmCost = time_diff(&intvalE[0], &intvalE[1], 1000);
                        sprintf_f(rs->logs, "[DV] TX interval end: %llu ms start: %llu ms diff: %d us - 2\n", time_get_ms(&intvalE[1]), time_get_ms(&intvalE[0]), tmCost);
                        print_f(rs->plogs, "P11", rs->logs);
                
                        fintvalE[0] = 0;
                    } else {
                        sprintf_f(rs->logs, "[DVF] TX interval should not be here !!! - 2\n");
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                }
                #endif
                
                if (wrtsz < 0) {
                    //usbentsTx = 0;
                    sprintf_f(rs->logs, "[DV] Error!!! send csw failed for 0x0b rcmd: 0x%.2x opc: 0x%.2x dump csw: \n", cmd, opc); 
                    print_f(rs->plogs, "P11", rs->logs);

                    continue;
                }

                sprintf(rs->logs, "__USB_SEND CSW_[%.2x][%.2x][%.2x]__", csw[10], csw[11], csw[12]); 
                dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);

                sprintf_f(rs->logs, "[DV] 0x0b rcmd: 0x%.2x opc: 0x%.2x dump csw: \n", cmd, opc); 
                print_f(rs->plogs, "P11", rs->logs);
                shmem_dump(csw, wrtsz);

                csw[8] = 0;
                csw[9] = 0;
                csw[10] = 0;
                csw[11] = 0;
                    
                msgret[0] = 'x';
                msgret[1] = 0x01;
                pipRet = write(pipeTx[1], msgret, 2);
                if (pipRet < 0) {
                    printf("[DV] Error!!! pipe send scan stop ret: %d \n", pipRet);
                }
                
                sprintf(msgcmd, "usbidle");
                
                ret = rs_ipc_get_ms(rcmd, rcmd->logs, 4096, 10);
                if (ret > 0) {
                    rcmd->logs[ret] = '\n';

                    sprintf_f(rs->logs, "[DV]  get usbscan result ret: %d\n", ret);
                    print_f(rs->plogs, "P11", rs->logs);   

                    print_f(rcmd->plogs, "C11", rcmd->logs);
                }
                
                cmd = 0;
                dat = 0;
                opc = 0;
                break;
            }
            else if ((cmd == OP_WRITE_FILE) && (opc == 0) && (dat == 0xff)) { /* usbentsTx == 1*/
                sprintf_f(rs->logs, "[DV] wait erase \n");
                print_f(rs->plogs, "P11", rs->logs);

                memcpy(csw, cswDefault, 16);

                if (pubfidnxt) {
                    val = ucbwfile->pramWrtorRd[0];
                    act = ucbwfile->ASIC_sel;
                    
                    sprintf_f(rs->logs, "[DV] wteras data length: %d, sel: %d, wr: %d \n", lenflh, act, val);
                    print_f(rs->plogs, "P11", rs->logs);
                    
                    chq = 0;
                    chd = 0;
                    
                    switch (val) {
                    case 3: // wrt
                        if (!act) {
                            //if (usbid01) {
                                while (1) {
                                    chq = 0;
                                    pipRet = read(pipeRx[0], &chq, 1);
                                    if (pipRet > 0) {
                                        break;
                                    }
                                }
                    
                                if (chq == 'H') {
                                    while (1) {
                                        pipRet = read(pipeRx[0], msgret, 4);
                                        if (pipRet > 0) {
                                            break;
                                        }
                                    }
                                    
                                    recvsz = 0;
                                    if (pipRet == 4) {
                                        recvsz = msgret[3];
                                        recvsz |= msgret[2] << 8;
                                        recvsz |= msgret[1] << 16;
                                        recvsz |= msgret[0] << 24;
                                    }
                                    
                                    sprintf_f(rs->logs, "[DV] polld ch: %c, file length: %d ret: %d\n", chq, recvsz, pipRet);
                                    print_f(rs->plogs, "P11", rs->logs);    
                                } 
                                else if ((chq == 'X') || (chq == 'U')) {
                                    chn = 0;
                                    while (1) {
                                        pipRet = read(pipeRx[0], &chn, 4);
                                        if (pipRet > 0) {
                                            break;
                                        }
                                    }
                                    
                                    sprintf_f(rs->logs, "[DV] polld get ch: %c status 0x%.2x \n", chq, chn);
                                    print_f(rs->plogs, "P11", rs->logs);    
                    
                                    memcpy(&csw[4], &iubsBuff[4], 4);
                    
                                    csw[8] = msgret[0];                    
                                    csw[9] = msgret[1];
                                    csw[10] = msgret[2];
                                    csw[11] = msgret[3];
                    
                                    csw[12] = chn;
                                }
                                else {
                                    sprintf_f(rs->logs, "[DV] error!!! polld ch : %c unexpected!! \n", chq);
                                    print_f(rs->plogs, "P11", rs->logs);    
                                }
                            //}
                        }
                        else {
                            //if (usbid02) {
                                while (1) {
                                    chd = 0;
                                    pipRet = read(pipeRxd[0], &chd, 1);
                                    if (pipRet > 0) {
                                        break;
                                    }
                                }
                                
                                if (chd == 'H') {
                                    while (1) {
                                        pipRet = read(pipeRxd[0], msgret, 4);
                                        if (pipRet > 0) {
                                            break;
                                        }
                                    }
                                    
                                    recvsz = 0;
                                    if (pipRet == 4) {
                                        recvsz = msgret[3];
                                        recvsz |= msgret[2] << 8;
                                        recvsz |= msgret[1] << 16;
                                        recvsz |= msgret[0] << 24;
                                    }
                                    
                                    sprintf_f(rs->logs, "[DV] polld ch: %c, file length: %d ret: %d \n", chd, recvsz, pipRet);
                                    print_f(rs->plogs, "P11", rs->logs);    
                                }
                                else if ((chd == 'X') || (chd == 'U')) {
                                    chm = 0;
                                    while (1) {
                                        pipRet = read(pipeRxd[0], &chm, 4);
                                        if (pipRet > 0) {
                                            break;
                                        }
                                    }
                                    
                                    sprintf_f(rs->logs, "[DV] polld get ch: %c status 0x%.2x \n", chd, chm);
                                    print_f(rs->plogs, "P11", rs->logs);    
                    
                                    memcpy(&csw[4], &iubsBuff[4], 4);
                    
                                    csw[8] = msgret[0];                    
                                    csw[9] = msgret[1];
                                    csw[10] = msgret[2];
                                    csw[11] = msgret[3];
                    
                                    csw[12] = chm;
                                }
                                else {
                                    sprintf_f(rs->logs, "[DV] error!!! polld ch : %c unexpected!! \n", chd);
                                    print_f(rs->plogs, "P11", rs->logs);    
                                }
                                
                            //}
                        }
                        break;
                    case 4: // rd
                        sprintf_f(rs->logs, "[DV] error!!! not support read trigger !!\n");
                        print_f(rs->plogs, "P11", rs->logs);    
                        break;
                    default:
                        sprintf_f(rs->logs, "[DV] error!!! unknown trigger val: %d !!\n", val);
                        print_f(rs->plogs, "P11", rs->logs);    
                        break;
                    }
                    
                    if ((chq == 'X') || (chd == 'X') || (chq == 'U') || (chd == 'U')) {
                        pubfidnxt->usfdsize = 0;

                        sprintf_f(rs->logs, "[DVB] 0x0b find next fileid for writting \n");
                        print_f(rs->plogs, "P11", rs->logs);
                        pubfidnxt = 0;
                    
                        if (pubf->usfacPt == 0) {
                            sprintf_f(rs->logs, "[DVB] Error !!! 0x0b find next fileid usfacPt is null \n");
                            print_f(rs->plogs, "P11", rs->logs);
                            break;
                        }

                        pubfidc = pubf->usfacPt;
                        lenbs = sizeof(struct usbFileidContent_s);
                        lens = pubf->usfacLength / lenbs;
                        act = ucbwfile->ASIC_sel;

                        sprintf_f(rs->logs, "[DVB] fileid len: %d, sizeof: %d, num: %d \n", pubf->usfacLength, lenbs, lens);
                        print_f(rs->plogs, "P11", rs->logs);
                            

                        for(ix=0; ix < lens; ix++) {
                            getents = pubfidc->usfdid[0] | (pubfidc->usfdid[1] << 8);

                            #if 0
                            sprintf_f(rs->logs, "    srhwrt - [%d] %d %c %d, addr: 0x%x size: %d select: %d\n", ix, getents, pubfidc->usfdid[2], 
                                           pubfidc->usfdid[3], pubfidc->usfdAddr, pubfidc->usfdsize, act);
                            print_f(rs->plogs, "P11", rs->logs);                                
                            #endif

                            if ((pubfidc->usfdsize != 0) && (pubfidc->usfdid[3] == act)) {
                                pubfidnxt = pubfidc;
                                break;
                            }
                            pubfidc++;
                        }

                        if (pubfidnxt == 0) {
                            pubf->usfacPt = 0;
                            continue;
                        }
                    
                        if (!act) {
                            //if (usbid01) {
                                endTran[0] = 'j';
                                endTran[1] = pubfidnxt->usfdid[1];
                                endTran[2] = pubfidnxt->usfdid[0];
                                endTran[3] = pubfidnxt->usfdAddr & 0xff;
                                endTran[4] = (pubfidnxt->usfdAddr >> 8) & 0xff;;
                                endTran[5] = (pubfidnxt->usfdAddr >> 16) & 0xff;;
                                endTran[6] = (pubfidnxt->usfdAddr >> 24) & 0xff;;

                                pipRet = write(pipeTx[1], endTran, 7);
                                if (pipRet < 0) {
                                    sprintf_f(rs->logs, "[DV] send erase section ret: %d \n", pipRet);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    continue;
                                }
                            //}
                        } else {
                            //if (usbid02) {
                                endTran[0] = 'j';
                                endTran[1] = pubfidnxt->usfdid[1];
                                endTran[2] = pubfidnxt->usfdid[0];
                                endTran[3] = pubfidnxt->usfdAddr & 0xff;
                                endTran[4] = (pubfidnxt->usfdAddr >> 8) & 0xff;;
                                endTran[5] = (pubfidnxt->usfdAddr >> 16) & 0xff;;
                                endTran[6] = (pubfidnxt->usfdAddr >> 24) & 0xff;;

                                pipRet = write(pipeTxd[1], endTran, 7);
                                if (pipRet < 0) {
                                    sprintf_f(rs->logs, "[DV] send erase section ret: %d \n", pipRet);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    continue;
                                }
                            //}
                        }
                    }
                } 
                else {
                    pubf->usfacPt = 0;
                    
                    csw[8] = 0;
                    csw[9] = 0;
                    csw[10] = 0;
                    csw[11] = 0;
                    
                    csw[12] = 0;

                    wrtsz = 0;
                    retry = 0;
                    while (1) {
                        wrtsz = usbc_write(usbfd, csw, 13);
                    
                        #if DBG_27_DV
                        sprintf_f(rs->logs, "[DV] usb TX size: %d \n====================\n", wrtsz); 
                        print_f(rs->plogs, "P11", rs->logs);
                        #endif
                    
                        if (wrtsz > 0) {
                            break;
                        }
                        retry++;
                        if (retry > 32768) {
                            break;
                        }
                    }

                    sprintf(rs->logs, "__USB_SEND CSW_[%.2x][%.2x][%.2x]__", csw[10], csw[11], csw[12]); 
                    dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);

                    sprintf_f(rs->logs, "[DV] 0x0b rcmd: 0x%.2x opc: 0x%.2x dat: 0x%.2x dump csw: \n", cmd, opc, dat); 
                    print_f(rs->plogs, "P11", rs->logs);
                    shmem_dump(csw, wrtsz);

                    #if 1
                    if (strcmp(msgcmd, "usbscan") == 0) {
                        //chq = 'x';
                        msgret[0] = 'x';
                        msgret[1] = 0x01;
                        pipRet = write(pipeTx[1], msgret, 2);
                        if (pipRet < 0) {
                            printf("[DV] Error!!! pipe send scan stop ret: %d \n", pipRet);
                        }

                        sprintf(msgcmd, "usbidle");

                        ret = rs_ipc_get_ms(rcmd, rcmd->logs, 4096, 10);
                        if (ret > 0) {
                            rcmd->logs[ret] = '\n';

                            sprintf_f(rs->logs, "[DV]  get usbscan result ret: %d\n", ret);
                            print_f(rs->plogs, "P11", rs->logs);   

                            print_f(rcmd->plogs, "C11", rcmd->logs);
                        }
                    }
                    #endif
                    
                    cmd = 0;
                    dat = 0;
                    opc = 0;
                    break;
                }
            }
            else if ((cmd == OP_WRITE_FILE) && (opc == 5) && (dat == 0xff)) { /* usbentsTx == 1*/
                sync();
                sync();
                sync();
                
                csw[12] = 0;
                wrtsz = 0;
                retry = 0;
                while (1) {
                    wrtsz = usbc_write(usbfd, csw, 13);
                    
                    #if DBG_27_DV
                    sprintf_f(rs->logs, "[DV] usb TX size: %d \n====================\n", wrtsz); 
                    print_f(rs->plogs, "P11", rs->logs);
                    #endif
                    
                    if (wrtsz > 0) {
                        break;
                    }
                    retry++;
                    if (retry > 32768) {
                        break;
                    }
                }

                sprintf(rs->logs, "__USB_SEND CSW_[%.2x][%.2x][%.2x]__", csw[10], csw[11], csw[12]); 
                dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);

                sprintf_f(rs->logs, "[DV] 0x0b clear cmd: 0x%.2x opc: 0x%.2x dat: 0x%.2x dump csw: \n", cmd, opc, dat); 
                print_f(rs->plogs, "P11", rs->logs);
                shmem_dump(csw, wrtsz);
                    
                cmd = 0;
                dat = 0;
                opc = 0;
                break;
            }
            else if ((cmd == OP_WRITE_FILE) && (opc == 6) && (dat == 0xff)) { /* usbentsTx == 1*/
                act = ucbwfile->ASIC_sel;
                
                sprintf_f(rs->logs, "[DV] wait reset to rom select: %d\n", act);
                print_f(rs->plogs, "P11", rs->logs);

                //if (act == 0) {
                    while (1) {
                        chq = 0;
                        pipRet = read(pipeRx[0], &chq, 1);
                        if (pipRet > 0) {
                            break;
                        }
                    }

                    if (chq == 'J') {
                        while (1) {
                            pipRet = read(pipeRx[0], msgret, 1);
                            if (pipRet > 0) {
                                break;
                            }
                        }
                        
                        chn = 0;
                        if (pipRet > 0) {
                            chn = msgret[0];
                        }
                        
                        sprintf_f(rs->logs, "[DV] rom rest polld ch: %c, result: %d ret: %d\n", chq, chn, pipRet);
                        print_f(rs->plogs, "P11", rs->logs);    
                    } 
                    else {
                        sprintf_f(rs->logs, "[DV] error!!! polld ch : %c unexpected!! \n", chq);
                        print_f(rs->plogs, "P11", rs->logs);    
                    }
                //}
                //else {
                    while (1) {
                        chd = 0;
                        pipRet = read(pipeRxd[0], &chd, 1);
                        if (pipRet > 0) {
                            break;
                        }
                    }
                    
                    if (chd == 'J') {
                        while (1) {
                            pipRet = read(pipeRxd[0], msgret, 1);
                            if (pipRet > 0) {
                                break;
                            }
                        }
                        
                        chm = 0;
                        if (pipRet > 0) {
                            chm = msgret[0];
                        }
                        
                        sprintf_f(rs->logs, "[DV] rom sec reset polld ch: %c, result: %d ret: %d \n", chd, chm, pipRet);
                        print_f(rs->plogs, "P11", rs->logs);    
                    }
                    else {
                        sprintf_f(rs->logs, "[DV] error!!! polld ch : %c unexpected!! \n", chd);
                        print_f(rs->plogs, "P11", rs->logs);    
                    } 
                //}

                if (act == 0) {
                    if (chn == 0xa1) {
                        csw[12] = 0;
                    } else {
                        csw[12] = 1; 
                    }
                } else {
                    if (chm == 0xa1) {
                        csw[12] = 0;
                    } else {
                        csw[12] = 1; 
                    }
                }

                sprintf_f(rs->logs, "[DV] rom csw[12]: %d, act: %d, n: 0x%.2x, m:0x%.2x - 1\n", csw[12], act, chn, chm);
                print_f(rs->plogs, "P11", rs->logs);

                while (csw[12]) {

                    ret = doSystemCmd(syscmd11);

                    changename = pinfushostd->ushostname;
                    pinfushostd->ushostname = pinfushost->ushostname;
                    pinfushost->ushostname = changename;
                    
                    sprintf_f(rs->logs, "[DV] rom pri[%s] sec[%s] \n", pinfushost->ushostname, pinfushostd->ushostname);
                    print_f(rs->plogs, "P11", rs->logs);

                    pinfushost->ushostpidvid[0] = 0;
                    pinfushost->ushostpidvid[1] = 0;

                    pinfushostd->ushostpidvid[0] = 0;
                    pinfushostd->ushostpidvid[1] = 0;

                    endTran[0] = '0';

                    pipRet = write(pipeTx[1], endTran, 1);
                    if (pipRet < 0) {
                        sprintf_f(rs->logs, "[DV] send pri reset to rom ret: %d \n", pipRet);
                        print_f(rs->plogs, "P11", rs->logs);
                        continue;
                    }
                    
                    sprintf_f(rs->logs, "[DV] rom pri send command ret:  %d\n", pipRet);
                    print_f(rs->plogs, "P11", rs->logs);

                    pipRet = write(pipeTxd[1], endTran, 1);
                    if (pipRet < 0) {
                        sprintf_f(rs->logs, "[DV] send sec reset to rom ret: %d \n", pipRet);
                        print_f(rs->plogs, "P11", rs->logs);
                        continue;
                    }

                    sprintf_f(rs->logs, "[DV] rom sec send command ret:  %d\n", pipRet);
                    print_f(rs->plogs, "P11", rs->logs);

                    while (1) {
                        chq = 0;
                        pipRet = read(pipeRx[0], &chq, 1);
                        if (pipRet > 0) {
                            break;
                        }
                    }
                    
                    sprintf_f(rs->logs, "[DV] wait pri 0x17 ch: %c \n", chq);
                    print_f(rs->plogs, "P11", rs->logs);

                    if (chq == 'J') {
                        while (1) {
                            pipRet = read(pipeRx[0], msgret, 1);
                            if (pipRet > 0) {
                                break;
                            }
                        }
                        
                        chn = 0;
                        if (pipRet > 0) {
                            chn = msgret[0];
                        }
                        
                        sprintf_f(rs->logs, "[DV] rom rest polld ch: %c, result: %d ret: %d - 2\n", chq, chn, pipRet);
                        print_f(rs->plogs, "P11", rs->logs);    
                    } 
                    else {
                        sprintf_f(rs->logs, "[DV] error!!! polld ch : %c unexpected!! - 2\n", chq);
                        print_f(rs->plogs, "P11", rs->logs);    
                    }

                    while (1) {
                        chd = 0;
                        pipRet = read(pipeRxd[0], &chd, 1);
                        if (pipRet > 0) {
                            break;
                        }
                    }
                    
                    sprintf_f(rs->logs, "[DV] wait sec 0x17 ch: %c \n", chd);
                    print_f(rs->plogs, "P11", rs->logs);

                    if (chd == 'J') {
                        while (1) {
                            pipRet = read(pipeRxd[0], msgret, 1);
                            if (pipRet > 0) {
                                break;
                            }
                        }
                        
                        chm = 0;
                        if (pipRet > 0) {
                            chm = msgret[0];
                        }
                        
                        sprintf_f(rs->logs, "[DV] rom sec reset polld ch: %c, result: %d ret: %d - 2\n", chd, chm, pipRet);
                        print_f(rs->plogs, "P11", rs->logs);    
                    }
                    else {
                        sprintf_f(rs->logs, "[DV] error!!! polld ch : %c unexpected!! - 2\n", chd);
                        print_f(rs->plogs, "P11", rs->logs);    
                    } 


                if (act == 0) {
                    if (chn == 0xa1) {
                        csw[12] = 0;
                    } else {
                        csw[12] = 1; 
                    }
                } else {
                    if (chm == 0xa1) {
                        csw[12] = 0;
                    } else {
                        csw[12] = 1; 
                    }
                }
                    
                }


                sprintf_f(rs->logs, "[DV] rom csw[12]: %d, act: %d, n: 0x%.2x, m:0x%.2x - 2\n", csw[12], act, chn, chm);
                print_f(rs->plogs, "P11", rs->logs);

                wrtsz = 0;
                retry = 0;
                while (1) {
                    wrtsz = usbc_write(usbfd, csw, 13);
                    
                    #if DBG_27_DV
                    sprintf_f(rs->logs, "[DV] usb TX size: %d \n====================\n", wrtsz); 
                    print_f(rs->plogs, "P11", rs->logs);
                    #endif
                    
                    if (wrtsz > 0) {
                        break;
                    }
                    retry++;
                    if (retry > 32768) {
                        break;
                    }
                }

                sprintf(rs->logs, "__USB_SEND CSW_[%.2x][%.2x][%.2x]__", csw[10], csw[11], csw[12]); 
                dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);

                sprintf_f(rs->logs, "[DV] 0x0c cmd: 0x%.2x opc: 0x%.2x dat: 0x%.2x dump csw: \n", cmd, opc, dat); 
                print_f(rs->plogs, "P11", rs->logs);
                shmem_dump(csw, wrtsz);
                    
                cmd = 0;
                dat = 0;
                opc = 0;
                break;
            }
            else if ((cmd == OP_WRITE_FILE) && (opc == 7) && (dat == 0xff)) { /* usbentsTx == 1*/
                
                sprintf_f(rs->logs, "[DV] wait reset ASIC \n");
                print_f(rs->plogs, "P11", rs->logs);

                while (1) {
                    chq = 0;
                    pipRet = read(pipeRx[0], &chq, 1);
                    
                    //sprintf_f(rs->logs, "[dbg] get chq: %c ret: %d \n", chq, pipRet);
                    //print_f(rs->plogs, "P11", rs->logs);

                    if (pipRet > 0) {
                        break;
                    }
                }

                if (chq == 'J') {
                    while (1) {
                        pipRet = read(pipeRx[0], msgret, 1);
                        if (pipRet > 0) {
                            break;
                        }
                    }
                    
                    chn = 0;
                    if (pipRet > 0) {
                        chn = msgret[0];
                    }
                    
                    sprintf_f(rs->logs, "[DV] rom rest polld ch: %c, result: %d ret: %d\n", chq, chn, pipRet);
                    print_f(rs->plogs, "P11", rs->logs);    
                } 
                else {
                    while (1) {
                        pipRet = read(pipeRx[0], msgret, 1);
                        if (pipRet <= 0) {
                            break;
                        }
                    }
                    
                    sprintf_f(rs->logs, "[DV] error!!! polld ch : %c unexpected!! \n", chq);
                    print_f(rs->plogs, "P11", rs->logs);    
                }
                
                while (1) {
                    chd = 0;
                    pipRet = read(pipeRxd[0], &chd, 1);
                    if (pipRet > 0) {
                        break;
                    }
                }
                
                if (chd == 'J') {
                    while (1) {
                        pipRet = read(pipeRxd[0], msgret, 1);
                        if (pipRet > 0) {
                            break;
                        }
                    }
                    
                    chm = 0;
                    if (pipRet > 0) {
                        chm = msgret[0];
                    }
                    
                    sprintf_f(rs->logs, "[DV] rom sec reset polld ch: %c, result: %d ret: %d \n", chd, chm, pipRet);
                    print_f(rs->plogs, "P11", rs->logs);    
                }
                else {
                    while (1) {
                        pipRet = read(pipeRxd[0], msgret, 1);
                        if (pipRet <= 0) {
                            break;
                        }
                    }
                    
                    sprintf_f(rs->logs, "[DV] error!!! polld ch : %c unexpected!! \n", chd);
                    print_f(rs->plogs, "P11", rs->logs);    
                }

                if ((chn == 0x03) || (chm == 0x04)) {
                    csw[12] = 0;
                }
                else if ((chn == 0x04) || (chm == 0x03)) {
                    csw[12] = 2;
                }
                else {
                    csw[12] = 1; 
                }

                sprintf_f(rs->logs, "[DV] rom csw[12]: 0x%.2x, chn: 0x%.2x, chm:0x%.2x \n", csw[12], chn, chm);
                print_f(rs->plogs, "P11", rs->logs);

                if (csw[12]) {
                    changename = pinfushostd->ushostname;
                    pinfushostd->ushostname = pinfushost->ushostname;
                    pinfushost->ushostname = changename;
                    
                    sprintf_f(rs->logs, "[DV] rom pri[%s] sec[%s] \n", pinfushost->ushostname, pinfushostd->ushostname);
                    print_f(rs->plogs, "P11", rs->logs);

                    pinfushost->ushostpidvid[0] = 0;
                    pinfushost->ushostpidvid[1] = 0;

                    pinfushostd->ushostpidvid[0] = 0;
                    pinfushostd->ushostpidvid[1] = 0;

                    endTran[0] = '0';

                    pipRet = write(pipeTx[1], endTran, 1);
                    if (pipRet < 0) {
                        sprintf_f(rs->logs, "[DV] send pri reset to rom ret: %d \n", pipRet);
                        print_f(rs->plogs, "P11", rs->logs);
                        continue;
                    }
                    sprintf_f(rs->logs, "[DV] rom pri send command ret:  %d \n", pipRet);
                    print_f(rs->plogs, "P11", rs->logs);

                    endTran[0] = '0';
                    
                    pipRet = write(pipeTxd[1], endTran, 1);
                    if (pipRet < 0) {
                        sprintf_f(rs->logs, "[DV] send sec reset to rom ret: %d \n", pipRet);
                        print_f(rs->plogs, "P11", rs->logs);
                        continue;
                    }
                    sprintf_f(rs->logs, "[DV] rom sec send command ret:  %d \n", pipRet);
                    print_f(rs->plogs, "P11", rs->logs);

                    while (1) {
                        chq = 0;
                        pipRet = read(pipeRx[0], &chq, 1);
                        if (pipRet > 0) {
                            break;
                        }
                    }
                    
                    sprintf_f(rs->logs, "[DV] wait pri 0x17 ch: %c \n", chq);
                    print_f(rs->plogs, "P11", rs->logs);

                    if (chq == 'J') {
                        while (1) {
                            pipRet = read(pipeRx[0], msgret, 1);
                            if (pipRet > 0) {
                                break;
                            }
                        }
                        
                        chn = 0;
                        if (pipRet > 0) {
                            chn = msgret[0];
                        }
                        
                        sprintf_f(rs->logs, "[DV] rom rest polld ch: %c, result: %d ret: %d - 2\n", chq, chn, pipRet);
                        print_f(rs->plogs, "P11", rs->logs);    
                    } 
                    else {
                        while (1) {
                            pipRet = read(pipeRx[0], msgret, 1);
                            if (pipRet <= 0) {
                                break;
                            }
                        }
                        
                        sprintf_f(rs->logs, "[DV] error!!! polld ch : %c unexpected!! - 2\n", chq);
                        print_f(rs->plogs, "P11", rs->logs);    
                    }

                    while (1) {
                        chd = 0;
                        pipRet = read(pipeRxd[0], &chd, 1);
                        if (pipRet > 0) {
                            break;
                        }
                    }
                    
                    sprintf_f(rs->logs, "[DV] wait sec 0x17 ch: %c \n", chd);
                    print_f(rs->plogs, "P11", rs->logs);

                    if (chd == 'J') {
                        while (1) {
                            pipRet = read(pipeRxd[0], msgret, 1);
                            if (pipRet > 0) {
                                break;
                            }
                        }
                        
                        chm = 0;
                        if (pipRet > 0) {
                            chm = msgret[0];
                        }
                        
                        sprintf_f(rs->logs, "[DV] rom sec reset polld ch: %c, result: %d ret: %d - 2\n", chd, chm, pipRet);
                        print_f(rs->plogs, "P11", rs->logs);    
                    }
                    else {
                        while (1) {
                            pipRet = read(pipeRxd[0], msgret, 1);
                            if (pipRet <= 0) {
                                break;
                            }
                        }
                        
                        sprintf_f(rs->logs, "[DV] error!!! polld ch : %c unexpected!! - 2\n", chd);
                        print_f(rs->plogs, "P11", rs->logs);    
                    } 
                }

                if ((chn == 0x03) && (chm == 0x04)) {
                    csw[12] = 0;
                }
                else {
                    if ((chn == 0x03) && (chm != 0x04)) {
                        csw[12] = 2; 
                    }
                    else if ((chn != 0x03) && (chm == 0x04)) {
                        csw[12] = 1; 
                    }
                    else if ((chn != 0x03) && (chm != 0x04)) {
                        csw[12] = 3; 
                    } 
                    else {
                        csw[12] = CSW_STATUS_USB_FAIL; 
                    }

                }

                sprintf_f(rs->logs, "[DV] rom csw[12]: 0x%.2x, chn: 0x%.2x, chm:0x%.2x - 2\n", csw[12], chn, chm);
                print_f(rs->plogs, "P11", rs->logs);

                wrtsz = 0;
                retry = 0;
                while (1) {
                    wrtsz = usbc_write(usbfd, csw, 13);
                    
                    #if DBG_27_DV
                    sprintf_f(rs->logs, "[DV] usb TX size: %d \n====================\n", wrtsz); 
                    print_f(rs->plogs, "P11", rs->logs);
                    #endif
                    
                    if (wrtsz > 0) {
                        break;
                    }
                    retry++;
                    if (retry > 32768) {
                        break;
                    }
                }

                sprintf(rs->logs, "__USB_SEND CSW_[%.2x][%.2x][%.2x]__", csw[10], csw[11], csw[12]); 
                dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);

                sprintf_f(rs->logs, "[DV] 0x0c cmd: 0x%.2x opc: 0x%.2x dat: 0x%.2x dump csw: \n", cmd, opc, dat); 
                print_f(rs->plogs, "P11", rs->logs);
                shmem_dump(csw, wrtsz);
                    
                cmd = 0;
                dat = 0;
                opc = 0;
                break;
            }
            else if ((cmd == OP_WRITE_FILE) && (opc == 9) && (dat == 0xff)) { /* usbentsTx == 1*/

                lenflh = 0;
                memset(ptrecv, 0x20, 128);

                ptrecv[lenflh] = '[';
                lenflh += 1;
                
                lens = strnlen(MSP_VERSION, sizeof(MSP_VERSION));
                if (lens > 24) {
                    lens = 24;
                }
                strncpy(&ptrecv[lenflh], MSP_VERSION, lens);
                lenflh += lens;
                ptrecv[lenflh] = ',';
                lenflh += 1;
                
                lens = strnlen(MSP_GIT, sizeof(MSP_GIT));
                if (lens > 28) {
                    lens = 28;
                }
                strncpy(&ptrecv[lenflh], MSP_GIT, lens);
                lenflh += lens;
                
                ptrecv[lenflh] = ',';
                lenflh += 1;

                lens = strnlen(MSP_TIME, 24);
                strncpy(&ptrecv[lenflh], MSP_TIME, lens);
                lenflh += lens;

                ptrecv[lenflh] = ',';
                lenflh += 1;

                lens = strnlen(MSP_SSID, 28);
                strncpy(&ptrecv[lenflh], MSP_SSID, lens);
                lenflh += lens;

                ptrecv[lenflh] = ']';
                lenflh += 1;

                if (lenflh > 128) {
                    sprintf_f(rs->logs, "error!!! wrong version total size: %d\n", lenflh); 
                    print_f(rs->plogs, "P11", rs->logs);
                }


                sprintf_f(rs->logs, "version: %s\n", ptrecv); 
                print_f(rs->plogs, "P11", rs->logs);
              

                wrtsz = 0;
                retry = 0;
                while (1) {
                    wrtsz = usbc_write(usbfd, ptrecv, 128);
                    
                    #if DBG_27_DV
                    sprintf_f(rs->logs, "[DV] usb TX size: %d \n====================\n", wrtsz); 
                    print_f(rs->plogs, "P11", rs->logs);
                    #endif
                    
                    if (wrtsz > 0) {
                        break;
                    }
                    retry++;
                    if (retry > 32768) {
                        break;
                    }
                }

                csw[12] = 0; 
                wrtsz = 0;
                retry = 0;
                while (1) {
                    wrtsz = usbc_write(usbfd, csw, 13);
                    
                    #if DBG_27_DV
                    sprintf_f(rs->logs, "[DV] usb TX size: %d \n====================\n", wrtsz); 
                    print_f(rs->plogs, "P11", rs->logs);
                    #endif
                    
                    if (wrtsz > 0) {
                        break;
                    }
                    retry++;
                    if (retry > 32768) {
                        break;
                    }
                }

                sprintf(rs->logs, "__USB_SEND CSW_[%.2x][%.2x][%.2x]__", csw[10], csw[11], csw[12]); 
                dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);

                sprintf_f(rs->logs, "[DV] OP_WRITE_FILE get version opc: 0x%.2x dat: 0x%.2x dump csw: \n", opc, dat); 
                print_f(rs->plogs, "P11", rs->logs);
                shmem_dump(csw, wrtsz);
                    
                cmd = 0;
                dat = 0;
                opc = 0;
                break;
            }
            else if (((cmd >= 0x00) && (cmd <= 0x0f)) && (opc == 0xff) && (dat == 0xff)) { /* usbentsTx == 1*/
                if (ucbwpram->ASIC_sel) {
                    //if (usbid02) {
                        while (1) {
                            chd = 0;
                            pipRet = read(pipeRxd[0], &chd, 1);
                            if (pipRet > 0) {
                                break;
                            }
                        }
                        
                        if (chd != 'J') {
                            sprintf_f(rs->logs, "[DV] polld status unknown result, ret: %c (0x%.2x) \n", chd, chd);
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                        
                        chm = 0;
                        while (1) {
                            pipRet = read(pipeRxd[0], &chm, 1);
                            if (pipRet < 0) {
                                break;
                            }
                        }
                        
                        if (chm) {
                        
                            #if LOG_FLASH 
                            sprintf_f(rs->logs, "[DV] polld status : (0x%.2x) \n", chm);
                            print_f(rs->plogs, "P11", rs->logs);
                            #endif
                            
                        }
                    //}
                }
                else {
                    //if (usbid01) {
                        while(1) {
                            ret = poll(ptfd, 1, 10);
                        
                            if (ret > 0) {
                                chq = 0;
                                pipRet = read(pipeRx[0], &chq, 1);
                        
                                if (pipRet > 0) {
                                
                                    #if LOG_FLASH 
                                    sprintf_f(rs->logs, "[DV] cmd:0x%.2x opc:0x%.2x get chr:0x%.2x \n", cmd, opc, chq);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    #endif
                        
                                    break;
                                }
                            }
                        }
                        
                        if (chq != 'J') {
                            sprintf_f(rs->logs, "[DV] poll status unknown result, ret: %c (0x%.2x) \n", chq, chq);
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                        
                        while(1) {
                            ret = poll(ptfd, 1, 10);
                        
                            if (ret > 0) {
                                chn = 0;
                                pipRet = read(pipeRx[0], &chn, 1);
                        
                                if (pipRet > 0) {
                                
                                    #if LOG_FLASH 
                                    sprintf_f(rs->logs, "[DV] cmd:0x%.2x opc:0x%.2x get chr:0x%.2x \n", cmd, opc, chn);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    #endif
                        
                                    break;
                                }
                            }
                        }
                        
                        if (chn) {
                        
                            #if LOG_FLASH 
                            sprintf_f(rs->logs, "[DV] poll status : (0x%.2x) \n", chn);
                            print_f(rs->plogs, "P11", rs->logs);
                            #endif
                        }
                    //}
                }
                
                if (!iubsBuff) {
                    sprintf_f(rs->logs, "\n[DVF] Error !!! iubsBuff is null!!!! cmd: 0x%.2x opc: 0x%.2x, dat: 0x%.2x  \n",cmd, opc, dat);
                    print_f(rs->plogs, "P11", rs->logs);
                    break;
                }
                
                #if LOG_FLASH /* debug flash read/write */
                sprintf_f(rs->logs, "[DV] read flash id:0x%.8x len:%d cmd:0x%.2x addr:0x%.8x direct:%d \n", 
                                              msb2lsb32(&ucbwpram->pramID), msb2lsb32(&ucbwpram->pramDataLength), 
                                              ucbwpram->pramType, (uint32_t)msb2lsb32(&ucbwpram->pramAddress), ucbwpram->pramDirect);
                print_f(rs->plogs, "P11", rs->logs);
                #endif
                lenflh = msb2lsb32(&ucbwpram->pramDataLength);
                msync(vubsBuff, lenflh, MS_SYNC);

                while (1) {
                    wrtsz = usbc_write(usbfd, vubsBuff, lenflh);
                    
                    #if DBG_27_DV
                    sprintf_f(rs->logs, "[DV] usb TX size: %d \n====================\n", wrtsz); 
                    print_f(rs->plogs, "P11", rs->logs);
                    #endif
                    
                    if (wrtsz > 0) {
                        break;
                    }
                    retry++;
                    if (retry > 32768) {
                        break;
                    }
                }

                if (wrtsz < 0) {
                    //usbentsTx = 0;
                    continue;
                }

                #if LOG_FLASH /* debug flash read/write */
                shmem_dump(vubsBuff, wrtsz);
                #endif

                #if 0
                csw[11] = 0;
                csw[12] = chn;
                #else
                memcpy(csw, vcswBuff, 13);
                #endif

                wrtsz = 0;
                retry = 0;
                while (1) {
                    wrtsz = usbc_write(usbfd, csw, 13);
                    
                    #if DBG_27_DV
                    sprintf_f(rs->logs, "[DV] usb TX size: %d \n====================\n", wrtsz); 
                    print_f(rs->plogs, "P11", rs->logs);
                    #endif
                    
                    if (wrtsz > 0) {
                        break;
                    }
                    retry++;
                    if (retry > 32768) {
                        break;
                    }
                }

                if (wrtsz < 0) {
                    //usbentsTx = 0;
                    continue;
                }

                #if LOG_FLASH 
                sprintf_f(rs->logs, "[DV] flasg read cmd: (0x%.2x) opc: (0x%.2x) dat: (0x%.2x) dump: \n", cmd, opc, dat);
                print_f(rs->plogs, "P11", rs->logs);
                shmem_dump(csw, wrtsz);
                #else
                printf("\rdone      \r");
                
                sprintf(rs->logs, "__USB_SEND CSW_[%.2x][%.2x][%.2x]__", csw[10], csw[11], csw[12]); 
                dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);
                #endif
                
                #if DBG_USB_TIME_MEASURE
                if (!fintvalE[0]) {
                    clock_gettime(CLOCK_REALTIME, &intvalE[0]);
                    fintvalE[0] = 1;
                
                    if (fintvalE[1]) {
                
                        tmCost = time_diff(&intvalE[1], &intvalE[0], 1000);
                        sprintf_f(rs->logs, "[DV] TX interval end: %llu ms start: %llu ms diff: %d us - 1\n", time_get_ms(&intvalE[0]), time_get_ms(&intvalE[1]), tmCost);
                        print_f(rs->plogs, "P11", rs->logs);
                
                        fintvalE[1] = 0;
                    }
                    else {
                        sprintf_f(rs->logs, "[DVF] TX interval should not be here !!! - 1\n");
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                } else {
                
                    if (!fintvalE[1]) {
                        clock_gettime(CLOCK_REALTIME, &intvalE[1]);
                        fintvalE[1] = 1;
                
                        tmCost = time_diff(&intvalE[0], &intvalE[1], 1000);
                        sprintf_f(rs->logs, "[DV] TX interval end: %llu ms start: %llu ms diff: %d us - 2\n", time_get_ms(&intvalE[1]), time_get_ms(&intvalE[0]), tmCost);
                        print_f(rs->plogs, "P11", rs->logs);
                
                        fintvalE[0] = 0;
                    } else {
                        sprintf_f(rs->logs, "[DVF] TX interval should not be here !!! - 2\n");
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                }
                #endif

                #if 0
                //chq = 'x';
                msgret[0] = 'x';
                msgret[1] = 0x01;
                pipRet = write(pipeTx[1], &msgret, 2);
                if (pipRet < 0) {
                    printf("[DV] Error!!! pipe send scan stop ret: %d \n", pipRet);
                }
                    
                sprintf(msgcmd, "usbidle");

                ret = rs_ipc_get_ms(rcmd, rcmd->logs, 4096, 500);
                if (ret > 0) {
                    rcmd->logs[ret] = '\n';

                    sprintf_f(rs->logs, "[DV]  get usbscan result ret: %d\n", ret);
                    print_f(rs->plogs, "P11", rs->logs);   

                    print_f(rcmd->plogs, "C11", rcmd->logs);
                }
                else {
                    sprintf_f(rs->logs, "[DV] cmd no message \n");
                    print_f(rs->plogs, "P11", rs->logs);
                }
                #endif
                    
                opc = 0;
                dat = 0;
                
                break;
            }
            else if (((cmd >= 0x00) && (cmd <= 0x0f)) && (opc == 0xff)) { /* usbentsTx == 1*/
                if (ucbwpram->ASIC_sel) {
                    //if (usbid02) {
                        while (1) {
                            chd = 0;
                            pipRet = read(pipeRxd[0], &chd, 1);
                            if (pipRet > 0) {
                                break;
                            }
                        }
                        
                        if (chd != 'J') {
                            sprintf_f(rs->logs, "[DV] polld status unknown result, ret: %c (0x%.2x) \n", chd, chd);
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                        
                        chm = 0;
                        while (1) {
                            pipRet = read(pipeRxd[0], &chm, 1);
                            if (pipRet < 0) {
                                break;
                            }
                        }
                        
                        if (chm) {
                            sprintf_f(rs->logs, "[DV] polld status : (0x%.2x) \n", chm);
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                    //}
                }
                else {
                    //if (usbid01) {
                        while(1) {
                            ret = poll(ptfd, 1, 10);
                        
                            if (ret > 0) {
                                chq = 0;
                                pipRet = read(pipeRx[0], &chq, 1);
                        
                                if (pipRet > 0) {
                                
                                    #if LOG_FLASH
                                    sprintf_f(rs->logs, "[DV] cmd:0x%.2x opc:0x%.2x get chr:0x%.2x \n", cmd, opc, chq);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    #endif
                        
                                    break;
                                }
                            }
                        }
                        
                        if (chq != 'J') {
                            sprintf_f(rs->logs, "[DV] poll status unknown result, ret: %c (0x%.2x) \n", chq, chq);
                            print_f(rs->plogs, "P11", rs->logs);
                        }
                        
                        while(1) {
                            ret = poll(ptfd, 1, 10);
                        
                            if (ret > 0) {
                                chn = 0;
                                pipRet = read(pipeRx[0], &chn, 1);
                        
                                if (pipRet > 0) {

                                    #if LOG_FLASH
                                    sprintf_f(rs->logs, "[DV] cmd:0x%.2x opc:0x%.2x get chr:0x%.2x \n", cmd, opc, chn);
                                    print_f(rs->plogs, "P11", rs->logs);
                                    #endif
                        
                                    break;
                                }
                            }
                        }
                        
                        if (chn) {

                            #if LOG_FLASH
                            sprintf_f(rs->logs, "[DV] poll status : (0x%.2x) \n", chn);
                            print_f(rs->plogs, "P11", rs->logs);
                            #endif
                            
                        }
                    //}
                }
                
                #if 0
                csw[11] = 0;
                csw[12] = chn;
                #else
                memcpy(csw, vcswBuff, 13);
                #endif

                wrtsz = 0;
                retry = 0;
                while (1) {
                    wrtsz = usbc_write(usbfd, csw, 13);
                    
                    #if DBG_27_DV
                    sprintf_f(rs->logs, "[DV] usb TX size: %d \n====================\n", wrtsz); 
                    print_f(rs->plogs, "P11", rs->logs);
                    #endif
                    
                    if (wrtsz > 0) {
                        break;
                    }
                    retry++;
                    if (retry > 32768) {
                        break;
                    }
                }

                if (wrtsz < 0) {
                    //usbentsTx = 0;
                    continue;
                }

                #if LOG_FLASH
                sprintf_f(rs->logs, "[DV] flash write cmd: (0x%.2x) opc: (0x%.2x) dat: (0x%.2x) dump: \n", cmd, opc, dat);
                print_f(rs->plogs, "P11", rs->logs);
                shmem_dump(csw, wrtsz);
                #else
                printf("\rdone      \r");

                sprintf(rs->logs, "__USB_SEND CSW_[%.2x][%.2x][%.2x]__", csw[10], csw[11], csw[12]); 
                dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);
                #endif

                #if DBG_USB_TIME_MEASURE
                if (!fintvalE[0]) {
                    clock_gettime(CLOCK_REALTIME, &intvalE[0]);
                    fintvalE[0] = 1;
                
                    if (fintvalE[1]) {
                
                        tmCost = time_diff(&intvalE[1], &intvalE[0], 1000);
                        sprintf_f(rs->logs, "[DV] TX interval end: %llu ms start: %llu ms diff: %d us - 1\n", time_get_ms(&intvalE[0]), time_get_ms(&intvalE[1]), tmCost);
                        print_f(rs->plogs, "P11", rs->logs);
                
                        fintvalE[1] = 0;
                    }
                    else {
                        sprintf_f(rs->logs, "[DVF] TX interval should not be here !!! - 1\n");
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                } else {
                
                    if (!fintvalE[1]) {
                        clock_gettime(CLOCK_REALTIME, &intvalE[1]);
                        fintvalE[1] = 1;
                
                        tmCost = time_diff(&intvalE[0], &intvalE[1], 1000);
                        sprintf_f(rs->logs, "[DV] TX interval end: %llu ms start: %llu ms diff: %d us - 2\n", time_get_ms(&intvalE[1]), time_get_ms(&intvalE[0]), tmCost);
                        print_f(rs->plogs, "P11", rs->logs);
                
                        fintvalE[0] = 0;
                    } else {
                        sprintf_f(rs->logs, "[DVF] TX interval should not be here !!! - 2\n");
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                }
                #endif

                #if 0
                //chq = 'x';
                msgret[0] = 'x';
                msgret[1] = 0x01;
                pipRet = write(pipeTx[1], &msgret, 2);
                if (pipRet < 0) {
                    printf("[DV] Error!!! pipe send scan stop ret: %d \n", pipRet);
                }
                    
                sprintf(msgcmd, "usbidle");

                ret = rs_ipc_get_ms(rcmd, rcmd->logs, 4096, 500);
                if (ret > 0) {
                    rcmd->logs[ret] = '\n';

                    sprintf_f(rs->logs, "[DV]  get usbscan result ret: %d\n", ret);
                    print_f(rs->plogs, "P11", rs->logs);   

                    print_f(rcmd->plogs, "C11", rcmd->logs);
                }
                #endif
                
                opc = 0;
                
                break;
            }
            else if (opc == 0xff) { /* usbentsTx == 1*/
                if (usbid01) {
                    while (1) {
                        chq = 0;
                        pipRet = read(pipeRx[0], &chq, 1);
                        if (pipRet > 0) {
                            break;
                        }
                    }
    
                    if (chq != 'J') {
                        sprintf_f(rs->logs, "[DV] poll status unknown result, ret: %c (0x%.2x) \n", chq, chq);
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                    
                    chn = 0;
                    while (1) {
                        pipRet = read(pipeRx[0], &chn, 1);
                        if (pipRet < 0) {
                            break;
                        }
                    }
    
                    if (chn) {
                        sprintf_f(rs->logs, "[DV] poll status : (0x%.2x) \n", chn);
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                }

                #if BYPASS_TWO
                if (usbid02) {
                    while (1) {
                        chd = 0;
                        pipRet = read(pipeRxd[0], &chd, 1);
                        if (pipRet > 0) {
                            break;
                        }
                    }
    
                    if (chd != 'J') {
                        sprintf_f(rs->logs, "[DV] polld status unknown result, ret: %c (0x%.2x) \n", chd, chd);
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                    
                    chm = 0;
                    while (1) {
                        pipRet = read(pipeRxd[0], &chm, 1);
                        if (pipRet < 0) {
                            break;
                        }
                    }
    
                    if (chm) {
                        sprintf_f(rs->logs, "[DV] polld status : (0x%.2x) \n", chm);
                        print_f(rs->plogs, "P11", rs->logs);
                    }
                }
                #endif

                #if 0
                csw[11] = 0;
                csw[12] = chn;
                #else
                memcpy(csw, vcswBuff, 13);
                #endif

                wrtsz = 0;
                retry = 0;
                while (1) {
                    wrtsz = usbc_write(usbfd, csw, 13);
                    
                    #if DBG_27_DV
                    sprintf_f(rs->logs, "[DV] usb TX size: %d \n====================\n", wrtsz); 
                    print_f(rs->plogs, "P11", rs->logs);
                    #endif
                    
                    if (wrtsz > 0) {
                        break;
                    }
                    retry++;
                    if (retry > 32768) {
                        break;
                    }
                }

                if (wrtsz < 0) {
                    //usbentsTx = 0;
                    continue;
                }

                sprintf(rs->logs, "__USB_SEND CSW_[%.2x][%.2x][%.2x]__", csw[10], csw[11], csw[12]); 
                dbgShowTimeStamp(rs->logs,  NULL, rs, 2, rs->logs);

                sprintf_f(rs->logs, "[DV] poll cmd: (0x%.2x) opc: (0x%.2x) dat: (0x%.2x) dump: \n", cmd, opc, dat);
                print_f(rs->plogs, "P11", rs->logs);

                shmem_dump(csw, wrtsz);

                msgret[0] = 'x';
                msgret[1] = 0x01;
                pipRet = write(pipeTx[1], msgret, 2);
                if (pipRet < 0) {
                    printf("[DV] Error!!! pipe send scan stop ret: %d \n", pipRet);
                }
                
                sprintf(msgcmd, "usbidle");
                
                ret = rs_ipc_get_ms(rcmd, rcmd->logs, 4096, 10);
                if (ret > 0) {
                    rcmd->logs[ret] = '\n';

                    sprintf_f(rs->logs, "[DV]  get usbscan result ret: %d\n", ret);
                    print_f(rs->plogs, "P11", rs->logs);   

                    print_f(rcmd->plogs, "C11", rcmd->logs);
                } 
                
                opc = 0;
                
                break;
            }
            else {
                /* do nothing */
                break;
            }

        }
        
    }

    while(1) {
        ret = rs_ipc_get(rs, &ch, 1);

        if (ret > 0) {
            sprintf_f(rs->logs, "get ch[0x%.2x] \n", ch);
            print_f(rs->plogs, "P11", rs->logs);
        } else {
            sprintf_f(rs->logs, "warnning ret: %d \n", ret);
            print_f(rs->plogs, "P11", rs->logs);
        }
    }

    p11_end(rs, rsd, rcmd);
    return 0;
}

static int read_image_fle( char *filename, void *buf, int buf_size )
{
    int fh;

    fh = open( filename, O_RDONLY );
    if( fh < 0 )
    {
        printf( "open file error %s errno=%d\r\n", filename, errno);
        return 0;
    }

    struct stat st;
    fstat(fh, &st);
    int size = (st.st_size>buf_size) ? buf_size : st.st_size ;
    size = read( fh, buf, size );
    close( fh );
    return size;
}

static int send_image_in_jpg(struct procRes_s *rs, int mbidx, int midx, int *max)
{
    int image_size=0, mul=0, tail=0, shf=0, ix=0, jpglen=0, exlen=0, yllen=0, val=0, mtlen=0;
    unsigned char *pt=0, *pmeta=0, *pexmt=0;
    //mfour_rjob_cmd cmd;
    char filename[256]={0};
    char fname[32] = "char_H%.3d.jpg";
    char filetest[128] = "/home/root/banknote/jpg/full_H%.3d.jpg";
    int ret=0;
    FILE *f=0, *f1=0, *f2=0;
    int size=0;
    int imgw=0, imgh=0;
    int *pimgw=0, *pimgh=0;
    struct bitmapDecodeMfour_s *pdec=0;
    struct bitmapDecodeItem_s *decjpg=0, *decmeta=0, *decexmt=0;
    mfour_image_param_st *decimgp=0, *img_param=0;
    int imgidx=0, simmax=-1, simidx=0;
    struct aspMetaDataviaUSB_s *pusbmeta=0;

    if (!rs) return -1;
    if ((mbidx < 0) || (mbidx >= 4)) return -2;

    pdec = rs->pbDecMfour[mbidx];
    aspBMPdecodeBuffGetIdx(pdec, &imgidx);

    sprintf(filename, filetest, imgidx);
    
    simmax = *max;

    f1 = fopen(filename, "r");
    if(f1) {
        f = f1;    
    } else {
        if (simmax < 0) {
            if (imgidx > 0) {
                simidx = imgidx - 1;

                sprintf(filename, filetest, simidx);
                f2 = fopen(filename, "r");
                if (f2) {
                    simmax = simidx;
                    fclose(f2);
                } else {
                    simmax = simidx - 1;
                }
                *max = simmax;
                simidx = ((imgidx - 1) % simmax) + 1;
                sprintf(filename, filetest, simidx);
                f = fopen(filename, "r");
            }
        } else {
            simidx = ((imgidx - 1) % simmax) + 1;
            sprintf(filename, filetest, simidx);
            f = fopen(filename, "r");
        }
    }

    if (!f) {
        sprintf_f(rs->logs,"open file error %s errno=%d\r\n", filename, errno);
        print_f(rs->plogs, "fIle", rs->logs);
        return -1;
    }

    sprintf_f(rs->logs,"open m4 sample file: [%s] file: %d, img: %d, max: %d\n", filename, simidx, imgidx, simmax);
    print_f(rs->plogs, "fIle", rs->logs);
    

    ret |= fseek(f, 0, SEEK_END);

    size = ftell(f);

    ret |= fseek(f, 0, SEEK_SET);

    if (ret) {
        return -3;
    }

    decjpg = &pdec->aspDecJpeg; //jpeg
    decimgp = decjpg->aspDcData;

    decmeta = &pdec->aspDecMeta; //meta

    decexmt = &pdec->aspDecMetaex; //meta
    
    img_param = decimgp;

    if (size > decjpg->aspDcMax) {
        fclose(f);
        return -4;
    }

    image_size = fread(img_param->mfourData, 1, size, f);
    if ((image_size < 0) || (image_size != size)) {
        sprintf_f(rs->logs,"read file error %s errno=%d ret=%d \r\n", filename, errno, image_size);
        print_f(rs->plogs, "fIle", rs->logs);
        fclose(f);
        return -5;
    }
    
    fclose(f);
    
    tail = size % 512;
    mul = (size - tail) / 512;

    sprintf_f(rs->logs,"read file: [%s] size: %d, mul: %d, tail: %d \n", filename, size, mul, tail);
    print_f(rs->plogs, "fIle", rs->logs);

    for (ix=0; ix < mul; ix++) {
        shf = (mul - ix) * 512;
        pt = img_param->mfourData + shf;
        
        if (pt[0] == 'A') {
            if ((pt[1] == 'S') && (pt[2] == 'P') && (pt[3] == 'C')) {
                pmeta = pt;
                break;
            }
        }
        
        /*
        else {
            sprintf_f(rs->logs,"%d. [0x%.8x]: 0x%.2x \n", ix, shf, pt[0]);
            print_f(rs->plogs, "fIle", rs->logs);
        }
        */
    }

    if (!pmeta) {
        sprintf_f(rs->logs,"Error!!! can't find meta search count: %d \n", ix);
        print_f(rs->plogs, "fIle", rs->logs);
        return -6;
    }
    
    jpglen = pmeta - img_param->mfourData;

    val = size - jpglen;

    tail = val % 16;
    mul = (val - tail) / 16;
    
    for (ix=0; ix < (mul - 1); ix++) {
        shf = (ix + 1) * 16;
        pt = pmeta + shf;

        if ((pt[0] == 'Y') && (pt[1] == 'L')) {
            pexmt = pt;
        }
    }

    if (!pexmt) return -7;
    mtlen = pexmt - pmeta;
    exlen = size - jpglen - mtlen;
    
    pusbmeta = (struct aspMetaDataviaUSB_s *)pmeta;

    pt = (unsigned char *)&(pusbmeta->YLines_Recorded);
    val = (pt[0] << 8) | pt[1];
    yllen = (val * 4) + 4;

    val = (pexmt[2] << 8) | pexmt[3];
    val += 4;

    if (imgidx % 2) {
        pusbmeta->PRI_O_SEC = 1;
    } else {
        pusbmeta->PRI_O_SEC = 0;
    }

    pusbmeta->Scaned_Page[0] = imgidx & 0xff;
    pusbmeta->Scaned_Page[1] = (imgidx >> 8) & 0xff;

    sprintf_f(rs->logs, "mass len: %d m_len: %d rec_len: %d meta_len: %d jpeg_len: %d updn: %d\n", exlen, val, yllen, mtlen, jpglen, pusbmeta->PRI_O_SEC); 
    print_f(rs->plogs, "fIle", rs->logs);

    if ((exlen != yllen) || (exlen != val)) {
        sprintf_f(rs->logs,"Error!!! extra len not match, len: %d should be %d or %d \n", exlen, yllen, val);
        print_f(rs->plogs, "fIle", rs->logs);
        return -8;
    }

    memcpy(decmeta->aspDcData->mfourData, pmeta, mtlen - 64);
    aspBMPdecodeItemSet(decmeta, 0, 0, mtlen - 64);

    memcpy(decexmt->aspDcData->mfourData, pexmt, exlen);
    aspBMPdecodeItemSet(decexmt, 0, 0, exlen);

    /*
    pimgw = (int *)(img_param->mfourData+0x12);
    pimgh = (int *)(img_param->mfourData+0x16);
    imgw = pimgw[0];
    imgh = pimgh[0];
    */

    imgw = (pusbmeta->IMG_WIDTH[1] << 8) | pusbmeta->IMG_WIDTH[0];
    imgh = pusbmeta->IMG_HIGH[0] | (pusbmeta->IMG_HIGH[1] << 8);

    img_param->mfourAttb.ImageRect.xc = imgw;
    img_param->mfourAttb.ImageRect.yr = imgh;

    decjpg->aspDcLen = image_size + sizeof(mfour_image_param_st);
    
    aspBMPdecodeItemSet(decjpg, imgw, imgh, jpglen+160);
    
    //sprintf(img_param->mfourFilename, fname, imgidx);
    //strncpy(img_param->mfourFilename, file_entry->d_name, sizeof(img_param->mfourFilename));

    sprintf_f(rs->logs,"open image (w=%d h=%d size=%d)\r\n", img_param->mfourAttb.ImageRect.xc, img_param->mfourAttb.ImageRect.yr, image_size);
    print_f(rs->plogs, "fIle", rs->logs);

    #if 0
    cmd.cmd = BKCMD_IMAGE_IN;
    cmd.tag = idx << 16;
    cmd.rsp = 0;
    cmd.dPtr = img_param;
    cmd.dSize = size;
    #endif

    return 0;
}

static int send_image_in_bmp(struct procRes_s *rs, int mbidx, int midx, int *max)
{
    int image_size=0, mul=0, tail=0, shf=0, ix=0, rawlen=0, exlen=0, yllen=0, val=0, mtlen=0;
    unsigned char *pt=0, *pmeta=0, *pexmt=0;
    //mfour_rjob_cmd cmd;
    char filename[256]={0};
    char fname[32] = "char_H%.3d.jpg";
    char filetest[128] = "/home/root/banknote/raw/full_H%.3d.bmp";
    int ret=0;
    FILE *f=0, *f1=0, *f2=0;
    int size=0;
    int imgw=0, imgh=0;
    int *pimgw=0, *pimgh=0;
    struct bitmapDecodeMfour_s *pdec=0;
    struct bitmapDecodeItem_s *decraw=0, *decmeta=0, *decexmt=0;
    mfour_image_param_st *decimgp=0, *img_param=0;
    int imgidx=0, simmax=-1, simidx=0;
    struct aspMetaDataviaUSB_s *pusbmeta=0;

    if (!rs) return -1;
    if ((mbidx < 0) || (mbidx >= 4)) return -2;

    pdec = rs->pbDecMfour[mbidx];
    aspBMPdecodeBuffGetIdx(pdec, &imgidx);

    sprintf(filename, filetest, imgidx);
    
    simmax = *max;

    f1 = fopen(filename, "r");
    if(f1) {
        f = f1;    
    } else {
        if (simmax < 0) {
            if (imgidx > 0) {
                simidx = imgidx - 1;

                sprintf(filename, filetest, simidx);
                f2 = fopen(filename, "r");
                if (f2) {
                    simmax = simidx;
                    fclose(f2);
                } else {
                    simmax = simidx - 1;
                }
                *max = simmax;
                simidx = ((imgidx - 1) % simmax) + 1;
                sprintf(filename, filetest, simidx);
                f = fopen(filename, "r");
            }
        } else {
            simidx = ((imgidx - 1) % simmax) + 1;
            sprintf(filename, filetest, simidx);
            f = fopen(filename, "r");
        }
    }

    if (!f) {
        sprintf_f(rs->logs,"open file error %s errno=%d\r\n", filename, errno);
        print_f(rs->plogs, "fIle", rs->logs);
        return -1;
    }

    sprintf_f(rs->logs,"open m4 sample file: [%s] file: %d, img: %d, max: %d\n", filename, simidx, imgidx, simmax);
    print_f(rs->plogs, "fIle", rs->logs);
    

    ret |= fseek(f, 0, SEEK_END);

    size = ftell(f);

    ret |= fseek(f, 0, SEEK_SET);

    if (ret) {
        return -3;
    }

    decraw = &pdec->aspDecRaw; //bmp
    decimgp = decraw->aspDcData;

    decmeta = &pdec->aspDecMeta; //meta

    decexmt = &pdec->aspDecMetaex; //meta
    
    img_param = decimgp;

    if (size > decraw->aspDcMax) {
        fclose(f);
        return -4;
    }

    image_size = fread(img_param->mfourData, 1, size, f);
    if ((image_size < 0) || (image_size != size)) {
        sprintf_f(rs->logs,"read file error %s errno=%d ret=%d \r\n", filename, errno, image_size);
        print_f(rs->plogs, "fIle", rs->logs);
        fclose(f);
        return -5;
    }
    
    fclose(f);
    
    tail = size % 512;
    mul = (size - tail) / 512;

    sprintf_f(rs->logs,"read file: [%s] size: %d, mul: %d, tail: %d \n", filename, size, mul, tail);
    print_f(rs->plogs, "fIle", rs->logs);

    for (ix=0; ix < mul; ix++) {
        shf = (mul - ix) * 512;
        pt = img_param->mfourData + shf;
        
        if (pt[0] == 'A') {
            if ((pt[1] == 'S') && (pt[2] == 'P') && (pt[3] == 'C')) {
                pmeta = pt;
                break;
            }
        }
        
        /*
        else {
            sprintf_f(rs->logs,"%d. [0x%.8x]: 0x%.2x \n", ix, shf, pt[0]);
            print_f(rs->plogs, "fIle", rs->logs);
        }
        */
    }

    if (!pmeta) {
        sprintf_f(rs->logs,"Error!!! can't find meta search count: %d \n", ix);
        print_f(rs->plogs, "fIle", rs->logs);
        return -6;
    }
    
    rawlen = pmeta - img_param->mfourData;

    val = size - rawlen;

    tail = val % 16;
    mul = (val - tail) / 16;
    
    for (ix=0; ix < (mul - 1); ix++) {
        shf = (ix + 1) * 16;
        pt = pmeta + shf;

        if ((pt[0] == 'Y') && (pt[1] == 'L')) {
            pexmt = pt;
        }
    }

    if (!pexmt) return -7;
    mtlen = pexmt - pmeta;
    exlen = size - rawlen - mtlen;
    
    pusbmeta = (struct aspMetaDataviaUSB_s *)pmeta;

    pt = (unsigned char *)&(pusbmeta->YLines_Recorded);
    val = (pt[0] << 8) | pt[1];
    yllen = (val * 4) + 4;

    val = (pexmt[2] << 8) | pexmt[3];
    val += 4;

    if (imgidx % 2) {
        pusbmeta->PRI_O_SEC = 1;
    } else {
        pusbmeta->PRI_O_SEC = 0;
    }

    pusbmeta->Scaned_Page[0] = imgidx & 0xff;
    pusbmeta->Scaned_Page[1] = (imgidx >> 8) & 0xff;

    sprintf_f(rs->logs, "mass len: %d m_len: %d rec_len: %d meta_len: %d jpeg_len: %d updn: %d\n", exlen, val, yllen, mtlen, rawlen, pusbmeta->PRI_O_SEC); 
    print_f(rs->plogs, "fIle", rs->logs);

    if ((exlen != yllen) || (exlen != val)) {
        sprintf_f(rs->logs,"Error!!! extra len not match, len: %d should be %d or %d \n", exlen, yllen, val);
        print_f(rs->plogs, "fIle", rs->logs);
        return -8;
    }

    memcpy(decmeta->aspDcData->mfourData, pmeta, mtlen - 64);
    aspBMPdecodeItemSet(decmeta, 0, 0, mtlen - 64);

    memcpy(decexmt->aspDcData->mfourData, pexmt, exlen);
    aspBMPdecodeItemSet(decexmt, 0, 0, exlen);

    /*
    pimgw = (int *)(img_param->mfourData+0x12);
    pimgh = (int *)(img_param->mfourData+0x16);
    imgw = pimgw[0];
    imgh = pimgh[0];
    */

    imgw = (pusbmeta->IMG_WIDTH[1] << 8) | pusbmeta->IMG_WIDTH[0];
    imgh = pusbmeta->IMG_HIGH[0] | (pusbmeta->IMG_HIGH[1] << 8);

    img_param->mfourAttb.ImageRect.xc = imgw;
    img_param->mfourAttb.ImageRect.yr = imgh;

    decraw->aspDcLen = image_size + sizeof(mfour_image_param_st);
    
    aspBMPdecodeItemSet(decraw, imgw, imgh, rawlen+160);
    
    //sprintf(img_param->mfourFilename, fname, imgidx);
    //strncpy(img_param->mfourFilename, file_entry->d_name, sizeof(img_param->mfourFilename));

    sprintf_f(rs->logs,"open image (w=%d h=%d size=%d)\r\n", img_param->mfourAttb.ImageRect.xc, img_param->mfourAttb.ImageRect.yr, image_size);
    print_f(rs->plogs, "fIle", rs->logs);

    #if 0
    cmd.cmd = BKCMD_IMAGE_IN;
    cmd.tag = idx << 16;
    cmd.rsp = 0;
    cmd.dPtr = img_param;
    cmd.dSize = size;
    #endif

    return 0;
}

/*
static int send_image_in_bmp(struct procRes_s *rs, int mbidx, int imgidx)
{
    int image_size=0;
    //mfour_rjob_cmd cmd;
    char filename[256]={0};
    char fname[32] = "test%.1d.bmp";
    char filetest[32] = "/asptest/test%.1d.bmp";
    int ret=0;
    FILE *f=0;
    int size=0;
    int imgw=0, imgh=0;
    int *pimgw=0, *pimgh=0;
    struct bitmapDecodeItem_s *decraw=0;
    mfour_image_param_st *decimgp=0, *img_param=0;
    
    sprintf(filename, filetest, imgidx);

    f = fopen(filename, "r");
    if(!f) {
        sprintf_f(rs->logs,"open file error %s errno=%d\r\n", filename, errno);
        print_f(rs->plogs, "fIle", rs->logs);
        
        return -1;
    }

    ret |= fseek(f, 0, SEEK_END);

    size = ftell(f);

    ret |= fseek(f, 0, SEEK_SET);

    if (ret) {
        return -2;
    }

    decraw = &rs->pbDecMfour[mbidx]->aspDecRaw; //replace raw
    decimgp = decraw->aspDcData;

    img_param = decimgp;

    if (size > decraw->aspDcMax) {
        fclose(f);
        return -3;
    }

    image_size = fread(img_param->mfourData, 1, size, f);

    if (image_size < 0) {
        sprintf_f(rs->logs,"read file error %s errno=%d ret=%d \r\n", filename, errno, image_size);
        print_f(rs->plogs, "fIle", rs->logs);
        fclose(f);
        return -4;
    }
    
    fclose(f);

    pimgw = (int *)(img_param->mfourData+0x12);
    pimgh = (int *)(img_param->mfourData+0x16);

    imgw = pimgw[0];
    imgh = pimgh[0];
        
    img_param->mfourAttb.ImageRect.xc = imgw;
    img_param->mfourAttb.ImageRect.yr = imgh;

    decraw->aspDcLen = image_size + sizeof(mfour_image_param_st);
    
    aspBMPdecodeItemSet(decraw, imgw, imgh, image_size + sizeof(mfour_image_param_st));
    
    //sprintf(img_param->mfourFilename, fname, imgidx);
    //strncpy(img_param->mfourFilename, file_entry->d_name, sizeof(img_param->mfourFilename));

    sprintf_f(rs->logs,"open image file (w=%d h=%d size=%d)\r\n", img_param->mfourAttb.ImageRect.xc, img_param->mfourAttb.ImageRect.yr, image_size);
    print_f(rs->plogs, "fIle", rs->logs);

    #if 0
    cmd.cmd = BKCMD_IMAGE_IN;
    cmd.tag = idx << 16;
    cmd.rsp = 0;
    cmd.dPtr = img_param;
    cmd.dSize = size;
    #endif

    return 0;
}
*/

static int AllocateImgParamImgDataR(t_ImageParam	*SrcBKJobImg_Param)
{
		int				Temp2, ipt;
		int				 yr, xc;
		unsigned char 	*SrcTemp_ptr, *DstTemp_ptr, *TempPtr;
		
		unsigned char 	*NewImageIP_Param;
		t_ImageParam	*BKJobImg_Param;
		t_Imgheader 	*DstImgRect;
		int 			ReqImageSize, JobImgParam_Size, allbuf_size;

		DstImgRect=(t_Imgheader *)&SrcBKJobImg_Param->ImageRect;
		JobImgParam_Size=sizeof(t_ImageParam);
		
		/*
		log_i( "JobImgParam_Size=%8x\r\n", JobImgParam_Size);
		
		yr=DstImgRect->yr;
		xc=DstImgRect->xc;		
		//xc must be multiple of 4
			Temp2 = xc >> 2;
		if ( xc != (Temp2 << 2))
			xc = (Temp2 + 1) << 2;
		DstImgRect->xc=xc;		
		ReqImageSize=xc*yr;
		
		allbuf_size= JobImgParam_Size + ReqImageSize;
		log_i( "allbuf_size=%8x\r\n", allbuf_size);

		//allocate all memory together
		NewImageIP_Param = (unsigned char *)malloc(allbuf_size); 
		log_i( "NewImageIP_Param = %p\r\n", NewImageIP_Param);
		if (NewImageIP_Param == NULL)
		{
			log_i(" NewImageIP_Param allmemory alloc fail ");
//			getchar();
			return 0;
		}
		
		BKJobImg_Param = (t_ImageParam	*)NewImageIP_Param;
		DstTemp_ptr = (unsigned char *)BKJobImg_Param ;
		SrcTemp_ptr = (unsigned char *)SrcBKJobImg_Param;
		log_i( "SrcTemp_ptrImgParam = %p\r\n", SrcTemp_ptr);
		log_i( "DstTemp_ptr = %p\r\n", DstTemp_ptr);
		for( ipt = 0; ipt < JobImgParam_Size; ipt++)
		{
			*DstTemp_ptr = *SrcTemp_ptr;	   
			SrcTemp_ptr ++;
			DstTemp_ptr ++;
		}
		BKJobImg_Param->IpPAMemorySize=allbuf_size;
				
		return (NewImageIP_Param);
		*/
		return 0;
	
}

#define DUMP_ROT_BMP (0)
#define LOG_ROT_EN (1)
static int handle_cmd_require_areaR(struct procRes_s *rs, int clidx, int mfidx, int midx)
{
    int ret=0;
    char *dst=0, *src=0, *bmpraw=0;
    int pimgY=0, iy=0, ix=0;
    mfour_rect_st *pDeRect=0;
    mfour_image_param_st *imgbuf=0;
    mfour_image_param_st *porgimg=0;
    struct bitmapDecodeItem_s *decraw=0, *decpic=0, *decmeta=0;
    struct aspMetaDataviaUSB_s *pusbmeta=0;
    int abuf_size;
    struct timespec jpgS, jpgE;
    int edwhA[2]={0}, edwhB[2]={0};
    int srhcntA[2]={0}, srhcntB[2]={0};
    int idxA=0, idxB=0, tmCost=0;
    CFLOAT infoPos[4];
    signed short rotAngle=0;
    
    #if DUMP_ROT_BMP
    static char ptfileSave[] = "/home/root/rotate/rot_%.3d.bmp";
    static char ptfileRawSave[] = "/home/root/rotate/raw_%.3d.bmp";
    char filepath[256]={0};
    FILE *fdump=0;
    #endif
    
    decraw = &rs->pbDecMfour[mfidx]->aspDecRaw;

    #if LOG_ROT_EN
    sprintf_f(rs->logs,"raw info w: %d h: %d len: %d id: %d - %d  !!!\n", decraw->aspDcWidth, decraw->aspDcHeight, decraw->aspDcLen, mfidx, clidx);
    print_f(rs->plogs, "CLIP", rs->logs);
    #endif

    if (decraw->aspDcLen == 0) {
        return -1;
    }

    porgimg = decraw->aspDcData;
    
    #if LOG_ROT_EN
    sprintf_f(rs->logs,"ocr img param info w: %d h: %d !!!\n", porgimg->mfourAttb.ImageRect.xc, porgimg->mfourAttb.ImageRect.yr);
    print_f(rs->plogs, "CLIP", rs->logs);
    #endif

    //if (porgimg->mfourImgW == 0) return -2;

    decmeta = &rs->pbDecMfour[mfidx]->aspDecMeta;
    decpic = &rs->pbDecMfour[mfidx]->aspDecMfPiRaw[clidx];
    pDeRect = &rs->pbDecMfour[mfidx]->aspDecRect[clidx];

    if((pDeRect->mfourRectW & 3) != 0) {
        sprintf_f(rs->logs,"require area width not 4byte alignment !!! \r\n" );
        print_f(rs->plogs, "CLIP", rs->logs);
    }

    pDeRect->mfourRectW &= 0xFFFC;    // width should be 4byte alignment
    abuf_size = pDeRect->mfourRectW * pDeRect->mfourRectH + sizeof(mfour_image_param_st);

    #if LOG_ROT_EN        
    sprintf_f(rs->logs,"require area x: %d y: %d w: %d h: %d Layer: %d \n", pDeRect->mfourRectX, pDeRect->mfourRectY, pDeRect->mfourRectW, pDeRect->mfourRectH, pDeRect->mfourLayer);
    print_f(rs->plogs, "CLIP", rs->logs);
    #endif
    
    if(abuf_size > (16 * 1024)) {
        sprintf_f(rs->logs,"ERROR : require area too large !!! \r\n");
        print_f(rs->plogs, "CLIP", rs->logs);
    }

    imgbuf = decpic->aspDcData;
    imgbuf->mfourIdx = clidx;
    imgbuf->mfourAttb.ImageRect.xc = pDeRect->mfourRectW;
    imgbuf->mfourAttb.ImageRect.yr = pDeRect->mfourRectH;

    clock_gettime(CLOCK_REALTIME, &jpgS);

    int *cutsides=0, *cutlayers=0;
    int cutcnt = 0, rawlen=0, bhlen=0, prisec=0, dstlen=0, cutnum=0, mtlen=0;
    struct usbhost_s *pushost=0;
    struct aspMetaData_s *metaRx = 0;
    struct bitmapHeader_s *bheader=0, *rawheader=0;
    char *metaPt=0, *bmpbuff=0, *bmpcolrtb=0, *bmprot=0, *bmpmeta=0;
    char *dstbuff=0, *ph=0, *phraw=0;
    uint32_t utmp=0, crod=0;
    int mreal[8]={0};

    bheader = rs->pbheader;
    ph = &bheader->aspbmpMagic[2];
    
    pushost = rs->pusbhost;
    metaPt = pushost->puhsmeta;
    metaRx = (struct aspMetaData_s *)metaPt;

    cutcnt =0;
    cutnum = msb2lsb16(&metaRx->BKNA_NUM);

    cutsides = aspMemalloc(cutnum*sizeof(int)*2, midx);
    memset(cutsides, 0, cutnum*sizeof(int)*2);
    cutlayers = aspMemalloc(cutnum*sizeof(int)*2, midx);
    memset(cutlayers, 0, cutnum*sizeof(int)*2);
    ret = 0;

    ret = aspMetaGetPages(metaRx, cutsides, cutlayers, cutnum);
    //sprintf_f(rs->logs, "[CUT] get page ret: %d num: %d\n", ret, cutnum);
    //print_f(rs->plogs, "CLIP", rs->logs);

    cutnum = ret;
    
    /*
    for (ix=0; ix < cutnum; ix++) {
        sprintf_f(rs->logs, "[CUT] clips %d. A:%d (%d) B:%d (%d), cur: %d \n", ix, cutsides[ix*2], cutlayers[ix*2], cutsides[ix*2+1], cutlayers[ix*2+1], clidx);
        print_f(rs->plogs, "CLIP", rs->logs);
    }
    */

    cutcnt = clidx;
    
    aspBMPdecodeItemGet(decmeta, &bmpmeta, &mtlen);
    pusbmeta = (struct aspMetaDataviaUSB_s *)bmpmeta;
    utmp = msb2lsb32(&pusbmeta->CROP_POS_F1);
    crod = utmp & 0xffff;
    utmp = utmp >> 16;
    mreal[0] = utmp;
    mreal[1] = crod;

    utmp = msb2lsb32(&pusbmeta->CROP_POS_F2);
    crod = utmp & 0xffff;
    utmp = utmp >> 16;
    mreal[2] = utmp;
    mreal[3] = crod;

    utmp = msb2lsb32(&pusbmeta->CROP_POS_F3);
    crod = utmp & 0xffff;
    utmp = utmp >> 16;
    mreal[4] = utmp;
    mreal[5] = crod;

    utmp = msb2lsb32(&pusbmeta->CROP_POS_F4);
    crod = utmp & 0xffff;
    utmp = utmp >> 16;
    mreal[6] = utmp;
    mreal[7] = crod;

    //sprintf_f(rs->logs, "meta size: %d, P1: (%4d, %4d) P2: (%4d, %4d) P3: (%4d, %4d) P4: (%4d, %4d) \n", mtlen, mreal[0], mreal[1], mreal[2], mreal[3], mreal[4], mreal[5], mreal[6], mreal[7]);
    //print_f(rs->plogs, "CLIP", rs->logs);    
    
    aspBMPdecodeItemGet(decraw, &bmpbuff, &rawlen);
    msync(bmpbuff, rawlen, MS_SYNC);
    
    bmpcolrtb = aspMemalloc(1080, midx);
    memcpy(bmpcolrtb, bmpbuff, 1078);
    //dbgBitmapHeader(bheader, sizeof(struct bitmapHeader_s)-2);
    
    #if DUMP_ROT_BMP    
    fdump = find_save(filepath, ptfileRawSave);
    if (fdump) {
        sprintf_f(rs->logs, "find save raw bmp [%s] succeed!!! \n", filepath);
        print_f(rs->plogs, "CLIP", rs->logs);
    }
    
    ret = fwrite((char*)bmpbuff, 1, rawlen, fdump);
    sprintf_f(rs->logs, "write [%s] size: %d / %d !!! \n", filepath, ret, rawlen);
    print_f(rs->plogs, "CLIP", rs->logs);

    fflush(fdump);
    fclose(fdump);
    sync();
    #endif
    
    bhlen = 0x436;
    aspBMPdecodeItemGet(decpic, &dstbuff, &dstlen);

    dstlen = pDeRect->mfourRectW * pDeRect->mfourRectH;
    msync(dstbuff, dstlen, MS_SYNC);
    
    bmprot = dstbuff;

    //sprintf_f(rs->logs, "raw size: %d, dst size: %d \n", rawlen, dstlen);
    //print_f(rs->plogs, "CLIP", rs->logs);    

    int cropinfo[8]; // x, y, w, h, imgW, imgH

    #if 1
    cropinfo[0] = (int)pDeRect->mfourRectX;
    cropinfo[1] = (int)pDeRect->mfourRectY;
    cropinfo[2] = (int)pDeRect->mfourRectW;
    cropinfo[3] = (int)pDeRect->mfourRectH;
    cropinfo[4] = 0;
    cropinfo[5] = 0;
    cropinfo[6] = ((pDeRect->mfourLayer >= 1) && (pDeRect->mfourLayer <= pusbmeta->BKNote_Total_Layers)) ? (pDeRect->mfourLayer - 1):0;
    cropinfo[7] = ((pusbmeta->BKNote_Total_Layers > 0) && (pusbmeta->BKNote_Total_Layers < 9)) ? pusbmeta->BKNote_Total_Layers:1;
    #else
    idxA = cutsides[cutcnt*2];

    ret = aspMetaGetPagePos(metaRx, infoPos, idxA);
    if (ret < 0) {
        sprintf_f(rs->logs, "Error!!! get A side pos wrong ret: %d !!! \n", ret);
        print_f(rs->plogs, "CLIP", rs->logs);
    }

    cropinfo[0] = (int)infoPos[0];
    cropinfo[1] = (int)infoPos[1];
    cropinfo[2] = (int)infoPos[2];
    cropinfo[3] = (int)infoPos[3];

    ret = aspMetaGetWH(metaRx, &cropinfo[4], srhcntA, 0);
    if (ret < 0) {
        sprintf_f(rs->logs, "Error!!! get A side tag wh & search count wrong ret: %d !!! \n", ret);
        print_f(rs->plogs, "CLIP", rs->logs);
    }

    //sprintf_f(rs->logs, "get A side idx: %d pos (%4d, %4d, %4d, %4d, %4d, %4d) !!! \n", idxA, cropinfo[0], cropinfo[1], cropinfo[2], cropinfo[3], cropinfo[4], cropinfo[5]);
    //print_f(rs->plogs, "CLIP", rs->logs);
    #endif

    sprintf(rs->logs, "__ROTATE_START__(%dx%d)", cropinfo[2], cropinfo[3]); 
    tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 32, rs->logs);
                
    ret = rotateBMPMf(bmprot, bmpcolrtb, cropinfo, bmpbuff+1078, mreal, 0xa5, midx);

    sprintf(rs->logs, "__ROTATE_END__"); 
    tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 32, rs->logs);

    clock_gettime(CLOCK_REALTIME, &jpgE);

    tmCost = time_diff(&jpgS, &jpgE, 1000);
    sprintf_f(rs->logs, "m4 rotate bmp cost: %d.%d ms\n", tmCost/1000, tmCost%1000);
    print_f(rs->plogs, "CLIP", rs->logs);

    memcpy(ph, bmpcolrtb, sizeof(struct bitmapHeader_s)-2);
    if (ret) {
        memset(dstbuff, 0, pDeRect->mfourRectW*pDeRect->mfourRectH);
        aspBMPdecodeItemSet(decpic, pDeRect->mfourRectW, pDeRect->mfourRectH, abuf_size);
    } else {
        abuf_size = bheader->aspbiRawSize + sizeof(mfour_image_param_st);
        aspBMPdecodeItemSet(decpic, bheader->aspbiWidth, bheader->aspbiHeight, abuf_size);
        pDeRect->mfourRectW = bheader->aspbiWidth;
        pDeRect->mfourRectH = bheader->aspbiHeight;
        imgbuf->mfourAttb.ImageRect.xc = pDeRect->mfourRectW;
        imgbuf->mfourAttb.ImageRect.yr = pDeRect->mfourRectH;
        imgbuf->mfourAttb.BKNoteImageRect.xc = cropinfo[4];
        imgbuf->mfourAttb.BKNoteImageRect.yr = cropinfo[5];
    }

    sprintf_f(rs->logs, "m4 rotate angle: %.3d.%.2d degree (%d) \n", bheader->aspbiNumImpColor/100, abs(bheader->aspbiNumImpColor%100), bheader->aspbiNumImpColor);
    print_f(rs->plogs, "CLIP", rs->logs);

    rotAngle = bheader->aspbiNumImpColor;

    pusbmeta->OCR_rotangle[0] = rotAngle & 0xff;
    pusbmeta->OCR_rotangle[1] = (rotAngle >> 8) & 0xff;
    
    msync(bmprot, abuf_size, MS_SYNC);
    
    //sprintf_f(rs->logs, "dump 512 bytes cropping result addr: 0x%.8x size: %d \n", (uint32_t)bmprot, abuf_size);
    //print_f(rs->plogs, "CLIP", rs->logs);    

    //shmem_dump(bmprot, 512);

    //sprintf_f(rs->logs, "rotate result w: %d, h: %d size: %d ret: %d\n", pDeRect->mfourRectW, pDeRect->mfourRectH, abuf_size, ret);
    //print_f(rs->plogs, "CLIP", rs->logs);    

    #if DUMP_ROT_BMP
    //sprintf_f(rs->logs, "show result bmp header: \n");
    //print_f(rs->plogs, "CLIP", rs->logs);    

    //dbgBitmapHeader(bheader, sizeof(struct bitmapHeader_s)-2);
    //memcpy(bmpcolrtb, ph, sizeof(struct bitmapHeader_s)-2);
    
    fdump = find_save(filepath, ptfileSave);
    if (fdump) {
        sprintf_f(rs->logs, "find save bmp [%s] succeed!!! \n", filepath);
        print_f(rs->plogs, "CLIP", rs->logs);
    }

    msync(bmpcolrtb, bhlen, MS_SYNC);
    ret = fwrite((char*)bmpcolrtb, 1, bhlen, fdump);
    //sprintf_f(rs->logs, "write [%s] size: %d / %d !!! \n", filepath, ret, bhlen);
    //print_f(rs->plogs, "CLIP", rs->logs);

    msync(bmprot, abuf_size, MS_SYNC);
    ret = fwrite((char*)bmprot, 1, abuf_size, fdump);
    //sprintf_f(rs->logs, "write [%s] size: %d / %d !!! \n", filepath, ret, abuf_size);
    //print_f(rs->plogs, "CLIP", rs->logs);
    

    fflush(fdump);
    fclose(fdump);
    sync();
    #endif
                                                
    /*                    
    bmpraw = porgimg->mfourData + 0x436;
    for(iy=0; iy< imgbuf->mfourImgH; iy++)
    {
        pimgY = (pDeRect->mfourRectY+iy)*porgimg->mfourImgW;

        dst = imgbuf->mfourData + iy*imgbuf->mfourImgW;
        src = bmpraw + pimgY + pDeRect->mfourRectX;

        memcpy(dst, src, imgbuf->mfourImgW);
    }
    sprintf_f(rs->logs, "find and set area %d: x=%d,y=%d,w=%d,h=%d \n", clidx, pDeRect->mfourRectX, pDeRect->mfourRectY, pDeRect->mfourRectW, pDeRect->mfourRectH);
    print_f(rs->plogs, "CLIP", rs->logs);    

    aspBMPdecodeItemSet(decpic, pDeRect->mfourRectW, pDeRect->mfourRectH, abuf_size);
    */
    


    return 0;
}

static int handle_cmd_require_area(struct procRes_s *rs, int clidx, int mfidx)
{
    char *dst=0, *src=0, *bmpraw=0;
    int pimgY=0, iy=0;
    mfour_rect_st *pDeRect=0;
    mfour_image_param_st *imgbuf=0;
    mfour_image_param_st *porgimg=0;
    struct bitmapDecodeItem_s *decraw=0, *decpic=0;
    int abuf_size;

    decraw = &rs->pbDecMfour[mfidx]->aspDecRaw;
    sprintf_f(rs->logs,"raw info w: %d h: %d len: %d id: %d - %d  !!!\n", decraw->aspDcWidth, decraw->aspDcHeight, decraw->aspDcLen, mfidx, clidx);
    print_f(rs->plogs, "CLIP", rs->logs);

    if (decraw->aspDcLen == 0) {
        return -1;
    }

    porgimg = decraw->aspDcData;
    sprintf_f(rs->logs,"img param info w: %d h: %d  !!!\n", porgimg->mfourAttb.ImageRect.xc, porgimg->mfourAttb.ImageRect.yr);
    print_f(rs->plogs, "CLIP", rs->logs);

    //if (porgimg->mfourImgW == 0) return -2;

    decpic = &rs->pbDecMfour[mfidx]->aspDecMfPiRaw[clidx];
    pDeRect = &rs->pbDecMfour[mfidx]->aspDecRect[clidx];

    if((pDeRect->mfourRectW & 3) != 0) {
        sprintf_f(rs->logs,"require area width not 4byte alignment !!! \r\n" );
        print_f(rs->plogs, "CLIP", rs->logs);
    }

    pDeRect->mfourRectW &= 0xFFFC;    // width should be 4byte alignment
    abuf_size = pDeRect->mfourRectW * pDeRect->mfourRectH + sizeof(mfour_image_param_st);

    if(abuf_size > (16 * 1024)) {
        sprintf_f(rs->logs,"ERROR : require area too large !!! \r\n");
        print_f(rs->plogs, "CLIP", rs->logs);
    }

    imgbuf =  decpic->aspDcData;
    imgbuf->mfourIdx = clidx;
    imgbuf->mfourAttb.ImageRect.xc = pDeRect->mfourRectW;
    imgbuf->mfourAttb.ImageRect.yr = pDeRect->mfourRectH;

    bmpraw = porgimg->mfourData + 0x436;
    for(iy=0; iy< imgbuf->mfourAttb.ImageRect.yr; iy++)
    {
        pimgY = (pDeRect->mfourRectY+iy)*porgimg->mfourAttb.ImageRect.xc;

        dst = imgbuf->mfourData + iy*imgbuf->mfourAttb.ImageRect.xc;
        src = bmpraw + pimgY + pDeRect->mfourRectX;

        memcpy(dst, src, imgbuf->mfourAttb.ImageRect.xc);
    }

    sprintf_f(rs->logs, "find and set area %d: x=%d,y=%d,w=%d,h=%d \n", clidx, pDeRect->mfourRectX, pDeRect->mfourRectY, pDeRect->mfourRectW, pDeRect->mfourRectH);
    print_f(rs->plogs, "CLIP", rs->logs);    

    aspBMPdecodeItemSet(decpic, pDeRect->mfourRectW, pDeRect->mfourRectH, abuf_size);

    return 0;
}

static int save_done_area(struct procRes_s *rs, int clidx, int mfidx)
{
    int ret=0, imgsize=0;
    FILE *fp=0;
    char filename[256]={0};
    char tailname[32] = "_%.3d.bmp";
    char filesave[32] = "/asptest/out_%.1d_%.1d";
    char *ptr=0;
    
    sprintf(filename, filesave, mfidx+1, clidx+1);

    strcat(filename, tailname);

    sprintf_f(rs->logs, "find save filename[%s] \n", filename);
    print_f(rs->plogs, "SAVE", rs->logs);   
    
    ret = file_save_get(&fp, filename);
    if (ret) {
        return -1;
    }

    imgsize = rs->pbDecMfour[mfidx]->aspDecMfPiRaw[clidx].aspDcLen;
    ptr = rs->pbDecMfour[mfidx]->aspDecMfPiRaw[clidx].aspDcData->mfourData;

    ret = fwrite(ptr, 1, imgsize, fp);

    fflush(fp);

    fclose(fp);

    return 0;
}

#define SAVE_DONE_IMG (0)
#define LOG_P12_EN (1)
static int p12(struct procRes_s *rs)
{
    char cmdstr[] = "/usr/local/projects/BANK_COMMON/fw_cortex_m4.sh start BANK_COMMON";
    char devstr[] = "/dev/rjob0";
    int *cutsides=0, *cutlayers=0;
    char *bmpcolrtb=0, *ph=0, *bmprot=0, *bmpbuff=0, *bmpbufc=0, *bmpcpy=0, *metaPt=0, *exmeta=0, *buffmeta=0;
    int ret=0, mfbidx=0, tcmd=0, mfbstat=0, colr=0, blen=0, bhlen=0, bdpp=0, val=0, bmpw=0, bmph=0, bdpi=0, tmp=0, err=0;
    int prisec=0, cutcnt=0, cutnum=0, tmCost=0, rotlen=0, jpgLen, mreal[2]={0}, updn=0, lenbs=0, bmpmax=0;
    int lastCylen=0, lrst=0, ix=0, uselen=0, rstlen=0, exmlen=0, exmax=0, bmtlen=0, bmtmax=0, imgidx=0, pipRet=0, mfcmd=0;
    int cid=0, testcnt=0;
    uint32_t fformat=0;
    char ch=0, chm=0;
    unsigned char *jpgrlt=0;
    char *rotsrc[8]={0}, *rotdst[8]={0};
    int rotsmax[8]={0}, rotdmax[8]={0};
    struct sdParseBuff_s *pabuff=0;
    struct timespec jpgS, jpgE;
    struct usbhost_s *pushost=0;
    struct aspMetaData_s *metaRx = 0;
    struct aspConfig_s *pct=0, *pdt=0;
    struct bitmapHeader_s *bheader=0;
    struct aspMetaDataviaUSB_s *ptmetausb=0;
    struct bitmapDecodeItem_s *pdecroi=0, *penroi=0;
    char pinfo[8]={0};
    int *pipeMfRx=0, *pipeMfTx=0;
    struct pollfd pllfd[2]={0};
    int cropinfo[8]={0};

    sprintf_f(rs->logs, "p12\n");
    print_f(rs->plogs, "P12", rs->logs);

    p12_init(rs);

    prctl(PR_SET_NAME, "msp-p12");

    pct = rs->pcfgTable;
    pabuff = &rs->psFat->parBuf;
    rs->pbheader = malloc(sizeof(struct bitmapHeader_s));
    bheader = rs->pbheader;
    memset(bheader, 0, sizeof(struct bitmapHeader_s));
    //ptmetausb = rs->pmetausb;

    pushost = rs->pusbhost;
    metaPt = pushost->puhsmeta;
    metaRx = (struct aspMetaData_s *)metaPt;
    
    while (1) {
        
        ret = rs_ipc_get_ms(rs, &ch, 1, 5000);

        if (ret > 0) {
            #if LOG_P12_EN
            sprintf_f(rs->logs, "m4 get ch[0x%.2x] \n", ch);
            print_f(rs->plogs, "P12", rs->logs);
            #endif
        } else {
            //rs_ipc_put(rs, "h", 1);
        
            //sprintf_f(rs->logs, "host not available !!\n");
            //print_f(rs->plogs, "P12", rs->logs);

            continue;
        }

        tcmd = ch;

        switch (tcmd) {
        case '1':
            pinfo[0] = '1';

            testcnt = 0;
            
            rs_ipc_put(rs, pinfo, 1);
            break;
        case 'f':
            ret = rs_ipc_get_ms(rs, &ch, 1, 5000);
            if (ret > 0) {
            
                #if LOG_P12_EN
                sprintf_f(rs->logs, "f get cont ch[0x%.2x] \n", ch);
                print_f(rs->plogs, "P12", rs->logs);
                #endif

                if (ch == 0x80) {
                    mfbidx = 0;
                } else {
                    mfbidx = ch & 0x7f;
                }

                if (mfbidx > 3) {
                    sprintf_f(rs->logs, "get buff index %d error!!! \n", mfbidx);
                    print_f(rs->plogs, "P12", rs->logs);
                    break;
                } else {
                    //sprintf_f(rs->logs, "get buff index %d succed!!! \n", mfbidx);
                    //print_f(rs->plogs, "P12", rs->logs);
                }

                imgidx = 0;
                mfbstat = 0;
                ret = aspBMPdecodeBuffGetIdx(rs->pbDecMfour[mfbidx], &imgidx);
                ret = aspBMPdecodeBuffStatusGet(rs->pbDecMfour[mfbidx], &mfbstat);
                sprintf_f(rs->logs, "get mfbuff index %d, imgindex: %d, status 0x%x succeed!!! \n", mfbidx, imgidx, mfbstat);
                print_f(rs->plogs, "P12", rs->logs);

                //#if MFOUR_SIM_MODE_BMP
                //ret = send_image_in_bmp(rs, mfbidx, (testcnt%4)+1);
                //testcnt += 1;
                //#endif // #if MFOUR_SIM_MODE_BMP

                if ((!ret) && (!mfbstat)) {
                    pinfo[0] = 'F';
                    pinfo[1] = ch;

                    rs_ipc_put(rs, pinfo, 2);

                    pipeMfRx = rs->pbDecMfour[mfbidx]->aspPipeMfourRx;
                    pipeMfTx = rs->pbDecMfour[mfbidx]->aspPipeMfourTx;

                    pllfd[0].fd = pipeMfRx[0];
                    pllfd[0].events = POLLIN;

                    while (1) {
                        pipRet = poll(pllfd, 1, 500);
                        if (pipRet > 0) {
                            ret = read(pllfd[0].fd, &chm, 1);

                            #if LOG_P12_EN
                            sprintf_f(rs->logs, "m4crop get chm from mfour rx, chm: %c [0x%.2x]\n", chm, chm);
                            print_f(rs->plogs, "P12", rs->logs);
                            #endif
                        
                            mfcmd = chm;
                        
                            switch (mfcmd) {
                            //case BKCMD_IMAGE_IN:            // receive scanner cmd
                            //    break;
                            case 'C': //BKCMD_REQUIRE_AREA:        // receive M4-postman cmd
                                ret = read(pllfd[0].fd, &chm, 1);
                                
                                #if LOG_P12_EN
                                sprintf_f(rs->logs, "C get cont chm from mfour rx, chm: %c [0x%.2x]\n", chm, chm);
                                print_f(rs->plogs, "P12", rs->logs);
                                #endif

                                if (chm == 0x80) {
                                    cid = 0;
                                } else {
                                    cid = chm & 0x7f;
                                }

                                if (cid > 3) {
                                    sprintf_f(rs->logs, "get clip index %d error!!! \n", cid);
                                    print_f(rs->plogs, "P12", rs->logs);
                                    break;
                                } else {
                                    //sprintf_f(rs->logs, "get clip index %d succed!!! \n", cid);
                                    //print_f(rs->plogs, "P12", rs->logs);
                                }
                                
                                pinfo[0] = 'b';
                                pinfo[1] = chm;

                                write(pipeMfTx[1], pinfo, 2);
                                
                                break;
                            case 'c': //BKCMD_REQUIRE_AREA:        // receive M4-postman cmd
                                ret = read(pllfd[0].fd, &chm, 1);
                                
                                #if LOG_P12_EN
                                sprintf_f(rs->logs, "c get cont chm from mfour rx, chm: %c [0x%.2x]\n", chm, chm);
                                print_f(rs->plogs, "P12", rs->logs);
                                #endif

                                if (chm == 0x80) {
                                    cid = 0;
                                } else {
                                    cid = chm & 0x7f;
                                }

                                if (cid > 3) {
                                    sprintf_f(rs->logs, "get clip index %d error!!! \n", cid);
                                    print_f(rs->plogs, "P12", rs->logs);
                                    break;
                                } else {
                                    //sprintf_f(rs->logs, "get clip index %d succed!!! \n", cid);
                                    //print_f(rs->plogs, "P12", rs->logs);
                                }

                                sprintf_f(rs->logs, "process current buff id: %d cid: %d \n", mfbidx, cid);
                                print_f(rs->plogs, "P12", rs->logs);
                
                                ret = handle_cmd_require_areaR(rs, cid, mfbidx, 12);
                                if (ret) {
                                    sprintf_f(rs->logs, "Error!!! mfour require area failed ret: %d \n", ret);
                                    print_f(rs->plogs, "P12", rs->logs);
                                }
                                
                                break;
                            case 'd': //BKCMD_DONE_AREA:           // receive M4-postman cmd
                                ret = read(pllfd[0].fd, &chm, 1);

                                #if LOG_P12_EN
                                sprintf_f(rs->logs, "d get cont chm from mfour rx, chm: %c [0x%.2x]\n", chm, chm);
                                print_f(rs->plogs, "P12", rs->logs);
                                #endif

                                if (chm == 0x80) {
                                    cid = 0;
                                } else {
                                    cid = chm & 0x7f;
                                }

                                if (cid > 3) {
                                    sprintf_f(rs->logs, "get clip index %d error!!! \n", cid);
                                    print_f(rs->plogs, "P12", rs->logs);
                                    break;
                                } else {
                                    //sprintf_f(rs->logs, "get clip index %d succed!!! \n", cid);
                                    //print_f(rs->plogs, "P12", rs->logs);
                                }

                                #if SAVE_DONE_IMG
                                ret = save_done_area(rs, cid, mfbidx);
                                if (ret) {
                                    sprintf_f(rs->logs, "Error!!! mfour save done area failed ret: %d \n", ret);
                                    print_f(rs->plogs, "P12", rs->logs);
                                }
                                #endif
                                break;
                            case 'e': //BKCMD_IMAGE_COMPLETE :     // M4 -> operator
                                //g_done_image_idx++;
                                //bkjob_send_cmd( chan->mqWaiter, &cmd );
                                //free(image_param);
                                pinfo[0] = 'e';

                                write(pipeMfTx[1], pinfo, 1);

                                #if LOG_P12_EN
                                sprintf_f(rs->logs, "end image idx: %d \n", mfbidx);
                                print_f(rs->plogs, "P12", rs->logs);
                                #endif
                                
                                break;
                            default:
                                break;
                            }
                        }
                        else {
                            sprintf_f(rs->logs, "wait mfour rx coming...\n");
                            print_f(rs->plogs, "P12", rs->logs);
                        }

                        if (mfcmd == 'e') {
                            break;
                        }
                    }
                }
                else {
                    sprintf_f(rs->logs, "bypass m4 image!!! ret: %d, cswerr: 0x%.2x\n", ret, mfbstat);
                    print_f(rs->plogs, "P12", rs->logs);                
                }

                pinfo[0] = 'R';
                pinfo[1] = ch;
                rs_ipc_put(rs, pinfo, 2);
            }

            
            break;
        case 's':
            ret = rs_ipc_get_ms(rs, &ch, 1, 5000);
            if (ret > 0) {
                sprintf_f(rs->logs, "get cont ch[0x%.2x] \n", ch);
                print_f(rs->plogs, "P12", rs->logs);

                if (ch == 0x80) {
                    mfbidx = 0;
                } else {
                    mfbidx = ch & 0x7f;
                }

                if (mfbidx > 3) {
                    sprintf_f(rs->logs, "get buff index %d error!!! \n", mfbidx);
                    print_f(rs->plogs, "P12", rs->logs);
                    break;
                } else {
                    sprintf_f(rs->logs, "get buff index %d succed!!! \n", mfbidx);
                    print_f(rs->plogs, "P12", rs->logs);
                }

                imgidx = 0;
                mfbstat = 0;
                ret = aspBMPdecodeBuffGetIdx(rs->pbDecMfour[mfbidx], &imgidx);
                ret = aspBMPdecodeBuffStatusGet(rs->pbDecMfour[mfbidx], &mfbstat);
                if (mfbstat == 0) {
                    sprintf_f(rs->logs, "get mfbuff index %d, imgindex: %d, status 0x%x error!!! \n", mfbidx, imgidx, mfbstat);
                    print_f(rs->plogs, "P12", rs->logs);
                    //break;
                } else {
                    sprintf_f(rs->logs, "get mfbuff index %d, imgindex: %d, status 0x%x succeed!!! \n", mfbidx, imgidx, mfbstat);
                    print_f(rs->plogs, "P12", rs->logs);
                }

                ret = aspBMPdecodeItemGet(&rs->pbDecMfour[mfbidx]->aspDecRaw, &bmpbuff, &uselen);
                if (ret < 0) {
                    bmpbuff = 0;
                    bmpmax = 0;
                    uselen = 0;
                } else {
                    bmpmax = aspBMPdecodeItemMax(&rs->pbDecMfour[mfbidx]->aspDecRaw);
                }

                ret = aspBMPdecodeItemGet(&rs->pbDecMfour[mfbidx]->aspDecMeta, &buffmeta, &bmtlen);
                if (ret < 0) {
                    buffmeta = 0;
                    bmtmax = 0;
                    bmtlen = 0;
                } else {
                    bmtmax = aspBMPdecodeItemMax(&rs->pbDecMfour[mfbidx]->aspDecMeta);
                }
                
                ret = aspBMPdecodeItemGet(&rs->pbDecMfour[mfbidx]->aspDecMetaex, &exmeta, &exmlen);
                if (ret < 0) {
                    exmeta = 0;
                    exmax = 0;
                    exmlen = 0;
                } else {
                    exmax = aspBMPdecodeItemMax(&rs->pbDecMfour[mfbidx]->aspDecMetaex);
                }

                rstlen = uselen % 512;
                //sprintf_f(rs->logs, "get raw len: %d max: %d get meta len: %d max: %d get extra meta len: %d max: %d restlen: %d \n", uselen, bmpmax, bmtlen, bmtmax, exmlen, exmax, rstlen);
                //print_f(rs->plogs, "P12", rs->logs);

                //shmem_dump(buffmeta, bmtlen);
                
                ptmetausb = (struct aspMetaDataviaUSB_s *)buffmeta;
                
                //dbgMetaUsb(ptmetausb);

                /*
                val=0;
                ret = cfgTableGetChk(pct, ASPOP_IMG_LEN, &val, ASPOP_STA_APP);    
                sprintf_f(rs->logs, "[BMP] image length: %d \n", val);
                print_f(rs->plogs, "P12", rs->logs);
                */
                bmph = (ptmetausb->IMG_HIGH[1] << 8) | ptmetausb->IMG_HIGH[0];

                ret = cfgTableGetChk(pct, ASPOP_COLOR_MODE, &val, ASPOP_STA_APP);    
                switch (val) {
                case COLOR_MODE_COLOR:
                    colr = 24;
                    break;
                case COLOR_MODE_GRAY:
                case COLOR_MODE_GRAY_DETAIL:
                case COLOR_MODE_BLACKWHITE:
                    colr = 8;
                    break;
                default:
                    colr = 24;
                    break;
                }
                //sprintf_f(rs->logs, "[BMP] color mode: %d, ret: %d, bpp: %d \n", val, ret, colr);
                //print_f(rs->plogs, "P12", rs->logs);
            
                ret = cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_H, &val, ASPOP_STA_APP);    

                ret |= cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_L, &tmp, ASPOP_STA_APP);    
                tmp = val << 8 | tmp;

                val = 0;
                ret = cfgTableGetChk(pct, ASPOP_SCAN_WIDTH, &val, ASPOP_STA_UPD);
                
                bmpw = scanWidthConvert(tmp, val);
                bmpw = (ptmetausb->IMG_WIDTH[1] << 8) | ptmetausb->IMG_WIDTH[0];
                
                //sprintf_f(rs->logs, "[BMP] defined width: %d, scan width = %d result width: %d \n", tmp, val, bmpw);
                //print_f(rs->plogs, "P12", rs->logs);

                tmp = 0;
                ret = cfgTableGetChkDPI(pct, ASPOP_RESOLUTION, &tmp, ASPOP_STA_APP);   
                bdpi = tmp;
                //sprintf_f(rs->logs, "[BMP] resulution cfg: %d, dpi: %d\n", tmp, bdpi);
                //print_f(rs->plogs, "P12", rs->logs);
                
                bmpcolrtb = aspMemalloc(1078, 12);
                if (!bmpcolrtb) {
                    sprintf_f(rs->logs, "[BMP] allocate memory failed size: %d \n", 1078);
                    print_f(rs->plogs, "P12", rs->logs);                                
                }

                if (colr == 8) {
                    blen = 1078;
                    bdpp = 1;
                } else if (colr == 24) {
                    blen = 54;            
                    bdpp = 3;
                } else {
                    sprintf_f(rs->logs, "[BMP] error!!! unknown color bits: %d \n", colr);
                    print_f(rs->plogs, "P12", rs->logs);   
                }
                
                bhlen = blen;
                val = ((bmpw * colr + 31) / 32) * 4;
                val = val * bmph; 

                sprintf_f(rs->logs, "[BMP] bitmap info color: %d, w: %d, h: %d, dpi: %d, raw size: %d, header size: %d\n", colr, bmpw, bmph, bdpi, val, blen);
                print_f(rs->plogs, "P12", rs->logs);

                bitmapHeaderSetup(bheader, colr, bmpw, bmph, bdpi, val);

                ph = &bheader->aspbmpMagic[2];
                val = sizeof(struct bitmapHeader_s) - 2;
                memcpy(bmpcolrtb, ph, val);

                blen -= val;
                if (blen > 0) {
                    bitmapColorTableSetup(bmpcolrtb+val);
                    blen -= 1024;
                }

                if (blen) {
                    sprintf_f(rs->logs, "[BMP] Error!!! the bitmap header's len is wrong %d\n", bhlen);
                    print_f(rs->plogs, "P12", rs->logs);
                }
                
                prisec = ptmetausb->PRI_O_SEC;
                if (prisec > 1) {
                    sprintf_f(rs->logs, "Error !! the pri sec is wrong !!! val: %d \n", prisec);
                    print_f(rs->plogs, "P12", rs->logs);

                    prisec = 0;
                }
                
                cutcnt =0;
                cutnum = msb2lsb16(&metaRx->BKNA_NUM);

                cutsides = aspMemalloc(cutnum*sizeof(int)*2, 12);
                memset(cutsides, 0, cutnum*sizeof(int)*2);
                cutlayers = aspMemalloc(cutnum*sizeof(int)*2, 12);
                memset(cutlayers, 0, cutnum*sizeof(int)*2);
                ret = 0;
                
                ret = aspMetaGetPages(metaRx, cutsides, cutlayers, cutnum);
                sprintf_f(rs->logs, "[CUT] get page ret: %d num: %d\n", ret, cutnum);
                print_f(rs->plogs, "P12", rs->logs);
                

                pinfo[0] = 'S';
                pinfo[1] = ch;

                rs_ipc_put(rs, pinfo, 2);
            }  
            break;
        case 'r':
            ret = rs_ipc_get_ms(rs, &ch, 1, 5000);
            if (ret > 0) {
                sprintf_f(rs->logs, "get cont ch[0x%.2x] \n", ch);
                print_f(rs->plogs, "P12", rs->logs);

                if (ch == 0x80) {
                    mfbidx = 0;
                } else {
                    mfbidx = ch & 0x7f;
                }

                if (mfbidx > 3) {
                    sprintf_f(rs->logs, "get buff index %d error!!! \n", mfbidx);
                    print_f(rs->plogs, "P12", rs->logs);
                    break;
                } else {
                    sprintf_f(rs->logs, "get buff index %d succed!!! \n", mfbidx);
                    print_f(rs->plogs, "P12", rs->logs);
                }

                imgidx = 0;
                mfbstat = 0;
                ret = aspBMPdecodeBuffGetIdx(rs->pbDecMfour[mfbidx], &imgidx);
                ret = aspBMPdecodeBuffStatusGet(rs->pbDecMfour[mfbidx], &mfbstat);
                if (mfbstat == 0) {
                    sprintf_f(rs->logs, "get mfbuff index %d, imgindex: %d, status 0x%x error!!! \n", mfbidx, imgidx, mfbstat);
                    print_f(rs->plogs, "P12", rs->logs);
                    //break;
                } else {
                    sprintf_f(rs->logs, "get mfbuff index %d, imgindex: %d, status 0x%x succeed!!! \n", mfbidx, imgidx, mfbstat);
                    print_f(rs->plogs, "P12", rs->logs);
                }

                ret = aspBMPdecodeItemGet(&rs->pbDecMfour[mfbidx]->aspDecRaw, &bmpbuff, &uselen);
                if (ret < 0) {
                    bmpbuff = 0;
                    bmpmax = 0;
                    uselen = 0;
                } else {
                    bmpmax = aspBMPdecodeItemMax(&rs->pbDecMfour[mfbidx]->aspDecRaw);
                }

                ret = aspBMPdecodeItemGet(&rs->pbDecMfour[mfbidx]->aspDecMeta, &buffmeta, &bmtlen);
                if (ret < 0) {
                    buffmeta = 0;
                    bmtmax = 0;
                    bmtlen = 0;
                } else {
                    bmtmax = aspBMPdecodeItemMax(&rs->pbDecMfour[mfbidx]->aspDecMeta);
                }
                
                ret = aspBMPdecodeItemGet(&rs->pbDecMfour[mfbidx]->aspDecMetaex, &exmeta, &exmlen);
                if (ret < 0) {
                    exmeta = 0;
                    exmax = 0;
                    exmlen = 0;
                } else {
                    exmax = aspBMPdecodeItemMax(&rs->pbDecMfour[mfbidx]->aspDecMetaex);
                }

                rstlen = uselen % 512;
                //sprintf_f(rs->logs, "get raw len: %d max: %d get meta len: %d max: %d get extra meta len: %d max: %d restlen: %d \n", uselen, bmpmax, bmtlen, bmtmax, exmlen, exmax, rstlen);
                //print_f(rs->plogs, "P12", rs->logs);

                //shmem_dump(buffmeta, bmtlen);
                
                ptmetausb = (struct aspMetaDataviaUSB_s *)buffmeta;
                
                //dbgMetaUsb(ptmetausb);

                /*
                val=0;
                ret = cfgTableGetChk(pct, ASPOP_IMG_LEN, &val, ASPOP_STA_APP);    
                sprintf_f(rs->logs, "[BMP] image length: %d \n", val);
                print_f(rs->plogs, "P12", rs->logs);
                */
                bmph = (ptmetausb->IMG_HIGH[1] << 8) | ptmetausb->IMG_HIGH[0];

                ret = cfgTableGetChk(pct, ASPOP_COLOR_MODE, &val, ASPOP_STA_APP);    
                switch (val) {
                case COLOR_MODE_COLOR:
                    colr = 24;
                    break;
                case COLOR_MODE_GRAY:
                case COLOR_MODE_GRAY_DETAIL:
                case COLOR_MODE_BLACKWHITE:
                    colr = 8;
                    break;
                default:
                    colr = 24;
                    break;
                }
                //sprintf_f(rs->logs, "[BMP] color mode: %d, ret: %d, bpp: %d \n", val, ret, colr);
                //print_f(rs->plogs, "P12", rs->logs);
            
                ret = cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_H, &val, ASPOP_STA_APP);    

                ret |= cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_L, &tmp, ASPOP_STA_APP);    
                tmp = val << 8 | tmp;

                val = 0;
                ret = cfgTableGetChk(pct, ASPOP_SCAN_WIDTH, &val, ASPOP_STA_UPD);
                
                bmpw = scanWidthConvert(tmp, val);
                bmpw = (ptmetausb->IMG_WIDTH[1] << 8) | ptmetausb->IMG_WIDTH[0];
                
                //sprintf_f(rs->logs, "[BMP] defined width: %d, scan width = %d result width: %d \n", tmp, val, bmpw);
                //print_f(rs->plogs, "P12", rs->logs);

                tmp = 0;
                ret = cfgTableGetChkDPI(pct, ASPOP_RESOLUTION, &tmp, ASPOP_STA_APP);    
                bdpi = tmp;
                //sprintf_f(rs->logs, "[BMP] resulution cfg: %d, dpi: %d\n", tmp, bdpi);
                //print_f(rs->plogs, "P12", rs->logs);
                
                bmpcolrtb = aspMemalloc(1078, 12);
                if (!bmpcolrtb) {
                    sprintf_f(rs->logs, "[BMP] allocate memory failed size: %d \n", 1078);
                    print_f(rs->plogs, "P12", rs->logs);                                
                }

                if (colr == 8) {
                    blen = 1078;
                    bdpp = 1;
                } else if (colr == 24) {
                    blen = 54;            
                    bdpp = 3;
                } else {
                    sprintf_f(rs->logs, "[BMP] error!!! unknown color bits: %d \n", colr);
                    print_f(rs->plogs, "P12", rs->logs);   
                }
                
                bhlen = blen;
                val = ((bmpw * colr + 31) / 32) * 4;
                val = val * bmph; 

                sprintf_f(rs->logs, "[BMP] bitmap info color: %d, w: %d, h: %d, dpi: %d, raw size: %d, header size: %d\n", colr, bmpw, bmph, bdpi, val, blen);
                print_f(rs->plogs, "P12", rs->logs);

                bitmapHeaderSetup(bheader, colr, bmpw, bmph, bdpi, val);

                ph = &bheader->aspbmpMagic[2];
                val = sizeof(struct bitmapHeader_s) - 2;
                memcpy(bmpcolrtb, ph, val);

                blen -= val;
                if (blen > 0) {
                    bitmapColorTableSetup(bmpcolrtb+val);
                    blen -= 1024;
                }

                if (blen) {
                    sprintf_f(rs->logs, "[BMP] Error!!! the bitmap header's len is wrong %d\n", bhlen);
                    print_f(rs->plogs, "P12", rs->logs);
                }
                
                prisec = ptmetausb->PRI_O_SEC;
                if (prisec > 1) {
                    sprintf_f(rs->logs, "Error !! the pri sec is wrong !!! val: %d \n", prisec);
                    print_f(rs->plogs, "P12", rs->logs);

                    prisec = 0;
                }
                
                cutcnt =0;
                cutnum = msb2lsb16(&metaRx->BKNA_NUM);

                cutsides = aspMemalloc(cutnum*sizeof(int)*2, 12);
                memset(cutsides, 0, cutnum*sizeof(int)*2);
                cutlayers = aspMemalloc(cutnum*sizeof(int)*2, 12);
                memset(cutlayers, 0, cutnum*sizeof(int)*2);
                ret = 0;
                
                ret = aspMetaGetPages(metaRx, cutsides, cutlayers, cutnum);
                sprintf_f(rs->logs, "[CUT] get page ret: %d num: %d\n", ret, cutnum);
                print_f(rs->plogs, "P12", rs->logs);

                #if 1
                cutsides[ret*2] = -1;
                cutsides[ret*2+1] = -1;
                cutlayers[ret*2] = 0;
                cutlayers[ret*2+1] = 0;
                
                ret += 1;
                
                cutsides[ret*2] = -2;
                cutsides[ret*2+1] = -2;
                cutlayers[ret*2] = 0;
                cutlayers[ret*2+1] = 0;
                
                ret += 1;
                #endif

                cutnum = ret;

                for (ix=0; ix < cutnum; ix++) {

                    sprintf_f(rs->logs, "[CUT] clips %d. A:%d (%d) B:%d (%d)\n", ix, cutsides[ix*2], cutlayers[ix*2], cutsides[ix*2+1], cutlayers[ix*2+1]);
                    print_f(rs->plogs, "P12", rs->logs);

                }

                if (cutnum > BMP_DECODE_PIC_SIZE) {
                    cutnum = BMP_DECODE_PIC_SIZE;
                }
                
                for (ix=0; ix < cutnum; ix++) {

                    pdecroi = &rs->pbDecMfour[mfbidx]->aspDecMfPiRaw[ix];
                    penroi = &rs->pbDecMfour[mfbidx]->aspDecMfPiJpg[ix];

                    ret = aspBMPdecodeItemGet(pdecroi, &rotsrc[ix], 0);
                    if (ret < 0) {
                        rotsrc[ix] = 0;
                        rotsmax[ix] = 0;
                    } else {
                        rotsmax[ix] = aspBMPdecodeItemMax(pdecroi);
                    }
                    
                    sprintf_f(rs->logs, "[BUFF] %d. src addr: 0x.8%x (max:%d) rotate dst addr:0x%.8x (max:%d)\n", ix, (uint32_t)bmpbuff, bmpmax, (uint32_t)rotsrc[ix], rotsmax[ix]);
                    print_f(rs->plogs, "P12", rs->logs);

                }

                mreal[0] = -1;
                mreal[1] = -1;
                
                while (cutcnt < cutnum) {

                    bmprot = rotsrc[cutcnt];

                    jpgLen = 0;
                    rotlen = 0;

                    if (!bmph) {
                        break;
                    }

                    memcpy(ph, bmpcolrtb, 54);
                    
                    sprintf_f(rs->logs, "[BMP] doEncode %d. pri or sec: %d (%d, %d) \n", cutcnt, prisec, mreal[0], mreal[1]);
                    print_f(rs->plogs, "P12", rs->logs);
                    
                    clock_gettime(CLOCK_REALTIME, &jpgS);
                    
                    ret = rotateBMPMf(bmprot, bmpcolrtb, cropinfo, bmpbuff, mreal, 0xa5, 12);
                    
                    clock_gettime(CLOCK_REALTIME, &jpgE);
                    
                    sprintf_f(rs->logs, "[BMP] rotate bmp w: %d h: %d rawoffset: %d ret: %d\n", bheader->aspbiWidth, bheader->aspbiHeight, bheader->aspbhRawoffset, ret);
                    print_f(rs->plogs, "P12", rs->logs);
                    
                    tmCost = time_diff(&jpgS, &jpgE, 1000000);
                    sprintf_f(rs->logs, "[BMP] rotate bmp cost: %d ms\n", tmCost);
                    print_f(rs->plogs, "P12", rs->logs);
                    
                    bmpbufc = pabuff->dirParseBuff;   
                    rotlen = pabuff->dirBuffUsed;
                    
                    aspBMPdecodeItemSet(&rs->pbDecMfour[mfbidx]->aspDecMfPiRaw[cutcnt], bheader->aspbiWidth, bheader->aspbiHeight, rotlen);
                    
                    cutcnt ++;
                    
                }

                pinfo[0] = 'R';
                pinfo[1] = ch;

                rs_ipc_put(rs, pinfo, 2);
            }        
            break;
        default:
            sprintf_f(rs->logs, "Error !!! unknown tcmd: 0x%x !!! \n", tcmd);
            print_f(rs->plogs, "P12", rs->logs);

            break;
        }

        aspMemClear(aspMemAsign, asptotMalloc, 12);
    }

    p12_end(rs);
    
    return 0;
}

#define LOG_JPGH_EN (0)
#if GHP_EN
#define GHP_EN_JPGH (1)
#else
#define GHP_EN_JPGH (0)
#endif

static int jpghostd(struct procRes_s *rs, char *sp, int dlog, int midx)
{
    char chq=0, chd=0, che=0, cindexfo[2], mindexfo[2], cinfo[12], cswerr=0, pagerst=2, ch=0, mfourinfo[2];
    char *addrd=0, *palloc=0, *endf=0, *endm=0, *bmpbufc=0, *bmpbuff=0, *addrb=0, *buffmeta=0;
    char *bmpcpy=0, *pshfmeta=0, *jpgout=0, *bmpcolrtb=0, *ph=0, *exmtaout=0, *bmprot=0, *metaPt=0;
    unsigned char *jpgrlt=0;
    int uimCylcnt=0, seqtx=0, maxsz=0, lens=0, pipRet=0, idlet=0, cindex=0, ix=0, waitCylen=0, chr=0, sendsz=0;
    int usbfd=0, ret=0, act=0, lastCylen=0, cmdprisec=0, bmplen=0, bmpmax=0, uselen=0, cpylen=0, distCylcnt=0, cntTx=0, lenbs=0, shfmeta=0;
    int udist=0, uthrhld=0, upas=0, ursm=0, upasd=0, ursmd=0, udistd=0, lrst=0, opsz=0, rawlen=0, val=0, bmph=0, bhlen=0, bmphmax=0;
    int colr=0, tmp=0, bmpw=0, bdpi=0, jpgetW=0, jpgetH=0, err=0, tmCost=0, blen=0, bdpp=0, prisec=0, cutcnt=0, cutnum=0;
    int mreal[2]={0}, recvsz=0, sides[2]={0}, rotlen=0, jpgLen=0, updn=0, rotlast=0, cntsent=0, bret=0, wrtsz=0, retry=0;
    int acusz=0, maxCylcnt=0, errcnt=0, lastflag=0, buffidx=-1, outmax=0, imgdex=0, mbstat=0, exmax=0, extlen=0, mtlen=0;
    int *cutsides=0, *cutlayers=0;
    int *piptx=0, *piprx=0;
    int *pipeRx, *pipeRxd, *pipeTx, *pipeTxd;
    uint8_t cmd=0, opc=0, dat=0;
    struct usbhost_s *pushost=0, *pushostd=0, *puscur=0;
    struct usbHostmem_s *pinfushost=0, *pinfushostd=0, *pinfcur=0, *pinfcurd=0;
    struct usbIndex_s *puimCnTH=0, *puimTmp=0, *puimUse=0, *puimCur=0, *puimGet=0, *puimNxt=0, *puimCud=0;
    struct timespec tidleS, tidleE;
    struct timespec tstart, tend;
    struct shmem_s *usbTx=0, *usbTxd=0, *usbCur=0;
    struct pollfd ptfdc[2];
    struct aspConfig_s *pct=0, *pdt=0;
    struct aspMetaDataviaUSB_s *ptmetausb=0;
    struct timespec jpgS, jpgE;
    struct aspMetaData_s *metaRx = 0;
    struct bitmapHeader_s *bheader = 0;
    struct sdParseBuff_s *pabuff=0;
    struct bitmapDecodeItem_s *pdecraw=0;
    char emptyLine[4] = {0x59, 0x4c, 0x03, 0x10};
    char emptyLast[4] = {0x41, 0x53, 0x50, 0x43};
    char endstr[128] = "usb_conti_stop";
    char csw[16] = {0x55, 0x53, 0x42, 0x43, 0x11, 0x22, 0x33, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff};
    char ptrecv[256] = {0};
    uint32_t fformat=0;
    CFLOAT throughput=0.0;
    int simMax=-1;
    //int coffsetx=0, coffsetw=0, coffsety=0, coffseth=0;
    //uint32_t upos1=0, upos4=0, upos9=0, upos11=0;
    //struct procRes_s *rsd=0;

    #if 0
    sprintf_f(rs->logs, "p13\n");
    print_f(rs->plogs, sp, rs->logs);

    p13_init(rs);

    prctl(PR_SET_NAME, "msp-p13");
    #endif

    if (midx == 13) {
    pinfushost = rs->pusbmh[0];
    if (!pinfushost) {
        sprintf_f(rs->logs, "Error!!! usb host 0 info not available !!! \n");
        print_f(rs->plogs, sp, rs->logs);
    } else {
        sprintf_f(rs->logs, "usb host 0 info name:[%s] vidpid:[0x%.2x:0x%.2x] \n", pinfushost->ushostname, pinfushost->ushostpidvid[0], pinfushost->ushostpidvid[1]);
        print_f(rs->plogs, sp, rs->logs);
    }

    pinfushostd = rs->pusbmh[0];
    if (!pinfushostd) {
        sprintf_f(rs->logs, "Error!!! usb host 1 info not available !!! \n");
        print_f(rs->plogs, sp, rs->logs);
    } else {
        sprintf_f(rs->logs, "usb host 0 info name:[%s] vidpid:[0x%.2x:0x%.2x] \n", pinfushostd->ushostname, pinfushostd->ushostpidvid[0], pinfushostd->ushostpidvid[1]);
        print_f(rs->plogs, sp, rs->logs);
    }
    } else {
    pinfushost = rs->pusbmh[1];
    if (!pinfushost) {
        sprintf_f(rs->logs, "Error!!! usb host 0 info not available !!! \n");
        print_f(rs->plogs, sp, rs->logs);
    } else {
        sprintf_f(rs->logs, "usb host 1 info name:[%s] vidpid:[0x%.2x:0x%.2x] \n", pinfushost->ushostname, pinfushost->ushostpidvid[0], pinfushost->ushostpidvid[1]);
        print_f(rs->plogs, sp, rs->logs);
    }

    pinfushostd = rs->pusbmh[1];
    if (!pinfushostd) {
        sprintf_f(rs->logs, "Error!!! usb host 1 info not available !!! \n");
        print_f(rs->plogs, sp, rs->logs);
    } else {
        sprintf_f(rs->logs, "usb host 1 info name:[%s] vidpid:[0x%.2x:0x%.2x] \n", pinfushostd->ushostname, pinfushostd->ushostpidvid[0], pinfushostd->ushostpidvid[1]);
        print_f(rs->plogs, sp, rs->logs);
    }

    }

    rs->pbheader = malloc(sizeof(struct bitmapHeader_s));
    
    pabuff = &rs->psFat->parBuf;
    bheader = rs->pbheader;
    memset(bheader, 0, sizeof(struct bitmapHeader_s));
    
    pct = rs->pcfgTable;

    rs->pmetausb = malloc(sizeof(struct aspMetaDataviaUSB_s));    
    ptmetausb = rs->pmetausb;
    
    pushost = rs->pusbhost;
    //pushostd = rsd->pusbhost;
    
    metaPt = pushost->puhsmeta;
    metaRx = (struct aspMetaData_s *)metaPt;

    pipeRx = pushost->pjpgrx;
    pipeTx = pushost->pjpgtx;

    //pipeRxd = pushostd->pjpgrx;
    //pipeTxd = pushostd->pjpgtx;

    ptfdc[0].fd = pipeRx[0];
    ptfdc[0].events = POLLIN;

    //ptfdc[1].fd = pipeRxd[0];
    //ptfdc[1].events = POLLIN;

    cmd = 0x12;
    opc = 0x0f;

    puscur = pushost;
    pinfcur = pinfushost;
    usbCur = puscur->pushring;
    piptx = puscur->pjpgtx;
    piprx = puscur->pjpgrx; 

    while (1) {
    
        aspMemClear(aspMemAsign, asptotMalloc, midx);
        
        sprintf_f(rs->logs, "[DV] cmd: 0x%.2x opc: 0x%.2x \n", cmd, opc);
        print_f(rs->plogs, sp, rs->logs);
        //usleep(100000);
        
        while (1) {
            #if 0//DBG_BK_DV
            sprintf_f(rs->logs, "[DV] addrd: 0x%.8x cylcnt: %d pipe%d\n", addrd, uimCylcnt, piprx[0]);
            print_f(rs->plogs, sp, rs->logs);
            #endif

            while (1) {
                aspMemClear(aspMemAsign, asptotMalloc, midx);
        
                while (1) {
                    if (uimCylcnt > 0) {
                        break;
                    }
                    
                    chq = 0;
                    chd = 0;

                    clock_gettime(CLOCK_REALTIME, &tidleE);
                    idlet = time_diff(&tidleS, &tidleE, 1000000);
        
                    #if LOG_JPGH_EN
                    sprintf_f(rs->logs, "[DV] start poll %d ms puimGet: 0x%.8x puimCnTH: 0x%.8x rx: %d, 0: %d \n", idlet, (puimGet==0)?0:(uint32_t)puimGet->uimIdex, (puimCnTH==0)?0:(uint32_t)puimCnTH->uimIdex, piprx[0], ptfdc[0].fd);
                    print_f(rs->plogs, sp, rs->logs);
                    #endif
                    
                    pipRet = poll(ptfdc, 1, 500);
                    if (pipRet <= 0) {
                        clock_gettime(CLOCK_REALTIME, &tidleE);
                        idlet = time_diff(&tidleS, &tidleE, 1000000);
                        
                        #if LOG_JPGH_EN
                        sprintf_f(rs->logs, "[DV] wait for %d ms puimGet: 0x%.8x puimCnTH: 0x%.8x\n", idlet, puimGet==0?0:(uint32_t)puimGet->uimIdex, puimCnTH==0?0:(uint32_t)puimCnTH->uimIdex);
                        print_f(rs->plogs, sp, rs->logs);
                        #endif
        
                        if (puimGet) {
                            if ((puimGet->uimGetCnt == 0) && ((opc == 0x0a) || (opc == 0x05) || (opc == 0x0e) || (opc == 0x0f))) {
                                //sprintf_f(rs->logs, "[DV] wait id %d - %d \n", puimGet->uimIdex, puimGet->uimCount);
                                //print_f(rs->plogs, sp, rs->logs);
        
                                if (idlet > 60000) {
                                    clock_gettime(CLOCK_REALTIME, &tidleS);
        
                                    if (puimCnTH == puimGet) {
                                        puimCnTH = puimGet->uimNxt;
                                        
                                        puimNxt = 0;
                                        ix=0;
                                        cindex = 0;
                                        puimTmp = puimCnTH;
                                        while (puimTmp) {
                                            puimUse = puimTmp;
        
                                            #if 1
                                            if (cindex == 0) {
                                                cindex = puimUse->uimIdex & 0x3ff;
                                                puimNxt = puimUse;
                                            } else {
                                                if ((puimUse->uimIdex & 0x3ff) < cindex) {
                                                    cindex = puimUse->uimIdex & 0x3ff;
                                                    puimNxt = puimUse;
                                                }
                                            }
                                            #else
                                            if (puimUse->uimIdex == ((puimGet->uimIdex & 0x3ff) + 1)) {
                                                puimNxt = puimUse;
                                            }
                                            #endif
                                            
                                            puimTmp = puimUse->uimNxt;
                                            ix++;
                                        }
                                    }
                                    else {
        
                                        ix=0;
                                        puimTmp = puimCnTH;
                                        while (puimTmp) {
                                            puimUse = puimTmp;
                                            
                                            #if 1
                                            if (cindex == 0) {
                                                cindex = puimUse->uimIdex & 0x3ff;
                                                puimNxt = puimUse;
                                            } else {
                                                if ((puimUse->uimIdex & 0x3ff) < cindex) {
                                                    cindex = puimUse->uimIdex & 0x3ff;
                                                    puimNxt = puimUse;
                                                }
                                            }
                                            #else
                                            if (puimUse->uimIdex == ((puimGet->uimIdex & 0x3ff) + 1)) {
                                                puimNxt = puimUse;
                                            }
                                            #endif
                                            
                                            puimTmp = puimUse->uimNxt;
                                            if (puimTmp == puimGet) {
                                                puimUse->uimNxt = puimGet->uimNxt;
                                            }                
        
                                            puimTmp = puimUse->uimNxt;
                                            ix++;
                                        }
                                    }
        
                                    free(puimGet);
                                    puimGet = 0;
                                    
                                    if (puimNxt) {
                                        puimGet = puimNxt;
                                    }
                                    
                                    ix = 0;
                                    puimTmp = puimCnTH;
                                    while(puimTmp) {
                                        #if 1
                                        sprintf_f(rs->logs, "[DV] %d - 0x%.2x %d:%d timeout srh\n", ix, puimTmp->uimIdex, puimTmp->uimGetCnt, puimTmp->uimCount);
                                        print_f(rs->plogs, sp, rs->logs);
                                        #endif
        
                                        if (puimTmp->uimCount > 0) {
                                            ix++;
                                        }
                                        puimTmp = puimTmp->uimNxt;
                                    }                             
        
                                    waitCylen = ix;
                                    sprintf_f(rs->logs, "[DV] wait page size: %d timeout\n", waitCylen);
                                    print_f(rs->plogs, sp, rs->logs);
        
                                    chr = 0;
        
                                    if (!puimGet) {
                                        sprintf_f(rs->logs, "[DV] puimGet is null timeout break, usbfd: %d\n", usbfd);
                                        print_f(rs->plogs, sp, rs->logs);
                                        continue;
                                    }
                                }
                            }
                        }
                    }
                    else {

                        clock_gettime(CLOCK_REALTIME, &tidleS);
                        
                        //for (ix=0; ix < 1; ix++) {
                            ix = 0;
                            if ((ptfdc[ix].revents & POLLIN) == POLLIN) {
                                if (ptfdc[ix].fd == piprx[0]) {
                                    ret = read(ptfdc[ix].fd, &chq, 1);
        
                                    #if LOG_JPGH_EN
                                    sprintf_f(rs->logs, "[DV] chq: 0x%.2x chr: 0x%.2x %d.pipe%d ret=%d \n", chq, chr, ix, ptfdc[ix].fd, ret);
                                    print_f(rs->plogs, sp, rs->logs);
                                    #endif
        
                                } else {
                                    ret = read(ptfdc[ix].fd, &chd, 1);
                                    
                                    #if LOG_JPGH_EN
                                    sprintf_f(rs->logs, "[DV] extra chd: 0x%.2x chr: 0x%.2x %d.pipe%d ret=%d \n", chd, chr, ix, ptfdc[ix].fd, ret);
                                    print_f(rs->plogs, sp, rs->logs);
                                    #endif
                                }
        
                                if ((chd & 0xc0) == 0xc0) {
                                    cindexfo[0] = chd;
                                    pipRet = read(ptfdc[ix].fd, &chd, 1);
                                    while (pipRet < 0) {
                                        pipRet = read(ptfdc[ix].fd, &chd, 1);
                                    }
        
                                    #if LOG_JPGH_EN
                                    sprintf_f(rs->logs, "[DV] extra pre: 0x%.2x nxt: 0x%.2x pipe%d\n", cindexfo[0], chd, ptfdc[ix].fd);
                                    print_f(rs->plogs, sp, rs->logs);
                                    #endif
        
                                    if ((chd & 0xc0) == 0x40) {
                                        cindexfo[1] = chd;
                                    } else {
                                        sprintf_f(rs->logs, "[DV]  WARNNING get unknown chd: 0x%.2x \n", chd);
                                        print_f(rs->plogs, sp, rs->logs);
                                        break;
                                    }
        
                                    cindex = ((cindexfo[0] & 0x3f) << 5) | (cindexfo[1] & 0x1f);
        
                                    #if LOG_JPGH_EN
                                    sprintf_f(rs->logs, "[DV] get page index extra: 0x%.3x currx: %d \n", cindex, piprx[0]);
                                    print_f(rs->plogs, sp, rs->logs);
                                    #endif
        
                                    if (!puimCnTH) {
                                        //sprintf_f(rs->logs, "extra puimCnTH is null!!! \n");
                                        //print_f(rs->plogs, sp, rs->logs);
        
                                        puimCnTH = malloc(sizeof(struct usbIndex_s));
                                        if (!puimCnTH) {
                                            sprintf_f(rs->logs, "Error!!! can't get memory for usbIndex_s\n\n\n");
                                            print_f(rs->plogs, sp, rs->logs);
                                            break;
                                        }
        
                                        memset(puimCnTH, 0, sizeof(struct usbIndex_s));
        
                                        puimCnTH->uimIdex = cindex;
                                    }
                                    #if DBG_BK_DV
                                    else {
                                        act = 0;
                                        puimTmp = puimCnTH;
                                        while(puimTmp) {
        
                                            sprintf_f(rs->logs, "[DV] extra page.%d - 0x%.3x %d/%d (addr: 0x%.8x) \n", act, puimTmp->uimIdex, puimTmp->uimGetCnt, puimTmp->uimCount, (uint32_t)puimTmp);
                                            print_f(rs->plogs, sp, rs->logs);
        
                                            puimTmp = puimTmp->uimNxt;
        
                                            act++;
                                        }                             
                                    }
                                    #endif
        
                                    if (puimCud) {
                                        if ((puimCud->uimIdex & 0x3ff) == (cindex & 0x3ff)) {
                                            puimCud->uimCount += 1;
                                        }
                                        else {
        
                                            sprintf_f(rs->logs, "[DV] extra current puim index not mach wait:0x%.3x, get:0x%.3x chr: 0x%.3x!!!\n\n", puimCud->uimIdex, cindex, chr);
                                            print_f(rs->plogs, sp, rs->logs);
        
                                            puimTmp= puimCnTH;
                                            while(puimTmp) {
                                                puimUse = puimTmp;
                                                if ((puimUse->uimIdex & 0x3ff) == (cindex & 0x3ff)) {
                                                    puimTmp = puimUse;
                                                    break;
                                                }
                                                puimTmp = puimUse->uimNxt;
                                            }
        
                                            if (puimTmp) {
                                                puimTmp->uimCount += 1;
                                                puimCud = puimTmp;
                                            } else {
        
                                                puimTmp = malloc(sizeof(struct usbIndex_s));
                                                if (!puimTmp) {
                                                    sprintf_f(rs->logs, "Error!!! can't get memory for puimTmp -2 !!!\n\n\n");
                                                    print_f(rs->plogs, sp, rs->logs);
                                                    break;
                                                }
        
                                                memset(puimTmp, 0, sizeof(struct usbIndex_s));
        
                                                puimTmp->uimIdex = cindex;
                                                puimTmp->uimCount += 1;
                                                puimUse->uimNxt = puimTmp;
        
                                                puimCud = puimTmp;
                                            }
                                        }
                                    }
                                    else {
                                        if ((puimCnTH->uimIdex & 0x3ff) == (cindex & 0x3ff)) {
                                            puimCnTH->uimCount += 1;
                                            puimCud = puimCnTH;
                                        } else {
        
                                            puimTmp= puimCnTH;
                                            while(puimTmp) {
                                                puimUse = puimTmp;
                                                if ((puimUse->uimIdex & 0x3ff) == (cindex  & 0x3ff)) {
                                                    puimTmp = puimUse;
                                                    break;
                                                }
                                                puimTmp = puimUse->uimNxt;
                                            }
        
                                            if (puimTmp) {
                                                puimTmp->uimCount += 1;                            
                                                puimCud = puimTmp;
                                            } else {
                                                puimTmp = malloc(sizeof(struct usbIndex_s));
                                                if (!puimTmp) {
                                                    sprintf_f(rs->logs, "Error!!! can't get memory for puimTmp!!! \n\n\n");
                                                    print_f(rs->plogs, sp, rs->logs);
                                                    break;
                                                }
        
                                                memset(puimTmp, 0, sizeof(struct usbIndex_s));
        
                                                puimTmp->uimIdex = cindex;
                                                puimTmp->uimCount += 1;
                                                puimUse->uimNxt = puimTmp;
        
                                                puimCud = puimTmp;
                                            }
                                        }
                                    }  
        
                                    chd = 0;
                                }
                            }
                        //}
                    }
                    
                    if (chq == 0xff) {
                        if (chr) {
                        
                            mindexfo[0] = ((chr >> 5) & 0x3f) | 0xc0;
                            mindexfo[1] = (chr & 0x1f) | 0x40;
                                
                            pipRet = write(piptx[1], mindexfo, 2);
                            if (pipRet < 0) {
                                sprintf_f(rs->logs, "[DV]  pipe(%d) put chr: %d ret: %d act 0x80\n", piptx[1], chr, pipRet);
                                print_f(rs->plogs, sp, rs->logs);
                                continue;
                            }
                        } else {
                            sprintf_f(rs->logs, "[DV] warnning!!! chr should not be 0 !! \n");
                            print_f(rs->plogs, sp, rs->logs);
                        }
                    }
                    else if (chq == 0xbf) {
                        sprintf_f(rs->logs, "[DV] send redundant page size: %d\n", maxsz);
                        print_f(rs->plogs, sp, rs->logs);
                        endf = endstr;
                        if (maxsz) {
                            seqtx = maxsz;
                            endm = palloc;
        
                            #if 0                                                
                            addrd = endm;
                            if (seqtx < USB_BUF_SIZE) {
                                lens = seqtx;
                                seqtx = maxsz;
                                endm = palloc;                                                    
                            } else {
                                lens = USB_BUF_SIZE;
                                seqtx = seqtx - lens;
                                endm += lens;
                            }
                            #endif                                                
                        }
                        
                        #if 0
                        else {
                            addrd = endf;
                            lens = strlen(endf);                                    
                        }
                        #endif                                                                             
                        break;
                    }
                    else if ((chq & 0xc0) == 0xc0) {
                        cindexfo[0] = chq;
                        pipRet = read(piprx[0], &chq, 1);
                        while (pipRet < 0) {
                            pipRet = read(piprx[0], &chq, 1);
                        }
        
                        #if LOG_JPGH_EN
                        sprintf_f(rs->logs, "[DV] pre: 0x%.2x nxt: 0x%.2x pipe%d\n", cindexfo[0], chq, piprx[0]);
                        print_f(rs->plogs, sp, rs->logs);
                        #endif
        
                        if ((chq & 0xc0) == 0x40) {
                            cindexfo[1] = chq;
                        } else {
                            sprintf_f(rs->logs, "[DV]  WARNNING get unknown chq: 0x%.2x \n", chq);
                            print_f(rs->plogs, sp, rs->logs);
                            continue;
                        }
        
                        cindex = ((cindexfo[0] & 0x3f) << 5) | (cindexfo[1] & 0x1f);
        
                        #if LOG_JPGH_EN
                        sprintf_f(rs->logs, "[DV] get page index: 0x%.3x currx: %d \n", cindex, piprx[0]);
                        print_f(rs->plogs, sp, rs->logs);
                        #endif
        
                        if (!puimCnTH) {
                            puimCnTH = malloc(sizeof(struct usbIndex_s));
                            if (!puimCnTH) {
                                sprintf_f(rs->logs, "\n\nError!!! can't get memory for usbIndex_s\n");
                                print_f(rs->plogs, sp, rs->logs);
                            }
                            
                            memset(puimCnTH, 0, sizeof(struct usbIndex_s));
        
                            puimCnTH->uimIdex = cindex;
                            puimGet = puimCnTH;
                                
                            if (!chr) {
                                chr = puimGet->uimIdex & 0x3ff;
        
                                if (chr == (cindex & 0x3ff)) {
                                mindexfo[0] = ((chr >> 5) & 0x3f) | 0xc0;
                                mindexfo[1] = (chr & 0x1f) | 0x40;
        
                                pipRet = write(piptx[1], mindexfo, 2);
                                if (pipRet < 0) {
                                    sprintf_f(rs->logs, "[DV]  pipe(%d) put chr: %d ret: %d \n", piptx[1], chr, pipRet);
                                    print_f(rs->plogs, sp, rs->logs);
                                    continue;
                                }
                                }
                            } else {
                                sprintf_f(rs->logs, "[DV] warring!!! puimCnTH == 0, and chr == %d \n", chr);
                                print_f(rs->plogs, sp, rs->logs);
                                if (chr == (cindex & 0x3ff)) {
                                mindexfo[0] = ((chr >> 5) & 0x3f) | 0xc0;
                                mindexfo[1] = (chr & 0x1f) | 0x40;
        
                                pipRet = write(piptx[1], mindexfo, 2);
                                if (pipRet < 0) {
                                    sprintf_f(rs->logs, "[DV]  pipe(%d) put chr: %d ret: %d \n", piptx[1], chr, pipRet);
                                    print_f(rs->plogs, sp, rs->logs);
                                    continue;
                                }
                                }
                            }
                        }
        
                        #if DBG_BK_DV
                        else {
                            ix = 0;
                            puimTmp = puimCnTH;
                            while(puimTmp) {
                            
                                sprintf_f(rs->logs, "[DV] %d - 0x%.2x %d:%d \n", ix, puimTmp->uimIdex, puimTmp->uimGetCnt, puimTmp->uimCount);
                                print_f(rs->plogs, sp, rs->logs);
                                
                                puimTmp = puimTmp->uimNxt;
        
                                ix++;
                            }                             
                        }
                        #endif
        
                        if (puimGet) {
                            if (!chr) {
                                if (puimGet->uimGetCnt < puimGet->uimCount) {
                                    chr = puimGet->uimIdex & 0x3ff;
                                    mindexfo[0] = ((chr >> 5) & 0x3f) | 0xc0;
                                    mindexfo[1] = (chr & 0x1f) | 0x40;
                                    
                                    pipRet = write(piptx[1], mindexfo, 2);
                                    if (pipRet < 0) {
                                        sprintf_f(rs->logs, "[DV]  pipe(%d) put chr: %d ret: %d \n", piptx[1], chr, pipRet);
                                        print_f(rs->plogs, sp, rs->logs);
                                        continue;
                                    }
                                } else {
                                    sprintf_f(rs->logs, "\n[DV] %d:%d wait for new data get begin \n", puimGet->uimGetCnt, puimGet->uimCount);
                                    print_f(rs->plogs, sp, rs->logs);
                                }
                            } else {
                                //sprintf_f(rs->logs, "[DV] wait for response (0x%.2x) %d:%d\n", puimGet->uimIdex, puimGet->uimGetCnt, puimGet->uimCount);
                            }
                        }
                        else {
        
                            ix = 0;
                            puimTmp = puimCnTH;
                            puimUse = puimCnTH;
                            while (puimTmp) {
                                if ((puimTmp->uimIdex & 0x3ff) > (puimUse->uimIdex & 0x3ff)) {
                                    if (puimTmp->uimCount > 0) {
                                        puimUse = puimTmp;
                                    }
                                }
                                ix++;
                                puimTmp = puimTmp->uimNxt;
                            }
        
                            if (ix > 0) {
                                puimGet = puimUse;
                            } 
                                
                            if (puimGet) {
                                sprintf_f(rs->logs, "[DV] get puim index: 0x%.2x %d:%d\n", puimGet->uimIdex, puimGet->uimGetCnt, puimGet->uimCount);
                                print_f(rs->plogs, sp, rs->logs);
                                
                                if (!chr) {
                                    if (puimGet->uimGetCnt < puimGet->uimCount) {
                                        chr = puimGet->uimIdex & 0x3ff;
        
                                        mindexfo[0] = ((chr >> 5) & 0x3f) | 0xc0;
                                        mindexfo[1] = (chr & 0x1f) | 0x40;
        
                                        pipRet = write(piptx[1], mindexfo, 2);
                                        if (pipRet < 0) {
                                            sprintf_f(rs->logs, "[DV]  pipe(%d) put chr: %d ret: %d \n", piptx[1], chr, pipRet);
                                            print_f(rs->plogs, sp, rs->logs);
                                            continue;
                                        }
        
                                        sprintf_f(rs->logs, "[DV]  new puimGet send req 0x%.8x \n", puimGet->uimIdex);
                                        print_f(rs->plogs, sp, rs->logs);
                                    } else {
                                        sprintf_f(rs->logs, "\n[DV] %d:%d wait for new data at begin \n", puimGet->uimGetCnt, puimGet->uimCount);
                                        print_f(rs->plogs, sp, rs->logs);
                                        chr = 0;
                                    }
                                }
                                else {
                                    sprintf_f(rs->logs, "[DV] should not be here chr: (%d) \n", chr);
                                    print_f(rs->plogs, sp, rs->logs);
                                }
                            }
                            else {
                                sprintf_f(rs->logs, "[DV] wait for more data \n");
                                print_f(rs->plogs, sp, rs->logs);
                            }
                        }
                        
                        if (puimCur) {
                            if ((puimCur->uimIdex & 0x3ff) == (cindex & 0x3ff)) {
                                puimCur->uimCount += 1;
                            }
                            else {
                                //sprintf_f(rs->logs, "[DV] current puim index not mach wait:0x%.3x, get:0x%.3x chr: 0x%.3x \n\n", puimCur->uimIdex, cindex, chr);
                                //print_f(rs->plogs, sp, rs->logs);
        
                                puimTmp= puimCnTH;
                                while(puimTmp) {
                                    puimUse = puimTmp;
                                    if ((puimUse->uimIdex & 0x3ff) == (cindex & 0x3ff)) {
                                        puimTmp = puimUse;
                                        break;
                                    }
                                    puimTmp = puimUse->uimNxt;
                                }
        
                                if (puimTmp) {
                                    puimTmp->uimCount += 1;
                                    puimCur = puimTmp;
                                } else {
                                    puimTmp = malloc(sizeof(struct usbIndex_s));
                                    if (!puimTmp) {
                                        sprintf_f(rs->logs, "\n\nError!!! can't get memory for puimTmp -2\n");
                                        print_f(rs->plogs, sp, rs->logs);
                                    }
        
                                    memset(puimTmp, 0, sizeof(struct usbIndex_s));
        
                                    puimTmp->uimIdex = cindex;
                                    puimTmp->uimCount += 1;
                                    puimUse->uimNxt = puimTmp;
        
                                    puimCur = puimTmp;
                                }
                            }
                        }
                        else {
                            if ((puimCnTH->uimIdex & 0x3ff) == (cindex & 0x3ff)) {
                                puimCnTH->uimCount += 1;
                                puimCur = puimCnTH;
                            } else {
                                puimTmp= puimCnTH;
                                while(puimTmp) {
                                    puimUse = puimTmp;
                                    if ((puimUse->uimIdex & 0x3ff) == (cindex  & 0x3ff)) {
                                        puimTmp = puimUse;
                                        break;
                                    }
                                    puimTmp = puimUse->uimNxt;
                                }
        
                                if (puimTmp) {
                                    puimTmp->uimCount += 1;                            
                                    puimCur = puimTmp;
                                } else {
                                    puimTmp = malloc(sizeof(struct usbIndex_s));
                                    if (!puimTmp) {
                                        sprintf_f(rs->logs, "\n\nError!!! can't get memory for puimTmp\n");
                                        print_f(rs->plogs, sp, rs->logs);
                                    }
                                    memset(puimTmp, 0, sizeof(struct usbIndex_s));
                            
                                    puimTmp->uimIdex = cindex;
                                    puimTmp->uimCount += 1;
                                    puimUse->uimNxt = puimTmp;
        
                                    puimCur = puimTmp;
                                }
                            }
                        }  
                    }
                    else if ((chq & 0xc0) == 0x80) {
                        if (!puimGet) {
                            sprintf_f(rs->logs, "\n[DV] Error!!! puimCur is null \n");
                            print_f(rs->plogs, sp, rs->logs);
                        }
                        else {
        
                            if (!chr) {
                                //sprintf_f(rs->logs, "\n[DV] Warnning !!! chr == 0 not make sense !!!\n");
                                //print_f(rs->plogs, sp, rs->logs);
                            }
        
                            cindexfo[0] = chq;
                            pipRet = read(piprx[0], &chq, 1);
                            while (pipRet < 0) {
                                pipRet = read(piprx[0], &chq, 1);
                            }
                            
                            if ((chq & 0xc0) == 0x40) {
                                cindexfo[1] = chq;
                            } else {
                                sprintf_f(rs->logs, "[DV]  WARNNING get unknown chq: 0x%.2x - 3\n", chq);
                                print_f(rs->plogs, sp, rs->logs);
                                continue;
                            }
        
                            cindex = ((cindexfo[0] & 0x3f) << 5) | (cindexfo[1] & 0x1f);
                            
                            if ((puimGet->uimIdex & 0x3ff) == (cindex & 0x3ff)) {
                                puimGet->uimGetCnt += 1;
                                
                                if (puimGet->uimGetCnt < puimGet->uimCount) {
                                    chr = puimGet->uimIdex & 0x3ff;
        
                                    mindexfo[0] = ((chr >> 5) & 0x3f) | 0xc0;
                                    mindexfo[1] = (chr & 0x1f) | 0x40;
        
                                    pipRet = write(piptx[1], mindexfo, 2);
                                    if (pipRet < 0) {
                                        sprintf_f(rs->logs, "[DV]  pipe(%d) put chr: %d ret: %d \n", piptx[1], chr, pipRet);
                                        print_f(rs->plogs, sp, rs->logs);
                                        continue;
                                    }
                                } else {
                                    chr = 0;
                                }
        
                                uimCylcnt = CYCLE_LEN;
                                
                                break;
                            }
                            else {
                                sprintf_f(rs->logs, "\n[DV] Error!!! puimCur index is not match!! \n");
                                print_f(rs->plogs, sp, rs->logs);
                            }
                        }
                    }
                    else {
                        if (chq == 0x7f) {
                            puimGet->uimGetCnt += 1;
        
                            memset(cinfo, 0, 12);
                            pipRet = read(piprx[0], cinfo, 10);
                            while (pipRet < 0) {
                                pipRet = read(piprx[0], cinfo, 10);
                            }
        
                            lastCylen = cinfo[6];
                            
                            lastCylen  = lastCylen << 8;
                            lastCylen |= cinfo[5];
        
                            lastCylen  = lastCylen << 8;
                            lastCylen |= cinfo[4];
                            
                            lastCylen  = lastCylen << 8;
                            lastCylen |= cinfo[3];
                            
                            uimCylcnt = (cinfo[0] & 0x7f) | ((cinfo[1] & 0x7f) << 7);
                            
                            cmdprisec = cinfo[2];
        
                            cswerr = cinfo[7] & 0x7f;
                            if (cswerr == 0x7f) {
                                cswerr = 0;
                            }
        
                            //sprintf_f(rs->logs, "[DV] get csw err: 0x%.2x \n", cswerr);
                            //print_f(rs->plogs, sp, rs->logs);
                            puimNxt = 0;
        
                            pagerst = cinfo[8] & 0x7f;
                            //sprintf_f(rs->logs, "[DV] get page rest: %d \n", pagerst);
                            //print_f(rs->plogs, sp, rs->logs);

                            if (cinfo[9] == 0x80) {
                                buffidx = 0;
                            } else {
                                buffidx = cinfo[9] & 0x7f;
                            }
                            
                            sprintf_f(rs->logs, "[DV] get decode buff idex: %d \n", buffidx);
                            print_f(rs->plogs, sp, rs->logs);

                            ret = aspBMPdecodeBuffGetIdx(rs->pbDecMfour[buffidx], &imgdex);
                            if (ret) {
                                sprintf_f(rs->logs, "[DV] check decode buff idex failed ret: %d \n", ret);
                                print_f(rs->plogs, sp, rs->logs);
                            }

                            if (imgdex != (puimGet->uimIdex & 0x3ff)) {
                                sprintf_f(rs->logs, "[DV] check decode buff imgdex: %d error!! should be %d \n", imgdex, puimGet->uimIdex & 0x3ff);
                                print_f(rs->plogs, sp, rs->logs);
                            }

                            sprintf_f(rs->logs, "[DV] buffid: %d check decode imgdex: %d (%d) \n", buffidx, imgdex, puimGet->uimIdex & 0x3ff);
                            print_f(rs->plogs, sp, rs->logs);
                            
                            sprintf_f(rs->logs, "[DV] get the last trunk read cycle: %d, lastlen: %d, cswerr: 0x%.2x pagerst: %d\n", uimCylcnt, lastCylen, cswerr, pagerst);
                            print_f(rs->plogs, sp, rs->logs);

                            if (uimCylcnt < 2) {
                                sprintf_f(rs->logs, "[DV] WARNING!!!! the cycle count == %d is error!!! should bigger than 2 \n", uimCylcnt);
                                print_f(rs->plogs, sp, rs->logs);
                            }
        
                            bmplen = (uimCylcnt - 2) * USB_BUF_SIZE;
                            bmplen += lastCylen;

                            #if 0// test code
                            if (buffidx >= 0) {
                                ret = aspBMPdecodeItemGet(&rs->pbDecMfour[buffidx]->aspDecJpeg, &bmpbuff);
                                if (ret < 0) {
                                    bmpbuff = 0;
                                    bmpmax = 0;
                                } else {
                                    bmpmax = aspBMPdecodeItemMax(&rs->pbDecMfour[buffidx]->aspDecJpeg);
                                }
                                
                                sprintf_f(rs->logs, "[BMP] pre allocate aspDecJpeg buffer: 0x%.8x max: %d req: %d ret: %d \n", (uint32_t)bmpbuff, bmpmax, bmplen, ret);
                                print_f(rs->plogs, sp, rs->logs);
                            }
                            #endif
                                
                            //sprintf_f(rs->logs, "[DV] cycle count: %d lastlen: %d total: %d \n", uimCylcnt, lastCylen, bmplen);
                            //print_f(rs->plogs, sp, rs->logs);
        
                            bmpbufc = 0;
                            cpylen = 0;
        
                            ret = cfgTableGetChk(pct, ASPOP_FILE_FORMAT, &fformat, ASPOP_STA_CON);    
                            //sprintf_f(rs->logs, "[BMP] get file format ret: %d format: 0x%.2x !!!\n", ret, fformat);
                            //print_f(rs->plogs, sp, rs->logs);
                            
                            if (ret) {
                                fformat = 0;
                            }
                            
                            #if GHP_EN_JPGH
                            //if (((fformat == FILE_FORMAT_RAW) || (fformat == FILE_FORMAT_JPG)) && (opc == 0x0f)) {
                            if (opc == 0x0f) {

                                sprintf(rs->logs, "__M4_PROCESS_START(%d)__", buffidx); 
                                tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 14, rs->logs);
                                
                                switch (fformat) {
                                case FILE_FORMAT_JPG:
                                if (buffidx >= 0) {
                                    ret = aspBMPdecodeItemGet(&rs->pbDecMfour[buffidx]->aspDecJpeg, &bmpbuff, 0);
                                    if (ret < 0) {
                                        bmpbuff = 0;
                                        bmpmax = 0;
                                    } else {
                                        bmpmax = aspBMPdecodeItemMax(&rs->pbDecMfour[buffidx]->aspDecJpeg);
                                    }

                                    ret = aspBMPdecodeItemGet(&rs->pbDecMfour[buffidx]->aspDecMeta, &buffmeta, 0);
                                    if (ret < 0) {
                                        buffmeta = 0;
                                        uselen = 0;
                                    } else {
                                        uselen = aspBMPdecodeItemMax(&rs->pbDecMfour[buffidx]->aspDecMeta);
                                    }
                                    
                                    //sprintf_f(rs->logs, "[BMP] pre allocate aspDecJpeg buffer: 0x%.8x max: %dKB req: %dKB ret: %d \n", (uint32_t)bmpbuff, bmpmax/1000, bmplen/1000, ret);
                                    //print_f(rs->plogs, sp, rs->logs);

                                    if (bmplen > bmpmax) {
                                        sprintf_f(rs->logs, "\n\n[BMP] pre allocate aspDecJpeg  max: %dKB  < req: %dKB Error!!!! \n", bmpmax/1000, bmplen/1000);
                                        print_f(rs->plogs, sp, rs->logs);
                                    }

                                }
                                //bmpbuff = aspMemalloc(bmplen, midx);
        
                                if (bmpbuff) {
                                    //sprintf_f(rs->logs, "[BMP] allocate bmp buffer size: %d succeed!!!\n", bmplen);
                                    //print_f(rs->plogs, sp, rs->logs);
        
                                    bmpbufc = bmpbuff;
                                } else {
                                    sprintf_f(rs->logs, "[BMP] allocate JPG buffer size: %d failed!!!\n", bmplen);
                                    print_f(rs->plogs, sp, rs->logs);
                                }
                                break;
                                case FILE_FORMAT_RAW:
                                if (buffidx >= 0) {
                                    ret = aspBMPdecodeItemGet(&rs->pbDecMfour[buffidx]->aspDecRaw, &bmpbuff, 0);
                                    if (ret < 0) {
                                        bmpbuff = 0;
                                        bmpmax = 0;
                                    } else {
                                        bmpmax = aspBMPdecodeItemMax(&rs->pbDecMfour[buffidx]->aspDecRaw);
                                    }

                                    ret = aspBMPdecodeItemGet(&rs->pbDecMfour[buffidx]->aspDecMeta, &buffmeta, 0);
                                    if (ret < 0) {
                                        buffmeta = 0;
                                        uselen = 0;
                                    } else {
                                        uselen = aspBMPdecodeItemMax(&rs->pbDecMfour[buffidx]->aspDecMeta);
                                    }
                                    
                                    //sprintf_f(rs->logs, "[BMP] pre allocate aspDecRaw buffer: 0x%.8x max: %dKB req: %dKB ret: %d \n", (uint32_t)bmpbuff, bmpmax/1000, bmplen/1000, ret);
                                    //print_f(rs->plogs, sp, rs->logs);

                                    if (bmplen > bmpmax) {
                                        sprintf_f(rs->logs, "\n\n[BMP] pre allocate aspDecRaw  max: %dKB  < req: %dKB Error!!!! \n", bmpmax/1000, bmplen/1000);
                                        print_f(rs->plogs, sp, rs->logs);
                                    }

                                }
                                //bmpbuff = aspMemalloc(bmplen, midx);
        
                                if (bmpbuff) {
                                    //sprintf_f(rs->logs, "[BMP] allocate bmp buffer size: %d succeed!!!\n", bmplen);
                                    //print_f(rs->plogs, sp, rs->logs);
        
                                    bmpbufc = bmpbuff;
                                } else {
                                    sprintf_f(rs->logs, "[BMP] allocate BMP buffer size: %d failed!!!\n", bmplen);
                                    print_f(rs->plogs, sp, rs->logs);
                                }
                                break;
                                default:
                                sprintf_f(rs->logs, "[BMP] Error!!! unknown file format 0x%x !!!\n", fformat);
                                print_f(rs->plogs, sp, rs->logs);
                                break;
                                }

                                sprintf(rs->logs, "__MEMCOPY_START(%d)__", buffidx); 
                                tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 32, rs->logs);
                                
                            }
                            #endif // #if GHP_EN_JPGH
        
                            switch (cmdprisec) {
                            case 1:
                                #if 1//LOG_JPGH_EN
                                sprintf_f(rs->logs, "[DV]  distinguish primary 0x7f 0x%.3x \n", puimGet->uimIdex);
                                print_f(rs->plogs, sp, rs->logs);
                                #endif
                                break;
                            case 2:
                                #if 1//LOG_JPGH_EN
                                sprintf_f(rs->logs, "[DV]  distinguish secondary 0x7f 0x%.3x \n", puimGet->uimIdex);
                                print_f(rs->plogs, sp, rs->logs);
                                #endif
                                break;
                            default:
                                sprintf_f(rs->logs, "[DV]  error!!! unknown cmdprisec: %d, at 0x7f index: 0x%.8x \n", cmdprisec, cindex);
                                print_f(rs->plogs, sp, rs->logs);
                                break;
                            }

                            if (puimCur == puimGet) {
                                puimCur = 0;
                            }
        
                            puimUse = 0;
                            
                            if (puimCnTH == puimGet) {
                                puimCnTH = puimGet->uimNxt;
                                
                                ix=0;
                                cindex = 0;
                                puimTmp = puimCnTH;
                                while (puimTmp) {
                                    puimUse = puimTmp;
                                    
                                    #if 1
                                    if (cindex == 0) {
                                        cindex = puimUse->uimIdex & 0x3ff;
                                        puimNxt = puimUse;
                                    } else {
                                        if ((puimUse->uimIdex & 0x3ff) < cindex) {
                                            cindex = puimUse->uimIdex & 0x3ff;
                                            puimNxt = puimUse;
                                        }
                                    }
                                    #else
                                    if ((puimUse->uimIdex & 0x3ff) == ((puimGet->uimIdex + 1) & 0x3ff)) {
                                        puimNxt = puimUse;
                                    }
                                    #endif
                                    
                                    puimTmp = puimUse->uimNxt;
                                    ix++;
                                }
                            } else {
                                ix=0;
                                cindex = 0;
                                puimTmp = puimCnTH;
                                while (puimTmp) {
                                    puimUse = puimTmp;
                                    
                                    #if 1
                                    if (cindex == 0) {
                                        cindex = puimUse->uimIdex & 0x3ff;
                                        puimNxt = puimUse;
                                    } else {
                                        if ((puimUse->uimIdex & 0x3ff) < cindex) {
                                            cindex = puimUse->uimIdex & 0x3ff;
                                            puimNxt = puimUse;
                                        }
                                    }
                                    #else
                                    if ((puimUse->uimIdex & 0x3ff) == ((puimGet->uimIdex + 1) & 0x3ff)) {
                                        puimNxt = puimUse;
                                    }
                                    #endif
                                    
                                    puimTmp = puimUse->uimNxt;
                                    if (puimTmp == puimGet) {
                                        puimUse->uimNxt = puimGet->uimNxt;
                                    }                
                                    puimTmp = puimUse->uimNxt;
                                    ix++;
                                }
                            }
        
                            free(puimGet);
                            puimGet = 0;
                            
                            if (puimNxt) {
                            
                                puimGet = puimNxt;
                                
                                #if 1//LOG_JPGH_EN
                                sprintf_f(rs->logs, "[DV] puimGet: 0x%.3x %d/%d\n", puimGet->uimIdex, puimGet->uimGetCnt, puimGet->uimCount);
                                print_f(rs->plogs, sp, rs->logs);
                                #endif
                            } else {
                                #if LOG_JPGH_EN
                                sprintf_f(rs->logs, "[DV] puimGet is null \n");
                                print_f(rs->plogs, sp, rs->logs);
                                #endif
                            }
        
                            ix = 0;
                            puimTmp = puimCnTH;
                            while(puimTmp) {
                            
                                #if LOG_JPGH_EN
                                sprintf_f(rs->logs, "[DV] page.%d - 0x%.2x %d:%d (addr:0x%.8x)\n", ix, puimTmp->uimIdex, puimTmp->uimGetCnt, puimTmp->uimCount, (uint32_t)puimTmp);
                                print_f(rs->plogs, sp, rs->logs);
                                #endif
        
                                if (puimTmp->uimCount > 0) {
                                    ix++;
                                }
        
                                puimTmp = puimTmp->uimNxt;
                            }                             
                                    
                            waitCylen = ix;
        
                            #if LOG_JPGH_EN
                            sprintf_f(rs->logs, "[DV] wait page number: %d, wait page rest: %d\n", waitCylen, pagerst);
                            print_f(rs->plogs, sp, rs->logs);
                            #endif
        
                            #if 0
                            if ((waitCylen > 0) || (pagerst > 1)) {
                                if (!puimNxt) {
        
                                    ix = (puimGet->uimIdex & 0x3ff) + 1;
                                    memset(puimGet, 0, sizeof(struct usbIndex_s));
                                    puimGet->uimIdex = ix;
                                    if (puimUse) {
                                        puimUse->uimNxt = puimGet;
                                    } else {
                                        puimCnTH = puimGet;
                                    }                                       
                            
                                    clock_gettime(CLOCK_REALTIME, &tidleS);
                                }
                                
                            } else {
                                if (!puimNxt) {
                                    if (puimGet) {
                                        free(puimGet);
                                        puimGet = 0;
                                    }
                                }
                            }
                            #endif
        
                            chr = 0;
                            
                            break;
                        } 
                        else {
                            #if 0//LOG_JPGH_EN
                            sprintf_f(rs->logs, "[DV] idle warning!!! chq: 0x%.2x chr: 0x%.2x puimGet: 0x%.8x puimCnTH: 0x%.8x\n", chq, chr, (uint32_t)puimGet, (uint32_t)puimCnTH);
                            print_f(rs->plogs, sp, rs->logs);
                            #endif
        
                            if ((!chq) && (!chr) && (puimGet)) {
                                if (puimGet->uimGetCnt < puimGet->uimCount) {
                                    chr = puimGet->uimIdex & 0x3ff;
                                    mindexfo[0] = ((chr >> 5) & 0x3f) | 0xc0;
                                    mindexfo[1] = (chr & 0x1f) | 0x40;

                                    if ((puimGet->uimIdex & 0x400) == 0) {
                                        #if 1//LOG_JPGH_EN
                                        sprintf_f(rs->logs, "[DV] checkbfrequire primary 0x80 0x%.8x \n", puimGet->uimIdex);
                                        print_f(rs->plogs, sp, rs->logs);
                                        #endif
                                    } else {
                                        #if 1//LOG_JPGH_EN
                                        sprintf_f(rs->logs, "[DV] checkbfrequire secondary 0x80 0x%.8x \n", puimGet->uimIdex);
                                        print_f(rs->plogs, sp, rs->logs);
                                        #endif
                                    }
                                    
                                    pipRet = write(piptx[1], mindexfo, 2);
                                    if (pipRet < 0) {
                                        sprintf_f(rs->logs, "[DV]  pipe(%d) put chr: %d ret: %d \n", piptx[1], chr, pipRet);
                                        print_f(rs->plogs, sp, rs->logs);
                                        continue;
                                    }
                                }
                            } else {
                                if ((puimCnTH) && (!puimGet)) {
                                    ix=0;
                                    cindex = 0;
                                    puimNxt = 0;
                                    puimTmp = puimCnTH;
                                    while (puimTmp) {
                                        puimUse = puimTmp;
                                    
                                        if (cindex == 0) {
                                            cindex = puimUse->uimIdex & 0x3ff;
                                            puimNxt = puimUse;
                                        } else {
                                            if ((puimUse->uimIdex & 0x3ff) < cindex) {
                                                cindex = puimUse->uimIdex & 0x3ff;
                                                puimNxt = puimUse;
                                            }
                                        }
        
                                        #if LOG_JPGH_EN
                                        sprintf_f(rs->logs, "[DV] idle page.%d - 0x%.2x %d:%d (addr:0x%.8x)\n", ix, puimTmp->uimIdex, puimTmp->uimGetCnt, puimTmp->uimCount, (uint32_t)puimTmp);
                                        print_f(rs->plogs, sp, rs->logs);
                                        #endif
        
                                        puimTmp = puimUse->uimNxt;
                                        ix++;
                                    }
        
                                    if (puimNxt) {
        
                                        puimGet = puimNxt;
        
                                        #if LOG_JPGH_EN
                                        sprintf_f(rs->logs, "[DV] idle get puimGet: 0x%.3x %d/%d\n", puimGet->uimIdex, puimGet->uimGetCnt, puimGet->uimCount);
                                        print_f(rs->plogs, sp, rs->logs);
                                        #endif
        
                                        if ((puimGet->uimIdex & 0x400) == 0) {
                                            #if LOG_JPGH_EN
                                            sprintf_f(rs->logs, "[DV] idle primary 0x80 0x%.8x \n", puimGet->uimIdex);
                                            print_f(rs->plogs, sp, rs->logs);
                                            #endif
                                        } else {
                                            #if LOG_JPGH_EN
                                            sprintf_f(rs->logs, "[DV] idle secondary 0x80 0x%.8x \n", puimGet->uimIdex);
                                            print_f(rs->plogs, sp, rs->logs);
                                            #endif
                                        }
                                    } else {
                                        #if LOG_JPGH_EN
                                        sprintf_f(rs->logs, "[DV] idle get puimGet is null \n");
                                        print_f(rs->plogs, sp, rs->logs);
                                        #endif
                                    }
                                }
                            }
                            continue;
                        }
                    }
                }
        
                if (uimCylcnt) {
                    lens = 0;
                    lens = ring_buf_cons_up(usbCur, &addrd, &addrb);                
                    while (lens < 0) {
                        //sprintf_f(rs->logs, "[DV] cons ring buff ret: %d \n", lens);
                        //print_f(rs->plogs, sp, rs->logs);
        
                        usleep(500);
                        lens = ring_buf_cons_up(usbCur, &addrd, &addrb);                
                    }
        
                    if (lens & 0x40000) {
                        lastflag = 0x40000;
                    } else {
                        lastflag = 0;
                    }
                    lens = lens & 0x1ffff;
        
                    uimCylcnt = uimCylcnt - 1;
        
                    distCylcnt = ring_buf_cons_tag(usbCur);
                    cntTx++;
        
                    msync(pinfcur, sizeof(struct usbHostmem_s), MS_SYNC);
        
                    #if GHP_EN_JPGH
                    if (bmpbufc) {
                        cpylen += lens;

                        if (cpylen < bmpmax) {
                            bmpcpy = memcpy(bmpbufc, addrd, lens);
                            msync(bmpcpy, lens, MS_SYNC);    
                            bmpbufc = bmpcpy + lens;
                        }
        
                        //shmem_dump(bmpcpy, 128);
                        //sprintf_f(rs->logs, "[BMP] copy len: %d, total: %d \n", lens, cpylen);
                        //print_f(rs->plogs, sp, rs->logs);
                    }
                    #endif //#if GHP_EN_JPGH
                    
                    upas = pinfcur->ushostpause;
                    ursm = pinfcur->ushostresume;
                    
                    #if USB_AUTO_RESUME
                    udist = pinfcur->ushostbmax - distCylcnt;
                    pinfcur->ushostbtrkbuffed = distCylcnt;
                    //pinfcur->ushostbtrkcms = pinfcur->ushostbtrktot - distCylcnt;
                    
                    #if DBG_PAUSE_RESUME
                    sprintf_f(rs->logs, "resume info distCylcnt: %d, udist: %d, buffered: %d avg: %d thrhld:%d\n", distCylcnt, udist, pinfcur->ushostbtrkbuffed, pinfcur->ushostbtrkpageavg, pinfcur->ushostbthrshold);
                    print_f(rs->plogs, sp, rs->logs);
                    #endif
        
                    #if DBG_PAUSE_RESUME
                    sprintf_f(rs->logs, "resume flag pause: %d, resume: %d udist: %d L1\n", upas, ursm, udist);
                    print_f(rs->plogs, sp, rs->logs);
                    #endif
        
                    if ((upas) && (ursm >= 0)) {
                        //udist = pinfcur->ushostbmax - pinfcur->ushostbtrkbuffed;
                        
                        if (pinfcur->ushostbtrkpageavg > pinfcur->ushostbthrshold) {
                            if (udist > pinfcur->ushostbtrkpageavg) {
                                //USB_IOCT_LOOP_READ_RESTART(usbid, &ix);
                                #if 0
                                pipRet = write(piptx[1], "v", 1);
                                if (pipRet < 0) {
                                    sprintf_f(rs->logs, "[DV]  pipe(%d) put resume: %c failed!!! ret: %d \n", piptx[1], "v", pipRet);
                                    print_f(rs->plogs, sp, rs->logs);
                                    continue;
                                }
                                #endif
        
                                if (pinfcur == pinfushost) {
                                    pinfcurd= pinfushostd;
                                } else {
                                    pinfcurd= pinfushost;
                                }
                                
                                msync(pinfcurd, sizeof(struct usbHostmem_s), MS_SYNC);
                                
                                upasd = pinfcurd->ushostpause;
                                ursmd = pinfcurd->ushostresume;
                                udistd = pinfcurd->ushostbmax - pinfcurd->ushostbtrkbuffed;
        
                                #if DBG_PAUSE_RESUME
                                sprintf_f(rs->logs, "resume flag pause: %d, resume: %d udistd: %d buffered: %d L2.\n", upasd, ursmd, udistd, pinfcurd->ushostbtrkbuffed);
                                print_f(rs->plogs, sp, rs->logs);
                                #endif
        
                                if ((upasd) && (ursmd >= 0)) {
                                    if (pinfcurd->ushostbtrkpageavg > pinfcurd->ushostbthrshold) {
                                        if (udistd > pinfcurd->ushostbtrkpageavg) {
                                        
                                            msync(pinfushost, sizeof(struct usbHostmem_s), MS_SYNC);
                                            msync(pinfushostd, sizeof(struct usbHostmem_s), MS_SYNC);
        
                                            pinfushost->ushostpause = 0;
                                            pinfushostd->ushostpause = 0;  
                                            
                                            pinfushost->ushostresume = 1;
                                            pinfushostd->ushostresume = 2;
                                            
                                            msync(pinfushost, sizeof(struct usbHostmem_s), MS_SYNC);
                                            msync(pinfushostd, sizeof(struct usbHostmem_s), MS_SYNC);
        
                                            #if 1//DBG_PAUSE_RESUME
                                            sprintf_f(rs->logs, "RESUME distCylcnt: %d, udist: %d, avg: %d, udistd: %d, avg: %d - 1. \n", distCylcnt, udist, pinfcur->ushostbtrkpageavg, udistd, pinfcurd->ushostbtrkpageavg);
                                            print_f(rs->plogs, sp, rs->logs);
                                            #endif
                                        }
                                    } 
                                }
                            }
                        }
                        else {
                            uthrhld = pinfcur->ushostbtrkpageavg * 6;
                            if (uthrhld > (pinfcur->ushostbmax - pinfcur->ushostbthrshold)) {
                                uthrhld = pinfcur->ushostbmax - pinfcur->ushostbthrshold;
                            }
                            
                            if ((uthrhld) && (udist > uthrhld)) {
                                //USB_IOCT_LOOP_READ_RESTART(usbid, &ix);
                                #if 0
                                pipRet = write(piptx[1], "v", 1);
                                if (pipRet < 0) {
                                    sprintf_f(rs->logs, "[DV]  pipe(%d) put resume: %c failed!!! ret: %d \n", piptx[1], "v", pipRet);
                                    print_f(rs->plogs, sp, rs->logs);
                                    continue;
                                }
                                #endif
                                
                                if (pinfcur == pinfushost) {
                                    pinfcurd= pinfushostd;
                                } else {
                                    pinfcurd= pinfushost;
                                }
                                
                                msync(pinfcurd, sizeof(struct usbHostmem_s), MS_SYNC);
                                
                                upasd = pinfcurd->ushostpause;
                                ursmd = pinfcurd->ushostresume;
                                udistd = pinfcurd->ushostbmax - pinfcurd->ushostbtrkbuffed;
        
                                #if DBG_PAUSE_RESUME
                                sprintf_f(rs->logs, "resume flag pause: %d, resume: %d udistd: %d L3\n", upasd, ursmd, udistd);
                                print_f(rs->plogs, sp, rs->logs);
                                #endif
        
                                if ((upasd) && (ursmd >= 0)) {
                                    if (pinfcurd->ushostbtrkpageavg < pinfcurd->ushostbthrshold) {
                                        uthrhld = pinfcurd->ushostbtrkpageavg * 6;
        
                                        if (uthrhld > (pinfcurd->ushostbmax - pinfcurd->ushostbthrshold)) {
                                            uthrhld = pinfcurd->ushostbmax - pinfcurd->ushostbthrshold;
                                        }
        
                                        if ((uthrhld) && (udistd > uthrhld)) {
        
                                            msync(pinfushost, sizeof(struct usbHostmem_s), MS_SYNC);
                                            msync(pinfushostd, sizeof(struct usbHostmem_s), MS_SYNC);
                                            
                                            pinfushost->ushostpause = 0;
                                            pinfushostd->ushostpause = 0;                                        
                                        
                                            pinfushost->ushostresume = 1;
                                            pinfushostd->ushostresume = 2;
        
                                            msync(pinfushost, sizeof(struct usbHostmem_s), MS_SYNC);
                                            msync(pinfushostd, sizeof(struct usbHostmem_s), MS_SYNC);
        
                                            #if 1//DBG_PAUSE_RESUME
                                            sprintf_f(rs->logs, "RESUME buff1: %d, buff2: %d, udist: %d, udistd: %d, avg1: %d, avg2: %d - 2.\n", distCylcnt, pinfcurd->ushostbtrkbuffed, udist, udistd, pinfcur->ushostbtrkpageavg, pinfcurd->ushostbtrkpageavg);
                                            print_f(rs->plogs, sp, rs->logs);
                                            #endif
                                        }
                                    }
                                }
                            }
                        }
                    }
                    #endif //#if USB_AUTO_RESUME
            
                    if ((uimCylcnt == 1) && (lastCylen > 0)){
                        lens = lastCylen;
                        lenbs = &ptmetausb->EPOINT_RESERVE1[0] - &ptmetausb->ASP_MAGIC_ASPC[0];
                        
                        shfmeta = lens % 512;
                        if (shfmeta < lenbs) {
                            sprintf_f(rs->logs, "Error!!! usb meta len less than expected len: %d expect: %d \n", shfmeta, lenbs);
                            print_f(rs->plogs, sp, rs->logs);
                        }
        
                        //sprintf_f(rs->logs, "dume usb meta size: %d / %d \n", shfmeta, lens);
                        //print_f(rs->plogs, sp, rs->logs);
        
                        pshfmeta = addrd + (lens - shfmeta);
        
                        #if LOG_JPGH_EN
                        shmem_dump(pshfmeta, shfmeta);
                        #endif

                        //sprintf_f(rs->logs, "usb meta forward to pc \n");
                        //print_f(rs->plogs, sp, rs->logs);
                        
                        /* deal with bmp retate */
                        memset(ptmetausb, 0, sizeof(struct aspMetaDataviaUSB_s));
                        memcpy(ptmetausb, pshfmeta, shfmeta);
                        //dbgMetaUsb(ptmetausb);

                        memcpy(buffmeta, pshfmeta, shfmeta);
                        aspBMPdecodeItemSet(&rs->pbDecMfour[buffidx]->aspDecMeta, 0, 0, shfmeta);
                        
                    }
        
                    #if LOG_JPGH_EN
                    sprintf_f(rs->logs, "[DV] addr: 0x%.8x lens: %d, cyclecnt: %d, lastCylen: %d dist: %d lastflag: 0x%.5x count: %d\n", (uint32_t)addrd, lens, uimCylcnt, lastCylen, distCylcnt, lastflag, cntTx);
                    print_f(rs->plogs, sp, rs->logs);
                    #endif
                    
                    msync(addrd, lens, MS_SYNC);
        
                    #if DBG_DUMP_DAT32
                    sprintf_f(rs->logs, "[DV] dump 32 - 3 [0x%.8x] \n", (uint32_t)addrd);
                    print_f(rs->plogs, sp, rs->logs);
                    shmem_dump(addrd, 32);
                    #endif
                }
                
                if ((lens > 0) && (lens < USB_BUF_SIZE) && (!uimCylcnt) && (lastflag)) {
                    che = 'E';

                    ret = aspBMPdecodeItemGet(&rs->pbDecMfour[buffidx]->aspDecMetaex, &exmtaout, 0);
                    if (ret < 0) {
                        exmtaout = 0;
                        exmax = 0;
                    } else {
                        exmax = aspBMPdecodeItemMax(&rs->pbDecMfour[buffidx]->aspDecMetaex);
                    }

                    sprintf_f(rs->logs, "[BMP] Metaex buffer: 0x%.8x max: %dKB req: %dKB ret: %d \n", (uint32_t)exmtaout, exmax/1000, lens/1000, ret);
                    print_f(rs->plogs, sp, rs->logs);

                    if (lens > exmax) {
                        sprintf_f(rs->logs, "\n\n[BMP] pre allocate aspDecMetaex  max: %dKB  < req: %dKB Error!!!! \n", exmax/1000, lens/1000);
                        print_f(rs->plogs, sp, rs->logs);
                    } else {

                        memcpy(exmtaout, addrd, lens);

                        aspBMPdecodeItemSet(&rs->pbDecMfour[buffidx]->aspDecMetaex, 0, 0, lens);
                    }
                    
                }
        
                sendsz = 0;
                
                if (che == 'E') break;
            }

            sprintf(rs->logs, "__MEMCOPY_END(%d)__", buffidx); 
            tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 32, rs->logs);

            #if MFOUR_SIM_MODE
            if (cswerr == 0) {
                switch (fformat) {
                case FILE_FORMAT_JPG:
                ret = send_image_in_jpg(rs, buffidx, midx, &simMax);
                if (ret) {
                    sprintf_f(rs->logs, "[SIM] Error!!! m4 sim get jpg ret: %d \n", ret);
                    print_f(rs->plogs, sp, rs->logs); 
                }

                sprintf_f(rs->logs, "[BMP] m4 sample get jpg ret: %d, max: %d  \n", ret, simMax);
                print_f(rs->plogs, sp, rs->logs); 
                
                break;
                case FILE_FORMAT_RAW:
                ret = send_image_in_bmp(rs, buffidx, midx, &simMax);
                if (ret) {
                    sprintf_f(rs->logs, "[SIM] Error!!! m4 sim get bmp ret: %d \n", ret);
                    print_f(rs->plogs, sp, rs->logs); 
                }

                sprintf_f(rs->logs, "[BMP] m4 sample get raw ret: %d, max: %d  \n", ret, simMax);
                print_f(rs->plogs, sp, rs->logs); 
                break;
                default:
                sprintf_f(rs->logs, "Error!!! unknown format: %d  \n", fformat);
                print_f(rs->plogs, sp, rs->logs); 
                    break;
                }
                
                ret = aspBMPdecodeItemGet(&rs->pbDecMfour[buffidx]->aspDecMeta, &buffmeta, &mtlen);
                if (ret < 0) {
                    buffmeta = 0;
                    mtlen = 0;
                    uselen = 0;
                } else {
                    uselen = aspBMPdecodeItemMax(&rs->pbDecMfour[buffidx]->aspDecMeta);
                }
                
                sprintf_f(rs->logs, "[BMP] m4 sample get meta size: %d(%d) \n", mtlen, sizeof(struct aspMetaDataviaUSB_s));
                print_f(rs->plogs, sp, rs->logs); 
                
                memset(ptmetausb, 0, sizeof(struct aspMetaDataviaUSB_s));
                memcpy(ptmetausb, buffmeta, mtlen);                        
                                        
                ret = aspBMPdecodeItemGet(&rs->pbDecMfour[buffidx]->aspDecMetaex, &exmtaout, &extlen);
                if (ret < 0) {
                    exmtaout = 0;
                    exmax = 0;
                    extlen = 0;
                } else {
                    exmax = aspBMPdecodeItemMax(&rs->pbDecMfour[buffidx]->aspDecMetaex);
                }
                
                //sprintf_f(rs->logs, "[BMP] m4 sample get extra meta size: %d \n", extlen);
                //print_f(rs->plogs, sp, rs->logs); 
                
                addrd = exmtaout;
                lens = extlen;
            }
            #endif // #if MFOUR_SIM_MODE
        
            rawlen = cpylen - lens;
            
            sprintf_f(rs->logs, "[BMP] cpylen: %d, rawlen: %d, lastlen: %d, metaex len: %d \n", cpylen, rawlen, lastCylen, lens);
            print_f(rs->plogs, sp, rs->logs); 
        
            bmpbufc = bmpbuff;
        
            act = aspMetaReleaseviaUsbdlBmp(0, rs, addrd, lens);
        
            val=0;
            ret = cfgTableGetChk(pct, ASPOP_IMG_LEN, &val, ASPOP_STA_APP);    
            sprintf_f(rs->logs, "[BMP] image length: %d \n", val);
            print_f(rs->plogs, sp, rs->logs);
            bmph = val;
        
            //bhlen = 0;
            
            if (act || (bmph == 0)) {
                sprintf_f(rs->logs, "[BMP] pop usb meta failed ret: %d bmph: %d addr: 0x%.8x lens: %d\n", act, bmph, (uint32_t)addrd, lens);
                print_f(rs->plogs, sp, rs->logs); 

                if (act) continue;

            } else {
                //sprintf_f(rs->logs, "[BMP] pop usb meta succeed!! \n");
                //print_f(rs->plogs, sp, rs->logs); 
        
                ret = cfgTableGetChk(pct, ASPOP_COLOR_MODE, &val, ASPOP_STA_APP);    
                switch (val) {
                case COLOR_MODE_COLOR:
                    colr = 24;
                    break;
                case COLOR_MODE_GRAY:
                case COLOR_MODE_GRAY_DETAIL:
                case COLOR_MODE_BLACKWHITE:
                    colr = 8;
                    break;
                default:
                    colr = 24;
                    break;
                }
                //sprintf_f(rs->logs, "[BMP] color mode: %d, ret: %d, bpp: %d \n", val, ret, colr);
                //print_f(rs->plogs, sp, rs->logs);
        
                ret = cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_H, &val, ASPOP_STA_APP);    
        
                ret |= cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_L, &tmp, ASPOP_STA_APP);    
                tmp = val << 8 | tmp;
                //sprintf_f(rs->logs, "[BMP] width high: %d, ret:%d\n", tmp, ret);
                //print_f(rs->plogs, sp, rs->logs);
        
                val = 0;
                ret = cfgTableGetChk(pct, ASPOP_SCAN_WIDTH, &val, ASPOP_STA_UPD);
                bmpw = scanWidthConvert(tmp, val);
                //sprintf_f(rs->logs, "[BMP] defined width: %d, scan width = %d result width: %d \n", tmp, val, bmpw);
                //print_f(rs->plogs, sp, rs->logs);

                tmp = 0;
                ret = cfgTableGetChkDPI(pct, ASPOP_RESOLUTION, &tmp, ASPOP_STA_APP);    
                bdpi = tmp;
                //sprintf_f(rs->logs, "[BMP] resulution cfg: %d, dpi: %d\n", tmp, bdpi);
                //print_f(rs->plogs, sp, rs->logs);

                tmp = ((bmpw * colr + 31) / 32) * 4;
                bmphmax = (bmpmax - 1078) / tmp;
                
                jpgout = 0;
                
                #if MFOUR_SIM_MODE
                switch (fformat) {
                case FILE_FORMAT_JPG:
                    if (cswerr == 0) {
                        bmpw = rs->pbDecMfour[buffidx]->aspDecJpeg.aspDcWidth;
                        bmph = rs->pbDecMfour[buffidx]->aspDecJpeg.aspDcHeight;
                        aspBMPdecodeItemGet(&rs->pbDecMfour[buffidx]->aspDecJpeg, &bmpbuff, &bmplen);
                    } else {
                        aspBMPdecodeItemSet(&rs->pbDecMfour[buffidx]->aspDecJpeg, bmpw, bmph, rawlen);
                    }
                    break;
                case FILE_FORMAT_RAW:
                    if (cswerr == 0) {
                        bmpw = rs->pbDecMfour[buffidx]->aspDecRaw.aspDcWidth;
                        bmph = rs->pbDecMfour[buffidx]->aspDecRaw.aspDcHeight;
                        aspBMPdecodeItemGet(&rs->pbDecMfour[buffidx]->aspDecRaw, &bmpbuff, &bmplen);
                    } else {
                        aspBMPdecodeItemSet(&rs->pbDecMfour[buffidx]->aspDecRaw, bmpw, bmph, rawlen);
                    }
                    jpgout = bmpbuff;
                    break;
                }
                
                val=bmph;
                ret = cfgTableUpd(pct, ASPOP_IMG_LEN, val);
                //ret = cfgTableGetChk(pct, ASPOP_IMG_LEN, &val, ASPOP_STA_APP);    
                //sprintf_f(rs->logs, "[BMP] hack image length: %d \n", val);
                //print_f(rs->plogs, sp, rs->logs);                
                #else
                
                sprintf_f(rs->logs, "[BMP] bmphmax: %d, bmph: %d\n", bmphmax, bmph);
                print_f(rs->plogs, sp, rs->logs);
                
                if (bmphmax < bmph) {
                    rotlast = bmphmax % ptmetausb->BKNote_Total_Layers;
                    val = bmphmax - rotlast;
                } else {
                    val = bmph;
                }

                if (rawlen > bmpmax) {
                    bhlen = bmpmax;
                } else {
                    bhlen = rawlen;                    
                }
                    
                switch (fformat) {
                case FILE_FORMAT_JPG:
                    
                    aspBMPdecodeItemSet(&rs->pbDecMfour[buffidx]->aspDecJpeg, bmpw, val, bhlen);
                    break;
                case FILE_FORMAT_RAW:
                    pdecraw = &rs->pbDecMfour[buffidx]->aspDecRaw;
                    pdecraw->aspDcData->mfourAttb.ImageRect.xc = bmpw;
                    pdecraw->aspDcData->mfourAttb.ImageRect.yr = val;
                    pdecraw->aspDcData->mfourIdx = buffidx;

                    shmem_dump((char *)&pdecraw->aspDcData->mfourAttb.ImageLayerInfo, 8);

                    memcpy(&pdecraw->aspDcData->mfourAttb.ImageLayerInfo, &ptmetausb->BKNote_Total_Layers, sizeof(t_ImageLayers));

                    shmem_dump((char *)&pdecraw->aspDcData->mfourAttb.ImageLayerInfo, 8);
                    
                    aspBMPdecodeItemSet(&rs->pbDecMfour[buffidx]->aspDecRaw, bmpw, val, bhlen);
                    jpgout = bmpbuff;
                    break;
                default:
                    break;
                }
                #endif 

                #if GHP_EN_JPGH
                if (fformat == FILE_FORMAT_JPG) {
                    tmp = ((bmpw * colr + 31) / 32) * 4;
                    tmp = tmp * bmph + 1078;
                    //jpgout = aspMemalloc(tmp, midx);
                    pdecraw = &rs->pbDecMfour[buffidx]->aspDecRaw;
                    if (buffidx >= 0) {
                        ret = aspBMPdecodeItemGet(pdecraw, &jpgout, 0);
                        if (ret < 0) {
                            jpgout = 0;
                            outmax = 0;
                        } else {
                            outmax = aspBMPdecodeItemMax(&rs->pbDecMfour[buffidx]->aspDecRaw);
                        }
                        
                        //sprintf_f(rs->logs, "[BMP] pre allocate aspDecRaw buffer: 0x%.8x max: %dKB req: %dKB ret: %d \n", (uint32_t)jpgout, outmax/1000, tmp/1000, ret);
                        //print_f(rs->plogs, sp, rs->logs);
                    }
                    
                    if (!jpgout) {
                        //sprintf_f(rs->logs, "[BMP] to get memory for jpeg decode out, size: %d succeed!!!\n", tmp);
                        //print_f(rs->plogs, sp, rs->logs);
                    //} else {
                        sprintf_f(rs->logs, "[BMP] to get memory for jpeg decode out, size: %d failed!!!\n", tmp);
                        print_f(rs->plogs, sp, rs->logs);
                    }
        
                    changeJpgLen(bmpbuff, bmph, bmplen);
                    
                    msync(ptmetausb, sizeof(struct aspMetaDataviaUSB_s), MS_SYNC);
                    //dbgMetaUsb(ptmetausb);

                    #if 1 /* partial decode */
                    uint32_t upos1=0, coffsetx=0, upos4=0, coffsetw=0;
                    uint32_t upos9=0, coffsety=0, upos11=0, coffseth=0;

                    upos1 = msb2lsb32(&ptmetausb->CROP_POS_1);
                    coffsetx = (upos1 >> 16) & 0xffff;
                    coffsetx += 50;
                    upos4 = msb2lsb32(&ptmetausb->CROP_POS_4);
                    coffsetw = (upos4 >> 16) & 0xffff;
                    coffsetw -= 50;
                    coffsetw = coffsetw - coffsetx;
                    if (bdpi >= 200) {
                        coffsetx = (coffsetx * bdpi) / 300;
                        coffsetw = (coffsetw * bdpi) / 300;
                    }

                    upos9 = msb2lsb32(&ptmetausb->CROP_POS_9);
                    coffsety = upos9 & 0xffff;
                    //coffsety += 50;                    
                    upos11 = msb2lsb32(&ptmetausb->CROP_POS_11);
                    coffseth = upos11 & 0xffff;
                    coffseth -= 50;
                    coffseth = coffseth - coffsety;
                    
                    sprintf_f(rs->logs, "[JPG] p1: 0x%.8x offsetx: %d, p4: 0x%.8x offsetw: %d\n", upos1, coffsetx, upos4, coffsetw);
                    print_f(rs->plogs, sp, rs->logs);
                    sprintf_f(rs->logs, "[JPG] p9: 0x%.8x offsetx: %d, p11: 0x%.8x offsetw: %d\n", upos9, coffsety, upos11, coffseth);
                    print_f(rs->plogs, sp, rs->logs);
                    #endif
                    
                    clock_gettime(CLOCK_REALTIME, &jpgS);

                    sprintf(rs->logs, "__JPG_DECODE_START(%d)__", buffidx); 
                    tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 32, rs->logs);

                    if ((bmphmax > bmph)) {
                        err = jpeg2rgb(bmpbuff, bmplen, jpgout + 1078, tmp, &jpgetW, &jpgetH, colr);
                        //err = jpeg2rgbRvs(bmpbuff, bmplen, jpgout + 1078, tmp, &jpgetW, &jpgetH, colr);
                        //err = jpeg2rgbW(bmpbuff, bmplen, jpgout + 1078, tmp, &jpgetW, &jpgetH, colr, coffsetx, coffsetw);
                        //err = jpeg2rgbWH(bmpbuff, bmplen, jpgout + 1078, tmp, &jpgetW, &jpgetH, colr, coffsetx, coffsetw, coffsety, coffseth);
                    } else {
                        jpgetW = bmpw;
                        jpgetH = bmphmax;
                    
                        memset(jpgout + 1078, 0xff, bmpmax - 1078);
                    }

                    sprintf(rs->logs, "__JPG_DECODE_END(%d)__", buffidx); 
                    tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 32, rs->logs);
                    
                    clock_gettime(CLOCK_REALTIME, &jpgE);
        
                    tmCost = time_diff(&jpgS, &jpgE, 1000);

                    if (bmphmax < bmph) {
                        val = ptmetausb->BKNote_Total_Layers;
                        rotlast = jpgetH % val;
                        jpgetH = jpgetH - rotlast;

                        tmp = ((bmpw * colr + 31) / 32) * 4;
                        tmp = tmp * jpgetH + 1078;
                    }
                        
                    sprintf_f(rs->logs, "[JPG] decode jpg ret: %d w: %d h: %d cost: %d.%d ms\n", err, jpgetW, jpgetH, tmCost/1000, tmCost%1000);
                    print_f(rs->plogs, sp, rs->logs);
                
                    pdecraw->aspDcData->mfourAttb.ImageRect.xc = jpgetW;
                    pdecraw->aspDcData->mfourAttb.ImageRect.yr = jpgetH;
                    pdecraw->aspDcData->mfourIdx = buffidx;

                    shmem_dump((char *)&pdecraw->aspDcData->mfourAttb.ImageLayerInfo, 8);

                    memcpy(&pdecraw->aspDcData->mfourAttb.ImageLayerInfo, &ptmetausb->BKNote_Total_Layers, sizeof(t_ImageLayers));

                    shmem_dump((char *)&pdecraw->aspDcData->mfourAttb.ImageLayerInfo, 8);
                    
                    aspBMPdecodeItemSet(&rs->pbDecMfour[buffidx]->aspDecRaw, jpgetW, jpgetH, tmp);

                    bmpw = jpgetW;
                    bmph = jpgetH;

                }
                #endif
                
                bmpcolrtb = jpgout;
        
                if (colr == 8) {
                    blen = 1078;
                } else if (colr == 24) {
                    blen = 54;            
                } else {
                    sprintf_f(rs->logs, "[BMP] error!!! unknown color bits: %d \n", colr);
                    print_f(rs->plogs, sp, rs->logs);   
                }

                if (bmphmax < bmph) {
                    val = ptmetausb->BKNote_Total_Layers;
                    rotlast = bmphmax % val;
                    bmph = bmphmax - rotlast;
                }
                
                //bhlen = blen;
                val = ((bmpw * colr + 31) / 32) * 4;
                val = val * bmph;
        
                sprintf_f(rs->logs, "[BMP] bitmap info color: %d, w: %d, h: %d, dpi: %d, raw size: %d, header size: %d\n", colr, bmpw, bmph, bdpi, val, blen);
                print_f(rs->plogs, sp, rs->logs);
        
                bitmapHeaderSetup(bheader, colr, bmpw, bmph, bdpi, val);
        
                ph = &rs->pbheader->aspbmpMagic[2];
                val = sizeof(struct bitmapHeader_s) - 2;
                memcpy(bmpcolrtb, ph, val);
        
                blen -= val;
                if (blen > 0) {
                    bitmapColorTableSetup(bmpcolrtb+val);
                    blen -= 1024;
                }
        
                if (blen) {
                    sprintf_f(rs->logs, "[BMP] Error!!! the bitmap header's len is wrong %d\n", blen);
                    print_f(rs->plogs, sp, rs->logs);
                } 
                    
                //dbgBitmapHeader(bheader, val);
            }

            #if MFOUR_SIM_MODE
            if (cswerr) {
                mfourinfo[0] = 'd';
            } else {
                mfourinfo[0] = 's';
            }
            #else
            mfourinfo[0] = 'd';
            #endif

            if (buffidx == 0) {
                mfourinfo[1] = 0x80;
            } else {
                mfourinfo[1] = buffidx & 0x7f;
            }

            mbstat = 0;
            val = 0;
            ret = aspBMPdecodeBuffPagerstGet(rs->pbDecMfour[buffidx], &val);
            ret |= aspBMPdecodeBuffStatusGet(rs->pbDecMfour[buffidx], &mbstat);
            //sprintf_f(rs->logs, "[BMP] bmp buff idx %d get status: 0x%.4x pagerst: %d ret: %d \n", buffidx, mbstat, val, ret);
            //print_f(rs->plogs, sp, rs->logs);

            //mbstat = (mbstat << 1) | 0x01;
            val = pagerst;
            mbstat = cswerr;

            ret = aspBMPdecodeBuffPagerstSet(rs->pbDecMfour[buffidx], val);                        
            ret |= aspBMPdecodeBuffStatusSet(rs->pbDecMfour[buffidx], mbstat);
            //sprintf_f(rs->logs, "[BMP] bmp buff idx %d set status: 0x%.4x pagerst: %d ret: %d \n", buffidx, mbstat, val, ret);
            //print_f(rs->plogs, sp, rs->logs);

            mbstat = 0;
            imgdex = 0;
            val = 0;
            ret = aspBMPdecodeBuffGetIdx(rs->pbDecMfour[buffidx], &imgdex);
            ret |= aspBMPdecodeBuffStatusGet(rs->pbDecMfour[buffidx], &mbstat);
            ret |= aspBMPdecodeBuffPagerstGet(rs->pbDecMfour[buffidx], &val);
            sprintf_f(rs->logs, "[BMP] double check bmp buff idx %d, image index: %d, status: 0x%x pagerst: %d ret: %d \n", buffidx, imgdex, mbstat, val, ret);
            print_f(rs->plogs, sp, rs->logs);
                
            rs_ipc_put(rs, mfourinfo, 2);

            che = 0;
            maxCylcnt = cntTx;
            cntTx = 0;
            
        }
    }
    
    //p13_end(rs);

    while (1) {
        ret = rs_ipc_get_ms(rs, &ch, 1, 5000);

        if (ret > 0) {
            sprintf_f(rs->logs, "break loop!!! get ch[0x%.2x] \n", ch);
            print_f(rs->plogs, sp, rs->logs);
        } else {
            sprintf_f(rs->logs, "JPG host not available !!\n");
            print_f(rs->plogs, sp, rs->logs);
        }
    }

    return -1;
}

#define LOG_P13_EN (1)
static int p13(struct procRes_s *rs)
{
    int ret=0;
    char ch=0;
    sprintf_f(rs->logs, "p13\n");
    print_f(rs->plogs, "P13", rs->logs);

    p13_init(rs);

    prctl(PR_SET_NAME, "msp-p13");

    while (1) {
        ret = jpghostd(rs, "P13", LOG_P13_EN, 13);
    }
    
    while (1) {
        ret = rs_ipc_get_ms(rs, &ch, 1, 5000);

        if (ret > 0) {
            sprintf_f(rs->logs, "break loop!!! get ch[0x%.2x] \n", ch);
            print_f(rs->plogs, "P13", rs->logs);
        } else {
            sprintf_f(rs->logs, "break loop!!! not available !!\n");
            print_f(rs->plogs, "P13", rs->logs);
        }
    }
    
    p13_end(rs);

    return 0;
}

#define LOG_P14_EN (1)
static int p14(struct procRes_s *rs)
{
    int ret=0;
    char ch=0;
    sprintf_f(rs->logs, "p14\n");
    print_f(rs->plogs, "P14", rs->logs);

    p14_init(rs);

    prctl(PR_SET_NAME, "msp-p14");

    while (1) {
        ret = jpghostd(rs, "P14", LOG_P14_EN, 14);
    }

    while (1) {
        ret = rs_ipc_get_ms(rs, &ch, 1, 5000);

        if (ret > 0) {
            sprintf_f(rs->logs, "break loop!!! get ch[0x%.2x] \n", ch);
            print_f(rs->plogs, "P14", rs->logs);
        } else {
            sprintf_f(rs->logs, "break loop!!! not available !!\n");
            print_f(rs->plogs, "P14", rs->logs);
        }
    }
    
    p14_end(rs);
    
    return 0;
}

#define LOG_P15_EN (1)
static int p15(struct procRes_s *rs)
{
    int *cutsides=0, *cutlayers=0;
    char *bmpcolrtb=0, *ph=0, *bmprot=0, *bmpbuff=0, *bmpbufc=0, *bmpcpy=0, *metaPt=0, *exmeta=0, *buffmeta=0, *bufftmp=0, *bufforg=0;
    int ret=0, mfbidx=0, mfcmd=0, mfbstat=0, colr=0, blen=0, bhlen=0, bdpp=0, val=0, bmpw=0, bmph=0, bdpi=0, tmp=0, err=0, tmplen=0, orglen=0;
    int prisec=0, cutcnt=0, cutnum=0, tmCost=0, rotlen=0, jpgLen, sides[2]={0}, mreal[2]={0}, updn=0, lenbs=0, bmpmax=0;
    int lastCylen=0, lrst=0, ix=0, uselen=0, rstlen=0, exmlen=0, exmax=0, bmtlen=0, bmtmax=0, imgidx=0;
    uint32_t fformat=0, u32tmp=0;
    char ch=0;
    unsigned char *jpgrlt=0;
    char *rotsrc[8]={0}, *rotdst[8]={0};
    int rotsmax[8]={0}, rotdmax[8]={0}, rotsrclen[8]={0};
    struct sdParseBuff_s *pabuff=0;
    struct timespec jpgS, jpgE;
    struct usbhost_s *pushost=0;
    struct aspMetaData_s *metaRx = 0;
    struct aspConfig_s *pct=0, *pdt=0;
    struct bitmapHeader_s *bheader=0, bmpheader, *rawheader=0;
    struct aspMetaDataviaUSB_s *ptmetausb=0, *metatmp=0;
    struct bitmapDecodeItem_s *pdecroi=0, *penroi=0, *pdecraw=0;
    char pinfo[2];
    char *buffraw=0;
    int rawlen=0;
    
    sprintf_f(rs->logs, "p15\n");
    print_f(rs->plogs, "P15", rs->logs);

    p15_init(rs);

    prctl(PR_SET_NAME, "msp-p15");


    pct = rs->pcfgTable;
    pabuff = &rs->psFat->parBuf;
    rs->pbheader = malloc(sizeof(struct bitmapHeader_s));
    bheader = &bmpheader;
    memset(bheader, 0, sizeof(struct bitmapHeader_s));
    //bheader = rs->pbheader;
    //ptmetausb = rs->pmetausb;

    pushost = rs->pusbhost;
    metaPt = pushost->puhsmeta;
    metaRx = (struct aspMetaData_s *)metaPt;

    while (1) {
    
        aspMemClear(aspMemAsign, asptotMalloc, 15);

        ret = rs_ipc_get_ms(rs, &ch, 1, 5000);
        if (ret > 0) {
            //sprintf_f(rs->logs, "get ch[0x%.2x] %c\n", ch, ch);
            //print_f(rs->plogs, "P15", rs->logs);
            
        } else {
            //rs_ipc_put(rs, "h", 1);
        
            //sprintf_f(rs->logs, "host not available !!\n");
            //print_f(rs->plogs, "P15", rs->logs);

            continue;
        }

        mfcmd = ch;

        #if 1
        switch (mfcmd) {
        case '1':
            pinfo[0] = '1';
            rs_ipc_put(rs, pinfo, 1);
            break;
        case 'e':
            ret = rs_ipc_get_ms(rs, &ch, 1, 5000);
            if (ret > 0) {
                //sprintf_f(rs->logs, "e get cont ch[0x%.2x] \n", ch);
                //print_f(rs->plogs, "P15", rs->logs);

                if (ch == 0x80) {
                    mfbidx = 0;
                } else {
                    mfbidx = ch & 0x7f;
                }

                if (mfbidx > 3) {
                    sprintf_f(rs->logs, "get buff index %d error!!! \n", mfbidx);
                    print_f(rs->plogs, "P15", rs->logs);
                    break;
                } else {
                    //sprintf_f(rs->logs, "get buff index %d succed!!! \n", mfbidx);
                    //print_f(rs->plogs, "P15", rs->logs);
                }
                                
                imgidx = 0;
                mfbstat = 0;
                ret = aspBMPdecodeBuffGetIdx(rs->pbDecMfour[mfbidx], &imgidx);
                ret = aspBMPdecodeBuffStatusGet(rs->pbDecMfour[mfbidx], &mfbstat);
                sprintf_f(rs->logs, "encode m4 get mfbuff index %d, imgindex: %d, status 0x%x succeed!!! \n", mfbidx, imgidx, mfbstat);
                print_f(rs->plogs, "P15", rs->logs);

                ret = aspBMPdecodeItemGet(&rs->pbDecMfour[mfbidx]->aspDecRaw, &bmpbuff, &uselen);
                if (ret < 0) {
                    bmpbuff = 0;
                    bmpmax = 0;
                    uselen = 0;
                } else {
                    bmpmax = aspBMPdecodeItemMax(&rs->pbDecMfour[mfbidx]->aspDecRaw);
                }

                ret = aspBMPdecodeItemGet(&rs->pbDecMfour[mfbidx]->aspDecMeta, &buffmeta, &bmtlen);
                if (ret < 0) {
                    buffmeta = 0;
                    bmtmax = 0;
                    bmtlen = 0;
                } else {
                    bmtmax = aspBMPdecodeItemMax(&rs->pbDecMfour[mfbidx]->aspDecMeta);
                }
                
                ret = aspBMPdecodeItemGet(&rs->pbDecMfour[mfbidx]->aspDecMetaex, &exmeta, &exmlen);
                if (ret < 0) {
                    exmeta = 0;
                    exmax = 0;
                    exmlen = 0;
                } else {
                    exmax = aspBMPdecodeItemMax(&rs->pbDecMfour[mfbidx]->aspDecMetaex);
                }

                rstlen = uselen % 512;
                //sprintf_f(rs->logs, "get raw len: %d max: %d get meta len: %d max: %d get extra meta len: %d max: %d restlen: %d \n", uselen, bmpmax, bmtlen, bmtmax, exmlen, exmax, rstlen);
                //print_f(rs->plogs, "P15", rs->logs);

                //shmem_dump(buffmeta, bmtlen);
                
                ptmetausb = (struct aspMetaDataviaUSB_s *)buffmeta;
                //dbgMetaUsb(ptmetausb);

                bmph = (ptmetausb->IMG_HIGH[1] << 8) | ptmetausb->IMG_HIGH[0];

                ret = cfgTableGetChk(pct, ASPOP_COLOR_MODE, &val, ASPOP_STA_APP);    
                switch (val) {
                case COLOR_MODE_COLOR:
                    colr = 24;
                    break;
                case COLOR_MODE_GRAY:
                case COLOR_MODE_GRAY_DETAIL:
                case COLOR_MODE_BLACKWHITE:
                    colr = 8;
                    break;
                default:
                    colr = 24;
                    break;
                }
                //sprintf_f(rs->logs, "[BMP] color mode: %d, ret: %d, bpp: %d \n", val, ret, colr);
                //print_f(rs->plogs, "P15", rs->logs);
            
                ret = cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_H, &val, ASPOP_STA_APP);    

                ret |= cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_L, &tmp, ASPOP_STA_APP);    
                tmp = val << 8 | tmp;

                val = 0;
                ret = cfgTableGetChk(pct, ASPOP_SCAN_WIDTH, &val, ASPOP_STA_UPD);
                
                bmpw = scanWidthConvert(tmp, val);
                bmpw = (ptmetausb->IMG_WIDTH[1] << 8) | ptmetausb->IMG_WIDTH[0];
                
                //sprintf_f(rs->logs, "[BMP] defined width: %d, scan width = %d result width: %d \n", tmp, val, bmpw);
                //print_f(rs->plogs, "P15", rs->logs);

                ret = cfgTableGetChk(pct, ASPOP_FILE_FORMAT, &fformat, ASPOP_STA_CON);    
                sprintf_f(rs->logs, "[BMP] get file format format: 0x%.2x ret: %d !!!\n", fformat, ret);
                print_f(rs->plogs, "P15", rs->logs);
                if (ret) {
                    fformat = 0;
                }
                            
                tmp = 0;
                ret = cfgTableGetChkDPI(pct, ASPOP_RESOLUTION, &tmp, ASPOP_STA_APP);    
                bdpi = tmp;
                //sprintf_f(rs->logs, "[BMP] resulution cfg: %d, dpi: %d\n", tmp, bdpi);
                //print_f(rs->plogs, "P15", rs->logs);
                
                bmpcolrtb = aspMemalloc(1078, 15);
                if (!bmpcolrtb) {
                    sprintf_f(rs->logs, "[BMP] allocate memory failed size: %d \n", 1078);
                    print_f(rs->plogs, "P15", rs->logs);                                
                }

                if (colr == 8) {
                    blen = 1078;
                    bdpp = 1;
                } else if (colr == 24) {
                    blen = 54;            
                    bdpp = 3;
                } else {
                    sprintf_f(rs->logs, "[BMP] error!!! unknown color bits: %d \n", colr);
                    print_f(rs->plogs, "P15", rs->logs);   
                }
                
                bhlen = blen;
                val = ((bmpw * colr + 31) / 32) * 4;
                val = val * bmph; 

                //sprintf_f(rs->logs, "[BMP] e bitmap info color: %d, w: %d, h: %d, dpi: %d, raw size: %d, header size: %d\n", colr, bmpw, bmph, bdpi, val, blen);
                //print_f(rs->plogs, "P15", rs->logs);

                bitmapHeaderSetup(bheader, colr, bmpw, bmph, bdpi, val);

                ph = &bheader->aspbmpMagic[2];
                val = sizeof(struct bitmapHeader_s) - 2;
                memcpy(bmpcolrtb, ph, val);

                blen -= val;
                if (blen > 0) {
                    bitmapColorTableSetup(bmpcolrtb+val);
                    blen -= 1024;
                }

                if (blen) {
                    sprintf_f(rs->logs, "[BMP] Error!!! the bitmap header's len is wrong %d\n", bhlen);
                    print_f(rs->plogs, "P15", rs->logs);
                } 
                
                prisec = ptmetausb->PRI_O_SEC;
                if (prisec > 1) {
                    sprintf_f(rs->logs, "Error !! the pri sec is wrong !!! val: %d \n", prisec);
                    print_f(rs->plogs, "P15", rs->logs);

                    prisec = 0;
                }


                
                cutcnt =0;

                for (ix=0; ix < BMP_DECODE_PIC_SIZE; ix++) {

                    pdecroi = &rs->pbDecMfour[mfbidx]->aspDecMfPiRaw[ix];
                    penroi = &rs->pbDecMfour[mfbidx]->aspDecMfPiJpg[ix];

                    ret = aspBMPdecodeItemGet(pdecroi, &rotsrc[cutcnt], &rotsrclen[cutcnt]);
                    if (ret < 0) {
                        rotsrc[cutcnt] = 0;
                        rotsmax[cutcnt] = 0;
                    } else {
                        rotsmax[cutcnt] = aspBMPdecodeItemMax(pdecroi);
                    }

                    if (rotsrclen[cutcnt] > 0) {
                        ret = aspBMPdecodeItemGet(penroi, &rotdst[cutcnt], 0);
                        if (ret < 0) {
                            rotdst[cutcnt] = 0;
                            rotdmax[cutcnt] = 0;
                        } else {
                            rotdmax[cutcnt] = aspBMPdecodeItemMax(penroi);
                        }
                    
                        //sprintf_f(rs->logs, "    used buff search %d. size: %d, w: %d h: %d len: %d\n", ix, rotsrclen[cutcnt], pdecroi->aspDcWidth, pdecroi->aspDcHeight, pdecroi->aspDcLen);
                        //print_f(rs->plogs, "P15", rs->logs);

                        #if 0 /* debug print */
                        bmprot = rotsrc[cutcnt];
                        memcpy(ph, bmprot, 54);
                        dbgBitmapHeader(bheader, sizeof(struct bitmapHeader_s) - 2);

                        sprintf_f(rs->logs, "[BMP] search and dump raw image addr: 0x%.8x, len: %d\n", (uint32_t)bmprot, rotsrclen[cutcnt]);
                        print_f(rs->plogs, "P15", rs->logs);
                        shmem_dump(bmprot, 128);
                        #endif
                        
                        cutcnt++;
                    }
                }

                cutnum = cutcnt;
                cutcnt = 0;
                
                while (cutcnt < cutnum) {

                    pdecroi = &rs->pbDecMfour[mfbidx]->aspDecMfPiRaw[cutcnt];
                    
                    bmprot = rotsrc[cutcnt];
                    jpgrlt = rotdst[cutcnt];

                    if (!bmph) {
                        break;
                    }
                    
                    jpgLen = 0;
                    rotlen = 0;
                    
                    memcpy(ph, bmprot, 54);
                    
                    sprintf_f(rs->logs, "[BMP] %d. raw scale w: %d h: %d len: %d, max: %d\n", cutcnt, pdecroi->aspDcWidth, pdecroi->aspDcHeight, pdecroi->aspDcLen, pdecroi->aspDcMax);
                    print_f(rs->plogs, "P15", rs->logs);
                                            
                    bmpbufc = bmprot;   
                    rotlen = rotsrclen[cutcnt];

                    #if 0 /* debug dump data */
                    sprintf_f(rs->logs, "[BMP] dump 512 raw image addr: 0x%.8x, total len: %d\n", (uint32_t)bmpbufc, rotlen);
                    print_f(rs->plogs, "P15", rs->logs);

                    shmem_dump(bmpbufc, 512);
                    #endif

                    clock_gettime(CLOCK_REALTIME, &jpgS);

                    switch (fformat) {
                    case FILE_FORMAT_JPG:
                    #if GHP_EN
                    sprintf(rs->logs, "__JPG_ENCODE_START(%d)__", mfbidx); 
                    tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 32, rs->logs);
                    
                    err = rgb2jpg(bmpbufc+bheader->aspbhRawoffset, jpgrlt, &jpgLen, pdecroi->aspDcWidth, pdecroi->aspDcHeight, colr);
                    
                    sprintf(rs->logs, "__JPG_ENCODE_END(%d)__", mfbidx); 
                    tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 32, rs->logs);
                    #endif
                    break;
                    case FILE_FORMAT_RAW:
                    memcpy(jpgrlt, bmpbufc, rotlen);
                    jpgLen = rotlen;
                    err = 0;
                    break;
                    default:
                    break;
                    }
                    clock_gettime(CLOCK_REALTIME, &jpgE);
                    
                    if (err) {
                        sprintf_f(rs->logs, "[BMP] raw encode to jpg failed ret: %d  \n", err);
                        print_f(rs->plogs, "P15", rs->logs);
                    }
                    
                    tmCost = time_diff(&jpgS, &jpgE, 1000);
                    sprintf_f(rs->logs, "[BMP] e raw encode to jpg len: %d addr: 0x%.8x cost: %d.%d ms\n", jpgLen, (uint32_t)jpgrlt, tmCost/1000, tmCost%1000);
                    print_f(rs->plogs, "P15", rs->logs);

                    rotlen = 512 - (jpgLen % 512);
                    rotlen = rotlen + jpgLen;
                    bmpbufc = jpgrlt;

                    //shmem_dump(bmpbufc, 512);
                    metatmp = aspMemalloc(bmtlen, 15);
                    memcpy(metatmp, ptmetausb, bmtlen);
                    #if PIC_ALL_SEND
                    aspMetaReleaseviaUsbdlBmpUpd(metatmp, pdecroi->aspDcWidth, pdecroi->aspDcHeight, 1, cutcnt+1, 1, ((cutcnt+1) == cutnum) ? 0:1);
                    #else
                    if ((cutcnt+1) == cutnum) {
                        aspMetaReleaseviaUsbdlBmpUpd(metatmp, pdecroi->aspDcWidth, pdecroi->aspDcHeight, 1, 1, 1, 0);
                    } else {
                        aspMetaReleaseviaUsbdlBmpUpd(metatmp, pdecroi->aspDcWidth, pdecroi->aspDcHeight, 1, 0, 1, 1);
                    }
                    #endif
                    //sprintf_f(rs->logs, "[BMP] update new width and height: %d, %d \n", pdecroi->aspDcWidth, pdecroi->aspDcHeight);
                    //print_f(rs->plogs, "P15", rs->logs);
                    
                    lenbs = &metatmp->EPOINT_RESERVE1[0] - &metatmp->ASP_MAGIC_ASPC[0];
                    
                    bmpcpy = bmpbufc + rotlen;
                    memcpy(bmpcpy, metatmp, bmtlen);
                    
                    //shmem_dump(bmpbufc+rotlen-512, 1024);
                    //dbgMetaUsb(ptmetausb);
                    //dbgMetaUsb((struct aspMetaDataviaUSB_s *)bmpcpy);

                    #if PIC_ALL_SEND
                    aspBMPdecodeItemSet(&rs->pbDecMfour[mfbidx]->aspDecMfPiJpg[cutcnt], pdecroi->aspDcWidth, pdecroi->aspDcHeight, rotlen+bmtlen);
                    #else
                    if ((cutcnt+1) == cutnum) {
                        aspBMPdecodeItemSet(&rs->pbDecMfour[mfbidx]->aspDecMfPiJpg[cutcnt], pdecroi->aspDcWidth, pdecroi->aspDcHeight, rotlen+bmtlen);
                    } else {
                        aspBMPdecodeItemSet(&rs->pbDecMfour[mfbidx]->aspDecMfPiJpg[cutcnt], pdecroi->aspDcWidth, pdecroi->aspDcHeight, 0);
                    }
                    #endif
                                        
                    //sprintf_f(rs->logs, "[BMP] usb meta size check, meta size: %d : sizeofmeta: %d jpglen: %d \n", bmtlen, lenbs, rotlen+bmtlen);
                    //print_f(rs->plogs, "P15", rs->logs);
                    
                    cutcnt ++;
                    
                }

                orglen = 0;
                rawlen = 0;
                for (ix=cutnum; ix < BMP_DECODE_PIC_SIZE; ix++) {

                    penroi = &rs->pbDecMfour[mfbidx]->aspDecMfPiJpg[ix];

                    ret = aspBMPdecodeItemGet(penroi, &bufftmp, &tmplen);
                    
                    //sprintf_f(rs->logs, "[encode] %d. jpeg len: %d ret: %d \n", ix, tmplen, ret);
                    //print_f(rs->plogs, "P15", rs->logs);
                    #if MFOUR_BMP_SEND_BACK
                    if ((!ret) && (tmplen == 0) && (rawlen == 0)) {
                        pdecraw = &rs->pbDecMfour[mfbidx]->aspDecRaw;     
                        err = aspBMPdecodeItemGet(pdecraw, &buffraw, &rawlen);
                        if ((!err) && (rawlen > 0)) {
                        
                            memcpy(bufftmp, buffraw, rawlen);

                            #if 1 /* reverse bmp height */
                            rawheader = (struct bitmapHeader_s *)(bufftmp - 2);
                            
                            u32tmp = 0xffffffff;
                            u32tmp = u32tmp - rawheader->aspbiHeight + 1;

                            //sprintf_f(rs->logs, "[BMP] raw height: %d 0x%.8x\n", rawheader->aspbiHeight, u32tmp);
                            //print_f(rs->plogs, "P15", rs->logs);
                            rawheader->aspbiHeight = u32tmp;
                            //shmem_dump(bufftmp, 512);
                            #endif

                            metatmp = aspMemalloc(bmtlen, 15);
                            memcpy(metatmp, ptmetausb, bmtlen);
                    
                            aspMetaReleaseviaUsbdlBmpUpd(metatmp, pdecraw->aspDcWidth, pdecraw->aspDcHeight, 1, ix+1, 0, 1);
                            sprintf_f(rs->logs, "[BMP] raw to update w and h: %d, %d len: %d \n", pdecraw->aspDcWidth, pdecraw->aspDcHeight, rawlen);
                            print_f(rs->plogs, "P15", rs->logs);
                            
                            //rawlen -= 160;

                            rawlen = (rawlen + 511)  & 0xfffffe00;
                            
                            bmpcpy = bufftmp + rawlen; 

                            //shmem_dump(bmpcpy - 160, 256);

                            //memcpy(bmpcpy, pdecraw, rawlen);
                            //bmpcpy = bmpcpy + rawlen;
                            //rawlen += rawlen;
                            
                            memcpy(bmpcpy, metatmp, bmtlen);
                            rawlen += bmtlen;
                            
                            //shmem_dump(bmpbufc+rotlen-512, 1024);
                            //dbgMetaUsb(ptmetausb);
                            //dbgMetaUsb((struct aspMetaDataviaUSB_s *)bmpcpy);
                            
                            aspBMPdecodeItemSet(penroi, pdecraw->aspDcWidth, pdecraw->aspDcHeight, rawlen);

                            //sprintf_f(rs->logs, "[encode] to put org jpeg to id%d len: %d ret: %d \n", ix, rawlen, err);
                            //print_f(rs->plogs, "P15", rs->logs);

                            msync(bufftmp, rawlen, MS_SYNC);

                            continue;
                        }
                    }
                    #endif

                    #if MFOUR_IMG_SEND_BACK
                    if ((!ret) && (tmplen == 0) && (orglen == 0)) {
                    //if (!ret) {
                        pdecroi = &rs->pbDecMfour[mfbidx]->aspDecJpeg;
                        //pdecroi = &rs->pbDecMfour[mfbidx]->aspDecRaw;     
                        //pdecroi = &rs->pbDecMfour[mfbidx]->aspDecMfPiJpg[0];     
                        //err = aspBMPdecodeItemGet(pdecraw, &buffraw, &rawlen);
                        err = aspBMPdecodeItemGet(pdecroi, &bufforg, &orglen);
                        if ((!err) && (orglen > 0)) {
                        
                            memcpy(bufftmp, bufforg, orglen);

                            //sprintf_f(rs->logs, "[encode] dump the jpg size: %d \n", 512);
                            //print_f(rs->plogs, "P15", rs->logs);
                            
                            //shmem_dump(bufftmp, 512);

                            metatmp = aspMemalloc(bmtlen, 15);
                            memcpy(metatmp, ptmetausb, bmtlen);
                            
                            aspMetaReleaseviaUsbdlBmpUpd(metatmp, pdecroi->aspDcWidth, pdecroi->aspDcHeight, 1, ix+1, 0, 1);
                            sprintf_f(rs->logs, "[BMP] to update w and h: %d, %d len: %d \n", pdecroi->aspDcWidth, pdecroi->aspDcHeight, orglen);
                            print_f(rs->plogs, "P15", rs->logs);
                            
                            orglen -= 160;

                            //orglen = (orglen + 511)  & 0xfffffe00;
                            
                            bmpcpy = bufftmp + orglen; 

                            //shmem_dump(bmpcpy - 160, 256);

                            //memcpy(bmpcpy, buffraw, rawlen);
                            //bmpcpy = bmpcpy + rawlen;
                            //orglen += rawlen;
                            
                            memcpy(bmpcpy, metatmp, bmtlen);
                            orglen += bmtlen;
                            
                            //shmem_dump(bmpbufc+rotlen-512, 1024);
                            //dbgMetaUsb(ptmetausb);
                            //dbgMetaUsb((struct aspMetaDataviaUSB_s *)bmpcpy);
                            
                            aspBMPdecodeItemSet(penroi, pdecroi->aspDcWidth, pdecroi->aspDcHeight, orglen);

                            //sprintf_f(rs->logs, "[encode] to put org jpeg to id%d len: %d ret: %d \n", ix, orglen, err);
                            //print_f(rs->plogs, "P15", rs->logs);

                            msync(bufftmp, orglen, MS_SYNC);

                            continue;
                        }
                    }
                    #endif
                }

                sprintf(rs->logs, "__M4_PROCESS_END(%d)__", mfbidx); 
                tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 14, rs->logs);
    
                ret = aspBMPdecodeBuffTimeCostGet(rs->pbDecMfour[mfbidx], &tmCost);

                sprintf_f(rs->logs, "[DV] img buff id %d process end cost: %d.%d ms ret: %d\n", mfbidx, tmCost / 1000, tmCost % 1000, ret);
                print_f(rs->plogs, "P15", rs->logs);

                pinfo[0] = 'P';
                pinfo[1] = ch;

                rs_ipc_put(rs, pinfo, 2);
            }        
            break;
        case 'c':
            ret = rs_ipc_get_ms(rs, &ch, 1, 5000);
            if (ret > 0) {
                sprintf_f(rs->logs, "c get cont ch[0x%.2x] \n", ch);
                print_f(rs->plogs, "P15", rs->logs);

                if (ch == 0x80) {
                    mfbidx = 0;
                } else {
                    mfbidx = ch & 0x7f;
                }

                if (mfbidx > 3) {
                    sprintf_f(rs->logs, "get buff index %d error!!! \n", mfbidx);
                    print_f(rs->plogs, "P15", rs->logs);
                    break;
                } else {
                    sprintf_f(rs->logs, "get buff index %d succed!!! \n", mfbidx);
                    print_f(rs->plogs, "P15", rs->logs);
                }

                imgidx = 0;
                mfbstat = 0;
                ret = aspBMPdecodeBuffGetIdx(rs->pbDecMfour[mfbidx], &imgidx);
                ret = aspBMPdecodeBuffStatusGet(rs->pbDecMfour[mfbidx], &mfbstat);
                if (mfbstat == 0) {
                    sprintf_f(rs->logs, "get mfbuff index %d, imgindex: %d, status 0x%x error!!! \n", mfbidx, imgidx, mfbstat);
                    print_f(rs->plogs, "P15", rs->logs);
                    //break;
                } else {
                    sprintf_f(rs->logs, "get mfbuff index %d, imgindex: %d, status 0x%x succeed!!! \n", mfbidx, imgidx, mfbstat);
                    print_f(rs->plogs, "P15", rs->logs);
                }

                ret = aspBMPdecodeItemGet(&rs->pbDecMfour[mfbidx]->aspDecRaw, &bmpbuff, &uselen);
                if (ret < 0) {
                    bmpbuff = 0;
                    bmpmax = 0;
                    uselen = 0;
                } else {
                    bmpmax = aspBMPdecodeItemMax(&rs->pbDecMfour[mfbidx]->aspDecRaw);
                }

                ret = aspBMPdecodeItemGet(&rs->pbDecMfour[mfbidx]->aspDecMeta, &buffmeta, &bmtlen);
                if (ret < 0) {
                    buffmeta = 0;
                    bmtmax = 0;
                    bmtlen = 0;
                } else {
                    bmtmax = aspBMPdecodeItemMax(&rs->pbDecMfour[mfbidx]->aspDecMeta);
                }
                
                ret = aspBMPdecodeItemGet(&rs->pbDecMfour[mfbidx]->aspDecMetaex, &exmeta, &exmlen);
                if (ret < 0) {
                    exmeta = 0;
                    exmax = 0;
                    exmlen = 0;
                } else {
                    exmax = aspBMPdecodeItemMax(&rs->pbDecMfour[mfbidx]->aspDecMetaex);
                }

                rstlen = uselen % 512;
                //sprintf_f(rs->logs, "get raw len: %d max: %d get meta len: %d max: %d get extra meta len: %d max: %d restlen: %d \n", uselen, bmpmax, bmtlen, bmtmax, exmlen, exmax, rstlen);
                //print_f(rs->plogs, "P15", rs->logs);

                //shmem_dump(buffmeta, bmtlen);
                
                ptmetausb = (struct aspMetaDataviaUSB_s *)buffmeta;
                
                //dbgMetaUsb(ptmetausb);

                bmph = (ptmetausb->IMG_HIGH[1] << 8) | ptmetausb->IMG_HIGH[0];

                ret = cfgTableGetChk(pct, ASPOP_COLOR_MODE, &val, ASPOP_STA_APP);    
                switch (val) {
                case COLOR_MODE_COLOR:
                    colr = 24;
                    break;
                case COLOR_MODE_GRAY:
                case COLOR_MODE_GRAY_DETAIL:
                case COLOR_MODE_BLACKWHITE:
                    colr = 8;
                    break;
                default:
                    colr = 24;
                    break;
                }
                //sprintf_f(rs->logs, "[BMP] color mode: %d, ret: %d, bpp: %d \n", val, ret, colr);
                //print_f(rs->plogs, "P15", rs->logs);
            
                ret = cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_H, &val, ASPOP_STA_APP);    

                ret |= cfgTableGetChk(pct, ASPOP_WIDTH_ADJ_L, &tmp, ASPOP_STA_APP);    
                tmp = val << 8 | tmp;

                val = 0;
                ret = cfgTableGetChk(pct, ASPOP_SCAN_WIDTH, &val, ASPOP_STA_UPD);
                
                bmpw = scanWidthConvert(tmp, val);
                bmpw = (ptmetausb->IMG_WIDTH[1] << 8) | ptmetausb->IMG_WIDTH[0];
                
                //sprintf_f(rs->logs, "[BMP] defined width: %d, scan width = %d result width: %d \n", tmp, val, bmpw);
                //print_f(rs->plogs, "P15", rs->logs);

                tmp = 0;
                ret = cfgTableGetChkDPI(pct, ASPOP_RESOLUTION, &tmp, ASPOP_STA_APP);    
                bdpi = tmp;
                //sprintf_f(rs->logs, "[BMP] resulution cfg: %d, dpi: %d\n", tmp, bdpi);
                //print_f(rs->plogs, "P15", rs->logs);
                
                bmpcolrtb = aspMemalloc(1078, 15);
                if (!bmpcolrtb) {
                    sprintf_f(rs->logs, "[BMP] allocate memory failed size: %d \n", 1078);
                    print_f(rs->plogs, "P15", rs->logs);                                
                }

                if (colr == 8) {
                    blen = 1078;
                    bdpp = 1;
                } else if (colr == 24) {
                    blen = 54;            
                    bdpp = 3;
                } else {
                    sprintf_f(rs->logs, "[BMP] error!!! unknown color bits: %d \n", colr);
                    print_f(rs->plogs, "P15", rs->logs);   
                }
                
                bhlen = blen;
                val = ((bmpw * colr + 31) / 32) * 4;
                val = val * bmph; 

                sprintf_f(rs->logs, "[BMP] bitmap info color: %d, w: %d, h: %d, dpi: %d, raw size: %d, header size: %d\n", colr, bmpw, bmph, bdpi, val, blen);
                print_f(rs->plogs, "P15", rs->logs);

                bitmapHeaderSetup(bheader, colr, bmpw, bmph, bdpi, val);

                ph = &bheader->aspbmpMagic[2];
                val = sizeof(struct bitmapHeader_s) - 2;
                memcpy(bmpcolrtb, ph, val);

                blen -= val;
                if (blen > 0) {
                    bitmapColorTableSetup(bmpcolrtb+val);
                    blen -= 1024;
                }

                if (blen) {
                    sprintf_f(rs->logs, "[BMP] Error!!! the bitmap header's len is wrong %d\n", bhlen);
                    print_f(rs->plogs, "P15", rs->logs);
                } 
                
                prisec = ptmetausb->PRI_O_SEC;
                if (prisec > 1) {
                    sprintf_f(rs->logs, "Error !! the pri sec is wrong !!! val: %d \n", prisec);
                    print_f(rs->plogs, "P15", rs->logs);

                    prisec = 0;
                }
                
                cutcnt =0;
                cutnum = msb2lsb16(&metaRx->BKNA_NUM);

                cutsides = aspMemalloc(cutnum*sizeof(int)*2, 15);
                memset(cutsides, 0, cutnum*sizeof(int)*2);
                cutlayers = aspMemalloc(cutnum*sizeof(int)*2, 15);
                memset(cutlayers, 0, cutnum*sizeof(int)*2);
                ret = 0;
                
                ret = aspMetaGetPages(metaRx, cutsides, cutlayers, cutnum);
                sprintf_f(rs->logs, "[CUT] get page ret: %d num: %d\n", ret, cutnum);
                print_f(rs->plogs, "P15", rs->logs);

                #if 0
                cutsides[ret*2] = -1;
                cutsides[ret*2+1] = -1;
                cutlayers[ret*2] = 0;
                cutlayers[ret*2+1] = 0;
                
                ret += 1;
                
                cutsides[ret*2] = -2;
                cutsides[ret*2+1] = -2;
                cutlayers[ret*2] = 0;
                cutlayers[ret*2+1] = 0;
                
                ret += 1;
                #endif

                cutnum = ret;

                for (ix=0; ix < cutnum; ix++) {
                    sprintf_f(rs->logs, "[CUT] clips %d. A:%d (%d) B:%d (%d)\n", ix, cutsides[ix*2], cutlayers[ix*2], cutsides[ix*2+1], cutlayers[ix*2+1]);
                    print_f(rs->plogs, "P15", rs->logs);
                }

                if (cutnum > BMP_DECODE_PIC_SIZE) {
                    cutnum = BMP_DECODE_PIC_SIZE;
                }
                
                for (ix=0; ix < cutnum; ix++) {

                    pdecroi = &rs->pbDecMfour[mfbidx]->aspDecMfPiRaw[ix];
                    penroi = &rs->pbDecMfour[mfbidx]->aspDecMfPiJpg[ix];

                    ret = aspBMPdecodeItemGet(pdecroi, &rotsrc[ix], 0);
                    if (ret < 0) {
                        rotsrc[ix] = 0;
                        rotsmax[ix] = 0;
                    } else {
                        rotsmax[ix] = aspBMPdecodeItemMax(pdecroi);
                    }

                    ret = aspBMPdecodeItemGet(penroi, &rotdst[ix], 0);
                    if (ret < 0) {
                        rotdst[ix] = 0;
                        rotdmax[ix] = 0;
                    } else {
                        rotdmax[ix] = aspBMPdecodeItemMax(penroi);
                    }
                    
                    sprintf_f(rs->logs, "[BUFF] %d. src addr: 0x.8%x (max:%d) dst addr:0x%.8x (max:%d)\n", ix, (uint32_t)rotsrc[ix], rotsmax[ix], (uint32_t)rotdst[ix], rotdmax[ix]);
                    print_f(rs->plogs, "P15", rs->logs);

                }

                mreal[0] = -1;
                mreal[1] = -1;
                
                while (cutcnt < cutnum) {

                    bmprot = rotsrc[cutcnt];
                    jpgrlt = rotdst[cutcnt];

                    if (!bmph) {
                        break;
                    }
                    
                    jpgLen = 0;
                    rotlen = 0;
                    
                    memcpy(ph, bmprot, 54);
                    
                    sprintf_f(rs->logs, "[BMP] rotate bmp w: %d h: %d rawoffset: %d\n", bheader->aspbiWidth, bheader->aspbiHeight, bheader->aspbhRawoffset);
                    print_f(rs->plogs, "P15", rs->logs);
                                            
                    bmpbufc = bmprot;   
                    rotlen = bheader->aspbiRawSize;
                    
                    sprintf_f(rs->logs, "[BMP] encode addr: 0x%.8x, raw offset: %d used: %d\n", (uint32_t)bmpbufc, bheader->aspbhRawoffset, rotlen);
                    print_f(rs->plogs, "P15", rs->logs);

                    #if GHP_EN
                    clock_gettime(CLOCK_REALTIME, &jpgS);
                    err = rgb2jpgRvs(bmpbufc + bheader->aspbhRawoffset, jpgrlt, &jpgLen, bheader->aspbiWidth, bheader->aspbiHeight, colr);
                    clock_gettime(CLOCK_REALTIME, &jpgE);
                    if (err) {
                        sprintf_f(rs->logs, "[BMP] raw encode to jpg failed ret: %d  \n", err);
                        print_f(rs->plogs, "P15", rs->logs);
                    }
                    #endif
                    
                    tmCost = time_diff(&jpgS, &jpgE, 1000000);
                    sprintf_f(rs->logs, "[BMP] raw encode to jpg len: %d addr: 0x%.8x cost: %d ms\n", jpgLen, (uint32_t)jpgrlt, tmCost);
                    print_f(rs->plogs, "P15", rs->logs);

                    rotlen = 512 - (jpgLen % 512);
                    rotlen = rotlen + jpgLen;
                    bmpbufc = jpgrlt;

                    shmem_dump(bmpbufc, 512);

                    if (sides[prisec] > 0) {
                        updn = (sides[prisec] - 1) % 2;
                    } else {
                        updn = 0;
                    }
                    sprintf_f(rs->logs, "[BMP] updn: %d, side: %d cutcnt: %d\n", updn, sides[prisec], cutcnt);
                    print_f(rs->plogs, "P15", rs->logs);

                    metatmp = aspMemalloc(bmtlen, 15);
                    memcpy(metatmp, ptmetausb, bmtlen);
                            
                    aspMetaReleaseviaUsbdlBmpUpd(metatmp, bheader->aspbiWidth, bheader->aspbiHeight, cutlayers[cutcnt*2+updn], cutcnt+1, 0, 1);
                    sprintf_f(rs->logs, "[BMP] update new width and height: %d, %d \n", bheader->aspbiWidth, bheader->aspbiHeight);
                    print_f(rs->plogs, "P15", rs->logs);
                    
                    lenbs = &metatmp->EPOINT_RESERVE1[0] - &metatmp->ASP_MAGIC_ASPC[0];
                    
                    bmpcpy = bmpbufc + rotlen;
                    memcpy(bmpcpy, metatmp, bmtlen);
                    
                    //shmem_dump(bmpbufc+rotlen-512, 1024);
                    dbgMetaUsb(metatmp);
                    dbgMetaUsb((struct aspMetaDataviaUSB_s *)bmpcpy);

                    aspBMPdecodeItemSet(&rs->pbDecMfour[mfbidx]->aspDecMfPiJpg[cutcnt], bheader->aspbiWidth, bheader->aspbiHeight, rotlen+bmtlen);
                                        
                    sprintf_f(rs->logs, "[BMP] usb meta size check, meta size: %d : sizeofmeta: %d jpglen: %d \n", bmtlen, lenbs, rotlen+bmtlen);
                    print_f(rs->plogs, "P15", rs->logs);
                    
                    cutcnt ++;
                    
                }

                pinfo[0] = 'P';
                pinfo[1] = ch;

                rs_ipc_put(rs, pinfo, 2);
            }        
            break;
        default:
            break;
        }

        #endif
    }

    p15_end(rs);
    
    return 0;
}

#define LOG_P16_EN (1)
static int p16(struct procRes_s *rs)
{
    int ret=0, tcmd=0, errcnt=0, pipRet=0, mfcmd=0;
    int rj0id=0, mfbidx=0, imgidx=0, mfbstat=0, clipidx=0;
    char ch=0, chm=0;
    //char m4startcmd[256]="/usr/local/projects/BKJob_1/fw_cortex_m4.sh start";
    //char m4startcmd[256]="/home/root/fw_cortex_m4.sh start";
    struct bitmapDecodeItem_s *decraw=0, *decrect=0;
    mfour_image_param_st *img_param=0;
    mfour_rjob_cmd rjcmd;
    struct pollfd pllfd[2]={0};
    int *pipeMfCom=0, *pipeMfTx=0;
    int tmCost=0;
    
    sprintf_f(rs->logs, "p16\n");
    print_f(rs->plogs, "P16", rs->logs);

    p16_init(rs);

    prctl(PR_SET_NAME, "msp-p16");
    
    memset(&rjcmd, 0, sizeof(mfour_rjob_cmd));

    //sprintf(m4startcmd, "ls /dev | grep rjob");
    //ret = doSystemCmd(m4startcmd);

    #if MFOUR_API
    m4_enter(1105);
    #endif

    #if !MFOUR_API
    while (rj0id <= 0) {
        usleep(100000);
        rj0id = open("/dev/rjob0", O_RDWR);
        
        sprintf_f(rs->logs, "get m4 rjob 0 id: %d, sizeof: %d %d \n", rj0id, sizeof(rjcmd), sizeof(mfour_rjob_cmd));
        print_f(rs->plogs, "P16", rs->logs);

        errcnt++;
    }
    #endif
    
    while (1) {
        ret = rs_ipc_get_ms(rs, &ch, 1, 5000);

        if (ret > 0) {
            //sprintf_f(rs->logs, "m4t get ch[0x%.2x] \n", ch);
            //print_f(rs->plogs, "P16", rs->logs);
        } else {
            //sprintf_f(rs->logs, "loop!!! waitting cmd !!!\n");
            //print_f(rs->plogs, "P16", rs->logs);

            continue;
        }

        tcmd = ch;

        switch (tcmd) {
        case 'a':
            ret = rs_ipc_get_ms(rs, &ch, 1, 5000);
            if (ret > 0) {
                //sprintf_f(rs->logs, "rjob0 get cont ch[0x%.2x] \n", ch);
                //print_f(rs->plogs, "P16", rs->logs);

                if (ch == 0x80) {
                    mfbidx = 0;
                } else {
                    mfbidx = ch & 0x7f;
                }

                if (mfbidx > 3) {
                    sprintf_f(rs->logs, "get buff index %d error!!! \n", mfbidx);
                    print_f(rs->plogs, "P16", rs->logs);
                    break;
                } else {
                    //sprintf_f(rs->logs, "get buff index %d succed!!! \n", mfbidx);
                    //print_f(rs->plogs, "P16", rs->logs);
                }

                ret = aspBMPdecodeBuffGetIdx(rs->pbDecMfour[mfbidx], &imgidx);
                ret = aspBMPdecodeBuffStatusGet(rs->pbDecMfour[mfbidx], &mfbstat);
                sprintf_f(rs->logs, "m4 tx get mfbuff index %d, imgindex: %d, status 0x%x succeed!!! \n", mfbidx, imgidx, mfbstat);
                print_f(rs->plogs, "P16", rs->logs);

                decraw = &rs->pbDecMfour[mfbidx]->aspDecRaw;
                img_param = decraw->aspDcData;

                memset((char *)&rjcmd, 0, sizeof(mfour_rjob_cmd));
                
                rjcmd.cmd = BKCMD_IMAGE_IN;
                rjcmd.tag = (mfbidx+1) << 16;
                rjcmd.rsp = 0;
                rjcmd.dPtr = &img_param->mfourAttb;
                rjcmd.dSize = (decraw->aspDcLen > 16 * 1024) ? 16*1024:decraw->aspDcLen;

                #if MFOUR_API
                rjcmd.mPtr = rs->pbMfRxBuff;
                #endif

                sprintf_f(rs->logs, "print the cmd send out for cmd BKCMD_IMAGE_IN \n");
                print_f(rs->plogs, "P16", rs->logs);
                
                dbgRjobCmd(&rjcmd, sizeof(mfour_rjob_cmd));
                
                clock_gettime(CLOCK_REALTIME, rs->tm2[1]);
                msync(rs->tm2[1], sizeof(struct timespec), MS_SYNC);

                sprintf(rs->logs, "__M4_CMD_SEND_(%d)(BKCMD_IMAGE_IN)_IN__", mfbidx); 
                tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 20, rs->logs);
                                
                RJOB_IOCT_WT_CMD(rj0id, &rjcmd);

                sprintf(rs->logs, "__M4_CMD_SEND_(%d)(BKCMD_IMAGE_IN)_OUT__", mfbidx); 
                tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 20, rs->logs);

                clock_gettime(CLOCK_REALTIME, rs->rtpTo[1]);
                clock_gettime(CLOCK_REALTIME, rs->tm2[0]);
                msync(rs->tm2[0], sizeof(struct timespec), MS_SYNC);

                tmCost = time_diff(rs->tm2[1], rs->tm2[0], 1000);
                sprintf_f(rs->logs, "RJOB_IOCT_WT_CMD (BKCMD_IMAGE_IN) (cost: %d.%d ms)\n", tmCost/1000, tmCost%1000);
                print_f(rs->plogs, "P16", rs->logs);    
                            
                pipeMfCom = rs->pbDecMfour[mfbidx]->aspPipeMfourCom;
                pipeMfTx = rs->pbDecMfour[mfbidx]->aspPipeMfourTx;

                pllfd[0].fd = pipeMfTx[0];
                pllfd[0].events = POLLIN;

                while (1) {
                    mfcmd = 0;
                    pipRet = poll(pllfd, 1, 500);
                    if (pipRet > 0) {
                        ret = read(pllfd[0].fd, &chm, 1);
                        //sprintf_f(rs->logs, "m4tx get chm: %c [0x%.2x] for m4tx\n", chm, chm);
                        //print_f(rs->plogs, "P16", rs->logs);

                        mfcmd = chm;
                        
                        clock_gettime(CLOCK_REALTIME, rs->rtpTo[0]);
                        msync(rs->rtpTo[0], sizeof(struct timespec), MS_SYNC);
                        
                        tmCost = time_diff(rs->rtpBk[1], rs->rtpTo[0], 1000);
                        sprintf_f(rs->logs, "rjob round trip to (cost: %d.%d ms)\n", tmCost/1000, tmCost%1000);
                        print_f(rs->plogs, "P16", rs->logs);    
                    
                        switch (mfcmd) {
                        case 'b':
                            ret = read(pllfd[0].fd, &chm, 1);
                            //sprintf_f(rs->logs, "get cont chm: %c [0x%.2x] for m4tx\n", chm, chm);
                            //print_f(rs->plogs, "P16", rs->logs);

                            if (chm == 0x80) {
                                clipidx = 0;
                            } else {
                                clipidx = chm & 0x7f;
                            }

                            if (clipidx > 3) {
                                sprintf_f(rs->logs, "get clip index %d error!!! \n", clipidx);
                                print_f(rs->plogs, "P16", rs->logs);
                                break;
                            } else {
                                ///sprintf_f(rs->logs, "get clip index %d succed!!! \n", clipidx);
                                //print_f(rs->plogs, "P16", rs->logs);
                            }

                            decrect = &rs->pbDecMfour[mfbidx]->aspDecMfPiRaw[clipidx];
                            img_param = decrect->aspDcData;
                            
                            //sprintf_f(rs->logs, "aspDecMfPiRaw info id: %d w: %d h: %d len: %d\n", clipidx, decrect->aspDcWidth, decrect->aspDcHeight, decrect->aspDcLen);
                            //print_f(rs->plogs, "P16", rs->logs);

                            memset((char *)&rjcmd, 0, sizeof(mfour_rjob_cmd));
                            
                            rjcmd.cmd = BKCMD_SEND_AREA;
                            rjcmd.tag = (mfbidx+1) << 16;
                            rjcmd.rsp = 0;
                            rjcmd.dPtr = &img_param->mfourAttb;
                            rjcmd.dSize = decrect->aspDcLen;
                            #if MFOUR_API
                            rjcmd.mPtr = rs->pbMfRxBuff;
                            #endif

                            sprintf_f(rs->logs, "ocr img_param info w: %d h: %d id: %d totalayer: %d\n", img_param->mfourAttb.ImageRect.xc, img_param->mfourAttb.ImageRect.yr, img_param->mfourAttb.iJobIdx, img_param->mfourAttb.ImageLayerInfo.BKNote_Layers);
                            print_f(rs->plogs, "P16", rs->logs);

                            //dbgRjobCmd(&rjcmd, sizeof(mfour_rjob_cmd));
                            clock_gettime(CLOCK_REALTIME, rs->tm2[1]);
                            msync(rs->tm2[1], sizeof(struct timespec), MS_SYNC);

                            sprintf(rs->logs, "__M4_CMD_SEND_(%d)(BKCMD_SEND_AREA)_IN__", mfbidx); 
                            tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 20, rs->logs);
                
                            RJOB_IOCT_WT_CMD(rj0id, &rjcmd);

                            sprintf(rs->logs, "__M4_CMD_SEND_(%d)(BKCMD_SEND_AREA)_OUT__", mfbidx); 
                            tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 20, rs->logs);
                            
                            clock_gettime(CLOCK_REALTIME, rs->tm2[0]);
                            tmCost = time_diff(rs->tm2[1], rs->tm2[0], 1000);
                            sprintf_f(rs->logs, "RJOB_IOCT_WT_CMD (BKCMD_SEND_AREA) (cost: %d.%d ms)\n", tmCost/1000, tmCost%1000);
                            print_f(rs->plogs, "P16", rs->logs);    
                            
                            break;
                        case 'e':
                            //sprintf_f(rs->logs, "complete \n");
                            //print_f(rs->plogs, "P16", rs->logs);
                            break;
                        default:
                            sprintf_f(rs->logs, "Error m4tx get[0x%.2x] unknown command !!!\n", mfcmd);
                            print_f(rs->plogs, "P16", rs->logs);
                            break;
                        }

                        clock_gettime(CLOCK_REALTIME, rs->rtpTo[1]);
                        msync(rs->rtpTo[1], sizeof(struct timespec), MS_SYNC);
                        
                        tmCost = time_diff(rs->rtpTo[0], rs->rtpTo[1], 1000);
                        sprintf_f(rs->logs, "rjob round trip to delay (cost: %d.%d ms)\n", tmCost/1000, tmCost%1000);
                        print_f(rs->plogs, "P16", rs->logs);    
                        
                    }
                    else {
                        sprintf_f(rs->logs, "waiting command for tx to m4... \n");
                        print_f(rs->plogs, "P16", rs->logs);
                    }

                    if (mfcmd == 'e') {
                        break;
                    }

                }
                
            }
            break;
        default:
            sprintf_f(rs->logs, "Error!!! unknown cmd: %d !!!\n", tcmd);
            print_f(rs->plogs, "P16", rs->logs);    
            break;
        }
    }
    
    p16_end(rs);

    return 0;
}

#define DUMP_MFOUR_BMP (0)
#define LOG_P17_EN (0)
static int p17(struct procRes_s *rs)
{
#define MFOUR_WAIT_LIST_SIZE (8)
    int ret=0, tcmd=0, errcnt=0, mfbidx=0, imgidx=0, mfbstat=0, cid=0, imgsize=0, jid=0, seqid=0, m4id=0;
    int ix=0, ic=0, mfourCnt=2, mfourwait=0, mfourhead=0, mfourtail=0, m4dst=0;
    char mfourlist[MFOUR_WAIT_LIST_SIZE];
    char ch=0;
    int rj1id=0;
    char m4startcmd[256] = "ls";
    char *rx_buf=0;
    mfour_rect_st *pRect=0, *pArRect=0;
    struct bitmapDecodeItem_s *decpic=0, *decraw=0, *decmeta=0;
    struct aspMetaDataviaUSB_s *pusbmeta=0;
    mfour_image_param_st *img_param=0, *img_out=0, *img_raw=0, *img_rxbuf=0;
    mfour_areas_st *pArea=0;
    t_ImageParam *pImgArea=0, *pImgOutArea=0;
    mfour_rjob_cmd  outcmd, rspcmd;
    char minfo[8]={0};
    struct pollfd pllfd[2]={0};
    int *pipeMfCom=0, *pipeMfRx=0;
    char *cpyDst=0, *cpySrc=0;
    int *ptrw=0, *ptrh=0;
    struct bitmapHeader_s *pheader=0;
    int mtlen=0;
    char *bmpmeta=0;
    char outchr[3][36]={0};
    struct timespec mfoS, mfoE;
    int tmCost=0;

    //clock_gettime(CLOCK_REALTIME, &mfoE);
    //tmCost = time_diff(&mfoS, &mfoE, 1000000);
    
    #if DUMP_MFOUR_BMP
    static char ptfileSave[] = "/home/root/rotate/m4_%.3d_%.1d_%.1d.bmp";
    char filepath[256]={0};
    FILE *fdump=0;
    int dumpsize=0;
    char *dumpsrc=0;

    char *ocrpath=0;
    char filepathOcr[256]={0};
    char filepathOcrTxt[256]={0};
    FILE *focrtxt=0;
    int trimsize=0, modix=0, outstrlen=0;
    #endif
    
    sprintf_f(rs->logs, "p17\n");
    print_f(rs->plogs, "P17", rs->logs);

    p17_init(rs);

    prctl(PR_SET_NAME, "msp-p17");

    memset(&outcmd, 0, sizeof(mfour_rjob_cmd));
    memset(&rspcmd, 0, sizeof(mfour_rjob_cmd));
    
    rx_buf = malloc(RJOB_RX_BLOCK_SIZE+sizeof(mfour_image_param_st));
    
    img_rxbuf = (mfour_image_param_st *)rx_buf;
    
    sprintf_f(rs->logs, "memory allocate succeed addr: 0x%.8x size: %d \n", (uint32_t)rx_buf, RJOB_RX_BLOCK_SIZE/1024);
    print_f(rs->plogs, "P17", rs->logs);
    
    #if !MFOUR_API
    while (rj1id <= 0) {
        usleep(100000);
        rj1id = open("/dev/rjob1", O_RDWR);
        sprintf_f(rs->logs, "get m4 rjob 1 id: %d - %d\n", rj1id, errcnt);
        print_f(rs->plogs, "P17", rs->logs);

        errcnt++;
    }
    #endif

    while (1) {
        ret = rs_ipc_get_ms(rs, &ch, 1, 1000);

        if (ret > 0) {
            #if LOG_P17_EN
            sprintf_f(rs->logs, "m4r get ch[0x%.2x] \n", ch);
            print_f(rs->plogs, "P17", rs->logs);
            #endif
        } else {
            #if LOG_P17_EN
            sprintf_f(rs->logs, "loop!!! waitting cmd !!!\n");
            print_f(rs->plogs, "P17", rs->logs);
            #endif
            continue;
        }

        tcmd = ch;

        switch (tcmd) {
        case 'i':
            ret = rs_ipc_get_ms(rs, &ch, 1, 1000);
            if (ret <= 0) {
                sprintf_f(rs->logs, "rjob1 waitting cont ch \n");
                print_f(rs->plogs, "P17", rs->logs);
            } else {   //if (ret > 0) {
                sprintf_f(rs->logs, "rjob1 get cont ch[0x%.2x] \n", ch);
                print_f(rs->plogs, "P17", rs->logs);

                if (ch == 0x80) {
                    mfbidx = 0;
                } else {
                    mfbidx = ch & 0x7f;
                }

                if (mfbidx > 3) {
                    sprintf_f(rs->logs, "get buff index %d error!!! \n", mfbidx);
                    print_f(rs->plogs, "P17", rs->logs);
                    break;
                } else {
                    sprintf_f(rs->logs, "get buff index %d succed!!! \n", mfbidx);
                    print_f(rs->plogs, "P17", rs->logs);
                }
                
                decmeta = &rs->pbDecMfour[mfbidx]->aspDecMeta;
                aspBMPdecodeItemGet(decmeta, &bmpmeta, &mtlen);
                pusbmeta = (struct aspMetaDataviaUSB_s *)bmpmeta;
    
                ret = aspBMPdecodeBuffGetIdx(rs->pbDecMfour[mfbidx], &imgidx);
                ret = aspBMPdecodeBuffStatusGet(rs->pbDecMfour[mfbidx], &mfbstat);
                sprintf_f(rs->logs, "m4 rx get mfbuff index %d, imgindex: %d, status 0x%x succeed!!! \n", mfbidx, imgidx, mfbstat);
                print_f(rs->plogs, "P17", rs->logs);

                pipeMfCom = rs->pbDecMfour[mfbidx]->aspPipeMfourCom;
                pipeMfRx = rs->pbDecMfour[mfbidx]->aspPipeMfourRx;

                mfourCnt=1;
                mfourwait=0;
                mfourhead=0;
                mfourtail=0;
                
                while (1) {
                
                    outcmd.dSize = RJOB_RX_BLOCK_SIZE;
                    outcmd.dPtr  = &img_rxbuf->mfourAttb;
                    
                    ret = RJOB_IOCT_RD_CMD(rj1id, (unsigned long)&outcmd);
                    if (ret <0) {
                        sprintf_f(rs->logs, "Error!!! read rjob command ret: %d !!!\n", ret);
                        print_f(rs->plogs, "P17", rs->logs);    
                        continue;
                    }
                    
                    //sprintf_f(rs->logs, "m4rx print the cmd recv in:\n");
                    //print_f(rs->plogs, "P17", rs->logs);

                    clock_gettime(CLOCK_REALTIME, rs->rtpBk[0]);
                    msync(rs->rtpBk[0], sizeof(struct timespec), MS_SYNC);
                    
                    tmCost = time_diff(rs->rtpTo[1], rs->rtpBk[0], 1000);
                    sprintf_f(rs->logs, "rjob round trip back (cost: %d.%d ms)\n", tmCost/1000, tmCost%1000);
                    print_f(rs->plogs, "P17", rs->logs);    

                    switch(outcmd.cmd) {
                        case BKCMD_IMAGE_IN_RSP:
                            sprintf(rs->logs, "__M4_CMD_RECV_(%d)(BKCMD_IMAGE_IN_RSP)__", mfbidx); 
                            tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 26, rs->logs);
                            
                            clock_gettime(CLOCK_REALTIME, rs->tm2[1]);
                            msync(rs->tm2[1], sizeof(struct timespec), MS_SYNC);
                            
                            tmCost = time_diff(rs->rtpTo[1], rs->tm2[1], 1000);
                            sprintf_f(rs->logs, "Read rjob command %.4x (BKCMD_IMAGE_IN_RSP) (cost: %d.%d ms)\n", outcmd.cmd, tmCost/1000, tmCost%1000);
                            print_f(rs->plogs, "P17", rs->logs);    
                            
                            //dbgRjobCmd(&outcmd, sizeof(mfour_rjob_cmd));

                            mfourCnt += 1;

                            if (mfourwait > 0) {
                                minfo[0] = 'C';
                                minfo[1] = mfourlist[(mfourhead % MFOUR_WAIT_LIST_SIZE)];

                                mfourCnt -= 1;
                                
                                mfourhead += 1;
                                mfourwait -= 1;

                                write(pipeMfRx[1], minfo, 2);
                            }
                            
                            break;
                        case BKCMD_REQUIRE_AREA:           // M4 -> operator
                            sprintf(rs->logs, "__M4_CMD_RECV_(%d)(BKCMD_REQUIRE_AREA)__", mfbidx); 
                            tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 26, rs->logs);
                            
                            clock_gettime(CLOCK_REALTIME, rs->tm2[1]);
                            msync(rs->tm2[1], sizeof(struct timespec), MS_SYNC);
                            
                            tmCost = time_diff(rs->rtpTo[1], rs->tm2[1], 1000);
                            sprintf_f(rs->logs, "Read rjob command %.4x (BKCMD_REQUIRE_AREA) (cost: %d.%d ms)\n", outcmd.cmd, tmCost/1000, tmCost%1000);
                            print_f(rs->plogs, "P17", rs->logs);    
                            //dbgRjobCmd(&outcmd, sizeof(mfour_rjob_cmd));
                            
                            memset(&rspcmd, 0, sizeof(mfour_rjob_cmd));
                            memcpy(&rspcmd, &outcmd, sizeof(mfour_rjob_cmd));
                            
                            rspcmd.cmd = BKCMD_REQUIRE_AREA_RSP;
                            rspcmd.dSize = 0;
                            rspcmd.dPtr = 0;
                            rspcmd.mPtr = 0;
                            
                            //sprintf_f(rs->logs, "print the cmd send out for cmd BKCMD_REQUIRE_AREA_RSP:\n");
                            //print_f(rs->plogs, "P17", rs->logs);
                            //dbgRjobCmd(&rspcmd, sizeof(mfour_rjob_cmd));
                            sprintf(rs->logs, "__M4_CMD_SEND_(%d)(BKCMD_REQUIRE_AREA_RSP)_IN__", mfbidx); 
                            tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 20, rs->logs);
                            
                            RJOB_IOCT_WT_CMD(rj1id, (unsigned long)&rspcmd);

                            sprintf(rs->logs, "__M4_CMD_SEND_(%d)(BKCMD_REQUIRE_AREA_RSP)_OUT__", mfbidx); 
                            tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 20, rs->logs);
                            
                            clock_gettime(CLOCK_REALTIME, rs->tm2[0]);
                            msync(rs->tm2[0], sizeof(struct timespec), MS_SYNC);
                            
                            tmCost = time_diff(rs->tm2[1], rs->tm2[0], 1000);
                            sprintf_f(rs->logs, "RJOB_IOCT_WT_CMD (BKCMD_REQUIRE_AREA_RSP) (cost: %d.%d ms)\n", tmCost/1000, tmCost%1000);
                            print_f(rs->plogs, "P17", rs->logs);    
                            
                            //sprintf_f(rs->logs, "current buff id: %d \n", mfbidx);
                            //print_f(rs->plogs, "P17", rs->logs);
                
                            //outcmd.dPtr  = rx_buf;
                            #if 1
                            pImgArea = (t_ImageParam *)outcmd.dPtr;
                            sprintf_f(rs->logs, "ImgArea area seqid = %d jobid = %d (x:%d, y:%d, w:%d, h:%d, totalayer: %d, selayer: %d) \n", pImgArea->SeqIdx, pImgArea->iJobIdx, pImgArea->ImageRect.oxj, 
                                pImgArea->ImageRect.oyi, pImgArea->ImageRect.xc, pImgArea->ImageRect.yr, pImgArea->ImageLayerInfo.BKNote_Layers, pImgArea->ImageLayerInfo.SelLayerNum);
                            print_f(rs->plogs, "P17", rs->logs);

                            #if 1
                            for (ix=0; ix < BMP_DECODE_PIC_SIZE; ix++) {
                                decpic = &rs->pbDecMfour[mfbidx]->aspDecMfPiRaw[ix];
                                if ((decpic->aspDcLen == 0) && (decpic->aspDcWidth == 0)) {

                                    pRect = &rs->pbDecMfour[mfbidx]->aspDecRect[ix];
                                        
                                    //memcpy(pRect, pArRect, sizeof(mfour_rect_st));

                                    #if 1
                                    memcpy(&decpic->aspDcData->mfourAttb, pImgArea, sizeof(t_ImageParam));

                                    pRect->mfourRectX = pImgArea->ImageRect.oxj;
                                    pRect->mfourRectY = pImgArea->ImageRect.oyi;
                                    pRect->mfourRectW = pImgArea->ImageRect.xc;
                                    pRect->mfourRectH = pImgArea->ImageRect.yr;
                                    pRect->mfourLayer = pImgArea->ImageLayerInfo.SelLayerNum;
                                    #endif

                                    sprintf_f(rs->logs, "    search find and set area %d: x=%d,y=%d,w=%d,h=%d \n", ix, pRect->mfourRectX, pRect->mfourRectY, pRect->mfourRectW, pRect->mfourRectH);
                                    print_f(rs->plogs, "P17", rs->logs);    

                                    aspBMPdecodeItemSet(decpic, pRect->mfourRectW, pRect->mfourRectH, 0);

                                    rs->pbDecMfour[mfbidx]->aspDecRectSt[ix] = BKCMD_REQUIRE_AREA;
                                    msync(&rs->pbDecMfour[mfbidx]->aspDecRectSt[ix], sizeof(int), MS_SYNC);
                                    
                                    m4id = ix;
                                                                
                                    minfo[0] = 'c';

                                    if (ix == 0) {
                                        minfo[1] = 0x80;
                                    } else {
                                        minfo[1] = ix & 0x7f;
                                    }

                                   write(pipeMfRx[1], minfo, 2);

                                    if (mfourCnt > 0) {
                                        minfo[0] = 'C';

                                        mfourCnt -= 1;

                                        write(pipeMfRx[1], minfo, 2);
                                    } else {
                                        mfourlist[(mfourtail % MFOUR_WAIT_LIST_SIZE)] = minfo[1];
                                        mfourtail += 1;
                                        mfourwait += 1;
                                    }

                                    break;
                                }

                            }

                            #if 0 /* debug */
                            for (ix=0; ix < BMP_DECODE_PIC_SIZE; ix++) {
                                decpic = &rs->pbDecMfour[mfbidx]->aspDecMfPiRaw[ix];
                                
                                sprintf_f(rs->logs, "check area state %d: 0x%.4x \n", ix, rs->pbDecMfour[mfbidx]->aspDecRectSt[ix]);
                                print_f(rs->plogs, "P17", rs->logs);    
                            }
                            #endif

                            //sprintf_f(rs->logs, "Error!!! can't find available area \n");
                            //print_f(rs->plogs, "P17", rs->logs);    
                            #else
                            ix = 0;
                            decpic = &rs->pbDecMfour[mfbidx]->aspDecMfPiRaw[ix];

                            pRect = &rs->pbDecMfour[mfbidx]->aspDecRect[ix];                                        

                            //memcpy(pRect, pArRect, sizeof(mfour_rect_st));
                            
                            #if 1
                            memcpy(&decpic->aspDcData->mfourAttb, pImgArea, sizeof(t_ImageParam));
                            
                            pRect->mfourRectX = pImgArea->ImageRect.oxj;
                            pRect->mfourRectY = pImgArea->ImageRect.oyi;
                            pRect->mfourRectW = pImgArea->ImageRect.xc;
                            pRect->mfourRectH = pImgArea->ImageRect.yr;
                            #endif

                            sprintf_f(rs->logs, "imgArea set area %d: x=%d,y=%d,w=%d,h=%d \n", ix, pRect->mfourRectX, pRect->mfourRectY, pRect->mfourRectW, pRect->mfourRectH);
                            print_f(rs->plogs, "P17", rs->logs);    

                            aspBMPdecodeItemSet(decpic, pRect->mfourRectW, pRect->mfourRectH, 0);

                            minfo[0] = 'c';

                            if (ix == 0) {
                                minfo[1] = 0x80;
                            } else {
                                minfo[1] = ix & 0x7f;
                            }

                            write(pipeMfRx[1], minfo, 2);

                            if (mfourCnt > 0) {
                                minfo[0] = 'C';
                                mfourCnt -= 1;
                                write(pipeMfRx[1], minfo, 2);
                            } else {
                                mfourlist[(mfourtail % MFOUR_WAIT_LIST_SIZE)] = minfo[1];
                                mfourtail += 1;
                                mfourwait += 1;
                            }
                            #endif
                            #else
                            pArea = (mfour_areas_st *)outcmd.dPtr;
                            sprintf_f(rs->logs, "req area total = %d \n", pArea->mfourAreaTot);
                            print_f(rs->plogs, "P17", rs->logs);    

                            for (ic=0, ix=0; ic < pArea->mfourAreaTot; ic++) {
                                pArRect = &pArea->mfourAreas[ic];
                                sprintf_f(rs->logs, "req area %d: x=%d,y=%d,w=%d,h=%d \n", ic, pArRect->mfourRectX, pArRect->mfourRectY, pArRect->mfourRectW, pArRect->mfourRectH);
                                print_f(rs->plogs, "P17", rs->logs);    
                            
                                for (; ix < BMP_DECODE_PIC_SIZE; ix++) {
                                    decpic = &rs->pbDecMfour[mfbidx]->aspDecMfPiRaw[ix];
                                    if ((decpic->aspDcLen == 0) && (decpic->aspDcWidth == 0)) {
                                        pRect = &rs->pbDecMfour[mfbidx]->aspDecRect[ix];
                                        
                                        memcpy(pRect, pArRect, sizeof(mfour_rect_st));

                                        #if 0 // test code
                                        pRect->mfourRectX = 795;
                                        pRect->mfourRectY = 101;
                                        pRect->mfourRectW = 48;
                                        pRect->mfourRectH = 48;
                                        #endif

                                        sprintf_f(rs->logs, "find and set area %d: x=%d,y=%d,w=%d,h=%d \n", ix, pRect->mfourRectX, pRect->mfourRectY, pRect->mfourRectW, pRect->mfourRectH);
                                        print_f(rs->plogs, "P17", rs->logs);    
                                        
                                        aspBMPdecodeItemSet(decpic, pRect->mfourRectW, pRect->mfourRectH, 0);

                                        minfo[0] = 'c';

                                        if (ix == 0) {
                                            minfo[1] = 0x80;
                                        } else {
                                            minfo[1] = ix & 0x7f;
                                        }

                                        write(pipeMfRx[1], minfo, 2);

                                        if (mfourCnt > 0) {
                                            minfo[0] = 'C';

                                            mfourCnt -= 1;

                                            write(pipeMfRx[1], minfo, 2);
                                        } else {
                                            mfourlist[(mfourtail % MFOUR_WAIT_LIST_SIZE)] = minfo[1];
                                            mfourtail += 1;
                                            mfourwait += 1;
                                        }

                                        break;
                                    }

                                }
                            }
                            #endif
                            
                            break;
                        case BKCMD_DONE_AREA:              // M4 -> operator
                            sprintf(rs->logs, "__M4_CMD_RECV_(%d)(BKCMD_DONE_AREA)__", mfbidx); 
                            tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 26, rs->logs);

                            clock_gettime(CLOCK_REALTIME, rs->tm2[1]);
                            msync(rs->tm2[1], sizeof(struct timespec), MS_SYNC);
                            
                            tmCost = time_diff(rs->rtpTo[1], rs->tm2[1], 1000);
                            sprintf_f(rs->logs, "Read rjob command %.4x (BKCMD_DONE_AREA) (cost: %d.%d ms)\n", outcmd.cmd, tmCost/1000, tmCost%1000);
                            print_f(rs->plogs, "P17", rs->logs);  
                            
                            //dbgRjobCmd(&outcmd, sizeof(mfour_rjob_cmd));

                            memset(&rspcmd, 0, sizeof(mfour_rjob_cmd));
                            memcpy(&rspcmd, &outcmd, sizeof(mfour_rjob_cmd));
                            rspcmd.cmd = BKCMD_DONE_AREA_RSP;
                            rspcmd.dSize = 0;
                            rspcmd.dPtr = 0;
                            rspcmd.mPtr = 0;

                            sprintf(rs->logs, "__M4_CMD_SEND_(%d)(BKCMD_DONE_AREA_RSP)_IN__", mfbidx); 
                            tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 20, rs->logs);

                            RJOB_IOCT_WT_CMD(rj1id, (unsigned long)&rspcmd);

                            sprintf(rs->logs, "__M4_CMD_SEND_(%d)(BKCMD_DONE_AREA_RSP)_OUT__", mfbidx); 
                            tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 20, rs->logs);

                            clock_gettime(CLOCK_REALTIME, rs->tm2[0]);
                            msync(rs->tm2[0], sizeof(struct timespec), MS_SYNC);
                            
                            tmCost = time_diff(rs->tm2[1], rs->tm2[0], 1000);
                            sprintf_f(rs->logs, "RJOB_IOCT_WT_CMD (BKCMD_DONE_AREA_RSP) (cost: %d.%d ms)\n", tmCost/1000, tmCost%1000);
                            print_f(rs->plogs, "P17", rs->logs);    

                            pImgOutArea = outcmd.dPtr;
                            
                            img_out = container_of(pImgOutArea, mfour_image_param_st, mfourAttb);
                            jid = img_out->mfourAttb.iJobIdx;
                            seqid = img_out->mfourAttb.SeqIdx;
                            
                            sprintf_f(rs->logs, "area done current buff id: %d m4id: %d (x:%d y:%d w:%d h:%d) size: %d\n", mfbidx, m4id, img_out->mfourAttb.ImageRect.oxj, 
                                img_out->mfourAttb.ImageRect.oyi, img_out->mfourAttb.ImageRect.xc, img_out->mfourAttb.ImageRect.yr, outcmd.dSize);
                            print_f(rs->plogs, "P17", rs->logs);
                            
                            //outcmd.dPtr  = rx_buf;

                            #if 0 /*debug*/
                            //cid = img_out->mfourIdx;
                            cid = -1;
                            for (ix=0; ix <BMP_DECODE_PIC_SIZE; ix++) {
                                decpic = &rs->pbDecMfour[mfbidx]->aspDecMfPiRaw[ix];
                                m4dst = rs->pbDecMfour[mfbidx]->aspDecRectSt[ix];
                                img_param = decpic->aspDcData;

                                sprintf_f(rs->logs, "    search match buff info %d. %d, %d (seqid: %d jobid: %d) len: %d st: 0x%.4x cid: %d\n", ix, img_param->mfourAttb.SeqIdx, img_param->mfourAttb.iJobIdx, seqid, jid, decpic->aspDcLen, m4dst, cid);
                                print_f(rs->plogs, "P17", rs->logs);
                                
                                if ((decpic->aspDcLen > 0) && (cid < 0) && (m4dst == BKCMD_REQUIRE_AREA)) {
                                    cid = ix;
                                    rs->pbDecMfour[mfbidx]->aspDecRectSt[ix] = BKCMD_DONE_AREA;
                                    //break;
                                }
                            }
                            #else
                            cid = m4id;
                            #endif
                            
                            
                            //bkjob_send_cmd( chan->mqOperator, &outcmd);
                            sprintf_f(rs->logs, "send cmd BKCMD_DONE_AREA_RSP id: %d tag: %d, seqid: %d, Jobidx: %d, w: %d, h: %d \n", 
                                    cid, (uint32_t)(outcmd.tag >> 16), seqid, jid, 
                                    img_out->mfourAttb.ImageRect.xc, img_out->mfourAttb.ImageRect.yr);
                            print_f(rs->plogs, "P17", rs->logs);

                            decraw = &rs->pbDecMfour[mfbidx]->aspDecRaw;
                            img_raw = decraw->aspDcData;

                            if (cid < 0) {
                                sprintf_f(rs->logs, "Error no match buff break; !! \n");
                                print_f(rs->plogs, "P17", rs->logs);
                                break;
                            }
                            
                            decpic = &rs->pbDecMfour[mfbidx]->aspDecMfPiRaw[cid];
                            img_param = decpic->aspDcData;

                            cpyDst = img_param->mfourData;
                            cpySrc = img_raw->mfourData;

                            memcpy(cpyDst, cpySrc, 1078);

                            msync(cpyDst, 1078, MS_SYNC);

                            pheader = (struct bitmapHeader_s *)(img_param->mfourData - 2);
                            //dbgBitmapHeader(pheader, sizeof(struct bitmapHeader_s));

                            imgsize = img_out->mfourAttb.ImageRect.xc * img_out->mfourAttb.ImageRect.yr;
                            bitmapHeaderSetup(pheader, 8, img_out->mfourAttb.ImageRect.xc, img_out->mfourAttb.ImageRect.yr, 200, imgsize);
                            //dbgBitmapHeader(pheader, sizeof(struct bitmapHeader_s));
                                                        

                            cpyDst = img_param->mfourData + 1078; //offset:0x436
                            cpySrc = img_out->mfourData;

                            memcpy(cpyDst, cpySrc, imgsize);

                            imgsize += 1078;

                            aspBMPdecodeItemSet(decpic, img_out->mfourAttb.ImageRect.xc, img_out->mfourAttb.ImageRect.yr, imgsize);


                            #if 0
                            char filecharbmp[]="/home/root/charbmp/%c.bmp";
                            char filecharpath[256]={0};
                            char listchar[36] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};
                            char *charbmp[36] = {0};
                            FILE *fchar=0;
                            for (ix=0; ix<36; ix++) {
                                charbmp[ix] = malloc(22*22);
                            }

                            for (ix=0; ix<36; ix++) {
                                sprintf(filecharpath, filecharbmp, listchar[ix]);
                                fchar = fopen(filecharpath, "r");
                                if (fchar) {
                                    sprintf_f(rs->logs, "get char bmp [%s] succeed!!! \n", filecharpath);
                                    print_f(rs->plogs, "P17", rs->logs);
                                } else {
                                    sprintf_f(rs->logs, "find save bmp [%s] FAILED!!! \n", filecharpath);
                                    print_f(rs->plogs, "P17", rs->logs);
                                    break;
                                }

                                fclose(fchar);
                            }

                            for (ix=0; ix<36; ix++) {
                                free(charbmp[ix]);
                            }
                            #endif

                            sprintf_f(rs->logs, "m4attb image w: %d h: %d rtnCode: %d imgidx: %d\n", img_out->mfourAttb.ImageRect.xc, img_out->mfourAttb.ImageRect.yr, img_out->mfourAttb.iJobRtnCode, imgidx);
                            print_f(rs->plogs, "P17", rs->logs);
                            
                            if (img_out->mfourAttb.iJobRtnCode == iJobImgOCR) {
                            
                                sprintf(rs->logs, "__OCR_START_(0x%.2x)__", img_out->mfourAttb.iJobIdx); 
                                tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 32, rs->logs);
    
                                memset(outchr, 0, 36*3);
                                if (img_out->mfourAttb.iJobIdx == SRNBox1L) {

                                    clock_gettime(CLOCK_REALTIME, &mfoS);

                                    BKOCR_Check6(img_param->mfourData, imgsize, outchr[1], MaxCount_SRN);
                                    
                                    clock_gettime(CLOCK_REALTIME, &mfoE);
                                    tmCost = time_diff(&mfoS, &mfoE, 1000);

                                    //shmem_dump(outchr[1], 32);

                                    pusbmeta->OCR_strlen = strlen(outchr[1]);
                                    if (pusbmeta->OCR_strlen < 16) {
                                        memcpy(pusbmeta->OCR_chars, outchr[1], pusbmeta->OCR_strlen);
                                    }

                                    msync(&pusbmeta->OCR_strlen, 16, MS_SYNC);
                                    
                                    sprintf_f(rs->logs, "SRNBox1L OCR result len: %d cost: %d.%d ms\n", pusbmeta->OCR_strlen, tmCost/1000, tmCost%1000);
                                    print_f(rs->plogs, "P17", rs->logs);

                                } 
                                else if (img_out->mfourAttb.iJobIdx == SRNBox1R) {

                                    clock_gettime(CLOCK_REALTIME, &mfoS);
                                    
                                    BKOCR_Check7(img_param->mfourData, imgsize, outchr[2], MaxCount_SRN);

                                    clock_gettime(CLOCK_REALTIME, &mfoE);
                                    tmCost = time_diff(&mfoS, &mfoE, 1000);

                                    //shmem_dump(outchr[2], 32);
                                    
                                    pusbmeta->OCR_strlen = strlen(outchr[2]);
                                    if (pusbmeta->OCR_strlen < 16) {
                                        memcpy(pusbmeta->OCR_chars, outchr[2], pusbmeta->OCR_strlen);
                                    }

                                    msync(&pusbmeta->OCR_strlen, 16, MS_SYNC);
                                    
                                    sprintf_f(rs->logs, "SRNBox1R OCR result len: %d cost: %d.%d ms\n", pusbmeta->OCR_strlen, tmCost/1000, tmCost%1000);
                                    print_f(rs->plogs, "P17", rs->logs);

                                }

                                sprintf_f(rs->logs, "OCR RtnCode: [0x%x] iJobIdx: %d\n", img_out->mfourAttb.iJobRtnCode, img_out->mfourAttb.iJobIdx);
                                print_f(rs->plogs, "P17", rs->logs);

                                #if 1 /* debug show OCR result */
                                if ((pusbmeta->OCR_strlen > 10) && (pusbmeta->OCR_strlen < 16)) {
                                    memset(m4startcmd, 0, 256);
                                    memcpy(m4startcmd, pusbmeta->OCR_chars, pusbmeta->OCR_strlen);
                                    
                                    if (pusbmeta->OCR_chars[pusbmeta->OCR_strlen-1] == 0x0a) {
                                        m4startcmd[pusbmeta->OCR_strlen-1] = '\0';
                                    }
                                    sprintf_f(rs->logs, "OCR result chars: [%s] page: %d(%d) - %d\n", m4startcmd, (imgidx+1)/2, imgidx, pusbmeta->PRI_O_SEC);
                                    print_f(rs->plogs, "P17", rs->logs);
                                } else {
                                    sprintf_f(rs->logs, "OCR result chars failed ocrlen: %d page: %d(%d) - %d\n", pusbmeta->OCR_strlen, (imgidx+1)/2, imgidx, pusbmeta->PRI_O_SEC);
                                    print_f(rs->plogs, "P17", rs->logs);
                                }
                                #endif

                                sprintf(rs->logs, "__OCR_END_(LEN:%d)(%s)__", pusbmeta->OCR_strlen, m4startcmd); 
                                tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 32, rs->logs);

                            }                            

                            #if DUMP_MFOUR_BMP    
                            sprintf(filepath, ptfileSave, imgidx, mfbidx, cid);
                            //fdump = find_save(filepath, ptfileSave);
                            fdump = fopen(filepath, "w");
                            if (fdump) {
                                sprintf_f(rs->logs, "find save bmp [%s] succeed!!! \n", filepath);
                                print_f(rs->plogs, "P17", rs->logs);
                            } else {
                                sprintf_f(rs->logs, "find save bmp [%s] FAILED!!! \n", filepath);
                                print_f(rs->plogs, "P17", rs->logs);
                                break;
                            }

                            dumpsrc = img_param->mfourData;
                            dumpsize = imgsize;

                            ret = fwrite((char*)dumpsrc, 1, dumpsize, fdump);
                            sprintf_f(rs->logs, "write [%s] size: %d / %d !!! \n", filepath, ret, dumpsize);
                            print_f(rs->plogs, "P17", rs->logs);

                            fflush(fdump);
                            fclose(fdump);
                            sync();


                            for (modix=0; modix < 3; modix++) {
                                
                                outstrlen = strlen(outchr[modix]);
                                if (outstrlen > 0) {
                                    
                                    if (outstrlen > 20) {                                        
                                        sprintf_f(rs->logs, "Error !!! the ocr output str len is %d over 20 \n", outstrlen);
                                        print_f(rs->plogs, "P17", rs->logs);
                                        continue;
                                    }

                                    strcpy(filepathOcr, filepath);
                                    
                                    ocrpath = strchr(filepathOcr, '.');
                                    *ocrpath = '\0';

                                    //sprintf_f(rs->logs, "debug strchr, p: 0x%.8x ret: 0x%.8x !!! \n", (uint32_t)filepath, (uint32_t)ocrpath);
                                    //print_f(rs->plogs, "P17", rs->logs);

                                    ocrpath = strcat(filepathOcr, "_mod%.2d_sz%.2d.txt");
                                    sprintf(filepathOcrTxt, filepathOcr, modix, outstrlen);

                                    focrtxt = fopen(filepathOcrTxt, "w");
                                    if (focrtxt) {
                                        sprintf_f(rs->logs, "create ocrtxt file [%s] succeed !!!\n", filepathOcrTxt);
                                        print_f(rs->plogs, "P17", rs->logs);

                                        fwrite(outchr[modix], 1, outstrlen, focrtxt);

                                        fflush(focrtxt);
                                        fclose(focrtxt);
                                        sync();  
                                         focrtxt = 0;
                                     } else {
                                        sprintf_f(rs->logs, "create ocrtxt file [%s] failed!!! \n", filepathOcrTxt);
                                        print_f(rs->plogs, "P17", rs->logs);
                                    }                                    
                                }
                            }

                            memset(outchr, 0, 36*3);
                            #endif
                            
                            minfo[0] = 'd';

                            if (cid == 0) {
                                minfo[1] = 0x80;
                            } else {
                                minfo[1] = cid & 0x7f;
                            }

                            write(pipeMfRx[1], minfo, 2);
                            
                            mfourCnt += 1;
                            
                            if (mfourwait > 0) {
                                minfo[0] = 'C';
                                minfo[1] = mfourlist[(mfourhead % MFOUR_WAIT_LIST_SIZE)];

                                mfourCnt -= 1;
                                
                                mfourhead += 1;
                                mfourwait -= 1;

                                write(pipeMfRx[1], minfo, 2);
                            }
                            
                            break;
                        case BKCMD_ABORT:                  // M4 -> operator
                            sprintf_f(rs->logs, "Read rjob command %.4x (BKCMD_ABORT) \n", outcmd.cmd);
                            print_f(rs->plogs, "P17", rs->logs);    
                            //dbgRjobCmd(&outcmd, sizeof(mfour_rjob_cmd));
                            
                            //bkjob_send_cmd( chan->mqOperator, &cmd );
                            break;
                        case BKCMD_IMAGE_COMPLETE:         // M4 -> operator
                            sprintf(rs->logs, "__M4_CMD_RECV_(%d)(BKCMD_IMAGE_COMPLETE)__", mfbidx); 
                            tmCost = dbgShowTimeStamp(rs->logs,  NULL, rs, 26, rs->logs);
                            
                            clock_gettime(CLOCK_REALTIME, rs->tm2[1]);
                            msync(rs->tm2[1], sizeof(struct timespec), MS_SYNC);
                            
                            tmCost = time_diff(rs->rtpTo[1], rs->tm2[1], 1000);
                            sprintf_f(rs->logs, "Read rjob command %.4x (BKCMD_IMAGE_COMPLETE) (cost: %d.%d ms)\n", outcmd.cmd, tmCost/1000, tmCost%1000);
                            print_f(rs->plogs, "P17", rs->logs);  
                            
                            //dbgRjobCmd(&outcmd, sizeof(mfour_rjob_cmd));
                            

                            minfo[0] = 'e';
                            write(pipeMfRx[1], minfo, 1);
                            //bkjob_send_cmd( chan->mqOperator, &cmd );
                            break;
                        default:
                            sprintf_f(rs->logs, "Read rjob command %.4x (UNKNOWN) \n", outcmd.cmd);
                            print_f(rs->plogs, "P17", rs->logs);    
                            //dbgRjobCmd(&outcmd, sizeof(mfour_rjob_cmd));
                            
                            sprintf_f(rs->logs, "Error!!! unknowned cmd 0x%.2x !!!\n", outcmd.cmd);
                            print_f(rs->plogs, "P17", rs->logs);    
                            break;
                    }

                    clock_gettime(CLOCK_REALTIME, rs->rtpBk[1]);
                    msync(rs->rtpBk[1], sizeof(struct timespec), MS_SYNC);

                    tmCost = time_diff(rs->rtpBk[0], rs->rtpBk[1], 1000);
                    sprintf_f(rs->logs, "rjob round trip back delay (cost: %d.%d ms)\n", tmCost/1000, tmCost%1000);
                    print_f(rs->plogs, "P17", rs->logs); 
                    
                    if (outcmd.cmd == BKCMD_IMAGE_COMPLETE) {
                        break;
                    }
                }
                
            }
            break;
        default:
            sprintf_f(rs->logs, "Error!!! unknown cmd: %d !!!\n", tcmd);
            print_f(rs->plogs, "P17", rs->logs);    
            break;
        }

    }
    
    p17_end(rs);
    
    return 0;
}

#if MFOUR_API
#define LOG_P18_EN (1)
static int p18(struct procRes_s *rs)
{
    int ret=0;
    char ch=0;
    
    sprintf_f(rs->logs, "p18\n");
    print_f(rs->plogs, "P18", rs->logs);

    p18_init(rs);

    prctl(PR_SET_NAME, "msp-p18");

    mfourSetPipEpt1(pipMfTx);
    mfourSetPipEpt2(pipMfRx);
    
    while (1) {
        mfourmaind(rs->pbMfTxBuff);        
    }
    
    p18_end(rs);

    return 0;
}
#endif

#define DATA_RX_SIZE RING_BUFF_NUM
#define DATA_TX_SIZE RING_BUFF_NUM
#define CMD_RX_SIZE RING_BUFF_NUM
#define CMD_TX_SIZE RING_BUFF_NUM
int main(int argc, char *argv[])
{
//static char spi1[] = "/dev/spidev32766.0"; 
//static char spi0[] = "/dev/spidev32765.0"; 
    char dir[256] = "/mnt/mmc2";
    char wfssid[128] = "/root/scaner/ssid.gen";
    struct mainRes_s *pmrs;
    struct procRes_s rs[22];
    int ix, ret, len;
    char *log;
    int tdiff;
    int arg[8];
    uint32_t bitset;
    char syscmd[256] = "ls -al";
    struct sysinfo minfo;
    struct usbHostmem_s *usbh[2], *tusb=0;
    uint32_t *tbl0, *tbl1;
    uint32_t *phytbl0, *phytbl1;
    uint32_t ut32=0, vt32=0;
    int usbid0=0, usbid1=0;
    char *chvir;
    struct shmem_s *usbTx=0, *usbTxd=0, *usbCur=0;
    struct shmem_s *gateTx=0, *gateTxd=0;
    struct usbhost_s *pushost=0, *pushostd=0, *puscur=0;
    struct aspMetaData_s *metaRx = 0;
    char *metaPt=0;
    int *spipeTx, *spipeRx, *spipeTxd, *spipeRxd;
    int *sgateUpTx, *sgateUpRx, *sgateDnTx, *sgateDnRx;
    int *pipeJpgTx, *pipeJpgRx, *pipeJpgTxd, *pipeJpgRxd;
    struct usbFileidAccess_s *pusbf=0;
    struct bitmapDecodeMfour_s *pdec=0;
    FILE *fpssid=0;

    memset(MSP_SSID, 0, 128);
    len = 0;
    ret = 0;
    fpssid = fopen(wfssid, "r");
    if (fpssid) {
        ret |= fseek(fpssid, 0, SEEK_END);

        len |= ftell(fpssid);

        ret |= fseek(fpssid, 0, SEEK_SET);

        if ((!ret) && (len)) {
            ret = fread(MSP_SSID, 1, len, fpssid);
            if (ret == len) {
                if ((MSP_SSID[len - 1] == '\n') || (MSP_SSID[len - 1] == '\r')) {
                    MSP_SSID[len - 1] = '\0';
                }

                printf("SSID: [%s] \n", MSP_SSID);

            }
        }

        fclose(fpssid);
    } else {
        printf(" get ssid failed!! \n ");
    }

    printf("\n        ======== <%s, git version: %s> ========\n", MSP_VERSION, MSP_GIT);    
    printf("\n        ======== <build time: %s ssid: %s> ========\n\n", MSP_TIME, MSP_SSID);    
    
    aspMemAsign = (struct aspMemAsign_s *)mmap(NULL, sizeof(struct aspMemAsign_s) * MSP_P_NUM, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);
    memset(aspMemAsign, 0, sizeof(struct aspMemAsign_s) * MSP_P_NUM);
    asptotMalloc = (int *)mmap(NULL, sizeof(int) * MSP_P_NUM, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);
    memset(asptotMalloc, 0, sizeof(int) * MSP_P_NUM);
    totSalloc = (int *)mmap(NULL, sizeof(int), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);
    memset(totSalloc, 0, sizeof(int));

    mlogPool = (struct logPool_s *)mmap(NULL, sizeof(struct logPool_s), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);
    mlogPool->dislog = 0;
    mlogPool->max = OUT_BUFF_LEN - 4096;
    mlogPool->pool = mmap(NULL, mlogPool->max, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);
    if (!mlogPool->pool) {printf("get log pool share memory failed\n"); return 0;}
    mlogPool->len = 0;
    mlogPool->cur = mlogPool->pool;
    
    pmrs = (struct mainRes_s *)aspSalloc(sizeof(struct mainRes_s));
    memset(pmrs, 0, sizeof(struct mainRes_s));

    sprintf(pmrs->nmrs, "mrs");
    pmrs->mspconfig |= 0x4;
    pmrs->mspconfig |= 0x1;
    pmrs->plog = mlogPool;

    
    clock_gettime(CLOCK_REALTIME, &pmrs->time[0]);
    //dbgShowTimeStamp("s1 init system resource", pmrs, NULL, 2, NULL);
    //printSysinfo(&minfo);
    
    ret = file_save_get(&pmrs->flog, "/mnt/mmc2/rx/%d.log");
    if (ret) {printf("get log file failed\n"); return 0;}
    mlog = pmrs->flog;
    ret = fwrite("test file write \n", 1, 16, pmrs->flog);
    sprintf_f(pmrs->log, "write file size: %d/%d\n", ret, 16);
    print_f(pmrs->plog, "fwrite", pmrs->log);
    fflush(pmrs->flog);

    sprintf_f(pmrs->log, "argc:%d\n", argc);
    print_f(pmrs->plog, "main", pmrs->log);

// show arguments
    memset(arg, 0, sizeof(arg));
    ix = 0;
    len = argc;
    while(len) {
        //sprintf(pmrs->log, "%d. %s \n", ix, argv[ix]);
        //dbgShowTimeStamp(pmrs->log, pmrs, NULL, 4, NULL);
        
        arg[ix] = atoi(argv[ix]);
        sprintf_f(pmrs->log, "%d %d %s\n", ix, arg[ix], argv[ix]);
        print_f(pmrs->plog, "arg", pmrs->log);
        ix++;
        len--;
        if (ix > 7) break;
    }

    //sprintf(pmrs->log, "\n\n            ============ <MSP VERSION: %s> ===========\n\n", MSP_VERSION);    
    //dbgShowTimeStamp(pmrs->log, pmrs, NULL, 4, NULL);

    pmrs->mspconfig &= ~0x7;
    pmrs->plog->dislog = 0;
    switch (arg[1]) {
        case 1:
            pmrs->mspconfig |= 0x1;
            break;
        case 2:
            pmrs->mspconfig |= 0x2;
            break;
        case 3:
            pmrs->mspconfig |= 0x4;
            pmrs->plog->dislog = 1;
            break;
        case 4:
            pmrs->mspconfig |= 0x4;
            pmrs->mspconfig |= 0x1;
            pmrs->plog->dislog = 1;
            break;
        default:
            pmrs->mspconfig |= 0x1;
            break;
    }
    sprintf(pmrs->log, "LOG TYPE 0x%.2x", pmrs->mspconfig & 0x7);    
    dbgShowTimeStamp(pmrs->log, pmrs, NULL, 2, NULL);

    //sprintf(pmrs->log, "pull low delay: %d", PULL_LOW_AFTER_DATA);    
    //dbgShowTimeStamp(pmrs->log, pmrs, NULL, 4, NULL);

    #if 0
    dbgShowTimeStamp("s2", pmrs, NULL, 2, NULL);
    printSysinfo(&minfo);

    pmrs->spioc1 = aspSalloc(sizeof(struct spi_ioc_transfer));
    pmrs->spioc2 = aspSalloc(sizeof(struct spi_ioc_transfer));
    /* disable swap */
    sprintf(syscmd, "echo 0 > /proc/sys/vm/swappiness");
    ret = doSystemCmd(syscmd);

    sprintf(syscmd, "swapoff -a");
    ret = doSystemCmd(syscmd);

    sprintf(syscmd, "swapon -a");
    ret = doSystemCmd(syscmd);

    //sprintf(syscmd, "cat /proc/sys/vm/swappiness");
    //ret = doSystemCmd(syscmd);

    /* create folder */
    sprintf(syscmd, "mkdir -p /root/scaner");
    ret = doSystemCmd(syscmd);

    sprintf(syscmd, "mkdir -p /mnt/mmc2/rx");
    ret = doSystemCmd(syscmd);

    sprintf(syscmd, "mkdir -p /mnt/mmc2/tx");
    ret = doSystemCmd(syscmd);
    #endif
    
    // launchAP or directAccess
    #if 0//AP_CLR_STATUS
    /* clear status */
    sprintf(syscmd, "kill -9 $(ps aux | grep 'uap0' | awk '{print $1}')");
    ret = doSystemCmd(syscmd);

    //sprintf(syscmd, "kill -9 $(ps aux | grep 'mothership' | awk '{print $1}')");
    //ret = doSystemCmd(syscmd);

    sprintf(syscmd, "kill -9 $(ps aux | grep 'hostapd' | awk '{print $1}')");
    ret = doSystemCmd(syscmd);

    sprintf(syscmd, "ifconfig uap0 down");
    ret = doSystemCmd(syscmd);

    sprintf(syscmd, "kill -9 $(ps aux | grep '%s' | awk '{print $1}')", WIRELESS_INT);
    ret = doSystemCmd(syscmd);

    sprintf(syscmd, "kill -9 $(ps aux | grep '%s' | awk '{print $1}')", WIRELESS_INT_WPA);
    ret = doSystemCmd(syscmd);
        
    sprintf(syscmd, "kill -9 $(ps aux | grep 'wpa_supplicant' | awk '{print $1}')");
    ret = doSystemCmd(syscmd);

    sprintf(syscmd, "ifconfig %s down", WIRELESS_INT);
    ret = doSystemCmd(syscmd);

    sprintf(syscmd, "ifconfig %s down", WIRELESS_INT_WPA);
    ret = doSystemCmd(syscmd);
    
    sprintf_f(pmrs->log, "AP network interface: %s \n", pmrs->netIntfs);
    print_f(pmrs->plog, "inet", pmrs->log);

    sprintf_f(pmrs->log, "WPA network interface: %s \n", pmrs->netIntwpa);
    print_f(pmrs->plog, "inet", pmrs->log);

    sleep(1);
    #endif

    //dbgShowTimeStamp("s3 allocate share memory", pmrs, NULL, 2, NULL);
    //printSysinfo(&minfo);

// initial share parameter
    len = sizeof(struct aspMetaData_s);
    //pmrs->metaout = aspSalloc(len);
    //pmrs->metain = aspSalloc(len);

    len = SPI_TRUNK_SZ;
    pmrs->metaMass.masspt = aspSalloc(len);    
    pmrs->metaMass.massMax = len;
    pmrs->metaMass.massUsed = 0;

    if (pmrs->metaMass.masspt) {
        sprintf_f(pmrs->log, "inbuff addr(0x%.8x), outbuff addr(0x%.8x), massbuff addr(0x%.8x) \n", (uint32_t)&pmrs->metain, (uint32_t)&pmrs->metaout, (uint32_t)pmrs->metaMass.masspt);
        print_f(pmrs->plog, "meta", pmrs->log);
    } else {
        sprintf_f(pmrs->log, "Error!! allocate meta memory failed!!!! \n");
        print_f(pmrs->plog, "meta", pmrs->log);
    }
    
    len = sizeof(struct aspMetaData_s);
    //pmrs->metainDuo= aspSalloc(len);

    len = SPI_TRUNK_SZ;
    pmrs->metaMassDuo.masspt = aspSalloc(len);    
    pmrs->metaMassDuo.massMax = len;
    pmrs->metaMassDuo.massUsed = 0;

    if (pmrs->metaMassDuo.masspt) {
        sprintf_f(pmrs->log, " duo inbuff addr(0x%.8x), massbuff addr(0x%.8x) \n", (uint32_t)&pmrs->metainDuo, (uint32_t)pmrs->metaMassDuo.masspt);
        print_f(pmrs->plog, "metaduo", pmrs->log);
    } else {
        sprintf_f(pmrs->log, "Error!! duo allocate meta memory failed!!!! \n");
        print_f(pmrs->plog, "metaduo", pmrs->log);
    }
    
    /* data mode rx from spi */
    //clock_gettime(CLOCK_REALTIME, &pmrs->time[0]);
    pmrs->dataRx.pp = memory_init(&pmrs->dataRx.slotn, DATA_RX_SIZE*SPI_TRUNK_SZ, SPI_TRUNK_SZ); // 2MB
    if (!pmrs->dataRx.pp) goto end;
    pmrs->dataRx.r = (struct ring_p *)aspSalloc(sizeof(struct ring_p));
    pmrs->dataRx.totsz = DATA_RX_SIZE*SPI_TRUNK_SZ;
    pmrs->dataRx.chksz = SPI_TRUNK_SZ;
    pmrs->dataRx.svdist = 8;
    //sprintf_f(pmrs->log, "totsz:%d pp:0x%.8x\n", pmrs->dataRx.totsz, pmrs->dataRx.pp);
    //print_f(pmrs->plog, "minit_result", pmrs->log);
    //for (ix = 0; ix < pmrs->dataRx.slotn; ix++) {
    //    sprintf_f(pmrs->log, "[%d] 0x%.8x\n", ix, pmrs->dataRx.pp[ix]);
    //    print_f(pmrs->plog, "shminit_result", pmrs->log);
    //}
    //clock_gettime(CLOCK_REALTIME, &pmrs->time[1]);
    //tdiff = time_diff(&pmrs->time[0], &pmrs->time[1], 1000);
    //sprintf_f(pmrs->log, "tdiff:%d \n", tdiff);
    //print_f(pmrs->plog, "time_diff", pmrs->log);

    /* cmd mode rx from spi */
    //clock_gettime(CLOCK_REALTIME, &pmrs->time[0]);
    pmrs->cmdRx.pp = memory_init(&pmrs->cmdRx.slotn, CMD_RX_SIZE*SPI_TRUNK_SZ, SPI_TRUNK_SZ); // 2MB
    if (!pmrs->cmdRx.pp) goto end;
    pmrs->cmdRx.r = (struct ring_p *)aspSalloc(sizeof(struct ring_p));
    pmrs->cmdRx.totsz = CMD_RX_SIZE*SPI_TRUNK_SZ;;
    pmrs->cmdRx.chksz = SPI_TRUNK_SZ;
    pmrs->cmdRx.svdist = 16;
    //sprintf_f(pmrs->log, "totsz:%d pp:0x%.8x\n", pmrs->cmdRx.totsz, pmrs->cmdRx.pp);
    //print_f(pmrs->plog, "minit_result", pmrs->log);
    //for (ix = 0; ix < pmrs->cmdRx.slotn; ix++) {
    //    sprintf_f(pmrs->log, "[%d] 0x%.8x\n", ix, pmrs->cmdRx.pp[ix]);
    //    print_f(pmrs->plog, "shminit_result", pmrs->log);
    //}
    //clock_gettime(CLOCK_REALTIME, &pmrs->time[1]);
    //tdiff = time_diff(&pmrs->time[0], &pmrs->time[1], 1000);
    //sprintf_f(pmrs->log, "tdiff:%d \n", tdiff);
    //print_f(pmrs->plog, "time_diff", pmrs->log);
    
    /* cmd mode tx to spi */
    //clock_gettime(CLOCK_REALTIME, &pmrs->time[0]);
    pmrs->cmdTx.pp = memory_init(&pmrs->cmdTx.slotn, CMD_TX_SIZE*SPI_TRUNK_SZ, SPI_TRUNK_SZ); // 2MB
    if (!pmrs->cmdTx.pp) goto end;
    pmrs->cmdTx.r = (struct ring_p *)aspSalloc(sizeof(struct ring_p));
    pmrs->cmdTx.totsz = CMD_TX_SIZE*SPI_TRUNK_SZ;
    pmrs->cmdTx.chksz = SPI_TRUNK_SZ;
    pmrs->cmdTx.svdist = 16;
    //sprintf_f(pmrs->log, "totsz:%d pp:0x%.8x\n", pmrs->cmdTx.totsz, pmrs->cmdTx.pp);
    //print_f(pmrs->plog, "minit_result", pmrs->log);
    //for (ix = 0; ix < pmrs->cmdTx.slotn; ix++) {
    //    sprintf_f(pmrs->log, "[%d] 0x%.8x\n", ix, pmrs->cmdTx.pp[ix]);
    //    print_f(pmrs->plog, "shminit_result", pmrs->log);
    //}
    //clock_gettime(CLOCK_REALTIME, &pmrs->time[1]);
    //tdiff = time_diff(&pmrs->time[0], &pmrs->time[1], 1000);
    //sprintf_f(pmrs->log, "tdiff:%d \n", tdiff);
    //print_f(pmrs->plog, "time_diff", pmrs->log);

    pmrs->wtg.wtRlt =  aspSalloc(16);
    if (pmrs->wtg.wtRlt) {
        sprintf_f(pmrs->log, "wtg result buff:0x%.8x - DONE\n", (uint32_t)pmrs->wtg.wtRlt);
        print_f(pmrs->plog, "WTG", pmrs->log);
    } else {
        sprintf_f(pmrs->log, "wtg result buff alloc failed!!- ERROR\n");
        print_f(pmrs->plog, "WTG", pmrs->log);
    }
    pmrs->wtg.wtMrs = pmrs;

    //dbgShowTimeStamp("s4 check default param", pmrs, NULL, 2, NULL);
    //printSysinfo(&minfo);
    
    ret = file_save_get(&pmrs->fs, "/mnt/mmc2/rx/%d.bin");
    if (ret) {printf("get save file failed\n"); return 0;}
    //ret = fwrite("test file write \n", 1, 16, pmrs->fs);
    sprintf_f(pmrs->log, "write file size: %d/%d\n", ret, 16);
    print_f(pmrs->plog, "fwrite", pmrs->log);

    char paramFilePath[128] = "/root/scaner/scannerParam.bin";
    FILE *fprm=0;
    struct aspConfig_s* ctb = 0;
    int parmLen=0, parmTotz=0, readLen=0;
    struct modersp_s tmpModersp;
    
    parmTotz = ASPOP_CODE_MAX*sizeof(struct aspConfig_s);
    
    fprm = fopen(paramFilePath, "r");
    if (fprm) {
        ctb = pmrs->configTable;

        ret = fseek(fprm, 0, SEEK_END);
        if (ret) {
            sprintf_f(pmrs->log, " file seek failed!! ret:%d \n", ret);
            print_f(pmrs->plog, "PRAM", pmrs->log);
        } 

        parmLen = ftell(fprm);
        sprintf_f(pmrs->log, " file [%s] size: %d \n", paramFilePath, parmLen);
        print_f(pmrs->plog, "PRAM", pmrs->log);

        ret = fseek(fprm, 0, SEEK_SET);
        if (ret) {
            sprintf_f(pmrs->log, " file seek failed!! ret:%d \n", ret);
            print_f(pmrs->plog, "PRAM", pmrs->log);
        }
        if (parmLen == parmTotz) {
            readLen = fread(ctb, 1, parmLen, fprm);
        } else {
            sprintf_f(pmrs->log, " file size error !!! filesize:%d, memsize: %d\n", parmLen, parmTotz);
            print_f(pmrs->plog, "PRAM", pmrs->log);
        }
        fclose(fprm);
        /* reset the run time parameters */
        setDefaultConf(pmrs->configTable);
        setDefaultConfFile(pmrs->configTable);
    }
    
    if (readLen == 0) { 
        sprintf_f(pmrs->log, " load scaner parameter at [%s] failed !!! Reset configuration!!!\n", paramFilePath);
        print_f(pmrs->plog, "PRAM", pmrs->log);

        setDefaultConf(pmrs->configTable);
        
        fs109(pmrs, &tmpModersp);
    }

    //dbgShowTimeStamp("s5 wireless status check", pmrs, NULL, 2, NULL);
    //printSysinfo(&minfo);
    
    #if 0 /* manual launch AP mode or Direct mode, will disable if AP mode complete */
    if (arg[1] == 0) {
        /* launch AP  */
        sprintf(syscmd, "/root/script/launchAP_88w8787.sh");
        ret = doSystemCmd(syscmd);
        memset(pmrs->netIntfs, 0, 16);
        sprintf(pmrs->netIntfs, "%s", "uap0");
    } else {
        /* launch wpa connect */
        sprintf(syscmd, "/root/script/iw_con.sh");
        ret = doSystemCmd(syscmd);
        memset(pmrs->netIntfs, 0, 16);
        sprintf(pmrs->netIntfs, "%s", WIRELESS_INT);
    }
    #else
    /* read AP config */
    char ssidPath[128] = "/root/scaner/ssid.bin";
    char pskPath[128] = "/root/scaner/psk.bin";
    FILE *fssid=0, *fpsk=0;
    int wfcLen;
    struct apWifiConfig_s *pwfc=0;

    pwfc = &pmrs->wifconf;
    
    fssid = fopen(ssidPath, "r");
    if (fssid) {
        fpsk = fopen(pskPath, "r");
        readLen = 0;
        if (fpsk) {
            ret = fseek(fpsk, 0, SEEK_END);
            if (ret) {
                sprintf_f(pmrs->log, " file seek failed!! ret:%d \n", ret);
                print_f(pmrs->plog, "WIFC", pmrs->log);
            } 

            wfcLen = ftell(fpsk);
            sprintf_f(pmrs->log, " file [%s] size: %d \n", pskPath, wfcLen);
            print_f(pmrs->plog, "WIFC", pmrs->log);

            ret = fseek(fpsk, 0, SEEK_SET);
            if (ret) {
                sprintf_f(pmrs->log, " file seek failed!! ret:%d \n", ret);
                print_f(pmrs->plog, "WIFC", pmrs->log);
            }

            if ((wfcLen >= 8) && (wfcLen <=63)) {
                readLen = fread(pwfc->wfpsk, 1, wfcLen, fpsk);

                //sprintf_f(pmrs->log, "psk len: %d str: [%s] - 1 \n", readLen, pwfc->wfpsk);
                //print_f(pmrs->plog, "WIFC", pmrs->log);

                pwfc->wfpsk[readLen] = '\0';
                readLen = strlen(pwfc->wfpsk);
                if ((readLen > 0) && ((pwfc->wfpsk[readLen-1] == '\n') || (pwfc->wfpsk[readLen-1] == '\r'))) {
                    pwfc->wfpsk[readLen-1] = '\0';
                }
                readLen = strlen(pwfc->wfpsk);
                
                sprintf_f(pmrs->log, "psk len: %d str: [%s] \n", readLen, pwfc->wfpsk);
                print_f(pmrs->plog, "WIFC", pmrs->log);

                pwfc->wfpskLen = readLen;
            } else {
                sprintf_f(pmrs->log, " file size error !!! filesize:%d, readLen: %d\n", wfcLen, readLen);
                print_f(pmrs->plog, "WIFC", pmrs->log);
            }
            
            fclose(fpsk);
        }

        if (readLen > 0) {
            readLen = 0;
            ret = fseek(fssid, 0, SEEK_END);
            if (ret) {
                sprintf_f(pmrs->log, " file seek failed!! ret:%d \n", ret);
                print_f(pmrs->plog, "WIFC", pmrs->log);
            } 

            wfcLen = ftell(fssid);
            sprintf_f(pmrs->log, " file [%s] size: %d \n", ssidPath, wfcLen);
            print_f(pmrs->plog, "WIFC", pmrs->log);

            ret = fseek(fssid, 0, SEEK_SET);
            if (ret) {
                sprintf_f(pmrs->log, " file seek failed!! ret:%d \n", ret);
                print_f(pmrs->plog, "WIFC", pmrs->log);
            }

            if ((wfcLen > 0) && (wfcLen <= 32)) {
                readLen = fread(pwfc->wfssid, 1, wfcLen, fssid);
                
                //sprintf_f(pmrs->log, "ssid len: %d str: [%s] - 1 \n", readLen, pwfc->wfssid);
                //print_f(pmrs->plog, "WIFC", pmrs->log);

                pwfc->wfssid[readLen] = '\0';
                readLen = strlen(pwfc->wfssid);
                if ((readLen > 0) && ((pwfc->wfssid[readLen-1] == '\n') || (pwfc->wfssid[readLen-1] == '\r'))) {
                    pwfc->wfssid[readLen-1] = '\0';
                }
                readLen = strlen(pwfc->wfssid);
                
                sprintf_f(pmrs->log, "ssid len: %d str: [%s] \n", readLen, pwfc->wfssid);
                print_f(pmrs->plog, "WIFC", pmrs->log);
                                
                pwfc->wfsidLen = readLen;
            } else {
                sprintf_f(pmrs->log, " file size error !!! filesize:%d, readLen: %d\n", wfcLen, readLen);
                print_f(pmrs->plog, "WIFC", pmrs->log);
            }            
        }
        fclose(fssid);
    }
    
    sprintf(pmrs->log, "LAST TIME ACCESS SSID: %s ", pwfc->wfsidLen>0?pwfc->wfssid:" ");
    dbgShowTimeStamp(pmrs->log, pmrs, NULL, 2, NULL);
    //printSysinfo(&minfo);

    #if 0 //AP_AUTO
    /* AP mode launch or not */
    int isLaunch = 0;
    char s[INET_ADDRSTRLEN];
    char d[INET_ADDRSTRLEN];
    struct ifaddrs *ifaddr, *ifa;
    
    FILE *faptpe=0;
    char aptypestr[32] = WIRELESS_INT, lastnum=0;
    int itypelen=0, addroffset=0;
    
    ctb = &pmrs->configTable[ASPOP_AP_MODE];
    if (ctb->opCode != OP_AP_MODEN) {        
        sprintf_f(pmrs->log, " WARNING!!! get wrong opcode value 0x%x", ctb->opCode);
        print_f(pmrs->plog, "APM", pmrs->log);
    }

    sprintf_f(pmrs->log, "opc: 0x%x, status: 0x%x, value: %d \n", ctb->opCode, ctb->opStatus, ctb->opValue);
    print_f(pmrs->plog, "APM", pmrs->log);

    if (ctb->opValue == APM_AP) {
        /* launch wpa connect */
        pwfc = &pmrs->wifconf;
        if ((pwfc->wfpskLen > 0) && (pwfc->wfsidLen > 0)) {
            sprintf_f(pmrs->log, "launch AP mode ... ssid: \"%s\", psk: \"%s\"\n", pwfc ->wfssid, pwfc->wfpsk);
            print_f(pmrs->plog, "APM", pmrs->log);

            faptpe = 0;
            memset(aptypestr, 0, 32);
            memset(pmrs->netIntwpa, 0, 16);
            faptpe = fopen("/root/config/wpatype", "r");
            if (faptpe) {
                itypelen = fread(aptypestr, 1, 16, faptpe);
                if ((itypelen > 0) && (itypelen < 16)) {
                    aptypestr[itypelen] = '\0';
                    if (aptypestr[itypelen-1] == '\n') {
                        aptypestr[itypelen-1] = '\0';
                    }

                    if (aptypestr[itypelen-1] == '\r') {
                        aptypestr[itypelen-1] = '\0';
                    }
                    sprintf(pmrs->netIntwpa, "%s", aptypestr);
                } else {
                    memset(pmrs->netIntwpa, 0, 16);
                    sprintf(pmrs->netIntwpa, WIRELESS_INT_WPA);
                }
                fclose(faptpe);
                faptpe = 0;
            } else {
                memset(pmrs->netIntwpa, 0, 16);
                sprintf(pmrs->netIntwpa, WIRELESS_INT_WPA);
            }
        
            /* launch wpa connect */
            sprintf(syscmd, "/root/script/wpa_conf.sh \\\"%s\\\" \\\"%s\\\" /etc/wpa_supplicant.conf ", pwfc ->wfssid, pwfc->wfpsk);
            ret = doSystemCmd(syscmd);

            //sprintf(syscmd, "cp /root/script/interfaces_8723bu_wpa /etc/network/interfaces");
            //ret = doSystemCmd(syscmd);

            sprintf(syscmd, "wpa_supplicant -B -c /etc/wpa_supplicant.conf -i%s -Dnl80211 -dd", pmrs->netIntwpa);
            ret = doSystemCmd(syscmd);

            sleep(1);

            sprintf(syscmd, "udhcpc -i %s -t 5 -n", pmrs->netIntwpa);
            ret = doSystemCmd(syscmd);

            sprintf_f(pmrs->log, "exec [%s]...\n", syscmd);
            print_f(pmrs->plog, "APM", pmrs->log);

            sprintf_f(pmrs->log, "WPA interface: [%s]\n", pmrs->netIntwpa);
            print_f(pmrs->plog, "APM", pmrs->log);

            ret = getifaddrs(&ifaddr);
            if (ret == -1) {
                perror("getifaddrs");        
                //exit(EXIT_FAILURE);    
            } 
            else {
                for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
                    if (ifa->ifa_addr == NULL)
                        continue;

                    ret=getnameinfo(ifa->ifa_addr, sizeof(struct sockaddr_in),s, INET_ADDRSTRLEN, NULL, 0, NI_NUMERICHOST);
                    if (ret != 0) {
                        //printf("[%s] getnameinfo() failed: %s\n", ifa->ifa_name, gai_strerror(ret));
                        //exit(EXIT_FAILURE);
                        continue;
                    }
                    
                    if((strcmp(ifa->ifa_name, pmrs->netIntwpa)==0) && (ifa->ifa_addr->sa_family == AF_INET)) {

                        printf("\tInterface : <%s>\n",ifa->ifa_name );
                        printf("\t  Address : <%s>\n", s);

                        sprintf_f(pmrs->log, "iface: %s addr: %s", pmrs->netIntwpa, s);
                        print_f(pmrs->plog, "APM", pmrs->log);

                        addroffset = getaddoffset(s, &lastnum);
                        memset(d, 0, INET_ADDRSTRLEN);

                        memcpy(d, s, addroffset);
                        sprintf(&d[addroffset], "%d", 1);

                        sprintf_f(pmrs->log, "ping gatway ip: %s \n", d);
                        print_f(pmrs->plog, "APM", pmrs->log);

                        sprintf(syscmd, "ping %s -w 3", d);
                        ret = doSystemCmd(syscmd);

                        isLaunch = 1;
                    }
                }

                freeifaddrs(ifaddr);
            }
            
            if (!isLaunch) {
                ctb->opValue = APM_DIRECT;
                fs109(pmrs, &tmpModersp);
            }
        } else {
            sprintf_f(pmrs->log, "failed to launch AP mode, no ssid and psk ...\n");
            print_f(pmrs->plog, "APM", pmrs->log);
        }
    }
    
    if (ctb->opValue) {
        /* launch AP  */
        //sprintf(syscmd, "/root/script/clr_all.sh");
        //ret = doSystemCmd(syscmd);
        //sleep(1);

        memset(aptypestr, 0, 32);
        memset(pmrs->netIntfs, 0, 16);
        
        faptpe = fopen("/root/config/aptype", "r");
        if (faptpe) {
            itypelen = fread(aptypestr, 1, 16, faptpe);
            if ((itypelen > 0) && (itypelen < 16)) {
                aptypestr[itypelen] = '\0';
                if (aptypestr[itypelen-1] == '\n') {
                    aptypestr[itypelen-1] = '\0';
                }
                if (aptypestr[itypelen-1] == '\r') {
                    aptypestr[itypelen-1] = '\0';
                }
                sprintf(pmrs->netIntfs, "%s", aptypestr);
            } else {
                memset(pmrs->netIntfs, 0, 16);
                sprintf(pmrs->netIntfs, WIRELESS_INT);
            }
            fclose(faptpe);
        } else {
            memset(pmrs->netIntfs, 0, 16);
            sprintf(pmrs->netIntfs, WIRELESS_INT);
        }
        
        sprintf(syscmd, "/root/script/launchAP_now.sh > /dev/null 2>&1");
        ret = doSystemCmd(syscmd);
        
        sprintf_f(pmrs->log, "AP interface = [%s] \n", pmrs->netIntfs);
        print_f(pmrs->plog, "WIFC", pmrs->log);

        //shmem_dump(pmrs->netIntfs, 16);
        //shmem_dump(aptypestr, 16);
    }
  
    if ((pwfc->wfsidLen > 0) && (pwfc->wfpskLen > 0)) {
        sprintf_f(pmrs->log, " get ssid: [%s] size: %d, psk: [%s] size: %d\n", pwfc->wfssid, pwfc->wfsidLen, pwfc->wfpsk, pwfc->wfpskLen);
        print_f(pmrs->plog, "WIFC", pmrs->log);
    } else {
        sprintf_f(pmrs->log, " ssid and psk are unavilable!!\n");
        print_f(pmrs->plog, "WIFC", pmrs->log);
    }    

    dbgShowTimeStamp("s7", pmrs, NULL, 2, NULL);
    printSysinfo(&minfo);

    #endif
    
    #endif
    /* CROP */
    #if 0
    pmrs->crop32 = (struct aspCrop36_s *)aspSalloc(sizeof(struct aspCrop36_s));
    if (!pmrs->crop32) {
        sprintf_f(pmrs->log, "alloc share memory for crop 32 points FAIL!!! size = %d\n", sizeof(struct aspCrop36_s)); 
        print_f(pmrs->plog, "CROP32", pmrs->log);
        goto end;
    } else {
        sprintf_f(pmrs->log, "alloc share memory for crop 32 points DONE [0x%x] size:%d !!!\n", pmrs->crop32, sizeof(struct aspCrop36_s)); 
        print_f(pmrs->plog, "CROP32", pmrs->log);
    }

    pmrs->cropex = (struct aspCropExtra_s *)aspSalloc(sizeof(struct aspCropExtra_s));
    if (!pmrs->cropex) {
        sprintf_f(pmrs->log, "alloc share memory for crop extra points FAIL!!! size = %d\n", sizeof(struct aspCropExtra_s)); 
        print_f(pmrs->plog, "CROPEX", pmrs->log);

        pmrs->cropex->crpexMax = 2048;
        pmrs->cropex->crpexLfAbsMax = 2048;
        pmrs->cropex->crpexRtAbsMax = 2048;
        goto end;
    } else {
        sprintf_f(pmrs->log, "alloc share memory for crop extra points DONE [0x%x] size:%d !!!\n", pmrs->cropex, sizeof(struct aspCropExtra_s)); 
        print_f(pmrs->plog, "CROPEX", pmrs->log);
    }

    pmrs->crop32Duo = (struct aspCrop36_s *)aspSalloc(sizeof(struct aspCrop36_s));
    if (!pmrs->crop32Duo) {
        sprintf_f(pmrs->log, "alloc duo share memory for crop 32 points FAIL!!! size = %d\n", sizeof(struct aspCrop36_s)); 
        print_f(pmrs->plog, "CROP32DUO", pmrs->log);
        goto end;
    } else {
        sprintf_f(pmrs->log, "alloc duo share memory for crop 32 points DONE [0x%x] size:%d !!!\n", pmrs->crop32Duo, sizeof(struct aspCrop36_s)); 
        print_f(pmrs->plog, "CROP32DUO", pmrs->log);
    }

    pmrs->cropexDuo= (struct aspCropExtra_s *)aspSalloc(sizeof(struct aspCropExtra_s));
    if (!pmrs->cropexDuo) {
        sprintf_f(pmrs->log, "alloc share memory for crop extra points FAIL!!! size = %d\n", sizeof(struct aspCropExtra_s)); 
        print_f(pmrs->plog, "CROPEXDUO", pmrs->log);

        pmrs->cropexDuo->crpexMax = 2048;
        pmrs->cropexDuo->crpexLfAbsMax = 2048;
        pmrs->cropexDuo->crpexRtAbsMax = 2048;
        goto end;
    } else {
        sprintf_f(pmrs->log, "alloc share memory for crop extra points DONE [0x%x] size:%d !!!\n", pmrs->cropexDuo, sizeof(struct aspCropExtra_s)); 
        print_f(pmrs->plog, "CROPEXDUO", pmrs->log);
    }
    #endif
    /* BITMAP */
    #if 0
    pmrs->bmpRotate.aspRotCrossAry= aspSalloc(8192*4*3);
    if (!pmrs->bmpRotate.aspRotCrossAry) {
        sprintf_f(pmrs->log, "alloc share memory for BITMAP ROTATE FAIL!!! size = %d\n", 8192*4*3); 
        print_f(pmrs->plog, "BITMAP", pmrs->log);
        pmrs->bmpRotate.aspRotCASize = 0;
        goto end;
    } else {
        pmrs->bmpRotate.aspRotCASize = 8192*4*3;
        
        sprintf_f(pmrs->log, "alloc share memory for BITMAP ROTATE DONE [0x%.8x]!!! size = %d\n", (uint32_t)pmrs->bmpRotate.aspRotCrossAry, pmrs->bmpRotate.aspRotCASize); 
        print_f(pmrs->plog, "BITMAP", pmrs->log);
    }
    #endif

/*
    pmrs->bmpRotate.aspRotCpyBuff= aspSalloc(8*1024*1024);
    if (!pmrs->bmpRotate.aspRotCpyBuff) {
        sprintf_f(pmrs->log, "alloc share memory for BITMAP copy buffer FAIL!!! size = %d\n", 8*1024*1024); 
        print_f(pmrs->plog, "BITMAP", pmrs->log);
        pmrs->bmpRotate.aspRotCASize = 0;
    } else {
        pmrs->bmpRotate.aspRotBuffSize = 8*1024*1024;
        
        sprintf_f(pmrs->log, "alloc share memory for BITMAP copy buffer DONE [0x%.8x]!!! size = %d\n", pmrs->bmpRotate.aspRotCpyBuff, pmrs->bmpRotate.aspRotBuffSize); 
        print_f(pmrs->plog, "BITMAP", pmrs->log);
    }
*/

    //dbgShowTimeStamp("s8", pmrs, NULL, 2, NULL);
    //printSysinfo(&minfo);

    
    /* FAT */
    /*
    pmrs->aspFat.fatBootsec = (struct sdbootsec_s *)aspSalloc(sizeof(struct sdbootsec_s));
    if (!pmrs->aspFat.fatBootsec) {
        sprintf_f(pmrs->log, "alloc share memory for FAT boot sector FAIL!!!\n", pmrs->aspFat.fatBootsec); 
        print_f(pmrs->plog, "FAT", pmrs->log);
        goto end;
    } else {
        sprintf_f(pmrs->log, "alloc share memory for FAT boot sector DONE [0x%x]!!!\n", pmrs->aspFat.fatBootsec); 
        print_f(pmrs->plog, "FAT", pmrs->log);
    }
    */
    /*
    pmrs->aspFat.fatFSinfo = (struct sdFSinfo_s *)aspSalloc(sizeof(struct sdFSinfo_s));
    if (!pmrs->aspFat.fatFSinfo) {
        sprintf_f(pmrs->log, "alloc share memory for FAT file system info FAIL!!!\n", pmrs->aspFat.fatFSinfo); 
        print_f(pmrs->plog, "FAT", pmrs->log);
        goto end;
    } else {
        sprintf_f(pmrs->log, "alloc share memory for FAT file system info DONE [0x%x]!!!\n", pmrs->aspFat.fatFSinfo); 
        print_f(pmrs->plog, "FAT", pmrs->log);
    }
    */
    /*
    pmrs->aspFat.fatTable = (struct sdFATable_s *)aspSalloc(sizeof(struct sdFATable_s));
    if (!pmrs->aspFat.fatTable) {
        sprintf_f(pmrs->log, "alloc share memory for FAT table FAIL!!!\n", pmrs->aspFat.fatTable); 
        print_f(pmrs->plog, "FAT", pmrs->log);
        goto end;
    } else {
        sprintf_f(pmrs->log, "alloc share memory for FAT table DONE [0x%x]!!!\n", pmrs->aspFat.fatTable); 
        print_f(pmrs->plog, "FAT", pmrs->log);
    }

    sprintf_f(pmrs->log, "size of struct dir is %d \n", sizeof(struct directnFile_s)); 
    print_f(pmrs->plog, "FAT", pmrs->log);
    */
/*
    pmrs->aspFat.fatDirPool = (struct sdDirPool_s *)aspSalloc(sizeof(struct sdDirPool_s));
    if (!pmrs->aspFat.fatDirPool) {
        sprintf_f(pmrs->log, "alloc share memory for FAT dir pool FAIL!!!\n", pmrs->aspFat.fatDirPool); 
        print_f(pmrs->plog, "FAT", pmrs->log);
        goto end;
    } else {
        sprintf_f(pmrs->log, "alloc share memory for FAT dir pool DONE [0x%x]!!!\n", pmrs->aspFat.fatDirPool); 
        print_f(pmrs->plog, "FAT", pmrs->log);
    }

    struct sdDirPool_s    *pool;
    pool = pmrs->aspFat.fatDirPool;
    pool->dirPool = (struct directnFile_s *)aspSalloc(sizeof(struct directnFile_s) * DIR_POOL_SIZE);
    if (!pool->dirPool) {
        sprintf_f(pmrs->log, "alloc share memory for FAT dir pool content FAIL!!!\n", pool->dirPool); 
        print_f(pmrs->plog, "FAT", pmrs->log);
        goto end;
    } else {
        sprintf_f(pmrs->log, "alloc share memory for FAT dir pool content DONE [0x%x] , size is %d x %d = %d bytes!!!\n", pool->dirPool, DIR_POOL_SIZE, sizeof(struct directnFile_s),sizeof(struct directnFile_s)*DIR_POOL_SIZE); 
        print_f(pmrs->plog, "FAT", pmrs->log);
        memset(pool->dirPool, 0, sizeof(struct directnFile_s)*DIR_POOL_SIZE);
    }
    pool->dirMax = DIR_POOL_SIZE;
    pool->dirUsed = 0;
*/

#if 1
    pmrs->aspFat.fatDirTr.dirFATMax = FAT_DIRPOO_ARY_MAX;
    pmrs->aspFat.parBuf.dirParseBuff = 0;
    pmrs->aspFat.parBuf.dirBuffUsed = 0;
    pmrs->aspFat.parBuf.dirBuffMax = 0;
#else
    pool->parBuf.dirParseBuff = aspSalloc(16*1024*1024); // 16MB
    if (!pool->parBuf.dirParseBuff) {
        sprintf_f(pmrs->log, "alloc share memory for FAT dir parsing buffer FAIL!!!\n"); 
        print_f(pmrs->plog, "FAT", pmrs->log);
        goto end;
    } else {
        sprintf_f(pmrs->log, "alloc share memory for FAT dir parsing buffer DONE [0x%x] , size is %d!!!\n", pool->parBuf.dirParseBuff, 16*1024*1024); 
        print_f(pmrs->plog, "FAT", pmrs->log);
    }
    pool->parBuf.dirBuffMax = 16*1024*1024;
    pool->parBuf.dirBuffUsed = 0;
#endif

    pmrs->aspFat.fatStatus = ASPFAT_STATUS_INIT;

    //dbgShowTimeStamp("s9", pmrs, NULL, 2, NULL);
    //printSysinfo(&minfo);

    sprintf_f(pmrs->log, "before open device[%s]\n", spidev_0); 
    print_f(pmrs->plog, "SPI", pmrs->log);

#if 1 //DISABLE_SPI
    pmrs->sfm[0] = 0;
    pmrs->sfm[1] = 0;
    pmrs->smode = 0;
    pmrs->smode |= SPI_MODE_1;
    sprintf_f(pmrs->log, "disable SPI for debug!!!\n"); 
    print_f(pmrs->plog, "SPI", pmrs->log);
#else //#if DISABLE_SPI
/*
    ret = mspFS_createRoot(&pmrs->aspFat.fatRootdir, &pmrs->aspFat, dir);
    if (!ret) {
        sprintf_f(pmrs->log, "FS root [%s] create done, root:0x%x\n", dir, (uint32_t)pmrs->aspFat.fatRootdir);
        print_f(pmrs->plog, "FAT", pmrs->log);
        ret = mspFS_insertChilds(&pmrs->aspFat, pmrs->aspFat.fatRootdir);
        if (!ret) {
            sprintf_f(pmrs->log, "FS insert ch done\n");
            print_f(pmrs->plog, "FAT", pmrs->log);
            mspFS_showFolder( pmrs->aspFat.fatRootdir);
        } else {
            sprintf_f(pmrs->log, "FS insert ch failed\n");
            print_f(pmrs->plog, "FAT", pmrs->log);
        }
    } else {
        sprintf_f(pmrs->log, "FS root [%s] create failed ret:%d\n", ret);
        print_f(pmrs->plog, "FAT", pmrs->log);
    }
*/

// spidev id
    int fd0=0, fd1=0;
#if SPIDEV_SWITCH
    fd0 = open(spidev_1, O_RDWR);
#else
    fd0 = open(spidev_0, O_RDWR);
#endif
    if (fd0 <= 0) {
        sprintf_f(pmrs->log, "can't open device[%s]\n", spidev_0); 
        print_f(pmrs->plog, "SPI", pmrs->log);
        goto end;
    } else {
        sprintf_f(pmrs->log, "open device[%s] id: %d \n", spidev_0, fd0); 
        print_f(pmrs->plog, "SPI", pmrs->log);
    }
    if (spidev_1) {
#if SPIDEV_SWITCH
        fd1 = open(spidev_0, O_RDWR);
#else
        fd1 = open(spidev_1, O_RDWR);
#endif
        if (fd1 <= 0) {
            sprintf_f(pmrs->log, "can't open device[%s]\n", spidev_1); 
            print_f(pmrs->plog, "SPI", pmrs->log);
            fd1 = 0;
        } else {
            sprintf_f(pmrs->log, "open device[%s] id: %d\n", spidev_1, fd1); 
            print_f(pmrs->plog, "SPI", pmrs->log);
        }
    } else {
        fd1 = fd0;
    }

    pmrs->sfm[0] = fd0;
    pmrs->sfm[1] = fd1;
    pmrs->smode = 0;
    pmrs->smode |= SPI_MODE_1;

    bitset = 1;
    msp_spi_conf(pmrs->sfm[0], _IOW(SPI_IOC_MAGIC, 11, __u32), &bitset);   //SPI_IOC_WR_SLVE_READY
    sprintf_f(pmrs->log, "Set spi 0 slave ready: %d\n", bitset);
    print_f(pmrs->plog, "SPI", pmrs->log);
    bitset = 1;
    msp_spi_conf(pmrs->sfm[1], _IOW(SPI_IOC_MAGIC, 11, __u32), &bitset);   //SPI_IOC_WR_SLVE_READY
    sprintf_f(pmrs->log, "Set spi 1 slave ready: %d\n", bitset);
    print_f(pmrs->plog, "SPI", pmrs->log);

    bitset = 8;
    msp_spi_conf(pmrs->sfm[0], _IOW(SPI_IOC_MAGIC, 3, __u8), &bitset);   //SPI_IOC_WR_BITS_PER_WORD    
    msp_spi_conf(pmrs->sfm[1], _IOW(SPI_IOC_MAGIC, 3, __u8), &bitset);   //SPI_IOC_WR_BITS_PER_WORD    

    bitset = 0;     
    msp_spi_conf(pmrs->sfm[0], _IOW(SPI_IOC_MAGIC, 12, __u32), &bitset);   //SPI_IOC_WR_KBUFF_SEL    
    bitset = 1;    
    msp_spi_conf(pmrs->sfm[1], _IOW(SPI_IOC_MAGIC, 12, __u32), &bitset);   //SPI_IOC_WR_KBUFF_SEL

#if 0    
    while (1) {
        bitset = 0;
        msp_spi_conf(pmrs->sfm[0], _IOR(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_RD_CTL_PIN
        sprintf_f(pmrs->log, "wait for RDY become 1, get RDY pin: %d\n", bitset);
        print_f(pmrs->plog, "SPI", pmrs->log);
        
        //sleep(1);
        
        if (bitset == 1) break;
    }
#endif

    /* set RDY pin to low before spi setup ready */
    bitset = 0;
    ret = msp_spi_conf(pmrs->sfm[0], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
    sprintf_f(pmrs->log, "Set RDY low at beginning\n");
    print_f(pmrs->plog, "SPI0", pmrs->log);

    bitset = 0;
    ret = msp_spi_conf(pmrs->sfm[1], _IOW(SPI_IOC_MAGIC, 6, __u32), &bitset);   //SPI_IOC_WR_CTL_PIN
    sprintf_f(pmrs->log, "Set RDY low at beginning\n");
    print_f(pmrs->plog, "SPI1", pmrs->log);
    
    /*
     * spi mode 
     */ 
    ret = msp_spi_conf(pmrs->sfm[0], SPI_IOC_WR_MODE, &pmrs->smode);
    if (ret == -1) {
        sprintf_f(pmrs->log, "can't set spi mode\n"); 
        print_f(pmrs->plog, "SPI0", pmrs->log);
    }
    
    ret = msp_spi_conf(pmrs->sfm[0], SPI_IOC_RD_MODE, &pmrs->smode);
    if (ret == -1) {
        sprintf_f(pmrs->log, "can't get spi mode\n"); 
        print_f(pmrs->plog, "SPI0", pmrs->log);
    }
    
    /*
     * spi mode 
     */ 
    ret = msp_spi_conf(pmrs->sfm[1], SPI_IOC_WR_MODE, &pmrs->smode); 
    if (ret == -1) {
        sprintf_f(pmrs->log, "can't set spi mode\n"); 
        print_f(pmrs->plog, "SPI1", pmrs->log);
    }
    
    ret = msp_spi_conf(pmrs->sfm[1], SPI_IOC_RD_MODE, &pmrs->smode);
    if (ret == -1) {
        sprintf_f(pmrs->log, "can't get spi mode\n"); 
        print_f(pmrs->plog, "SPI1", pmrs->log);
    }

    dbgShowTimeStamp("s10", pmrs, NULL, 2, NULL);
    printSysinfo(&minfo);

#endif  //#if DISABLE_SPI

#if DISABLE_USB
    pmrs->usbhost[0] = 0;
    pmrs->usbhost[1] = 0;
#else  //#if DISABLE_USB

#define LOG_PHY_MEM 0
    /* USB0 */
    pmrs->usbmfd = open(MODULE_NAME , O_RDWR);
    if(pmrs->usbmfd < 0) {
        perror("/dev/mem open failed");
        goto end;
    } else {
        sprintf_f(pmrs->log, "open [%s] succeed!!!! \n", MODULE_NAME);
        print_f(pmrs->plog, "DMEM", pmrs->log);
    } 
    
    usbh[0] = 0;
    usbh[0] = aspSalloc(sizeof(struct usbHostmem_s));
    if (!usbh[0]) {
        sprintf_f(pmrs->log, "allocate for usb struct failed !!! \n");
        print_f(pmrs->plog, "USB", pmrs->log);
        goto end;
    }

    memset(usbh[0], 0, sizeof(struct usbHostmem_s));
    
    usbh[0]->ushostname = usbhostpath1;
    usbh[0]->ushostid = open(usbhostpath1, O_RDWR);
    if (usbh[0]->ushostid < 0) {
        sprintf_f(pmrs->log, "can't open device[%s]\n", usbhostpath1); 
        print_f(pmrs->plog, "USB", pmrs->log);
        close(usbh[0]->ushostid);

        usbh[0]->ushostid = 0;
        
        //goto end;
    } else {
        sprintf_f(pmrs->log, "open device[%s] usbid: %d \n", usbhostpath1, usbh[0]->ushostid); 
        print_f(pmrs->plog, "USB", pmrs->log);

        ret = USB_IOCT_GET_VID_PID(usbh[0]->ushostid, usbh[0]->ushostpidvid);
        if (ret < 0) {
            sprintf_f(pmrs->log, "can't get vid pid for [%s]\n", usbhostpath1); 
            print_f(pmrs->plog, "USB", pmrs->log);
            close(usbh[0]->ushostid);
            goto end;
        }
            
        ix = RING_BUFF_NUM_USB;
        ret = USB_IOCT_LOOP_BUFF_CREATE(usbh[0]->ushostid, &ix);
        if (ret < 0) {
            sprintf_f(pmrs->log, "can't create buff failed, size: %d [%s] ret: %d\n", RING_BUFF_NUM_USB, usbhostpath1, ret); 
            print_f(pmrs->plog, "USB", pmrs->log);
            close(usbh[0]->ushostid);
            goto end;
        }
        
        usbh[0]->ushostblvir = aspSalloc(RING_BUFF_NUM_USB*4);
        usbh[0]->ushostblphy = aspSalloc(RING_BUFF_NUM_USB*4);
        usbh[0]->ushostbmax = RING_BUFF_NUM_USB;
        usbh[0]->ushostbthrshold = usbh[0]->ushostbmax / 6;
        
        if ((!usbh[0]->ushostblphy) || (!usbh[0]->ushostblvir)) {
            sprintf_f(pmrs->log, "allocate memory failed, size: %d [%s]\n", RING_BUFF_NUM_USB*4, usbhostpath1); 
            print_f(pmrs->plog, "USB", pmrs->log);
            close(usbh[0]->ushostid);
            goto end;
        }
        
        ret = USB_IOCT_LOOP_BUFF_PROBE(usbh[0]->ushostid, usbh[0]->ushostblphy);
        if (ret < 0) {
            sprintf_f(pmrs->log, "can't probe phy addr, size: %d [%s]\n", RING_BUFF_NUM_USB, usbhostpath1); 
            print_f(pmrs->plog, "USB", pmrs->log);
            close(usbh[0]->ushostid);
            goto end;
        }
        
        ix = 0;
        sprintf_f(pmrs->log, "[%s] table size: %d, addr0: \n", usbhostpath1, RING_BUFF_NUM_USB);
        print_f(pmrs->plog, "USB", pmrs->log);
        for (ix=0; ix < RING_BUFF_NUM_USB; ix++) {
            ut32 = usbh[0]->ushostblphy[ix];
        
            #if LOG_PHY_MEM
            if ((ix % 4) == 0) {
                sprintf_f(pmrs->log, "%d: ", ix);
                print_f(pmrs->plog, "USB", pmrs->log);
            }
            #endif

            #if SMP_EN
            vt32 = (uint32_t)aspSalloc(USB_BUF_SIZE);
            chvir = (char *)vt32;
            memset(chvir, 0x00, USB_BUF_SIZE);
            chvir[0] = ix;
            #else
            ret = phy2vir(&vt32, ut32, USB_BUF_SIZE, pmrs->usbmfd);
            #endif
            if (ret < 0) {
                sprintf_f(pmrs->log, "addr0 phy 2 vir error!!! ret: %d \n", ret);
                print_f(pmrs->plog, "USB", pmrs->log);
                goto end;
            }
        
            usbh[0]->ushostblvir[ix] = vt32;
        
            #if LOG_PHY_MEM
            if ((ix % 4) == 3) {
                sprintf_f(pmrs->log, "p:0x%.8x v:0x%.8x \n", ut32, vt32);
                print_f(pmrs->plog, ".", pmrs->log);
            } else {
                sprintf_f(pmrs->log, "p:0x%.8x v:0x%.8x ", ut32, vt32);
                print_f(pmrs->plog, ".", pmrs->log);
            }
            #endif
            
        }
        
        sprintf_f(pmrs->log, "\n test \n");
        print_f(pmrs->plog, "USB", pmrs->log);
        
        for (ix=0; ix < RING_BUFF_NUM_USB; ix++) {
            chvir = (char *) usbh[0]->ushostblvir[ix];
            
            #if 0
            printf(" %d: \n", ix);            
            shmem_dump(chvir, 16);
            #endif
        
            if (chvir[0] != (ix & 0xff)) {
                printf("[DVF] 0e: %d-0x%.2x not match ", ix, chvir[0]);            
            }   

            #if 0
            if (((ix+1) % 4) == 0) {
                printf("\n\r");
            }
            #endif
        }
        
        pmrs->usbmh[0] = usbh[0];
        
        sprintf_f(pmrs->log, "[%s] setup complete usbid: %d, get pid: 0x%x, vid: 0x%x \n", usbhostpath1, usbh[0]->ushostid, usbh[0]->ushostpidvid[0], usbh[0]->ushostpidvid[1]);
        print_f(pmrs->plog, "USB", pmrs->log);
        
    }

    /* USB1 */
    
    usbh[1] = 0;
    usbh[1] = aspSalloc(sizeof(struct usbHostmem_s));
    if (!usbh[1]) {
        sprintf_f(pmrs->log, "allocate for usb 1 struct failed !!! \n");
        print_f(pmrs->plog, "USB", pmrs->log);
        goto end;
    }

    memset(usbh[1], 0, sizeof(struct usbHostmem_s));

    usbh[1]->ushostname = usbhostpath2;
    usbh[1]->ushostid = open(usbhostpath2, O_RDWR);
    if (usbh[1]->ushostid < 0) {
        sprintf_f(pmrs->log, "can't open device[%s]\n", usbhostpath2); 
        print_f(pmrs->plog, "USB", pmrs->log);
        close(usbh[1]->ushostid);

        usbh[1]->ushostid = 0;
        
        //#if !ONLY_ONE_USB
        //goto end;
        //#endif
        
    } else {
        sprintf_f(pmrs->log, "open device[%s] usbid: %d \n", usbhostpath2, usbh[1]->ushostid); 
        print_f(pmrs->plog, "USB", pmrs->log);

        ret = USB_IOCT_GET_VID_PID(usbh[1]->ushostid, usbh[1]->ushostpidvid);
        if (ret < 0) {
            sprintf_f(pmrs->log, "can't get vid pid for [%s]\n", usbhostpath2); 
            print_f(pmrs->plog, "USB", pmrs->log);
            close(usbh[1]->ushostid);
            goto end;
        }
            
        ix = RING_BUFF_NUM_USB;
        ret = USB_IOCT_LOOP_BUFF_CREATE(usbh[1]->ushostid, &ix);
        if (ret < 0) {
            sprintf_f(pmrs->log, "can't create buff failed, size: %d [%s] ret: %d \n", RING_BUFF_NUM_USB, usbhostpath2, ret); 
            print_f(pmrs->plog, "USB", pmrs->log);
            close(usbh[1]->ushostid);
            goto end;
        }
        
        usbh[1]->ushostblvir = aspSalloc(RING_BUFF_NUM_USB*4);
        usbh[1]->ushostblphy = aspSalloc(RING_BUFF_NUM_USB*4);
        usbh[1]->ushostbmax = RING_BUFF_NUM_USB;
        usbh[1]->ushostbthrshold = usbh[1]->ushostbmax / 6;
        
        if ((!usbh[1]->ushostblphy) || (!usbh[1]->ushostblvir)) {
            sprintf_f(pmrs->log, "allocate memory failed, size: %d [%s]\n", RING_BUFF_NUM_USB*4, usbhostpath2); 
            print_f(pmrs->plog, "USB", pmrs->log);
            close(usbh[1]->ushostid);
            goto end;
        }
            
        ret = USB_IOCT_LOOP_BUFF_PROBE(usbh[1]->ushostid, usbh[1]->ushostblphy);
        if (ret < 0) {
            sprintf_f(pmrs->log, "can't probe phy addr, size: %d [%s]\n", RING_BUFF_NUM_USB, usbhostpath2); 
            print_f(pmrs->plog, "USB", pmrs->log);
            close(usbh[1]->ushostid);
            goto end;
        }
        
        ix = 0;
        sprintf_f(pmrs->log, "[%s] table size: %d, addr0: \n", usbhostpath2, RING_BUFF_NUM_USB);
        print_f(pmrs->plog, "USB", pmrs->log);
        for (ix=0; ix < RING_BUFF_NUM_USB; ix++) {
            ut32 = usbh[1]->ushostblphy[ix];
        
            #if LOG_PHY_MEM
            if ((ix % 4) == 0) {
                sprintf_f(pmrs->log, "%d: ", ix);
                print_f(pmrs->plog, "USB", pmrs->log);
            }
            #endif

            #if SMP_EN
            vt32 = (uint32_t)aspSalloc(USB_BUF_SIZE);
            chvir = (char *)vt32;
            memset(chvir, 0x00, USB_BUF_SIZE);
            chvir[0] = ix;
            #else
            ret = phy2vir(&vt32, ut32, USB_BUF_SIZE, pmrs->usbmfd);
            #endif
            if (ret < 0) {
                sprintf_f(pmrs->log, "addr0 phy 2 vir error!!! ret: %d \n", ret);
                print_f(pmrs->plog, "USB", pmrs->log);
                goto end;
            }
        
            usbh[1]->ushostblvir[ix] = vt32;
        
            #if LOG_PHY_MEM
            if ((ix % 4) == 3) {
                sprintf_f(pmrs->log, "p:0x%.8x v:0x%.8x \n", ut32, vt32);
                print_f(pmrs->plog, ".", pmrs->log);
            } else {
                sprintf_f(pmrs->log, "p:0x%.8x v:0x%.8x ", ut32, vt32);
                print_f(pmrs->plog, ".", pmrs->log);
            }        
            #endif
        }
        
        sprintf_f(pmrs->log, "\n test \n");
        print_f(pmrs->plog, "USB", pmrs->log);
        
        for (ix=0; ix < RING_BUFF_NUM_USB; ix++) {
            chvir = (char *) usbh[1]->ushostblvir[ix];
        
            #if 0
            printf(" %d: \n", ix);            
            shmem_dump(chvir, 16);
            #endif
        
            if (chvir[0] != (ix & 0xff)) {
                printf("[DVF] 0e: %d-0x%.2x not match ", ix, chvir[0]);            
            }   

            #if 0
            if (((ix+1) % 4) == 0) {
                printf("\n\r");
            }
            #endif

        }
        
        pmrs->usbmh[1] = usbh[1];
        
        sprintf_f(pmrs->log, "setup complete usbid: %d, get pid: 0x%x, vid: 0x%x [%s]\n", usbh[1]->ushostid, usbh[1]->ushostpidvid[0], usbh[1]->ushostpidvid[1], usbhostpath2);
        print_f(pmrs->plog, "USB", pmrs->log);

    }


    if (usbh[0]->ushostpidvid[1] == usbh[1]->ushostpidvid[1]) {
        sprintf_f(pmrs->log, "Warnning!!! primary and second vid are the same!!! 0:0x%x 1:0x%x \n", usbh[0]->ushostpidvid[1], usbh[1]->ushostpidvid[1]);
        print_f(pmrs->plog, "USB", pmrs->log);
        pmrs->usbmh[0] = usbh[0];
        pmrs->usbmh[1] = usbh[1];
    }
    else if ((usbh[0]->ushostid == 0) || (usbh[1]->ushostid == 0)) {
        sprintf_f(pmrs->log, "Warnning!!! primary and second not all available!!! usbid0: %d usbid1: %d \n", usbh[0]->ushostid, usbh[1]->ushostid);
        print_f(pmrs->plog, "USB", pmrs->log);

        if ((usbh[0]->ushostid == 0) && (usbh[1]->ushostid == 0)) {
            pmrs->usbmh[0] = usbh[0];
            pmrs->usbmh[1] = usbh[1];
        } else {
            if (usbh[0]->ushostid == 0) {
                sprintf_f(pmrs->log, "Error!!! should not be here usb0==0 but usb1!=0 !!! usbid0: %d usbid1: %d \n", usbh[0]->ushostid, usbh[1]->ushostid);
                print_f(pmrs->plog, "USB", pmrs->log);
                pmrs->usbmh[0] = usbh[0];
                pmrs->usbmh[1] = usbh[1];
            }
            else if (usbh[0]->ushostpidvid[1] == 0x0a03) {
                pmrs->usbmh[0] = usbh[0];
                pmrs->usbmh[1] = usbh[1];
            }
            else if (usbh[0]->ushostpidvid[1] == 0x0a04) {
                pmrs->usbmh[0] = usbh[1];
                pmrs->usbmh[1] = usbh[0];
            } else {
                pmrs->usbmh[0] = usbh[0];
                pmrs->usbmh[1] = usbh[1];
            }
        }
    }
    else if (usbh[0]->ushostpidvid[1] < usbh[1]->ushostpidvid[1]) {
        pmrs->usbmh[0] = usbh[0];
        pmrs->usbmh[1] = usbh[1];
    }
    else {
        pmrs->usbmh[0] = usbh[1];
        pmrs->usbmh[1] = usbh[0];
    }

    metaRx = (struct aspMetaData_s *)aspSalloc(sizeof(struct aspMetaData_s));
    metaPt = (char *)metaRx;

    usbid0 = pmrs->usbmh[0]->ushostid;
    usbid1 = pmrs->usbmh[1]->ushostid;
    tbl0 = pmrs->usbmh[0]->ushostblvir;
    tbl1 = pmrs->usbmh[1]->ushostblvir;    

    phytbl0 = pmrs->usbmh[0]->ushostblphy;
    phytbl1 = pmrs->usbmh[1]->ushostblphy;    

    #if 0
    ix = RING_BUFF_NUM_USB;
    ret = USB_IOCT_LOOP_BUFF_RELEASE(usbid0, &ix);
    if (ret < 0) {
        sprintf_f(pmrs->log, "can't release buff failed, size: %d [%s]\n", RING_BUFF_NUM_USB, usbhostpath1); 
        print_f(pmrs->plog, "USB", pmrs->log);
        close(usbid0);
        goto end;
    }

    ix = RING_BUFF_NUM_USB;
    ret = USB_IOCT_LOOP_BUFF_RELEASE(usbid1, &ix);
    if (ret < 0) {
        sprintf_f(pmrs->log, "can't release buff failed, size: %d [%s]\n", RING_BUFF_NUM_USB, usbhostpath2); 
        print_f(pmrs->plog, "USB", pmrs->log);
        close(usbid1);
        goto end;
    }
    #endif
        
    close(usbid0);
    close(usbid1);
    close(pmrs->usbmfd);
    pmrs->usbmfd = 0;
    
    if (pmrs->usbmh[0]->ushostid == 0) {
        sprintf_f(pmrs->log, "Error!!! USB not available \n");
        print_f(pmrs->plog, "USB", pmrs->log);
    } else {

        usbTx = (struct shmem_s *)aspSalloc(sizeof(struct shmem_s));
        memset(usbTx, 0, sizeof(struct shmem_s));
        
        usbTx->pp =  (char **) memory_init_vtable(usbTx->pp, RING_BUFF_NUM_USB * TABLE_SLOT_SIZE, TABLE_SLOT_SIZE, tbl0);  
        usbTx->bb =  (char **) memory_init_vtable(usbTx->bb, RING_BUFF_NUM_USB * TABLE_SLOT_SIZE, TABLE_SLOT_SIZE, phytbl0);  
        usbTx->urun = (int *)aspSalloc(sizeof(int) * RING_BUFF_NUM_USB);
        usbTx->uget = (int *)aspSalloc(sizeof(int) * RING_BUFF_NUM_USB);
        
        if (!usbTx->pp) goto end;
        usbTx->r = (struct ring_p *)aspSalloc(sizeof(struct ring_p));
        
        usbTx->r->usbrunnig = (struct ring_s *)aspSalloc(sizeof(struct ring_s));
        usbTx->r->usbgettig = (struct ring_s *)aspSalloc(sizeof(struct ring_s));

        usbTx->slotn = RING_BUFF_NUM_USB;
        usbTx->totsz = RING_BUFF_NUM_USB*TABLE_SLOT_SIZE;
        usbTx->chksz = USB_BUF_SIZE;
        usbTx->svdist = 8;
        
        gateTx = (struct shmem_s *)aspSalloc(sizeof(struct shmem_s));
        memset(gateTx, 0, sizeof(struct shmem_s));
        
        gateTx->pp = (char **) memory_init_vtable(gateTx->pp, RING_BUFF_NUM_USB*TABLE_SLOT_SIZE, TABLE_SLOT_SIZE, tbl0); 
        gateTx->bb = (char **) memory_init_vtable(gateTx->bb, RING_BUFF_NUM_USB*TABLE_SLOT_SIZE, TABLE_SLOT_SIZE, phytbl0);
        gateTx->urun = (int *)aspSalloc(sizeof(int) * RING_BUFF_NUM_USB);
        gateTx->uget = (int *)aspSalloc(sizeof(int) * RING_BUFF_NUM_USB);
        
        if (!gateTx->pp) goto end;
        gateTx->r = (struct ring_p *)aspSalloc(sizeof(struct ring_p));
        
        gateTx->r->usbrunnig = usbTx->r->usbrunnig;
        gateTx->r->usbgettig = usbTx->r->usbgettig;

        gateTx->slotn = RING_BUFF_NUM_USB;
        gateTx->totsz = RING_BUFF_NUM_USB*TABLE_SLOT_SIZE;
        gateTx->chksz = USB_BUF_SIZE;
        gateTx->svdist = 8;
    }

    if (pmrs->usbmh[1]->ushostid == 0) {
        sprintf_f(pmrs->log, "Error!!! USB not available \n");
        print_f(pmrs->plog, "USB", pmrs->log);
    } else {

        usbTxd = (struct shmem_s *)aspSalloc(sizeof(struct shmem_s));
        memset(usbTxd, 0, sizeof(struct shmem_s));
        
        usbTxd->pp = (char **) memory_init_vtable(usbTxd->pp, RING_BUFF_NUM_USB*TABLE_SLOT_SIZE, TABLE_SLOT_SIZE, tbl1); 
        usbTxd->bb = (char **) memory_init_vtable(usbTxd->bb, RING_BUFF_NUM_USB*TABLE_SLOT_SIZE, TABLE_SLOT_SIZE, phytbl1); 
        usbTxd->urun = (int *)aspSalloc(sizeof(int) * RING_BUFF_NUM_USB);
        usbTxd->uget = (int *)aspSalloc(sizeof(int) * RING_BUFF_NUM_USB);
        if (!usbTxd->pp) goto end;
        usbTxd->r = (struct ring_p *)aspSalloc(sizeof(struct ring_p));
        
        usbTxd->r->usbrunnig = (struct ring_s *)aspSalloc(sizeof(struct ring_s));
        usbTxd->r->usbgettig = (struct ring_s *)aspSalloc(sizeof(struct ring_s));

        usbTxd->slotn = RING_BUFF_NUM_USB;
        usbTxd->totsz = RING_BUFF_NUM_USB*TABLE_SLOT_SIZE;
        usbTxd->chksz = USB_BUF_SIZE;
        usbTxd->svdist = 8;
        
        gateTxd = (struct shmem_s *)aspSalloc(sizeof(struct shmem_s));
        memset(gateTxd, 0, sizeof(struct shmem_s));
        
        gateTxd->pp = (char **) memory_init_vtable(gateTxd->pp, RING_BUFF_NUM_USB*TABLE_SLOT_SIZE, TABLE_SLOT_SIZE, tbl1); 
        gateTxd->bb = (char **) memory_init_vtable(gateTxd->bb, RING_BUFF_NUM_USB*TABLE_SLOT_SIZE, TABLE_SLOT_SIZE, phytbl1); 
        gateTxd->urun = (int *)aspSalloc(sizeof(int) * RING_BUFF_NUM_USB);
        gateTxd->uget = (int *)aspSalloc(sizeof(int) * RING_BUFF_NUM_USB);
        
        if (!gateTxd->pp) goto end;
        gateTxd->r = (struct ring_p *)aspSalloc(sizeof(struct ring_p));
        
        gateTxd->r->usbrunnig = usbTxd->r->usbrunnig;
        gateTxd->r->usbgettig = usbTxd->r->usbgettig;

        gateTxd->slotn = RING_BUFF_NUM_USB;
        gateTxd->totsz = RING_BUFF_NUM_USB*TABLE_SLOT_SIZE;
        gateTxd->chksz = USB_BUF_SIZE;
        gateTxd->svdist = 8;
    }
    
    spipeTx = (int *)aspSalloc(sizeof(int) * 2); 
    spipeRx = (int *)aspSalloc(sizeof(int) * 2); 
    sgateUpTx = (int *)aspSalloc(sizeof(int) * 2); 
    sgateUpRx = (int *)aspSalloc(sizeof(int) * 2); 

    pipeJpgTx = (int *)aspSalloc(sizeof(int) * 2); 
    pipeJpgRx = (int *)aspSalloc(sizeof(int) * 2); 
    
    pipe2(spipeTx, O_NONBLOCK);
    sprintf_f(pmrs->log, "[DV]  pipeTx 0:%d 1:%d\n", spipeTx[0], spipeTx[1]);
    print_f(pmrs->plog, "USB", pmrs->log);
    pipe2(spipeRx, O_NONBLOCK);
    sprintf_f(pmrs->log, "[DV]  pipeRx 0:%d 1:%d\n", spipeRx[0], spipeRx[1]);
    print_f(pmrs->plog, "USB", pmrs->log);
    
    pipe2(sgateUpTx, O_NONBLOCK);
    sprintf_f(pmrs->log, "[DV]  gateUpTx 0:%d 1:%d\n", sgateUpTx[0], sgateUpTx[1]);        
    print_f(pmrs->plog, "USB", pmrs->log);
    pipe2(sgateUpRx, O_NONBLOCK);
    sprintf_f(pmrs->log, "[DV]  gateUpRx 0:%d 1:%d\n", sgateUpRx[0], sgateUpRx[1]);
    print_f(pmrs->plog, "USB", pmrs->log);

    pipe2(pipeJpgTx, O_NONBLOCK);
    sprintf_f(pmrs->log, "[DV]  jpegTx 0:%d 1:%d\n", pipeJpgTx[0], pipeJpgTx[1]);        
    print_f(pmrs->plog, "USB", pmrs->log);
    pipe2(pipeJpgRx, O_NONBLOCK);
    sprintf_f(pmrs->log, "[DV]  jpegRx 0:%d 1:%d\n", pipeJpgRx[0], pipeJpgRx[1]);
    print_f(pmrs->plog, "USB", pmrs->log);
    
    pushost = (struct usbhost_s *)aspSalloc(sizeof(struct usbhost_s));
    memset(pushost, 0, sizeof(struct usbhost_s));
    
    pushost->pushring = usbTx;
    pushost->pgatring = gateTx;
    pushost->puhsmeta = metaPt;
    pushost->pushrx = spipeRx;
    pushost->pushtx = spipeTx;
    pushost->pgattx = sgateUpTx;
    pushost->pgatrx = sgateUpRx;
    pushost->pjpgrx = pipeJpgRx;
    pushost->pjpgtx = pipeJpgTx;
    pushost->pushvaddrtb = tbl0;
    pushost->ushid = 0;
    
    spipeTxd = (int *)aspSalloc(sizeof(int) * 2); 
    spipeRxd = (int *)aspSalloc(sizeof(int) * 2); 
    sgateDnTx = (int *)aspSalloc(sizeof(int) * 2); 
    sgateDnRx = (int *)aspSalloc(sizeof(int) * 2); 
    
    pipeJpgTxd = (int *)aspSalloc(sizeof(int) * 2); 
    pipeJpgRxd = (int *)aspSalloc(sizeof(int) * 2); 

    pipe2(spipeTxd, O_NONBLOCK);
    sprintf_f(pmrs->log, "[DV]  pipeTxd 0:%d 1:%d\n", spipeTxd[0], spipeTxd[1]);
    print_f(pmrs->plog, "USB", pmrs->log);
    pipe2(spipeRxd, O_NONBLOCK);
    sprintf_f(pmrs->log, "[DV]  pipeRxd 0:%d 1:%d\n", spipeRxd[0], spipeRxd[1]);
    print_f(pmrs->plog, "USB", pmrs->log);
    
    pipe2(sgateDnTx, O_NONBLOCK);
    sprintf_f(pmrs->log, "[DV]  gateDnTx 0:%d 1:%d\n", sgateDnTx[0], sgateDnTx[1]);
    print_f(pmrs->plog, "USB", pmrs->log);
    pipe2(sgateDnRx, O_NONBLOCK);
    sprintf_f(pmrs->log, "[DV]  gateDnRx 0:%d 1:%d\n", sgateDnRx[0], sgateDnRx[1]);
    print_f(pmrs->plog, "USB", pmrs->log);

    pipe2(pipeJpgTxd, O_NONBLOCK);
    sprintf_f(pmrs->log, "[DV]  jpegTxd 0:%d 1:%d\n", pipeJpgTxd[0], pipeJpgTxd[1]);        
    print_f(pmrs->plog, "USB", pmrs->log);
    pipe2(pipeJpgRxd, O_NONBLOCK);
    sprintf_f(pmrs->log, "[DV]  jpegRxd 0:%d 1:%d\n", pipeJpgRxd[0], pipeJpgRxd[1]);
    print_f(pmrs->plog, "USB", pmrs->log);
    
    pushostd = (struct usbhost_s *)aspSalloc(sizeof(struct usbhost_s));
    memset(pushostd, 0, sizeof(struct usbhost_s));
    
    pushostd->pushring = usbTxd;
    pushostd->pgatring = gateTxd;
    pushostd->puhsmeta = metaPt;
    pushostd->pushrx = spipeRxd;
    pushostd->pushtx = spipeTxd;
    pushostd->pgattx = sgateDnTx;
    pushostd->pgatrx = sgateDnRx;
    pushostd->pjpgrx = pipeJpgRxd;
    pushostd->pjpgtx = pipeJpgTxd;
    pushostd->pushvaddrtb = tbl1;
    pushostd->ushid = 1;

    pmrs->usbhost[0] = pushost;
    pmrs->usbhost[1] = pushostd;

    /* reset file id */
    pusbf = &pmrs->usbfile;
    pusbf->usfacMagicBegin[0] = 'f';
    pusbf->usfacMagicBegin[1] = 'i';
    pusbf->usfacMagicBegin[2] = 'l';
    pusbf->usfacMagicBegin[3] = 'e';
    pusbf->usfacLength = 0;
    pusbf->usfacPt = 0;
    pusbf->usfacMagicEnd[0] = 'c';
    pusbf->usfacMagicEnd[1] = 'r';
    pusbf->usfacMagicEnd[2] = 'o';
    pusbf->usfacMagicEnd[3] = 'm';
    
    #if 1
    pmrs->usbdv = open(usbdevpath, O_RDWR);
    if (pmrs->usbdv <= 0) {
        sprintf_f(pmrs->log, "can't open device[%s]!!\n", usbdevpath); 
        print_f(pmrs->plog, "USB", pmrs->log);

        pmrs->usbdv = open(usbdevpath0, O_RDWR);    
        if (pmrs->usbdv <= 0) {
            sprintf_f(pmrs->log, "can't open device[%s]\n", usbdevpath0); 
            print_f(pmrs->plog, "USB", pmrs->log);

            goto end;
        }
        else {
            pmrs->usbdvname = usbdevpath0;
            sprintf_f(pmrs->log, "open device[%s]\n", usbdevpath0); 
            print_f(pmrs->plog, "USB", pmrs->log);
        }
    }
    else {
        pmrs->usbdvname = usbdevpath;

        sprintf_f(pmrs->log, "open device[%s]\n", usbdevpath); 
        print_f(pmrs->plog, "USB", pmrs->log);
    }
    close(pmrs->usbdv);
    pmrs->usbdv = 0;
    #endif

    sprintf(pmrs->log, "USB to PC %s", pmrs->usbdvname==0?"FAILED":pmrs->usbdvname);
    dbgShowTimeStamp(pmrs->log, pmrs, NULL, 2, NULL);

    tusb = pmrs->usbmh[0];
    if (tusb->ushostid) {
        sprintf(pmrs->log, "USB to ASIC (1)VIDPID: 0x%.4x 0x%.4x BUFFNUM:%d %s ", tusb->ushostpidvid[0], tusb->ushostpidvid[1], tusb->ushostbmax, tusb->ushostname);
        dbgShowTimeStamp(pmrs->log, pmrs, NULL, 2, NULL);
    } else {
        sprintf(pmrs->log, "USB to ASIC (1) FAILED");
        dbgShowTimeStamp(pmrs->log, pmrs, NULL, 2, NULL);
    }

    tusb = pmrs->usbmh[1];
    if (tusb->ushostid) {
        sprintf(pmrs->log, "USB to ASIC (2)VIDPID: 0x%.4x 0x%.4x BUFFNUM:%d %s ", tusb->ushostpidvid[0], tusb->ushostpidvid[1], tusb->ushostbmax, tusb->ushostname);
        dbgShowTimeStamp(pmrs->log, pmrs, NULL, 2, NULL);
    } else {
        sprintf(pmrs->log, "USB to ASIC (2) FAILED");
        dbgShowTimeStamp(pmrs->log, pmrs, NULL, 2, NULL);
    }

    #if GHP_EN
    aspBMPdecodeAllocate(pmrs, 0);
    aspBMPdecodeAllocate(pmrs, 1);
    aspBMPdecodeAllocate(pmrs, 2);
    aspBMPdecodeAllocate(pmrs, 3);

    #if MFOUR_API
    len = 64 * 1024;
    pmrs->bmpMfourTxbuff = aspSalloc(len);
    if (pmrs->bmpMfourTxbuff) {
        memset(pmrs->bmpMfourTxbuff, 0, len);
    } else {
        sprintf_f(pmrs->log, "allocate memory for M4 tx buff failed !! size: %d KB\n", len / 1024); 
        print_f(pmrs->plog, "USB", pmrs->log);
    }

    len = 64 * 1024;
    pmrs->bmpMfourRxbuff = aspSalloc(len);
    if (pmrs->bmpMfourRxbuff) {
        memset(pmrs->bmpMfourRxbuff, 0, len);
    } else {
        sprintf_f(pmrs->log, "allocate memory for M4 rx buff failed !! size: %d KB\n", len / 1024); 
        print_f(pmrs->plog, "USB", pmrs->log);
    }

    pmrs->bmpMfourPipTx = aspSalloc(sizeof(int) * 2);
    pipe2(pmrs->bmpMfourPipTx, O_NONBLOCK);    
    pmrs->bmpMfourPipRx = aspSalloc(sizeof(int) * 2);
    pipe2(pmrs->bmpMfourPipRx, O_NONBLOCK);

    pipMfTx = pmrs->bmpMfourPipTx;
    pipMfRx = pmrs->bmpMfourPipRx;
    #endif
    
    aspBMPdecodeBuffInit(&pmrs->bmpDecMfour[0]);
    aspBMPdecodeBuffInit(&pmrs->bmpDecMfour[1]);
    aspBMPdecodeBuffInit(&pmrs->bmpDecMfour[2]);
    aspBMPdecodeBuffInit(&pmrs->bmpDecMfour[3]);

    sprintf(syscmd, "cat /proc/sys/kernel/printk");
    ret = doSystemCmd(syscmd);

    sprintf(syscmd, "echo \"1 1 1 1\" > /proc/sys/kernel/printk");
    ret = doSystemCmd(syscmd);

    sprintf(syscmd, "cat /proc/sys/kernel/printk");
    ret = doSystemCmd(syscmd);

    sprintf(syscmd, "/home/root/fw_cortex_m4.sh start");
    ret = doSystemCmd(syscmd);
    #endif
    
    printSysinfo(&minfo);
    
#endif //#if DISABLE_USB

// IPC
    pipe(pmrs->pipedn[0].rt);
    //pipe2(pmrs->pipedn[0].rt, O_NONBLOCK);
    pipe(pmrs->pipedn[1].rt);
    pipe(pmrs->pipedn[2].rt);
    pipe(pmrs->pipedn[3].rt);
    pipe(pmrs->pipedn[4].rt);
    pipe(pmrs->pipedn[5].rt);
    //pipe(pmrs->pipedn[6].rt);
    pipe2(pmrs->pipedn[6].rt, O_NONBLOCK);
    pipe(pmrs->pipedn[7].rt);
    pipe(pmrs->pipedn[8].rt);
    pipe(pmrs->pipedn[9].rt);
    //pipe(pmrs->pipedn[10].rt);
    //pipe(pmrs->pipedn[11].rt);
    //pipe(pmrs->pipedn[12].rt);
    //pipe(pmrs->pipedn[13].rt);
    pipe2(pmrs->pipedn[10].rt, O_NONBLOCK);
    pipe2(pmrs->pipedn[11].rt, O_NONBLOCK);
    pipe2(pmrs->pipedn[12].rt, O_NONBLOCK);
    pipe2(pmrs->pipedn[13].rt, O_NONBLOCK);
    pipe2(pmrs->pipedn[14].rt, O_NONBLOCK);
#if GHP_EN
    pipe2(pmrs->pipedn[15].rt, O_NONBLOCK);
    pipe2(pmrs->pipedn[16].rt, O_NONBLOCK);
    pipe2(pmrs->pipedn[17].rt, O_NONBLOCK);
    pipe2(pmrs->pipedn[18].rt, O_NONBLOCK);
    pipe2(pmrs->pipedn[19].rt, O_NONBLOCK);
    pipe2(pmrs->pipedn[20].rt, O_NONBLOCK);
    pipe2(pmrs->pipedn[21].rt, O_NONBLOCK);
#endif

    pipe2(pmrs->pipeup[0].rt, O_NONBLOCK);
    pipe2(pmrs->pipeup[1].rt, O_NONBLOCK);
    pipe2(pmrs->pipeup[2].rt, O_NONBLOCK);
    pipe2(pmrs->pipeup[3].rt, O_NONBLOCK);
    pipe2(pmrs->pipeup[4].rt, O_NONBLOCK);
    pipe2(pmrs->pipeup[5].rt, O_NONBLOCK);
    pipe2(pmrs->pipeup[6].rt, O_NONBLOCK);
    pipe2(pmrs->pipeup[7].rt, O_NONBLOCK);
    pipe2(pmrs->pipeup[8].rt, O_NONBLOCK);
    pipe2(pmrs->pipeup[9].rt, O_NONBLOCK);
    pipe2(pmrs->pipeup[10].rt, O_NONBLOCK);
    pipe2(pmrs->pipeup[11].rt, O_NONBLOCK);
    pipe2(pmrs->pipeup[12].rt, O_NONBLOCK);
    pipe2(pmrs->pipeup[13].rt, O_NONBLOCK);
    pipe2(pmrs->pipeup[14].rt, O_NONBLOCK);
#if GHP_EN
    pipe2(pmrs->pipeup[15].rt, O_NONBLOCK);
    pipe2(pmrs->pipeup[16].rt, O_NONBLOCK);
    pipe2(pmrs->pipeup[17].rt, O_NONBLOCK);
    pipe2(pmrs->pipeup[18].rt, O_NONBLOCK);
    pipe2(pmrs->pipeup[19].rt, O_NONBLOCK);
    pipe2(pmrs->pipeup[20].rt, O_NONBLOCK);
    pipe2(pmrs->pipeup[21].rt, O_NONBLOCK);
#endif

    res_put_in(&rs[0], pmrs, 0);
    res_put_in(&rs[1], pmrs, 1);
    res_put_in(&rs[2], pmrs, 2);
    res_put_in(&rs[3], pmrs, 3);
    res_put_in(&rs[4], pmrs, 4);
    res_put_in(&rs[5], pmrs, 5);
    res_put_in(&rs[6], pmrs, 6);
    res_put_in(&rs[7], pmrs, 7);
    res_put_in(&rs[8], pmrs, 8);
    res_put_in(&rs[9], pmrs, 9);
    res_put_in(&rs[10], pmrs, 10);
    res_put_in(&rs[11], pmrs, 11);
    res_put_in(&rs[12], pmrs, 12);
    res_put_in(&rs[13], pmrs, 13);
    res_put_in(&rs[14], pmrs, 14);
#if GHP_EN
    res_put_in(&rs[15], pmrs, 15);
    res_put_in(&rs[16], pmrs, 16);
    res_put_in(&rs[17], pmrs, 17);
    res_put_in(&rs[18], pmrs, 18);
    res_put_in(&rs[19], pmrs, 19);
    res_put_in(&rs[20], pmrs, 20);
    res_put_in(&rs[21], pmrs, 21);
#endif
  
//  Share memory init
    ring_buf_init(&pmrs->dataRx);
    pmrs->dataRx.r->folw.seq = 1;
    pmrs->dataRx.r->psudo.seq = 1;
    ring_buf_init(&pmrs->cmdRx);
    ring_buf_init(&pmrs->cmdTx);

// fork process
    len = strlen(argv[0]);
    memset(argv[0], 0, len);

    if (argc > 1) {
        len = strlen(argv[1]);
        memset(argv[1], 0, len);
    }
    
    sprintf(argv[0], "state");
    pmrs->sid[0] = fork();
    if (!pmrs->sid[0]) {
        p1(&rs[0], &rs[6]);
    } else {
        len = strlen(argv[0]);
        memset(argv[0], 0, len);
        sprintf(argv[0], "spi0");
        pmrs->sid[1] = fork();
        if (!pmrs->sid[1]) {
            p2(&rs[1]);
        } else {
            len = strlen(argv[0]);
            memset(argv[0], 0, len);
            sprintf(argv[0], "spi1");
            pmrs->sid[2] = fork();
            if (!pmrs->sid[2]) {
                p3(&rs[2]);
            } else {
                len = strlen(argv[0]);
                memset(argv[0], 0, len);
                sprintf(argv[0], "port 6000");
                pmrs->sid[3] = fork();
                if (!pmrs->sid[3]) {
                    p4(&rs[3]);
                } else {
                    len = strlen(argv[0]);
                    memset(argv[0], 0, len);
                    sprintf(argv[0], "port 5000");
                    pmrs->sid[4] = fork();
                    if (!pmrs->sid[4]) {
                        p5(&rs[4], &rs[5]);
                    } else {
                        len = strlen(argv[0]);
                        memset(argv[0], 0, len);
                        sprintf(argv[0], "command");
                        pmrs->sid[5] = fork();
                        if (!pmrs->sid[5]) {
                            dbg(pmrs);
                        } else {
                            len = strlen(argv[0]);
                            memset(argv[0], 0, len);
                            sprintf(argv[0], "port 4000");
                            pmrs->sid[6] = fork();
                            if (!pmrs->sid[6]) {
                                p6(&rs[7]);
                            } else {
                                len = strlen(argv[0]);
                                memset(argv[0], 0, len);
                                sprintf(argv[0], "port 7000");
                                pmrs->sid[7] = fork();
                                if (!pmrs->sid[7]) {
                                    p7(&rs[8]);
                                } else {
                                    len = strlen(argv[0]);
                                    memset(argv[0], 0, len);
                                    sprintf(argv[0], "udp");
                                    pmrs->sid[8] = fork();
                                    if (!pmrs->sid[8]) {
                                        p8(&rs[9]);
                                    } else {              
                                        len = strlen(argv[0]);
                                        memset(argv[0], 0, len);
                                        sprintf(argv[0], "usbhost0");
                                        pmrs->sid[9] = fork();
                                        if (!pmrs->sid[9]) {
                                            p9(&rs[10]);
                                        } else {              
                                            len = strlen(argv[0]);
                                            memset(argv[0], 0, len);
                                            sprintf(argv[0], "usbhost1");
                                            pmrs->sid[10] = fork();
                                            if (!pmrs->sid[10]) {
                                                p10(&rs[11]);
                                            } else {              
                                                len = strlen(argv[0]);
                                                memset(argv[0], 0, len);
                                                sprintf(argv[0], "g_printer");
                                                pmrs->sid[11] = fork();
                                                if (!pmrs->sid[11]) {
                                                    p11(&rs[12], &rs[13], &rs[14]);
                                                } else {
#if GHP_EN
                                                    len = strlen(argv[0]);
                                                    memset(argv[0], 0, len);
                                                    sprintf(argv[0], "m4");
                                                    pmrs->sid[12] = fork();
                                                    if (!pmrs->sid[12]) {
                                                        p12(&rs[15]);
                                                    } else {
                                                        len = strlen(argv[0]);
                                                        memset(argv[0], 0, len);
                                                        sprintf(argv[0], "jpghost0");
                                                        pmrs->sid[13] = fork();
                                                        if (!pmrs->sid[13]) {
                                                            p13(&rs[16]);
                                                        } else {
                                                            len = strlen(argv[0]);
                                                            memset(argv[0], 0, len);
                                                            sprintf(argv[0], "jpghost1");
                                                            pmrs->sid[14] = fork();
                                                            if (!pmrs->sid[14]) {
                                                                p14(&rs[17]);
                                                            } else {
                                                                len = strlen(argv[0]);
                                                                memset(argv[0], 0, len);
                                                                sprintf(argv[0], "jpgenode");
                                                                pmrs->sid[15] = fork();
                                                                if (!pmrs->sid[15]) {
                                                                    p15(&rs[18]);
                                                                } else {
                                                                    len = strlen(argv[0]);
                                                                    memset(argv[0], 0, len);
                                                                    sprintf(argv[0], "m4t");
                                                                    pmrs->sid[16] = fork();
                                                                    if (!pmrs->sid[16]) {
                                                                        p16(&rs[19]);
                                                                    } else {
                                                                        len = strlen(argv[0]);
                                                                        memset(argv[0], 0, len);
                                                                        sprintf(argv[0], "m4r");
                                                                        pmrs->sid[17] = fork();
                                                                        if (!pmrs->sid[17]) {
                                                                            p17(&rs[20]);
                                                                        } else {
                                                                            #if MFOUR_API
                                                                            len = strlen(argv[0]);
                                                                            memset(argv[0], 0, len);
                                                                            sprintf(argv[0], "m4");
                                                                            pmrs->sid[18] = fork();
                                                                            if (!pmrs->sid[18]) {
                                                                                p18(&rs[21]);
                                                                            } else {                                                                        
                                                                                len = strlen(argv[0]);
                                                                                memset(argv[0], 0, len);
                                                                                sprintf(argv[0], "func");
                                                                                p0(pmrs);
                                                                            }
                                                                            #else 
                                                                            len = strlen(argv[0]);
                                                                            memset(argv[0], 0, len);
                                                                            sprintf(argv[0], "func");
                                                                            p0(pmrs);
                                                                            #endif
                                                                        }                                                                        
                                                                    }                                                                
                                                                }                                                               
                                                            }                                                    
                                                        }                                                    
                                                    }

#else
                                                    len = strlen(argv[0]);
                                                    memset(argv[0], 0, len);
                                                    sprintf(argv[0], "func");
                                                    p0(pmrs);
#endif
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    end:

    sprintf_f(pmrs->log, "something wrong in mothership, break!\n");
    print_f(pmrs->plog, "main", pmrs->log);
    printf_flush(pmrs->plog, pmrs->flog);

    return 0;
}

static int print_dbg(struct logPool_s *plog, char *str, int size)
{
    int len, n;
    if(!str) return (-1);

    if (!plog) return (-2);
    
    msync(plog, sizeof(struct logPool_s), MS_SYNC);
    len = strlen(str);
    if (!size) { 
        n = len;
    } else if (len > size) {
        n = size;
    } else {
        n = len;
    }

    if ((len + plog->len) > plog->max) return (-3);
    memcpy(plog->cur, str, n);
    plog->cur += n;
    plog->len += n;
 
    return 0;
}

static int printf_dbgflush(struct logPool_s *plog, struct mainRes_s *mrs, int argc)
{
    msync(plog, sizeof(struct logPool_s), MS_SYNC);
    if (plog->cur == plog->pool) return (-1);
    if (plog->len > plog->max) return (-2);

    msync(plog->pool, plog->len, MS_SYNC);

    //printf("[DBG] get result: [%s] len: %d (%d) \n", plog->pool, plog->len, argc);

    switch (argc) {
    case 42:
    case 44:
        mrs_ipc_put(mrs, plog->pool, plog->len, 14); // channel for USB
        break;
    default:
        mrs_ipc_put(mrs, plog->pool, plog->len, 5); // channel for APP
        break;
    }
    
#if !MSP_SAVE_LOG_TO_FILE
    plog->cur = plog->pool;
    plog->len = 0;
#endif

    return 0;
}

#if LOG_ALL_DISABLE
static int print_f(struct logPool_s *plog, char *head, char *str)
{
    return 0;
}
//#define print_f  ////
#else 
static int print_f(struct logPool_s *plog, char *head, char *str)
{
    uint32_t logdisplayflag=0;
    int len;
    char ch[8192];

    logdisplayflag = plog->dislog;
    
    if (!logdisplayflag) {
        return 0;
    }

    if (!str) return (-1);

    if (head) {
        //if (!strcmp(head, "P2")) return 0;
        sprintf(ch, "[%s] %s", head, str);
    } else {
        sprintf(ch, "%s", str);
    }

    printf("%s",ch);

#if MSP_SAVE_LOG_TO_FILE
    if (!plog) return (-2);
    
    msync(plog, sizeof(struct logPool_s), MS_SYNC);
    len = strlen(ch);
    if ((len + plog->len) > plog->max) return (-3);
    memcpy(plog->cur, ch, strlen(ch));
    plog->cur += len;
    plog->len += len;
#endif
    //if (!mlog) return (-4);
    //fwrite(ch, 1, strlen(ch), mlog);
    //fflush(mlog);
    //fprintf(mlog, "%s", ch);
    
    return 0;
}
#endif

static int printf_flush(struct logPool_s *plog, FILE *f) 
{
#if MSP_SAVE_LOG_TO_FILE
    msync(plog, sizeof(struct logPool_s), MS_SYNC);
    if (plog->cur == plog->pool) return (-1);
    if (plog->len > plog->max) return (-2);

    msync(plog->pool, plog->len, MS_SYNC);
    fwrite(plog->pool, 1, plog->len, f);
    fflush(f);
    sync();

    plog->cur = plog->pool;
    plog->len = 0;
#endif
    return 0;
}

static char **memory_init_vtable(char **pbuf, int tsize, int csize, uint32_t *tbl)
{
    uint32_t *mbuf;
    char **pma;
    int asz, idx;
    char mlog[256];
    
    if ((!tsize) || (!csize)) return (0);
    if (tsize % csize) return (0);
    if (!(tsize / csize)) return (0);
        
    asz = tsize / csize;
    //pma = (char **) aspMemalloc(sizeof(char *) * asz);

    if (pbuf) {
        pma = pbuf;
    } else {
        pma = (char **) aspSalloc(sizeof(char *) * asz);
    }

    mbuf = tbl;
    
    //sprintf(mlog, "aspSalloc get 0x%.8x\n", mbuf);
    //print_f(mlogPool, "memory_init", mlog);
        
    for (idx = 0; idx < asz; idx++) {
        pma[(idx+1) % asz] = (char *) mbuf[idx];
    }

    //*sz = asz;
    return pma;
}

static char **memory_init(int *sz, uint32_t tsize, int csize)
{
    char *mbuf, *tmpB;
    char **pma;
    int asz, idx;
    char mlog[256];
    
    if ((!tsize) || (!csize)) return (0);
    if (tsize % csize) return (0);
    if (!(tsize / csize)) return (0);
        
    asz = tsize / csize;
    //pma = (char **) aspMemalloc(sizeof(char *) * asz);
    pma = (char **) aspSalloc(sizeof(char *) * asz);
    
    //sprintf(mlog, "asz:%d pma:0x%.8x\n", asz, pma);
    //print_f(mlogPool, "memory_init", mlog);
    
    mbuf = aspSalloc(tsize);
    
    //sprintf(mlog, "aspSalloc get 0x%.8x\n", mbuf);
    //print_f(mlogPool, "memory_init", mlog);
        
    tmpB = mbuf;
    for (idx = 0; idx < asz; idx++) {
        pma[idx] = mbuf;
        
        //sprintf(mlog, "%d 0x%.8x\n", idx, pma[idx]);
        //print_f(mlogPool, "memory_init", mlog);
        
        mbuf += csize;
    }
    *sz = asz;
    return pma;
}

static FILE *find_read(char *dst)
{
    FILE *f=0;

    f = fopen(dst, "r");
    if (!f) {
        //printf("open file [%s]\n", dst);
    } else {
        //printf("open file [%s] succeed \n", dst);
        //fclose(f);
        return f;
    }

    return f;
}

static FILE *find_write(char *dst)
{
    FILE *f=0;

    f = fopen(dst, "w");
    if (!f) {
        //printf("open file [%s] failed!!\n", dst);
    } else {
        //printf("open file [%s] succeed \n", dst);
        //fclose(f);
        return f;
    }

    return f;
}

static FILE *find_save(char *dst, char *tmple)
{
    int i;
    FILE *f;
    for (i =0; i < 1000; i++) {
        sprintf(dst, tmple, i);
        f = fopen(dst, "r");
        if (!f) {
            //printf("open file [%s]\n", dst);
            break;
        } else {
            //printf("open file [%s] succeed \n", dst);
            fclose(f);
        }
    }
    f = fopen(dst, "w");
    return f;
}

static int file_save_get(FILE **fp, char *path1)
{
//static char path1[] = "/mnt/mmc2/rx/%d.bin"; 

    char dst[128], temp[128], flog[256];
    FILE *f = NULL;
    int i;

    if (!path1) return (-1);

    sprintf(temp, "%s", path1);

    for (i =0; i < 1000; i++) {
        sprintf(dst, temp, i);
        f = fopen(dst, "r");
        if (!f) {
            sprintf(flog, "open file [%s]\n", dst);
            print_f(mlogPool, "save", flog);
            break;
        } else
            fclose(f);
    }
    f = fopen(dst, "w");

    *fp = f;
    return 0;
}

static int fileid_save(char *fileidpoll, struct usbFileidAccess_s *pubf) 
{
    FILE *fdpll=0;
    char *addrs=0;
    int lens=0, ret=0;
    
    fdpll = fopen(fileidpoll, "w+");
    if (fdpll) {
        addrs = (char *)pubf;
        ret = fwrite(addrs, 1, 8, fdpll);
        if (ret != 8) {
            fclose(fdpll);
            fdpll = 0;

            return -1;
        }
    }
    
    printf("[DVB] [%s] save fileid poll lengh: %d\n", fileidpoll, pubf->usfacLength);
    
    lens = pubf->usfacLength;
    if (fdpll) {
        addrs = (char *)pubf->usfacPt;
        ret = fwrite(addrs, 1, lens, fdpll);
        if (ret != lens) {
            fclose(fdpll);
            fdpll = 0;

            return -2;
        }
    }
    
    if (fdpll) {
        addrs = (char *)pubf->usfacMagicEnd;
        ret = fwrite(addrs, 1, 4, fdpll);
        if (ret != 4) {
            fclose(fdpll);
            fdpll = 0;

            return -3;
        }
    }
    
    if (fdpll) {
        fflush(fdpll);
        fclose(fdpll);
        sync();
    
        printf("[DVB] [%s] save fileid poll succeed!!!\n", fileidpoll);
    }

    return 0;
}

static int res_put_in(struct procRes_s *rs, struct mainRes_s *mrs, int idx)
{
    sprintf(rs->nrs, "rs%.2d", idx);
    rs->pmsconfig = &mrs->mspconfig;
    rs->pcmdRx = &mrs->cmdRx;
    rs->pcmdTx = &mrs->cmdTx;
    rs->pdataRx = &mrs->dataRx;
    rs->fs_s = mrs->fs;
    rs->flog_s = mrs->flog;
    rs->tm[0] = &mrs->time[0];
    rs->tm[1] = &mrs->time[1];

    rs->tm2[0] = &mrs->time2[0];
    rs->tm2[1] = &mrs->time2[1];

    rs->rtpTo[0] = &mrs->roundtripgoto[0];
    rs->rtpTo[1] = &mrs->roundtripgoto[1];

    rs->rtpBk[0] = &mrs->roundtripback[0];
    rs->rtpBk[1] = &mrs->roundtripback[1];

    rs->ppipedn = &mrs->pipedn[idx];
    rs->ppipeup = &mrs->pipeup[idx];
    rs->plogs = mrs->plog;

    if((idx == 0) || (idx == 1)) {
        rs->spifd = mrs->sfm[0];
    } else if (idx == 2) {
        rs->spifd = mrs->sfm[1];
    }

    rs->psocket_r = &mrs->socket_r;
    rs->psocket_t = &mrs->socket_t; 
    rs->psocket_at = &mrs->socket_at;
    rs->psocket_n = &mrs->socket_n;
    rs->psocket_v = &mrs->socket_v;

    rs->pmch = &mrs->mchine;
    rs->pstdata = &mrs->stdata;
    rs->pcfgTable = mrs->configTable;
    rs->psFat = &mrs->aspFat;
    rs->cpyfatDirTr = 0;
    rs->pnetIntfs = mrs->netIntfs;
    rs->pnetIntwpa = mrs->netIntwpa;
    rs->pwifconf = &mrs->wifconf;
    rs->pmetaout = &mrs->metaout;
    rs->pmetausb = &mrs->metaUsb;
    rs->pmetain = &mrs->metain;
    rs->pmetaMass = &mrs->metaMass;
    rs->pmetausbduo = &mrs->metaUsbDuo;
    rs->pmetainduo= &mrs->metainDuo;
    rs->pmetaMassduo= &mrs->metaMassDuo;

    rs->rspioc1 = mrs->spioc1;
    rs->rspioc2 = mrs->spioc2;

    rs->pcrop32 = &mrs->crop32;
    rs->pcropex = &mrs->cropex;
    rs->pcrop32duo= &mrs->crop32Duo;
    rs->pcropexduo= &mrs->cropexDuo;

    rs->pbheader = &mrs->bmpheader;
    rs->pbheaderDuo = &mrs->bmpheaderDuo;
    rs->pbrotate = &mrs->bmpRotate;

    #if GHP_EN
    rs->pbDecMfour[0] = &mrs->bmpDecMfour[0];
    rs->pbDecMfour[1] = &mrs->bmpDecMfour[1];
    rs->pbDecMfour[2] = &mrs->bmpDecMfour[2];
    rs->pbDecMfour[3] = &mrs->bmpDecMfour[3];
    #if MFOUR_API
    rs->pbMfTxBuff = mrs->bmpMfourTxbuff;
    rs->pbMfRxBuff = mrs->bmpMfourRxbuff;
    #endif
    #endif
    
    rs->usbdvid = mrs->usbdv;
    rs->usvdvname = mrs->usbdvname;

    if ((idx == 10) || (idx == 12) || (idx == 16) || (idx == 18)) { 
        rs->pusbhost = mrs->usbhost[0];
        rs->pusbmh[0] = mrs->usbmh[0];
        rs->pusbmh[1] = mrs->usbmh[1];
    } else if ((idx == 11) || (idx == 13) || (idx == 17) || (idx == 15) ) {
        rs->pusbhost = mrs->usbhost[1];
        rs->pusbmh[0] = mrs->usbmh[0];
        rs->pusbmh[1] = mrs->usbmh[1];
    } else {
        rs->pusbhost = 0;
    }

    rs->pusbfile = &mrs->usbfile;
    
    return 0;
}


